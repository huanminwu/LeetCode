#pragma once
#ifndef LeetCodeBit_H
#define LeetCodeBit_H
#include <stdint.h>
#include <stdlib.h>     /* srand, rand */
#include <time.h>       /* time */
#include <algorithm> 
#include <functional> 
#include <bitset> 
#include <list>
#include <map>
#include <queue>
#include <set>
#include <stdexcept>
#include <string>
#include <unordered_map> 
#include <unordered_set> 
#include <vector> 
#include <stack> 
#include "leetcode.h"

using namespace std;
/// <summary>
/// The class is to implement bit operation related algorithm  
/// </summary>
struct TrieBitNode 
{
    TrieBitNode* m_Child[2] = {};
    int m_Count = 0; 
    int m_MaxBits = 31;
    TrieBitNode(int max_bits)
    {
        m_MaxBits = max_bits;
    }
    
    void increase(long long number, int d) 
    {
        TrieBitNode* cur = this;
        for (int i = m_MaxBits; i >= 0; --i)
        {
            int bit = (int)((number >> i) & 1);
            if (cur->m_Child[bit] == nullptr) cur->m_Child[bit] = new TrieBitNode(m_MaxBits);
            cur = cur->m_Child[bit];
            cur->m_Count += d;
        }
    }

    void decrease(long long number, int d)
    {
        TrieBitNode* cur = this;
        for (int i = m_MaxBits; i >= 0; --i)
        {
            int bit = (int)((number >> i) & 1);
            cur = cur->m_Child[bit];
            cur->m_Count -= d;
        }
    }

    long long findMax(long long number) 
    {
        TrieBitNode* cur = this;
        long long result = 0;
        for (int i = m_MaxBits; i >= 0; --i)
        {
            if (cur == nullptr) break;
            int bit = (number >> i) & 1;
            if (cur->m_Child[1 - bit] != nullptr && cur->m_Child[1 - bit]->m_Count > 0) 
            {
                cur = cur->m_Child[1 - bit];
                result |= ((long long)1 << (long long)i);
            }
            else
            {
                cur = cur->m_Child[bit];
            }
        }
        return result;
    }
};

class LeetCodeBit
{
public:
#pragma region BitOperation
    /// <summary>
    /// Leet code # 371. Sum of Two Integers 
    /// 
    /// Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. 
    /// Example: 
    /// Given a = 1 and b = 2, return 3. 
    /// </summary>
    int getSum(int a, int b);

    /// <summary>
    /// Leet code # 191. Number of 1 Bits
    /// 
    /// Write a function that takes an unsigned integer and returns the number of ’1' 
    /// bits it has (also known as the Hamming weight). 
    /// For example, the 32-bit integer ’11' has binary representation 
    /// 00000000000000000000000000001011, so the function should return 3. 
    /// </summary>
    int hammingWeight(uint32_t n);

    /// <summary>
    /// Leet code #338. Counting Bits    
    /// Given a non negative integer number num. For every numbers i in the range 0 <= i <= num 
    /// calculate the number of 1's in their binary representation and return them as an array. 
    /// Example:
    /// For num = 5 you should return [0,1,1,2,1,2].
    /// Follow up: 
    /// It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?
    /// Space complexity should be O(n).
    /// Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.
    /// Hint:
    /// 1.You should make use of what you have produced already.
    /// 2.Divide the numbers in ranges like [2-3], [4-7], [8-15] and so on. And try to generate new range from previous.
    /// 3.Or does the odd/even status of the number help you in calculating the number of 1s?
    /// </summary>
    vector<int> countBits(int num);

    /// <summary>
    /// Leet code #342. Power of Four    
    /// Given an integer (signed 32 bits), write a function to check whether it is a power of 4.
    /// Example:
    /// Given num = 16, return true. Given num = 5, return false. 
    /// Follow up: Could you solve it without loops/recursion?
    /// </summary>
    bool isPowerOfFour(int num);

    /// <summary>
    /// Leet code #136. Single Number
    /// Given an array of integers, every element appears twice except for one. Find that single one.
    /// Note:
    /// Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 
    /// </summary>
    int singleNumber(vector<int>& nums);

    /// <summary>
    /// Leet code #389. Find the Difference 
    /// Given two strings s and t which consist of only lowercase letters.
    /// String t is generated by random shuffling string s and then add one more letter at a random position.
    /// Find the letter that was added in t.
    /// Example: 
    /// Input:
    /// s = "abcd"
    /// t = "abcde"
    /// Output:
    /// e
    /// Explanation:
    /// 'e' is the letter that was added.    
    /// </summary>
    char findTheDifference(string s, string t);

    /// <summary>
    /// Leet code #89. Gray Code 
    /// Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. 
    /// A gray code sequence must begin with 0. 
    /// For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:
    /// 00 - 0
    /// 01 - 1
    /// 11 - 3
    /// 10 - 2
    ///
    /// Note:
    ///   For a given n, a gray code sequence is not uniquely defined. 
    /// For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.
    /// For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.
    /// </summary>
    vector<int> grayCode(int n);

    /// <summary>
    /// Leet code #405. Convert a Number to Hexadecimal 
    /// Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.  
    /// Note: 
    /// 1.All letters in hexadecimal (a-f) must be in lowercase.
    /// 2.The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character '0'; otherwise, 
    ///   the first character in the hexadecimal string will not be the zero character.
    /// 3.The given number is guaranteed to fit within the range of a 32-bit signed integer.
    /// 4.You must not use any method provided by the library which converts/formats the number to hex directly.
    /// Example 1: 
    /// Input:
    /// 26
    /// Output:
    /// "1a"
    ///
    /// Example 2: 
    /// Input:
    /// -1
    /// Output:
    /// "ffffffff"
    /// </summary>
    string toHex(int num);

    /// <summary>
    /// Leet code #137. Single Number II 
    /// Given an array of integers, every element appears three times except for one. Find that single one.   
    /// Note: 
    /// Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 
    /// </summary>
    int singleNumberII(vector<int>& nums);

    /// <summary>
    /// Leet code #190. Reverse Bits 
    /// Reverse bits of a given 32 bits unsigned integer.
    /// For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), 
    /// return 964176192 (represented in binary as 00111001011110000010100101000000).
    /// Follow up:
    /// If this function is called many times, how would you optimize it? 
    /// </summary>
    uint32_t reverseBits(uint32_t n);

    /// <summary>
    /// Leet code #397. Integer Replacement 
    /// Given a positive integer n and you can do operations as follow: 
    /// 1.If n is even, replace n with n/2.
    /// 2.If n is odd, you can replace n with either n + 1 or n - 1.
    /// What is the minimum number of replacements needed for n to become 1? 
    /// Example 1: 
    /// Input:
    /// 8
    /// Output:
    /// 3
    /// Explanation:
    /// 8 -> 4 -> 2 -> 1
    ///
    /// Example 2: 
    /// Input:
    /// 7
    /// Output:
    /// 4
    /// Explanation:
    /// 7 -> 8 -> 4 -> 2 -> 1
    /// or
    /// 7 -> 6 -> 3 -> 2 -> 1
    /// </summary>
    int integerReplacement(int n);

    /// <summary>
    /// Leet code #201. Bitwise AND of Numbers Range 
    /// Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.
    /// For example, given the range [5, 7], you should return 4. 
    /// </summary>
    int rangeBitwiseAnd(int m, int n);

    /// <summary>
    /// Leet code #318. Maximum Product of Word Lengths 
    /// Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where 
    /// the two words do not share common letters. You may assume that each word will contain only 
    /// lower case letters. If no such two words exist, return 0. 
    ///
    /// Example 1:
    /// Given ["abcw", "baz", "foo", "bar", "xtfn", "abcdef"]
    /// Return 16
    /// The two words can be "abcw", "xtfn". 
    ///
    /// Example 2:
    /// Given ["a", "ab", "abc", "d", "cd", "bcd", "abcd"]
    /// Return 4
    /// The two words can be "ab", "cd". 
    ///
    /// Example 3:
    /// Given ["a", "aa", "aaa", "aaaa"]
    /// Return 0
    /// No such pair of words. 
    /// </summary>
    int maxProductWordLength(vector<string>& words);

    /// <summary>
    /// Leet code #268. Missing Number  
    /// Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.
    /// For example, 
    /// Given nums = [0, 1, 3] return 2. 
    ///
    /// Note:
    /// Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? 
    /// </summary>
    int missingNumber(vector<int>& nums);

    /// <summary>
    /// Leet code #260. Single Number III 
    /// Given an array of numbers nums, in which exactly two elements appear only once and all the other elements 
    /// appear exactly twice. Find the two elements that appear only once. 
    ///
    /// Given nums = [1, 2, 1, 3, 2, 5], return [3, 5]. 
    /// Note:
    /// 1.The order of the result is not important. So in the above example, [5, 3] is also correct.
    /// 2.Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?
    /// </summary>
    vector<int> singleNumberIII(vector<int>& nums);

    /// <summary>
    /// Leet code #421. Maximum XOR of Two Numbers in an Array Add to List 
    /// Given a non-empty array of numbers, a0, a1, a2,... an-1, where 0 ≤ ai < 231.
    /// Find the maximum result of ai XOR aj, where 0 ≤ i, j < n. 
    ///
    /// Could you do this in O(n) runtime? 
    /// Example:
    /// Input: [3, 10, 5, 25, 2, 8]
    /// Output: 28
    /// Explanation: The maximum result is 5 ^ 25 = 28.
    /// </summary>
    int findMaximumXOR(vector<int>& nums);

    /// <summary>
    /// Leet code #461. Hamming Distance
    /// The Hamming distance between two integers is the number of positions at which the 
    /// corresponding bits are different.
    /// Given two integers x and y, calculate the Hamming distance.
    /// Note:
    /// 0 ≤ x, y < 231. 
    /// Example: 
    /// Input: x = 1, y = 4
    /// Output: 2
    /// Explanation:
    /// 1   (0 0 0 1)
    /// 4   (0 1 0 0)
    /// The above arrows point to positions where the corresponding bits are different.    
    /// </summary>
    int hammingDistance(int x, int y);

    /// <summary>
    /// Leet code #477. Total Hamming Distance 
    /// The Hamming distance between two integers is the number of positions at which the corresponding bits are different.
    /// Now your job is to find the total Hamming distance between all pairs of the given numbers. 
    /// Example:
    /// Input: 4, 14, 2
    /// Output: 6
    /// 
    /// Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just
    /// showing the four bits relevant in this case). So the answer will be:
    /// HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.
    /// Note:
    /// 1.Elements of the given array are in the range of 0  to 10^9 
    /// 2.Length of the array will not exceed 10^4. 
    /// </summary>
    int totalHammingDistance(vector<int>& nums);

    /// <summary>
    /// Leet code #390. Elimination Game   
    /// 
    /// There is a list of sorted integers from 1 to n. Starting from left to right, 
    /// remove the first number and every other number afterward until you reach the end of the list.
    /// Repeat the previous step again, but this time from right to left, remove the right most 
    /// number and every other number from the remaining numbers.
    /// We keep repeating the steps again, alternating left to right and right to left, until a single number remains.
    /// Find the last number that remains starting with a list of length n.
    /// Example: 
    /// Input:
    /// n = 9,
    /// 1 2 3 4 5 6 7 8 9
    /// 2 4 6 8
    /// 2 6
    /// 6
    ///
    /// Output:
    /// 6
    /// </summary>
    int lastRemaining(int n);

    /// <summary>
    /// Leet code #476. Number Complement    
    /// 
    /// Given a positive integer, output its complement number. The complement 
    /// strategy is to flip the bits of its binary representation.
    /// Note:
    /// 1.The given integer is guaranteed to fit within the range of a 32-bit signed integer.
    /// 2.You could assume no leading zero bit in the integer’s binary representation.
    /// Example 1:
    /// Input: 5
    /// Output: 2
    /// Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.
    /// Example 2:
    /// Input: 1
    /// Output: 0
    /// Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.
    /// </summary>
    int findComplement(int num);

    /// <summary>
    /// Leet code #693. Binary Number with Alternating Bits
    /// Given a positive integer, check whether it has alternating bits: 
    /// namely, if two adjacent bits will always have different values.
    ///  
    /// Example 1:
    /// Input: 5
    /// Output: True
    /// Explanation:
    /// The binary representation of 5 is: 101
    ///
    /// Example 2:
    /// Input: 7
    /// Output: False
    /// Explanation:
    /// The binary representation of 7 is: 111.
    ///
    /// Example 3:
    /// Input: 11
    /// Output: False
    /// Explanation:
    /// The binary representation of 11 is: 1011.
    ///
    /// Example 4:
    /// Input: 10
    /// Output: True
    /// Explanation:
    /// The binary representation of 10 is: 1010.
    /// </summary>
    bool hasAlternatingBits(int n);

    /// <summary>
    /// Leet code #762. Prime Number of Set Bits in Binary Representation    
    ///
    /// Given two integers L and R, find the count of numbers in the range 
    /// [L, R] (inclusive) having a prime number of set bits in their binary 
    /// representation. 
    /// (Recall that the number of set bits an integer has is the number of 1s 
    /// present when written in binary. For example, 21 written in binary is 
    /// 10101 which has 3 set bits. Also, 1 is not a prime.) 
    ///
    ///
    ///
    /// Example 1:
    ///
    /// Input: L = 6, R = 10
    /// Output: 4
    /// Explanation:
    /// 6 -> 110 (2 set bits, 2 is prime)
    /// 7 -> 111 (3 set bits, 3 is prime)
    /// 9 -> 1001 (2 set bits , 2 is prime)
    /// 10->1010 (2 set bits , 2 is prime)
    ///
    /// Example 2:
    ///
    /// Input: L = 10, R = 15
    /// Output: 5
    /// Explanation:
    /// 10 -> 1010 (2 set bits, 2 is prime)
    /// 11 -> 1011 (3 set bits, 3 is prime)
    /// 12 -> 1100 (2 set bits, 2 is prime)
    /// 13 -> 1101 (3 set bits, 3 is prime)
    /// 14 -> 1110 (3 set bits, 3 is prime)
    /// 15 -> 1111 (4 set bits, 4 is not prime)
    ///
    /// 
    /// Note:
    /// 1.L, R will be integers L <= R in the range [1, 10^6].
    /// 2.R - L will be at most 10000.
    /// </summary>
    int countPrimeSetBits(int L, int R);

    /// <summary>
    /// Leet code #805. Split Array With Same Average
    /// 
    /// In a given integer array A, we must move every element of A to either 
    /// list B or list C. (B and C initially start empty.)
    ///
    /// Return true if and only if after such a move, it is possible that the 
    /// average value of B is equal to the average value of C, and B and C are 
    /// both non-empty.
    ///
    /// Example :
    /// Input: 
    /// [1,2,3,4,5,6,7,8]
    /// Output: true
    /// Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and 
    /// both of them have the average of 4.5.
    /// Note:
    ///
    /// 1. The length of A will be in the range [1, 30].
    /// 2. A[i] will be in the range of [0, 10000].
    /// </summary>
    bool splitArraySameAverage(vector<int>& A);

    /// <summary>
    /// Leet code #805. Split Array With Same Average
    /// 
    /// In a given integer array A, we must move every element of A to either 
    /// list B or list C. (B and C initially start empty.)
    ///
    /// Return true if and only if after such a move, it is possible that the 
    /// average value of B is equal to the average value of C, and B and C are 
    /// both non-empty.
    ///
    /// Example :
    /// Input: 
    /// [1,2,3,4,5,6,7,8]
    /// Output: true
    /// Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and 
    /// both of them have the average of 4.5.
    /// Note:
    ///
    /// 1. The length of A will be in the range [1, 30].
    /// 2. A[i] will be in the range of [0, 10000].
    /// </summary>
    bool splitArraySameAverageII(vector<int>& A);

    /// <summary>
    /// Leet code #868. Binary Gap
    /// 
    /// Given a positive integer N, find and return the longest distance 
    /// between two consecutive 1's in the binary representation of N.
    ///
    /// If there aren't two consecutive 1's, return 0.
    /// 
    ///
    /// Example 1:
    ///
    /// Input: 22
    /// Output: 2
    /// Explanation: 
    /// 22 in binary is 0b10110.
    /// In the binary representation of 22, there are three ones, and two 
    /// consecutive pairs of 1's.
    /// The first consecutive pair of 1's have distance 2.
    /// The second consecutive pair of 1's have distance 1.
    /// The answer is the largest of these two distances, which is 2.
    ///
    /// Example 2:
    /// Input: 5
    /// Output: 2
    /// Explanation: 
    /// 5 in binary is 0b101.
    ///
    /// Example 3:
    /// Input: 6
    /// Output: 1
    /// Explanation: 
    /// 6 in binary is 0b110.
    ///
    /// Example 4:
    /// Input: 8
    /// Output: 0
    /// Explanation: 
    /// 8 in binary is 0b1000.
    /// There aren't any consecutive pairs of 1's in the binary representation 
    /// of 8, so we return 0.
    /// Note:
    /// 1 <= N <= 10^9
    /// </summary>
    int binaryGap(int N);

    /// <summary>
    /// Leet code #1009. Complement of Base 10 Integer
    /// 
    /// Every non-negative integer N has a binary representation.  For example, 
    /// 5 can be represented as "101" in binary, 11 as "1011" in binary, and so on.
    /// Note that except for N = 0, there are no leading zeroes in any binary 
    /// representation.
    ///
    /// The complement of a binary representation is the number in binary you get 
    /// when changing every 1 to a 0 and 0 to a 1.  For example, the complement of 
    /// "101" in binary is "010" in binary.
    ///
    /// For a given number N in base-10, return the complement of it's binary 
    /// representation as a base-10 integer.
    ///
    /// 
    ///
    /// Example 1:
    ///
    /// Input: 5
    /// Output: 2
    /// Explanation: 5 is "101" in binary, with complement "010" in binary, which 
    /// is 2 in base-10.
    ///
    /// Example 2:
    ///
    /// Input: 7
    /// Output: 0
    /// Explanation: 7 is "111" in binary, with complement "000" in binary, which 
    /// is 0 in base-10.
    ///
    /// Example 3:
    ///
    /// Input: 10
    /// Output: 5
    /// Explanation: 10 is "1010" in binary, with complement "0101" in binary, 
    /// which is 5 in base-10.
    /// 
    ///
    /// Note:
    ///
    /// 1. 0 <= N < 10^9
    /// </summary>
    int bitwiseComplement(int N);

    /// <summary>
    /// Leet code #1016. Binary String With Substrings Representing 1 To N
    /// 
    /// Given a binary string S (a string consisting only of '0' and '1's) and a 
    /// positive integer N, return true if and only if for every integer X from 1 
    /// to N, the binary representation of X is a substring of S.
    ///
    /// Example 1:
    ///
    /// Input: S = "0110", N = 3
    /// Output: true
    ///
    /// Example 2:
    ///
    /// Input: S = "0110", N = 4
    /// Output: false
    /// 
    ///
    /// Note:
    /// 
    /// 1 <= S.length <= 1000
    /// 1 <= N <= 10^9
    /// </summary>
    bool queryString(string S, int N);

    /// <summary>
    /// Leet code #1017. Convert to Base -2
    /// 
    /// Given a number N, return a string consisting of "0"s and "1"s that 
    /// represents its value in base -2 (negative two).
    ///
    /// The returned string must have no leading zeroes, unless the string is "0".
    ///
    /// Example 1:
    /// Input: 2
    /// Output: "110"
    /// Explantion: (-2) ^ 2 + (-2) ^ 1 = 2
    ///
    /// Example 2:
    /// Input: 3
    /// Output: "111"
    /// Explantion: (-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3
    ///
    /// Example 3:
    /// Input: 4
    /// Output: "100"
    /// Explantion: (-2) ^ 2 = 4
    /// 
    ///
    /// Note:
    /// 1. 0 <= N <= 10^9
    /// </summary>
    string baseNeg2(int N);

    /// <summary>
    /// Leet code #1018. Binary Prefix Divisible By 5
    /// 
    /// Given an array A of 0s and 1s, consider N_i: the i-th subarray from A[0] 
    /// to A[i] interpreted as a binary number (from most-significant-bit to 
    /// least-significant-bit.)
    ///
    /// Return a list of booleans answer, where answer[i] is true if and only 
    /// if N_i is divisible by 5.
    ///
    /// Example 1:
    ///
    /// Input: [0,1,1]
    /// Output: [true,false,false]
    /// Explanation: 
    /// The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in 
    /// base-10.  Only the first number is divisible by 5, so answer[0] is true.
    ///
    /// Example 2:
    ///
    /// Input: [1,1,1]
    /// Output: [false,false,false]
    ///
    /// Example 3:
    ///
    /// Input: [0,1,1,1,1,1]
    /// Output: [true,false,false,false,true,false]
    ///
    /// Example 4:
    ///
    /// Input: [1,1,1,0,1]
    /// Output: [false,false,false,false,false]
    /// 
    ///
    /// Note:
    ///
    /// 1. 1 <= A.length <= 30000
    /// 2. A[i] is 0 or 1
    /// </summary>
    vector<bool> prefixesDivBy5(vector<int>& A);

    /// <summary>
    /// Leet code #1072. Flip Columns For Maximum Number of Equal Rows
    /// 
    /// Given a matrix consisting of 0s and 1s, we may choose any number of 
    /// columns in the matrix and flip every cell in that column.  Flipping 
    /// a cell changes the value of that cell from 0 to 1 or from 1 to 0.
    ///
    /// Return the maximum number of rows that have all values equal after 
    /// some number of flips.
    ///
    /// Example 1:
    /// Input: [[0,1],[1,1]]
    /// Output: 1
    /// Explanation: After flipping no values, 1 row has all values equal.
    ///
    /// Example 2:
    ///
    /// Input: [[0,1],[1,0]]
    /// Output: 2
    /// Explanation: After flipping values in the first column, both rows have 
    /// equal values.
    ///
    /// Example 3:
    ///
    /// Input: [[0,0,0],[0,0,1],[1,1,0]]
    /// Output: 2
    /// Explanation: After flipping values in the first two columns, the last 
    /// two rows have equal values.
    /// 
    /// Note:
    /// 1. 1 <= matrix.length <= 300
    /// 2. 1 <= matrix[i].length <= 300
    /// 3. All matrix[i].length's are equal
    /// 4. matrix[i][j] is 0 or 1
    /// </summary>
    int maxEqualRowsAfterFlips(vector<vector<int>>& matrix);

    /// <summary>
    /// Leet code #1073. Adding Two Negabinary Numbers
    /// 
    /// Given two numbers arr1 and arr2 in base -2, return the result of adding 
    /// them together.
    /// Each number is given in array format:  as an array of 0s and 1s, from 
    /// most significant bit to least significant bit.  For example, 
    /// arr = [1,1,0,1] represents the number (-2)^3 + (-2)^2 + (-2)^0 = -3.  
    /// A number arr in array format is also guaranteed to have no leading 
    /// zeros: either arr == [0] or arr[0] == 1.
    /// Return the result of adding arr1 and arr2 in the same format: as an array 
    /// of 0s and 1s with no leading zeros.
    /// 
    /// Example 1:
    /// Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1]
    /// Output: [1,0,0,0,0]
    /// Explanation: arr1 represents 11, arr2 represents 5, the output 
    /// represents 16.
    /// 
    /// Note:
    /// 1. 1 <= arr1.length <= 1000
    /// 2. 1 <= arr2.length <= 1000
    /// 3. arr1 and arr2 have no leading zeros
    /// 4. arr1[i] is 0 or 1
    /// 5. arr2[i] is 0 or 1
    /// </summary>
    vector<int> addNegabinary(vector<int>& arr1, vector<int>& arr2);

    /// <summary>
    /// Leet code #1238. Circular Permutation in Binary Representation
    /// 
    /// Given 2 integers n and start. Your task is return any permutation p of 
    /// (0,1,2.....,2^n -1) such that :
    ///
    /// p[0] = start
    /// p[i] and p[i+1] differ by only one bit in their binary representation.
    /// p[0] and p[2^n -1] must also differ by only one bit in their binary 
    /// representation.
    /// 
    /// Example 1:
    ///
    /// Input: n = 2, start = 3
    /// Output: [3,2,0,1]
    /// Explanation: The binary representation of the permutation is (11,10,00,01). 
    /// All the adjacent element differ by one bit. Another valid permutation 
    /// is [3,1,0,2]
    ///
    /// Example 2:
    ///
    /// Input: n = 3, start = 2
    /// Output: [2,6,7,5,4,0,1,3]
    /// Explanation: The binary representation of the permutation is 
    /// (010,110,111,101,100,000,001,011).
    /// 
    /// Constraints:
    /// 1. 1 <= n <= 16
    /// 2. 0 <= start < 2 ^ n
    /// </summary>
    vector<int> circularPermutation(int n, int start);

    /// <summary>
    /// Leet code #1461. Check If a String Contains All Binary Codes of Size K
    /// 
    /// Medium
    ///
    /// Given a binary string s and an integer k.
    ///
    /// Return True if all binary codes of length k is a substring of s. 
    /// Otherwise, return False.
    ///
    /// Example 1:
    /// Input: s = "00110110", k = 2
    /// Output: true
    /// Explanation: The binary codes of length 2 are "00", "01", "10" 
    /// and "11". They can be all found as substrings at indicies 0, 1, 3 
    /// and 2 respectively.
    ///
    /// Example 2:
    /// Input: s = "00110", k = 2
    /// Output: true
    ///
    /// Example 3:
    /// Input: s = "0110", k = 1
    /// Output: true
    /// Explanation: The binary codes of length 1 are "0" and "1", it 
    /// is clear that both exist as a substring. 
    ///
    /// Example 4:
    /// Input: s = "0110", k = 2
    /// Output: false
    /// Explanation: The binary code "00" is of length 2 and doesn't exist in 
    /// the array.
    ///
    /// Example 5:
    /// Input: s = "0000000001011100", k = 4
    /// Output: false
    ///
    /// Constraints:
    /// 1. 1 <= s.length <= 5 * 10^5
    /// 2. s consists of 0's and 1's only.
    /// 3. 1 <= k <= 20
    /// </summary>
    bool hasAllCodes(string s, int k);

    /// <summary>
    /// Leet code #861. Score After Flipping Matrix
    /// 
    /// We have a two dimensional matrix A where each value is 0 or 1.
    ///
    /// A move consists of choosing any row or column, and toggling each value 
    /// in that row or column: changing all 0s to 1s, and all 1s to 0s.
    ///
    /// After making any number of moves, every row of this matrix is interpreted 
    /// as a binary number, and the score of the matrix is the sum of these 
    /// numbers.
    ///
    /// Return the highest possible score.
    ///
    /// Example 1:
    ///
    /// Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]
    /// Output: 39
    /// Explanation:
    /// Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].
    /// 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
    /// 
    /// 
    /// Note:
    ///
    /// 1. 1 <= A.length <= 20
    /// 2. 1 <= A[0].length <= 20
    /// 3. A[i][j] is 0 or 1.
    /// </summary>
    int matrixScore(vector<vector<int>>& A);

    /// <summary>
    /// Leet code #1486. XOR Operation in an Array
    /// 
    /// Easy
    ///
    /// Given an integer n and an integer start.
    /// Define an array nums where nums[i] = start + 2*i (0-indexed) and 
    /// n == nums.length.
    ///
    /// Return the bitwise XOR of all elements of nums.
    ///
    /// Example 1:
    /// Input: n = 5, start = 0
    /// Output: 8
    /// Explanation: Array nums is equal to [0, 2, 4, 6, 8] where 
    /// (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8.
    /// Where "^" corresponds to bitwise XOR operator.
    ///
    /// Example 2:
    /// Input: n = 4, start = 3
    /// Output: 8
    /// Explanation: Array nums is equal to [3, 5, 7, 9] where 
    /// (3 ^ 5 ^ 7 ^ 9) = 8.
    ///
    /// Example 3:
    /// Input: n = 1, start = 7
    /// Output: 7
    ///
    /// Example 4:
    /// Input: n = 10, start = 5
    /// Output: 2
    ///
    /// Constraints:
    /// 1. 1 <= n <= 1000
    /// 2. 0 <= start <= 1000
    /// 3. n == nums.length
    /// </summary>
    int xorOperation(int n, int start);

    /// <summary>
    /// Leet code #1521. Find a Value of a Mysterious Function Closest to 
    ///                  Target
    /// 
    /// Hard
    ///
    /// Winston was given the above mysterious function func. He has an 
    /// integer array arr and an integer target and he wants to find the 
    /// values l and r that make the value |func(arr, l, r) - target| 
    /// minimum possible.
    ///
    /// Return the minimum possible value of |func(arr, l, r) - target|.
    ///
    /// Notice that func should be called with the values l and r where 
    /// 0 <= l, r < arr.length.
    ///
    /// Example 1:
    ///
    /// Input: arr = [9,12,3,7,15], target = 5
    /// Output: 2
    /// Explanation: Calling func with all the pairs of [l,r] =
    /// [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],
    /// [2,4],[0,3],[1,4],[0,4]], Winston got the following results 
    /// [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0]. The value closest to 5 is 7 and 3, 
    /// thus the minimum difference is 2.
    ///
    /// Example 2:
    /// Input: arr = [1000000,1000000,1000000], target = 1
    /// Output: 999999
    /// Explanation: Winston called the func with all possible values of 
    /// [l,r] and he always got 1000000, thus the min difference is 999999.
    ///
    /// Example 3:
    /// Input: arr = [1,2,4,8,16], target = 0
    /// Output: 0
    ///
    /// Constraints:
    /// 1. 1 <= arr.length <= 10^5
    /// 2. 1 <= arr[i] <= 10^6
    /// 3. 0 <= target <= 10^7
    /// </summary>
    int closestToTarget(vector<int>& arr, int target);

    /// <summary>
    /// Leet code #1529. Bulb Switcher IV
    /// 
    /// Medium
    ///
    /// There is a room with n bulbs, numbered from 0 to n-1, arranged in a 
    /// row from left to right. Initially all the bulbs are turned off.
    ///
    /// Your task is to obtain the configuration represented by target where 
    /// target[i] is '1' if the i-th bulb is turned on and is '0' if it is 
    /// turned off.
    ///
    /// You have a switch to flip the state of the bulb, a flip operation is 
    /// defined as follows:
    ///
    /// Choose any bulb (index i) of your current configuration.
    /// Flip each bulb from index i to n-1.
    /// When any bulb is flipped it means that if it is 0 it changes to 1 and 
    /// if it is 1 it changes to 0.
    ///
    /// Return the minimum number of flips required to form target.
    /// 
    /// Example 1:
    ///
    /// Input: target = "10111"
    /// Output: 3
    /// Explanation: Initial configuration "00000".
    /// flip from the third bulb:  "00000" -> "00111"
    /// flip from the first bulb:  "00111" -> "11000"
    /// flip from the second bulb:  "11000" -> "10111"
    /// We need at least 3 flip operations to form target.
    ///
    /// Example 2:
    /// Input: target = "101"
    /// Output: 3
    /// Explanation: "000" -> "111" -> "100" -> "101".
    ///
    /// Example 3:
    /// Input: target = "00000"
    /// Output: 0
    ///
    /// Example 4:
    /// Input: target = "001011101"
    /// Output: 5
    /// 
    /// Constraints:
    /// 1. 1 <= target.length <= 10^5
    /// 2. target[i] == '0' or target[i] == '1'
    /// </summary>
    int minFlips(string target);

    /// <summary>
    /// Leet code #1545. Find Kth Bit in Nth Binary String
    /// 
    /// Medium
    ///
    /// Given two positive integers n and k, the binary string  
    /// Sn is formed as follows:
    ///
    /// S1 = "0" 
    /// s[i] and s[i + 1] where:
    ///
    /// Si = Si-1 + "1" + reverse(invert(Si-1)) for i > 1
    /// Where + denotes the concatenation operation, reverse(x) returns 
    /// the reversed string x, and invert(x) inverts all the bits in 
    /// x (0 changes to 1 and 1 changes to 0).
    /// 
    /// For example, the first 4 strings in the above sequence are:
    /// S1 = "0"
    /// S2 = "011"
    /// S3 = "0111001"
    /// S4 = "011100110110001"
    /// Return the kth bit in Sn. It is guaranteed that k is valid for the given n.
    ///
    /// Example 1:
    /// Input: n = 3, k = 1
    /// Output: "0"
    /// Explanation: S3 is "0111001". The first bit is "0".
    ///
    /// Example 2:
    /// Input: n = 4, k = 11
    /// Output: "1"
    /// Explanation: S4 is "011100110110001". The 11th bit is "1".
    /// Example 3:
    /// Input: n = 1, k = 1
    /// Output: "0"
    ///
    /// Example 4:
    /// Input: n = 2, k = 3
    /// Output: "1"
    /// Constraints:
    /// 1. 1 <= n <= 20
    /// 2. 1 <= k <= 2n - 1
    /// 3. 0 <= i <= s.length - 2
    /// </summary>
    char findKthBit(int n, int k);

    /// <summary>
    /// Leet code #1707. Maximum XOR With an Element From Array
    /// 
    /// Hard
    /// 
    /// You are given an array nums consisting of non-negative integers. 
    /// You are also given a queries array, where queries[i] = [xi, mi].
    ///
    /// The answer to the ith query is the maximum bitwise XOR value of xi 
    /// and any element of nums that does not exceed mi. In other words, the 
    /// answer is max(nums[j] XOR xi) for all j such that nums[j] <= mi. If 
    /// all elements in nums are larger than mi, then the answer is -1.
    ///
    /// Return an integer array answer where answer.length == queries.length 
    /// and answer[i] is the answer to the ith query.
    ///
    /// Example 1:
    /// Input: nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]
    /// Output: [3,3,7]
    /// Explanation:
    /// 1) 0 and 1 are the only two integers not greater than 1. 0 XOR 
    ///    3 = 3 and 1 XOR 3 = 2. The larger of the two is 3.
    /// 2) 1 XOR 2 = 3.
    /// 3) 5 XOR 2 = 7.
    /// Example 2:
    /// 
    /// Input: nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]
    /// Output: [15,-1,5]
    /// Constraints:
    /// 1. 1 <= nums.length, queries.length <= 10^5
    /// 2. queries[i].length == 2
    /// 3. 0 <= nums[j], xi, mi <= 10^9
    /// </summary>
    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries);

    /// <summary>
    /// Leet code 1734. Decode XORed Permutation
    /// 
    /// Medium
    /// 
    /// There is an integer array perm that is a permutation of the first n 
    /// positive integers, where n is always odd.
    ///
    /// It was encoded into another integer array encoded of length n - 1, 
    /// such that encoded[i] = perm[i] XOR perm[i + 1]. For example, if 
    /// perm = [1,3,2], then encoded = [2,1].
    ///
    /// Given the encoded array, return the original array perm. It is 
    /// guaranteed that the answer exists and is unique.
    /// 
    /// Example 1:
    /// Input: encoded = [3,1]
    /// Output: [1,2,3]
    /// Explanation: If perm = [1,2,3], then encoded = [1 XOR 2,2 XOR 3] 
    /// = [3,1]
    ///
    /// Example 2:
    /// Input: encoded = [6,5,4,6]
    /// Output: [2,4,1,5,3]
    /// Constraints:
    /// 1. 3 <= n < 10^5
    /// 2. n is odd.
    /// 3. encoded.length == n - 1
    /// </summary>
    vector<int> decode(vector<int>& encoded);

    /// <summary>
    /// Leet code 1803. Count Pairs With XOR in a Range
    /// 
    /// Hard
    /// 
    /// Given a (0-indexed) integer array nums and two integers low and 
    /// high, return the number of nice pairs.
    ///
    /// A nice pair is a pair (i, j) where 0 <= i < j < nums.length and 
    /// low <= (nums[i] XOR nums[j]) <= high.
    /// 
    /// Example 1:
    /// Input: nums = [1,4,2,7], low = 2, high = 6
    /// Output: 6
    /// Explanation: All nice pairs (i, j) are as follows:
    /// - (0, 1): nums[0] XOR nums[1] = 5 
    /// - (0, 2): nums[0] XOR nums[2] = 3
    /// - (0, 3): nums[0] XOR nums[3] = 6
    /// - (1, 2): nums[1] XOR nums[2] = 6
    /// - (1, 3): nums[1] XOR nums[3] = 3
    /// - (2, 3): nums[2] XOR nums[3] = 5
    ///
    /// Example 2:
    /// Input: nums = [9,8,4,2,1], low = 5, high = 14
    /// Output: 8
    /// Explanation: All nice pairs (i, j) are as follows:
    /// - (0, 2): nums[0] XOR nums[2] = 13
    /// - (0, 3): nums[0] XOR nums[3] = 11
    /// - (0, 4): nums[0] XOR nums[4] = 8
    /// - (1, 2): nums[1] XOR nums[2] = 12
    /// - (1, 3): nums[1] XOR nums[3] = 10
    /// - (1, 4): nums[1] XOR nums[4] = 9
    /// - (2, 3): nums[2] XOR nums[3] = 6
    /// - (2, 4): nums[2] XOR nums[4] = 5
    /// 
    /// Constraints:
    /// 1. 1 <= nums.length <= 2 * 10^4
    /// 2. 1 <= nums[i] <= 2 * 10^4
    /// 3. 1 <= low <= high <= 2 * 10^4
    /// </summary>
    int countPairs(vector<int>& nums, int low, int high);

    /// <summary>
    /// Leet code 1803. Count Pairs With XOR in a Range
    /// </summary>
    int countPairs2(vector<int>& nums, int low, int high);

    /// <summary>
    /// Leet code 1803. Count Pairs With XOR in a Range
    /// </summary>
    int countPairs3(vector<int>& nums, int low, int high);

    /// <summary>
    /// Leet code 1829. Maximum XOR for Each Query
    /// 
    /// Medium
    /// 
    /// You are given a sorted array nums of n non-negative integers and an 
    /// integer maximumBit. You want to perform the following query n times:
    ///
    /// Find a non-negative integer k < 2maximumBit such that nums[0] XOR 
    /// nums[1] XOR ... XOR nums[nums.length-1] XOR k is maximized. k is the 
    /// answer to the ith query.
    /// Remove the last element from the current array nums.
    /// Return an array answer, where answer[i] is the answer to the ith query.
    /// 
    /// Example 1:
    /// Input: nums = [0,1,1,3], maximumBit = 2
    /// Output: [0,3,2,3]
    /// Explanation: The queries are answered as follows:
    /// 1st query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.
    /// 2nd query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.
    /// 3rd query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3.
    /// 4th query: nums = [0], k = 3 since 0 XOR 3 = 3.
    ///
    /// Example 2:
    /// Input: nums = [2,3,4,7], maximumBit = 3
    /// Output: [5,2,6,5]
    /// Explanation: The queries are answered as follows:
    /// 1st query: nums = [2,3,4,7], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7.
    /// 2nd query: nums = [2,3,4], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7.
    /// 3rd query: nums = [2,3], k = 6 since 2 XOR 3 XOR 6 = 7.
    /// 4th query: nums = [2], k = 5 since 2 XOR 5 = 7.
    ///
    /// Example 3:
    /// Input: nums = [0,1,2,2,5,7], maximumBit = 3
    /// Output: [4,3,6,4,6,7]
    /// Constraints:
    /// 1. nums.length == n
    /// 2. 1 <= n <= 10^5
    /// 3. 1 <= maximumBit <= 20
    /// 4. 0 <= nums[i] < 2^maximumBit
    /// 5. nums is sorted in ascending order.
    /// </summary>
    vector<int> getMaximumXor(vector<int>& nums, int maximumBit);

    /// <summary>
    /// Leet code 1835. Find XOR Sum of All Pairs Bitwise AND
    /// 
    /// Hard
    /// 
    /// The XOR sum of a list is the bitwise XOR of all its elements. If the 
    /// list only contains one element, then its XOR sum will be equal to this 
    /// element.
    ///
    /// For example, the XOR sum of [1,2,3,4] is equal to 1 XOR 2 XOR 3 XOR 
    /// 4 = 4, and the XOR sum of [3] is equal to 3.
    /// You are given two 0-indexed arrays arr1 and arr2 that consist only of 
    /// non-negative integers.
    ///
    /// Consider the list containing the result of arr1[i] AND arr2[j] 
    /// (bitwise AND) for every (i, j) pair where 0 <= i < arr1.length and 
    /// 0 <= j < arr2.length.
    ///
    /// Return the XOR sum of the aforementioned list.
    /// Example 1:
    /// Input: arr1 = [1,2,3], arr2 = [6,5]
    /// Output: 0
    /// Explanation: The list = [1 AND 6, 1 AND 5, 2 AND 6, 2 AND 5, 3 
    /// AND 6, 3 AND 5] = [0,1,2,0,2,1].
    /// The XOR sum = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0.
    ///
    /// Example 2:
    /// Input: arr1 = [12], arr2 = [4]
    /// Output: 4
    /// Explanation: The list = [12 AND 4] = [4]. The XOR sum = 4.
    ///
    /// Constraints:
    /// 1. 1 <= arr1.length, arr2.length <= 10^5
    /// 2. 0 <= arr1[i], arr2[j] <= 10^9
    /// </summary>
    int getXORSum(vector<int>& arr1, vector<int>& arr2);

    /// <summary>
    /// Leet code 1863. Sum of All Subset XOR Totals
    /// 
    /// Easy
    /// 
    /// The XOR total of an array is defined as the bitwise XOR of all its 
    /// elements, or 0 if the array is empty.
    ///
    /// For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
    /// Given an array nums, return the sum of all XOR totals for every subset 
    /// of nums. 
    ///
    /// Note: Subsets with the same elements should be counted multiple times.
    ///
    /// An array a is a subset of an array b if a can be obtained from b by 
    /// deleting some (possibly zero) elements of b.
    /// 
    /// Example 1:
    /// Input: nums = [1,3]
    /// Output: 6
    /// Explanation: The 4 subsets of [1,3] are:
    /// - The empty subset has an XOR total of 0.
    /// - [1] has an XOR total of 1.
    /// - [3] has an XOR total of 3.
    /// - [1,3] has an XOR total of 1 XOR 3 = 2.
    /// 0 + 1 + 3 + 2 = 6
    ///
    /// Example 2:
    /// Input: nums = [5,1,6]
    /// Output: 28
    /// Explanation: The 8 subsets of [5,1,6] are:
    /// - The empty subset has an XOR total of 0.
    /// - [5] has an XOR total of 5.
    /// - [1] has an XOR total of 1.
    /// - [6] has an XOR total of 6.
    /// - [5,1] has an XOR total of 5 XOR 1 = 4.
    /// - [5,6] has an XOR total of 5 XOR 6 = 3.
    /// - [1,6] has an XOR total of 1 XOR 6 = 7.
    /// - [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.
    /// 0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28
    ///
    /// Example 3:
    /// Input: nums = [3,4,5,6,7,8]
    /// Output: 480
    /// Explanation: The sum of all XOR totals for every subset is 480.
    ///
    /// Constraints:
    /// 1. 1 <= nums.length <= 12
    /// 2. 1 <= nums[i] <= 20
    /// </summary>
    int subsetXORSum(vector<int>& nums);

    /// <summary>
    /// Leet code 1938. Maximum Genetic Difference Query
    /// </summary>
    void maxGeneticDifference(TrieBitNode* root, int node_id, vector<vector<int>>& tree, 
        vector<vector<pair<int, int>>>& query_list, vector<int> & result);

    /// <summary>
    /// Leet code 1938. Maximum Genetic Difference Query
    ///                                  
    /// Hard
    /// 
    /// There is a rooted tree consisting of n nodes numbered 0 to n - 1. 
    /// Each node's number denotes its unique genetic value (i.e. the genetic 
    /// value of node x is x). The genetic difference between two genetic 
    /// values is defined as the bitwise-XOR of their values. You are given 
    /// the integer array parents, where parents[i] is the parent for node i. 
    /// If node x is the root of the tree, then parents[x] == -1.
    ///
    /// You are also given the array queries where queries[i] = [nodei, vali]. 
    /// For each query i, find the maximum genetic difference between vali and 
    /// pi, where pi is the genetic value of any node that is on the path 
    /// between nodei and the root (including nodei and the root). More 
    /// formally, you want to maximize vali XOR pi.
    ///
    /// Return an array ans where ans[i] is the answer to the ith query.
    /// 
    /// Example 1:
    /// Input: parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]]
    /// Output: [2,3,7]
    /// Explanation: The queries are processed as follows:
    /// - [0,2]: The node with the maximum genetic difference is 0, with a 
    ///   difference of 2 XOR 0 = 2.
    /// - [3,2]: The node with the maximum genetic difference is 1, with 
    ///   a difference of 2 XOR 1 = 3.
    /// - [2,5]: The node with the maximum genetic difference is 2, with 
    ///   a difference of 5 XOR 2 = 7.
    ///
    /// Example 2:
    /// Input: parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]]
    /// Output: [6,14,7]
    /// Explanation: The queries are processed as follows:
    /// - [4,6]: The node with the maximum genetic difference is 0, with a 
    ///   difference of 6 XOR 0 = 6.
    /// - [1,15]: The node with the maximum genetic difference is 1, with a 
    ///   difference of 15 XOR 1 = 14.
    /// - [0,5]: The node with the maximum genetic difference is 2, with 
    ///   a difference of 5 XOR 2 = 7.
    ///
    /// Constraints:
    /// 1. 2 <= parents.length <= 10^5
    /// 2. 0 <= parents[i] <= parents.length - 1 for every node i that is not 
    ///    the root.
    /// 3. parents[root] == -1
    /// 4. 1 <= queries.length <= 3 * 10^4
    /// 5. 0 <= nodei <= parents.length - 1
    /// 6. 0 <= vali <= 2 * 10^5
    /// </summary>
    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries);

    /// <summary>
    /// Leet 1980. Find Unique Binary String
    ///                                                                 
    /// Medium
    /// 
    /// Given an array of strings nums containing n unique binary strings each 
    /// of length n, return a binary string of length n that does not appear 
    /// in nums. If there are multiple answers, you may return any of them.
    ///
    /// Example 1:
    /// Input: nums = ["01","10"]
    /// Output: "11"
    /// Explanation: "11" does not appear in nums. "00" would also be correct.
    ///
    /// Example 2:
    /// Input: nums = ["00","01"]
    /// Output: "11"
    /// Explanation: "11" does not appear in nums. "10" would also be correct.
    ///
    /// Example 3:
    /// Input: nums = ["111","011","001"]
    /// Output: "101"
    /// Explanation: "101" does not appear in nums. "000", "010", "100", 
    /// and "110" would also be correct.
    /// 
    /// Constraints:
    /// 1. n == nums.length
    /// 2. 1 <= n <= 16
    /// 3. nums[i].length == n
    /// 4. nums[i] is either '0' or '1'.
    /// 5. All the strings of nums are unique.
    /// </summary>
    string findDifferentBinaryString(vector<string> & nums); 

    /// <summary>
    /// Leet Code 2220. Minimum Bit Flips to Convert Number
    ///                                                                                   
    /// Easy
    ///
    /// A bit flip of a number x is choosing a bit in the binary 
    /// representation of x and flipping it from either 0 to 1 or 1 to 0.
    ///
    /// For example, for x = 7, the binary representation is 111 and we 
    /// may choose any bit (including any leading zeros not shown) and 
    /// flip it. We can flip the first bit from the right to get 110, flip 
    /// the second bit from the right to get 101, flip the fifth bit from 
    /// the right (a leading zero) to get 10111, etc.
    /// Given two integers start and goal, return the minimum number of 
    /// bit flips to convert start to goal.
    /// 
    /// Example 1:
    /// Input: start = 10, goal = 7
    /// Output: 3
    /// Explanation: The binary representation of 10 and 7 are 1010 and 0111 
    /// respectively. We can convert 10 to 7 in 3 steps:
    /// - Flip the first bit from the right: 1010 -> 1011.
    /// - Flip the third bit from the right: 1011 -> 1111.
    /// - Flip the fourth bit from the right: 1111 -> 0111.
    /// It can be shown we cannot convert 10 to 7 in less than 3 steps. 
    /// Hence, we return 3.
    ///
    /// Example 2:
    /// Input: start = 3, goal = 4
    /// Output: 3
    /// Explanation: The binary representation of 3 and 4 are 011 and 100 
    /// respectively. We can convert 3 to 4 in 3 steps:
    /// - Flip the first bit from the right: 011 -> 010.
    /// - Flip the second bit from the right: 010 -> 000.
    /// - Flip the third bit from the right: 000 -> 100.
    /// It can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, 
    /// we return 3.
    /// 
    /// Constraints:
    /// 1. 0 <= start, goal <= 10^9
    /// </summary>
    int minBitFlips(int start, int goal);

    /// <summary>
    /// Leet Code 2275. Largest Combination With Bitwise AND Greater Than Zero
    ///                                                           
    /// Medium
    /// 
    /// The bitwise AND of an array nums is the bitwise AND of all integers in 
    /// nums.
    ///
    /// For example, for nums = [1, 5, 3], the bitwise AND is equal 
    /// to 1 & 5 & 3 = 1.
    /// Also, for nums = [7], the bitwise AND is 7.
    /// You are given an array of positive integers candidates. Evaluate the 
    /// bitwise AND of every combination of numbers of candidates. Each 
    /// number in candidates may only be used once in each combination.
    ///
    /// Return the size of the largest combination of candidates with a 
    /// bitwise AND greater than 0.
    /// 
    /// Example 1:
    /// Input: candidates = [16,17,71,62,12,24,14]
    /// Output: 4
    /// Explanation: The combination [16,17,62,24] has a bitwise AND 
    /// of 16 & 17 & 62 & 24 = 16 > 0.
    /// The size of the combination is 4.
    /// It can be shown that no combination with a size greater than 4 has a 
    /// bitwise AND greater than 0.
    /// Note that more than one combination may have the largest size.
    /// For example, the combination [62,12,24,14] has a bitwise AND 
    /// of 62 & 12 & 24 & 14 = 8 > 0.
    ///
    /// Example 2:
    /// Input: candidates = [8,8]
    /// Output: 2
    /// Explanation: The largest combination [8,8] has a bitwise AND 
    /// of 8 & 8 = 8 > 0.
    /// The size of the combination is 2, so we return 2.
    /// 
    /// Constraints:
    /// 1. 1 <= candidates.length <= 10^5
    /// 2. 1 <= candidates[i] <= 10^7
    /// </summary>
    int largestCombination(vector<int>& candidates);

    /// <summary>
    /// Leet Code 2317. Maximum XOR After Operations
    ///                                                           
    /// Medium
    ///
    /// You are given a 0-indexed integer array nums. In one operation, select 
    /// any non-negative integer x and an index i, then update nums[i] to be 
    /// equal to nums[i] AND (nums[i] XOR x).
    ///
    /// Note that AND is the bitwise AND operation and XOR is the bitwise XOR 
    /// operation.
    ///
    /// Return the maximum possible bitwise XOR of all elements of nums after 
    /// applying the operation any number of times.
    ///
    /// Example 1:
    /// Input: nums = [3,2,4,6]
    /// Output: 7
    /// Explanation: Apply the operation with x = 4 and i = 3, num[3] = 6 
    /// AND (6 XOR 4) = 6 AND 2 = 2.
    /// Now, nums = [3, 2, 4, 2] and the bitwise XOR of all the elements = 3 
    /// XOR 2 XOR 4 XOR 2 = 7.
    /// It can be shown that 7 is the maximum possible bitwise XOR.
    /// Note that other operations may be used to achieve a bitwise XOR of 7.
    ///
    /// Example 2:
    /// Input: nums = [1,2,3,9,2]
    /// Output: 11
    /// Explanation: Apply the operation zero times.
    /// The bitwise XOR of all the elements = 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11.
    /// It can be shown that 11 is the maximum possible bitwise XOR.
    /// 
    /// Constraints:
    /// 1. 1 <= nums.length <= 10^5
    /// 2. 0 <= nums[i] <= 10^8
    /// </summary>
    int maximumXOR(vector<int>& nums);

    /// <summary>
    /// Leet Code 2354. Number of Excellent Pairs
    ///                                                  
    /// Hard
    ///
    /// You are given a 0-indexed positive integer array nums and a positive 
    /// integer k.
    ///
    /// A pair of numbers (num1, num2) is called excellent if the following 
    /// conditions are satisfied:
    ///
    /// Both the numbers num1 and num2 exist in the array nums.
    /// The sum of the number of set bits in num1 OR num2 and num1 AND num2 
    /// is greater than or equal to k, where OR is the bitwise OR operation 
    /// and AND is the bitwise AND operation.
    /// Return the number of distinct excellent pairs.
    ///
    /// Two pairs (a, b) and (c, d) are considered distinct if either a != c 
    /// or b != d. For example, (1, 2) and (2, 1) are distinct.
    ///
    /// Note that a pair (num1, num2) such that num1 == num2 can also be 
    /// excellent if you have at least one occurrence of num1 in the array.
    ///
    /// Example 1:
    /// Input: nums = [1,2,3,1], k = 3
    /// Output: 5
    /// Explanation: The excellent pairs are the following:
    /// - (3, 3). (3 AND 3) and (3 OR 3) are both equal to (11) in binary. 
    ///   The total number of set bits is 2 + 2 = 4, which is greater than 
    ///   or equal to k = 3.
    /// - (2, 3) and (3, 2). (2 AND 3) is equal to (10) in binary, and 
    ///   (2 OR 3) is equal to (11) in binary. The total number of set bits 
    ///   is 1 + 2 = 3.
    /// - (1, 3) and (3, 1). (1 AND 3) is equal to (01) in binary, and 
    ///   (1 OR 3) is equal to (11) in binary. The total number of set bits 
    ///   is 1 + 2 = 3.
    /// So the number of excellent pairs is 5.
    ///
    /// Example 2:
    /// Input: nums = [5,1,1], k = 10
    /// Output: 0
    /// Explanation: There are no excellent pairs for this array.
    ///
    /// Constraints:
    /// 1. 1 <= nums.length <= 10^5
    /// 2. 1 <= nums[i] <= 10^9
    /// 3. 1 <= k <= 60
    /// </summary>
    long long countExcellentPairs(vector<int>& nums, int k);

    /// <summary>
    /// Leet Code 2425. Bitwise XOR of All Pairings
    ///                                                  
    /// Medium
    ///
    /// You are given two 0-indexed arrays, nums1 and nums2, consisting of 
    /// non-negative integers. There exists another array, nums3, which 
    /// contains the bitwise XOR of all pairings of integers between nums1 
    /// and nums2 (every integer in nums1 is paired with every integer in 
    /// nums2 exactly once).
    ///
    /// Return the bitwise XOR of all integers in nums3.
    /// Example 1:
    /// Input: nums1 = [2,1,3], nums2 = [10,2,5,0]
    /// Output: 13
    /// Explanation:
    /// A possible nums3 array is [8,0,7,2,11,3,4,1,9,1,6,3].
    /// The bitwise XOR of all these numbers is 13, so we return 13.
    ///
    /// Example 2:
    /// Input: nums1 = [1,2], nums2 = [3,4]
    /// Output: 0
    /// Explanation:
    /// All possible pairs of bitwise XORs are nums1[0] ^ nums2[0], 
    /// nums1[0] ^ nums2[1], nums1[1] ^ nums2[0],
    /// and nums1[1] ^ nums2[1].
    /// Thus, one possible nums3 array is [2,5,1,6].
    /// 2 ^ 5 ^ 1 ^ 6 = 0, so we return 0.
    /// 
    /// Constraints:
    /// 1. 1 <= nums1.length, nums2.length <= 10^5
    /// 2. 0 <= nums1[i], nums2[j] <= 10^9
    /// </summary>
    int xorAllNums(vector<int>& nums1, vector<int>& nums2);

    /// <summary>
    /// Leet Code 2429. Minimize XOR
    ///                                                  
    /// Medium
    ///
    /// Given two positive integers num1 and num2, find the integer x such 
    /// that:
    ///
    /// x has the same number of set bits as num2, and
    /// The value x XOR num1 is minimal.
    /// Note that XOR is the bitwise XOR operation.
    ///
    /// Return the integer x. The test cases are generated such that x 
    /// is uniquely determined.
    ///
    /// The number of set bits of an integer is the number of 1's in its 
    /// binary representation.
    /// 
    /// Example 1:
    /// Input: num1 = 3, num2 = 5
    /// Output: 3
    /// Explanation:
    /// The binary representations of num1 and num2 are 0011 and 0101, 
    /// respectively.
    /// The integer 3 has the same number of set bits as num2, and the value 3 
    /// XOR 3 = 0 is minimal.
    ///
    /// Example 2:
    /// Input: num1 = 1, num2 = 12
    /// Output: 3
    /// Explanation:
    /// The binary representations of num1 and num2 are 0001 and 1100, 
    /// respectively.
    /// The integer 3 has the same number of set bits as num2, and the value 3 
    /// XOR 1 = 2 is minimal.
    /// 
    /// Constraints:
    ///
    /// 1. 1 <= num1, num2 <= 10^9
    /// </summary>
    int minimizeXor(int num1, int num2);

    /// <summary>
    /// Leet Code 2433. Find The Original Array of Prefix Xor
    ///                                                  
    /// Medium
    ///
    /// You are given an integer array pref of size n. Find and return the 
    /// array arr of size n that satisfies:
    ///
    /// pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].
    /// Note that ^ denotes the bitwise-xor operation.
    ///
    /// It can be proven that the answer is unique.
    /// 
    /// Example 1:
    /// Input: pref = [5,2,0,3,1]
    /// Output: [5,7,2,3,2]
    /// Explanation: From the array [5,7,2,3,2] we have the following:
    /// - pref[0] = 5.
    /// - pref[1] = 5 ^ 7 = 2.
    /// - pref[2] = 5 ^ 7 ^ 2 = 0.
    /// - pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.
    /// - pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.
    ///
    /// Example 2:
    /// Input: pref = [13]
    /// Output: [13]
    /// Explanation: We have pref[0] = arr[0] = 13.
    /// 
    /// Constraints:
    /// 1. 1 <= pref.length <= 10^5
    /// 2. 0 <= pref[i] <= 10^6
    /// </summary>
    vector<int> findArray(vector<int>& pref);

    /// <summary>
    /// Leet Code 2479. Maximum XOR of Two Non-Overlapping Subtrees
    /// </summary>
    long long maxXorSum(int node, vector<vector<int>>& neighbors, 
        vector<int>& values, vector<int>& visited, vector<long long>& sums);

    /// <summary>
    /// Leet Code 2479. Maximum XOR of Two Non-Overlapping Subtrees
    /// </summary>
    void maxXorFind(int node, vector<vector<int>>& neighbors,
        vector<int>& visited, vector<long long>& sums, TrieBitNode * trie,
        long long &result);

    /// <summary>
    /// Leet Code 2479. Maximum XOR of Two Non-Overlapping Subtrees
    /// 
    /// Hard
    ///	
    /// There is an undirected tree with n nodes labeled from 0 to n - 1. 
    /// You are given the integer n and a 2D integer array edges of length 
    /// n - 1, where edges[i] = [ai, bi] indicates that there is an edge 
    /// between nodes ai and bi in the tree. The root of the tree is the node 
    /// labeled 0.
    ///
    /// Each node has an associated value. You are given an array values of 
    /// length n, where values[i] is the value of the ith node.
    ///
    /// Select any two non-overlapping subtrees. Your score is the bitwise 
    /// XOR of the sum of the values within those subtrees.
    ///
    /// Return the maximum possible score you can achieve. If it is impossible 
    /// to find two nonoverlapping subtrees, return 0.
    ///
    /// Note that:
    /// 1. The subtree of a node is the tree consisting of that node and all 
    ///    of its descendants.
    /// 2. Two subtrees are non-overlapping if they do not share any common 
    ///    node.
    /// 
    /// Example 1:
    /// 1. Input: n = 6, edges = [[0,1],[0,2],[1,3],[1,4],[2,5]], 
    ///    values = [2,8,3,6,2,5] 
    /// Output: 24
    /// Explanation: Node 1's subtree has sum of values 16, while node 2's 
    /// subtree has sum of values 8, so choosing these nodes will yield a 
    /// score of 16 XOR 8 = 24. It can be proved that is the maximum possible 
    /// score we can obtain.
    ///
    /// Example 2:
    /// Input: n = 3, edges = [[0,1],[1,2]], values = [4,6,1]
    /// Output: 0
    /// Explanation: There is no possible way to select two non-overlapping 
    /// subtrees, so we just return 0.
    /// 
    /// Constraints:
    /// 1. 2 <= n <= 5 * 10^4
    /// 2. edges.length == n - 1
    /// 3. 0 <= ai, bi < n
    /// 4. values.length == n
    /// 5. 1 <= values[i] <= 10^9
    /// 6. It is guaranteed that edges represents a valid tree.
    /// </summary>
    long long maxXor(int n, vector<vector<int>>& edges, vector<int>& values);

    /// <summary>
    /// Leet Code 2505. Bitwise OR of All Subsequence Sums
    /// 
    /// Medium
    ///	
    /// Given an integer array nums, return the value of the bitwise OR of 
    /// the sum of all possible subsequences in the array.
    ///
    /// A subsequence is a sequence that can be derived from another 
    /// sequence by removing zero or more elements without changing the 
    /// order of the remaining elements.
    ///
    /// Example 1:
    /// Input: nums = [2,1,0,3]
    /// Output: 7
    /// Explanation: All possible subsequence sums that we can have 
    /// are: 0, 1, 2, 3, 4, 5, 6.
    /// And we have 0 OR 1 OR 2 OR 3 OR 4 OR 5 OR 6 = 7, so we return 7.
    ///
    /// Example 2:
    /// Input: nums = [0,0,0]
    /// Output: 0
    /// Explanation: 0 is the only possible subsequence sum we can have, 
    /// so we return 0.
    ///
    /// Constraints:
    /// 
    /// 1. 1 <= nums.length <= 10^5
    /// 2. 0 <= nums[i] <= 10^9
    /// </summary>
    long long subsequenceSumOr(vector<int>& nums);

    /// <summary>
    /// Leet Code 2527. Find Xor-Beauty of Array
    /// 
    /// Medium
    ///	
    /// You are given a 0-indexed integer array nums.
    ///
    /// The effective value of three indices i, j, and k is defined as 
    /// ((nums[i] | nums[j]) & nums[k]).
    ///
    /// The xor-beauty of the array is the XORing of the effective values of 
    /// all the possible triplets of indices (i, j, k) where 0 <= i, j, k < n.
    ///
    /// Return the xor-beauty of nums.
    ///
    /// Note that:
    /// val1 | val2 is bitwise OR of val1 and val2.
    /// val1 & val2 is bitwise AND of val1 and val2.
    /// 
    /// Example 1:
    /// Input: nums = [1,4]
    /// Output: 5
    /// Explanation: 
    /// The triplets and their corresponding effective values are listed below:
    /// - (0,0,0) with effective value ((1 | 1) & 1) = 1
    /// - (0,0,1) with effective value ((1 | 1) & 4) = 0
    /// - (0,1,0) with effective value ((1 | 4) & 1) = 1
    /// - (0,1,1) with effective value ((1 | 4) & 4) = 4
    /// - (1,0,0) with effective value ((4 | 1) & 1) = 1
    /// - (1,0,1) with effective value ((4 | 1) & 4) = 4
    /// - (1,1,0) with effective value ((4 | 4) & 1) = 0
    /// - (1,1,1) with effective value ((4 | 4) & 4) = 4 
    /// Xor-beauty of array will be bitwise XOR of all beauties 
    /// = 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5.
    ///
    /// Example 2:
    /// Input: nums = [15,45,20,2,34,35,5,44,32,30]
    /// Output: 34
    /// Explanation: The xor-beauty of the given array is 34.
    /// 
    /// Constraints:
    /// 1. 1 <= nums.length <= 10^5
    /// 2. 1 <= nums[i] <= 10^9
    /// </summary>
    int xorBeauty(vector<int>& nums);

    /// <summary>
    /// Leet Code 2546. Apply Bitwise Operations to Make Strings Equal
    /// 
    /// Medium
    ///	
    /// You are given two 0-indexed binary strings s and target of the same 
    /// length n. You can do the following operation on s any number of times:
    ///
    /// Choose two different indices i and j where 0 <= i, j < n.
    /// Simultaneously, replace s[i] with (s[i] OR s[j]) and s[j] with (s[i] 
    /// XOR s[j]).
    /// For example, if s = "0110", you can choose i = 0 and j = 2, then 
    /// simultaneously replace s[0] with (s[0] OR s[2] = 0 OR 1 = 1), and 
    /// s[2] with (s[0] XOR s[2] = 0 XOR 1 = 1), so we will have s = "1110".
    ///
    /// Return true if you can make the string s equal to target, or false 
    /// otherwise.
    /// 
    /// Example 1:
    /// Input: s = "1010", target = "0110"
    /// Output: true
    /// Explanation: We can do the following operations:
    /// - Choose i = 2 and j = 0. We have now s = "0010".
    /// - Choose i = 2 and j = 1. We have now s = "0110".
    /// Since we can make s equal to target, we return true.
    ///
    /// Example 2:
    /// Input: s = "11", target = "00"
    /// Output: false
    /// Explanation: It is not possible to make s equal to target with any 
    /// number of operations.
    ///
    /// Constraints:
    /// 1. n == s.length == target.length
    /// 2. 2 <= n <= 10^5
    /// 3. s and target consist of only the digits 0 and 1.
    /// </summary>
    bool makeStringsEqual(string s, string target);

    /// <summary>
    /// Leet Code 2564. Substring XOR Queries
    /// 
    /// Medium
    ///	
    /// You are given a binary string s, and a 2D integer array queries where 
    /// queries[i] = [firsti, secondi].
    ///
    /// For the ith query, find the shortest substring of s whose decimal 
    /// value, val, yields secondi when bitwise XORed with firsti. In other 
    /// words, val ^ firsti == secondi.
    ///
    /// The answer to the ith query is the endpoints (0-indexed) of the 
    /// substring [lefti, righti] or [-1, -1] if no such substring exists. 
    /// If there are multiple answers, choose the one with the minimum lefti.
    ///
    /// Return an array ans where ans[i] = [lefti, righti] is the answer to 
    /// the ith query.
    ///
    /// A substring is a contiguous non-empty sequence of characters within 
    /// a string.
    /// 
    /// Example 1:
    /// Input: s = "101101", queries = [[0,5],[1,2]]
    /// Output: [[0,2],[2,3]]
    /// Explanation: For the first query the substring in range [0,2] is "101" 
    /// which has a decimal value of 5, and 5 ^ 0 = 5, hence the answer to the 
    /// first query is [0,2]. In the second query, the substring in 
    /// range [2,3] is "11", and has a decimal value of 3, and 3 ^ 1 = 2. 
    /// So, [2,3] is returned for the second query. 
    ///
    /// Example 2:
    /// Input: s = "0101", queries = [[12,8]]
    /// Output: [[-1,-1]]
    /// Explanation: In this example there is no substring that answers 
    /// the query, hence [-1,-1] is returned.
    ///
    /// Example 3:
    /// Input: s = "1", queries = [[4,5]]
    /// Output: [[0,0]]
    /// Explanation: For this example, the substring in range [0,0] has a 
    /// decimal value of 1, and 1 ^ 4 = 5. So, the answer is [0,0].
    /// 
    /// Constraints:
    /// 1. 1 <= s.length <= 10^4
    /// 2. s[i] is either '0' or '1'.
    /// 3. 1 <= queries.length <= 10^5
    /// 4. 0 <= firsti, secondi <= 10^9
    /// </summary>
    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries);

    /// <summary>
    /// Leet Code 2568. Minimum Impossible OR
    /// 
    /// Medium
    ///	
    /// You are given a 0-indexed integer array nums.
    ///
    /// We say that an integer x is expressible from nums if there exist 
    /// some integers 0 <= index1 < index2 < ... < indexk < nums.length 
    /// for which nums[index1] | nums[index2] | ... | nums[indexk] = x. 
    /// In other words, an integer is expressible if it can be written as 
    /// the bitwise OR of some subsequence of nums.
    ///
    /// Return the minimum positive non-zero integer that is not 
    /// expressible from nums.
    /// 
    /// Example 1:
    /// Input: nums = [2,1]
    /// Output: 4
    /// Explanation: 1 and 2 are already present in the array. We know 
    /// that 3 is expressible, since nums[0] | nums[1] = 2 | 1 = 3. 
    /// Since 4 is not expressible, we return 4.
    ///
    /// Example 2:
    /// Input: nums = [5,3,2]
    /// Output: 1
    /// Explanation: We can show that 1 is the smallest number that is not 
    /// expressible.
    ///
    /// Constraints:
    /// 1. 1 <= nums.length <= 10^5
    /// 2. 1 <= nums[i] <= 10^9
    /// </summary>
    int minImpossibleOR(vector<int>& nums);

    /// <summary>
    /// Leet Code 2571. Minimum Operations to Reduce an Integer to 0
    /// 
    /// Medium
    ///	
    /// You are given a positive integer n, you can do the following operation 
    /// any number of times:
    ///
    /// Add or subtract a power of 2 from n.
    /// Return the minimum number of operations to make n equal to 0.
    ///
    /// A number x is power of 2 if x == 2^i where i >= 0.
    /// 
    /// Example 1:
    /// Input: n = 39
    /// Output: 3
    /// Explanation: We can do the following operations:
    /// - Add 2^0 = 1 to n, so now n = 40.
    /// - Subtract 2^3 = 8 from n, so now n = 32.
    /// - Subtract 2^5 = 32 from n, so now n = 0.
    /// It can be shown that 3 is the minimum number of operations we need 
    /// to make n equal to 0.
    ///
    /// Example 2:
    /// Input: n = 54
    /// Output: 3
    /// Explanation: We can do the following operations:
    /// - Add 2^1 = 2 to n, so now n = 56.
    /// - Add 2^3 = 8 to n, so now n = 64.
    /// - Subtract 2^6 = 64 from n, so now n = 0.
    /// So the minimum number of operations is 3.
    ///
    /// Constraints:
    /// 1. 1 <= n <= 10^5
    /// </summary>
    int minOperations(int n);

    /// <summary>
    /// Leet Code 2569. Handling Sum Queries After Update
    /// 
    /// Hard
    ///	
    /// You are given two 0-indexed arrays nums1 and nums2 and a 2D array 
    /// queries of queries. There are three types of queries:
    ///
    /// For a query of type 1, queries[i] = [1, l, r]. Flip the values 
    /// from 0 to 1 and from 1 to 0 in nums1 from index l to index r. 
    /// Both l and r are 0-indexed.
    /// For a query of type 2, queries[i] = [2, p, 0]. For every 
    /// index 0 <= i < n, set nums2[i] = nums2[i] + nums1[i] * p.
    /// For a query of type 3, queries[i] = [3, 0, 0]. Find the sum of the 
    /// elements in nums2.
    /// Return an array containing all the answers to the third type queries.
    ///
    /// Example 1:
    /// Input: nums1 = [1,0,1], nums2 = [0,0,0], 
    /// queries = [[1,1,1],[2,1,0],[3,0,0]]
    /// Output: [3]
    /// Explanation: After the first query nums1 becomes [1,1,1]. After the 
    /// second query, nums2 becomes [1,1,1], so the answer to the third 
    /// query is 3. Thus, [3] is returned.
    ///
    /// Example 2:
    /// Input: nums1 = [1], nums2 = [5], queries = [[2,0,0],[3,0,0]]
    /// Output: [5]
    /// Explanation: After the first query, nums2 remains [5], so 
    /// the answer to the second query is 5. Thus, [5] is returned.
    ///
    /// Constraints:
    /// 1. 1 <= nums1.length,nums2.length <= 10^5
    /// 2. nums1.length = nums2.length
    /// 3. 1 <= queries.length <= 10^5
    /// </summary>
    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries);

    /// <summary>
    /// Leet Code 2683. Neighboring Bitwise XOR
    /// 
    /// Medium
    ///	
    /// A 0-indexed array derived with length n is derived by computing the 
    /// bitwise XOR (^) of adjacent values in a binary array original of 
    /// length n.
    ///
    /// Specifically, for each index i in the range [0, n - 1]:
    ///
    /// If i = n - 1, then derived[i] = original[i] xor original[0].
    /// Otherwise, derived[i] = original[i] xor original[i + 1].
    /// Given an array derived, your task is to determine whether there exists 
    /// a valid binary array original that could have formed derived.
    ///
    /// Return true if such an array exists or false otherwise.
    ///
    /// A binary array is an array containing only 0's and 1's
    /// 
    /// Example 1:
    /// Input: derived = [1,1,0]
    /// Output: true
    /// Explanation: A valid original array that gives derived is [0,1,0].
    /// derived[0] = original[0] xor original[1] = 0 xor 1 = 1 
    /// derived[1] = original[1] xor original[2] = 1 xor 0 = 1
    /// derived[2] = original[2] xor original[0] = 0 xor 0 = 0
    ///
    /// Example 2:
    /// Input: derived = [1,1]
    /// Output: true
    /// Explanation: A valid original array that gives derived is [0,1].
    /// derived[0] = original[0] xor original[1] = 1
    /// derived[1] = original[1] xor original[0] = 1
    ///
    /// Example 3:
    /// Input: derived = [1,0]
    /// Output: false
    /// Explanation: There is no valid original array that gives derived.
    ///
    /// Constraints:
    /// 1. n == derived.length
    /// 2. 1 <= n <= 10^5
    /// 3. The values in derived are either 0's or 1's
    /// </summary>
    bool doesValidArrayExist(vector<int>& derived);

    /// <summary>
    /// Leet Code 2680. Maximum OR
    /// 
    /// Medium
    ///	
    /// You are given a 0-indexed integer array nums of length n and an 
    /// integer k. In an operation, you can choose an element and 
    /// multiply it by 2.
    ///
    /// Return the maximum possible value of nums[0] | 
    /// nums[1] | ... | nums[n - 1] that can be obtained after applying 
    /// the operation on nums at most k times.
    ///
    /// Note that a | b denotes the bitwise or between two integers a 
    /// and b.
    ///
    /// Example 1:
    ///
    /// Input: nums = [12,9], k = 1
    /// Output: 30
    /// Explanation: If we apply the operation to index 1, our new 
    /// array nums will be equal to [12,18]. Thus, we return the bitwise or 
    /// of 12 and 18, which is 30.
    ///
    /// Example 2:
    /// Input: nums = [8,1,2], k = 2
    /// Output: 35
    /// Explanation: If we apply the operation twice on index 0, we yield a 
    /// new array of [32,1,2]. Thus, we return 32|1|2 = 35.
    /// 
    ///
    /// Constraints:
    /// 1. 1 <= nums.length <= 10^5
    /// 2. 1 <= nums[i] <= 10^9
    /// 3. 1 <= k <= 15
    /// </summary>
    long long maximumOr(vector<int>& nums, int k);

    /// <summary>
    /// Leet Code 2732. Find a Good Subset of the Matrix
    /// 
    /// Hard
    ///
    /// You are given a 0-indexed m x n binary matrix grid.
    ///
    /// Let us call a non-empty subset of rows good if the sum of each column 
    /// of the subset is at most half of the length of the subset.
    ///
    /// More formally, if the length of the chosen subset of rows is k, then 
    /// the sum of each column should be at most floor(k / 2).
    ///
    /// Return an integer array that contains row indices of a good subset 
    /// sorted in ascending order.
    ///
    /// If there are multiple good subsets, you can return any of them. If 
    /// there are no good subsets, return an empty array.
    ///
    /// A subset of rows of the matrix grid is any matrix that can be obtained 
    /// by deleting some (possibly none or all) rows from grid.
    ///
    /// Example 1:
    /// Input: grid = [[0,1,1,0],[0,0,0,1],[1,1,1,1]]
    /// Output: [0,1]
    /// Explanation: We can choose the 0th and 1st rows to create a good 
    /// subset of rows.
    /// The length of the chosen subset is 2.
    /// - The sum of the 0th column is 0 + 0 = 0, which is at most half of the 
    ///   length of the subset.
    /// - The sum of the 1st column is 1 + 0 = 1, which is at most half of the 
    ///   length of the subset.
    /// - The sum of the 2nd column is 1 + 0 = 1, which is at most half of the 
    ///   length of the subset.
    /// - The sum of the 3rd column is 0 + 1 = 1, which is at most half of the 
    ///   length of the subset.
    ///
    /// Example 2:
    /// Input: grid = [[0]]
    /// Output: [0]
    /// Explanation: We can choose the 0th row to create a good subset of rows.
    /// The length of the chosen subset is 1.
    /// - The sum of the 0th column is 0, which is at most half of the length 
    ///   of the subset.
    ///
    /// Example 3:
    /// Input: grid = [[1,1,1],[1,1,1]]
    /// Output: []
    /// Explanation: It is impossible to choose any subset of rows to create 
    /// a good subset.
    ///
    /// Constraints:
    /// 1. m == grid.length
    /// 2. n == grid[i].length
    /// 3. 1 <= m <= 10^4
    /// 4. 1 <= n <= 5
    /// 5. grid[i][j] is either 0 or 1.
    /// </summary>
    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid);

    /// <summary>
    /// Leet Code 2859. Sum of Values at Indices With K Set Bits
    /// 
    /// Easy
    ///
    /// You are given a 0-indexed integer array nums and an integer k.
    ///
    /// Return an integer that denotes the sum of elements in nums whose 
    /// corresponding indices have exactly k set bits in their binary 
    /// representation.
    ///
    /// The set bits in an integer are the 1's present when it is written 
    /// in binary.
    ///
    /// For example, the binary representation of 21 is 10101, which has 3 
    /// set bits.
    ///
    ///
    /// Example 1:
    /// Input: nums = [5,10,1,5,2], k = 1
    /// Output: 13
    /// Explanation: The binary representation of the indices are: 
    /// 0 = 000
    /// 1 = 001
    /// 2 = 010
    /// 3 = 011
    /// 4 = 100
    /// Indices 1, 2, and 4 have k = 1 set bits in their binary representation.
    /// Hence, the answer is nums[1] + nums[2] + nums[4] = 13.
    ///
    /// Example 2:
    /// Input: nums = [4,3,2,1], k = 2
     /// Output: 1
    /// Explanation: The binary representation of the indices are:
    /// 0 = 00
    /// 1 = 01
    /// 2 = 10
    /// 3 = 11
    /// Only index 3 has k = 2 set bits in its binary representation.
    /// Hence, the answer is nums[3] = 1.
    ///
    /// Constraints:
    /// 1. 1 <= nums.length <= 1000
    /// 2. 1 <= nums[i] <= 10^5
    /// 3. 0 <= k <= 10
    /// </summary>
    int sumIndicesWithKSetBits(vector<int>& nums, int k);

    /// <summary>
    /// Leet Code 2864. Maximum Odd Binary Number
    /// 
    /// Easy
    /// 
    /// You are given a binary string s that contains at least one '1'.
    /// 
    /// You have to rearrange the bits in such a way that the resulting binary 
    /// number is the maximum odd binary number that can be created from this 
    /// combination.
    ///
    /// Return a string representing the maximum odd binary number that can be 
    /// created from the given combination.
    ///
    /// Note that the resulting string can have leading zeros.
    ///
    /// Example 1:
    /// Input: s = "010"
    /// Output: "001"
    /// Explanation: Because there is just one '1', it must be in the last 
    /// position. So the answer is "001".
    ///
    /// Example 2:
    /// Input: s = "0101"
    /// Output: "1001"
    /// Explanation: One of the '1's must be in the last position. The maximum 
    /// number that can be made with the remaining digits is "100". So the 
    /// answer is "1001".
    ///
    /// Constraints:
    /// 1. 1 <= s.length <= 100
    /// 2. s consists only of '0' and '1'.
    /// 3. s contains at least one '1'.
    /// </summary>
    string maximumOddBinaryNumber(string s);

    /// <summary>
    /// Leet Code 2897. Apply Operations on Array to Maximize Sum of Squares
    /// 
    /// Hard
    /// 
    /// You are given a 0-indexed integer array nums and a positive integer k.
    ///
    /// You can do the following operation on the array any number of times:
    ///
    /// Choose any two distinct indices i and j and simultaneously update the 
    /// values of nums[i] to (nums[i] AND nums[j]) and nums[j] to 
    /// (nums[i] OR nums[j]). Here, OR denotes the bitwise OR operation, and 
    /// AND denotes the bitwise AND operation.
    /// You have to choose k elements from the final array and calculate the 
    /// sum of their squares.
    ///
    /// Return the maximum sum of squares you can achieve.
    ///
    /// Since the answer can be very large, return it modulo 10^9 + 7.
    ///
    /// Example 1:
    /// Input: nums = [2,6,5,8], k = 2
    /// Output: 261
    /// Explanation: We can do the following operations on the array:
    /// - Choose i = 0 and j = 3, then change nums[0] to (2 AND 8) = 0 and 
    ///   nums[3] to (2 OR 8) = 10. The resulting array is nums = [0,6,5,10].
    /// - Choose i = 2 and j = 3, then change nums[2] to (5 AND 10) = 0 and 
    ///   nums[3] to (5 OR 10) = 15. The resulting array is nums = [0,6,0,15].
    /// We can choose the elements 15 and 6 from the final array. The sum of 
    /// squares is 15^2 + 6^2 = 261.
    /// It can be shown that this is the maximum value we can get.
    ///
    /// Example 2:
    /// Input: nums = [4,5,4,7], k = 3
    /// Output: 90
    /// Explanation: We do not need to apply any operations.
    /// We can choose the elements 7, 5, and 4 with a sum of squares: 
    /// 7^2 + 5^2 + 4^2 = 90.
    /// It can be shown that this is the maximum value we can get.
    /// 
    /// Constraints:
    /// 1. 1 <= k <= nums.length <= 10^5
    /// 2. 1 <= nums[i] <= 10^9
    /// </summary>
    int maxSum(vector<int>& nums, int k);

    /// <summary>
    /// Leet Code 2917. Find the K-or of an Array
    /// 
    /// Easy
    ///
    /// You are given a 0-indexed integer array nums, and an integer k.
    ///
    /// The K-or of nums is a non-negative integer that satisfies the 
    /// following:
    ///
    /// The ith bit is set in the K-or if and only if there are at least k 
    /// elements of nums in which bit i is set.
    /// Return the K-or of nums.
    ///
    /// Note that a bit i is set in x if (2i AND x) == 2i, where AND is the 
    /// bitwise AND operator.
    ///
    /// Example 1:
    /// Input: nums = [7,12,9,8,9,15], k = 4
    /// Output: 9
    /// Explanation: Bit 0 is set at nums[0], nums[2], nums[4], and nums[5].
    /// Bit 1 is set at nums[0], and nums[5].
    /// Bit 2 is set at nums[0], nums[1], and nums[5].
    /// Bit 3 is set at nums[1], nums[2], nums[3], nums[4], and nums[5].
    /// Only bits 0 and 3 are set in at least k elements of the array, and 
    /// bits i >= 4 are not set in any of the array's elements. Hence, the 
    /// answer is 2^0 + 2^3 = 9.
    ///
    /// Example 2:
    /// Input: nums = [2,12,1,11,4,5], k = 6
    /// Output: 0
    /// Explanation: Since k == 6 == nums.length, the 6-or of the array is 
    /// equal to the bitwise AND of all its elements. Hence, the answer is 
    /// 2 AND 12 AND 1 AND 11 AND 4 AND 5 = 0.
    ///
    /// Example 3:
    /// Input: nums = [10,8,5,9,11,6,8], k = 1
    /// Output: 15
    /// Explanation: Since k == 1, the 1-or of the array is equal to the 
    /// bitwise OR of all its elements. Hence, the answer is 10 OR 8 OR 5 
    /// OR 9 OR 11 OR 6 OR 8 = 15.
    /// 
    /// Constraints:
    /// 1. 1 <= nums.length <= 50
    /// 2. 0 <= nums[i] < 2^31
    /// 3. 1 <= k <= nums.length
    /// </summary>
    int findKOr(vector<int>& nums, int k);

    /// <summary>
    /// Leet Code 2932. Maximum Strong Pair XOR I
    ///  
    /// Easy
    ///
    /// You are given a 0-indexed integer array nums. A pair of integers x and 
    /// y is called a strong pair if it satisfies the condition:
    ///
    /// |x - y| <= min(x, y)
    /// You need to select two integers from nums such that they form a strong 
    /// pair and their bitwise XOR is the maximum among all strong pairs in 
    /// the array.
    ///
    /// Return the maximum XOR value out of all possible strong pairs in the 
    /// array nums.
    ///
    /// Note that you can pick the same integer twice to form a pair.
    ///
    /// Example 1:
    /// Input: nums = [1,2,3,4,5]
    /// Output: 7
    /// Explanation: There are 11 strong pairs in the array nums: (1, 1), 
    /// (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), 
    /// (4, 5) and (5, 5).
    /// The maximum XOR possible from these pairs is 3 XOR 4 = 7.
    ///
    /// Example 2:
    /// Input: nums = [10,100] 
    /// Output: 0
    /// Explanation: There are 2 strong pairs in the array nums: (10, 10) and 
    /// (100, 100).
    /// The maximum XOR possible from these pairs is 10 XOR 10 = 0 since the 
    /// pair (100, 100) also gives 100 XOR 100 = 0.
    ///
    /// Example 3:
    /// Input: nums = [5,6,25,30]
    /// Output: 7
    /// Explanation: There are 6 strong pairs in the array nums: (5, 5), 
    /// (5, 6), (6, 6), (25, 25), (25, 30) and (30, 30).
    /// The maximum XOR possible from these pairs is 25 XOR 30 = 7 since the 
    /// only other non-zero XOR value is 5 XOR 6 = 3.
    /// 
    /// Constraints:
    /// 1. 1 <= nums.length <= 50
    /// 2. 1 <= nums[i] <= 100
    /// </summary>
    int maximumStrongPairXorI(vector<int>& nums);

    /// <summary>
    /// Leet Code 2935. Maximum Strong Pair XOR II
    ///  
    /// Hard
    ///
    /// You are given a 0-indexed integer array nums. A pair of integers x 
    /// and y is called a strong pair if it satisfies the condition:
    ///
    /// |x - y| <= min(x, y)
    /// You need to select two integers from nums such that they form a strong 
    /// pair and their bitwise XOR is the maximum among all strong pairs in 
    /// the array.
    ///
    /// Return the maximum XOR value out of all possible strong pairs in the 
    /// array nums.
    ///
    /// Note that you can pick the same integer twice to form a pair.
    /// 
    /// Example 1:
    /// Input: nums = [1,2,3,4,5]
    /// Output: 7
    /// Explanation: There are 11 strong pairs in the array nums: (1, 1), 
    /// (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), 
    /// (4, 5) and (5, 5).
    /// The maximum XOR possible from these pairs is 3 XOR 4 = 7.
    ///
    /// Example 2:
    /// Input: nums = [10,100]
    /// Output: 0
    /// Explanation: There are 2 strong pairs in the array nums: (10, 10) 
    /// and (100, 100).
    /// The maximum XOR possible from these pairs is 10 XOR 10 = 0 since the 
    /// pair (100, 100) also gives 100 XOR 100 = 0.
    ///
    /// Example 3:
    /// Input: nums = [500,520,2500,3000]
    /// Output: 1020
    /// Explanation: There are 6 strong pairs in the array nums: (500, 500), 
    /// (500, 520), (520, 520), (2500, 2500), (2500, 3000) and (3000, 3000).
    /// The maximum XOR possible from these pairs is 500 XOR 520 = 1020 since 
    /// the only other non-zero XOR value is 2500 XOR 3000 = 636.
    ///
    /// Constraints:
    /// 1. 1 <= nums.length <= 5 * 10^4
    /// 2. 1 <= nums[i] <= 2^20 - 1
    /// </summary>
    int maximumStrongPairXorII(vector<int>& nums);

    /// <summary>
    /// Leet Code 2939. Maximum Xor Product
    ///  
    /// Medium
    ///
    /// Given three integers a, b, and n, return the maximum value of 
    /// (a XOR x) * (b XOR x) where 0 <= x < 2^n.
    ///
    /// Since the answer may be too large, return it modulo 10^9 + 7.
    ///
    /// Note that XOR is the bitwise XOR operation.
    /// 
    /// Example 1:
    /// Input: a = 12, b = 5, n = 4
    /// Output: 98
    /// Explanation: For x = 2, (a XOR x) = 14 and (b XOR x) = 7. 
    /// Hence, (a XOR x) * (b XOR x) = 98. 
    /// It can be shown that 98 is the maximum value of (a XOR x) * (b XOR x) 
    /// for all 0 <= x < 2n.
    ///
    /// Example 2:
    /// Input: a = 6, b = 7 , n = 5
    /// Output: 930
    /// Explanation: For x = 25, (a XOR x) = 31 and (b XOR x) = 30. Hence, 
    /// (a XOR x) * (b XOR x) = 930.
    /// It can be shown that 930 is the maximum value of (a XOR x) * (b XOR x) 
    /// for all 0 <= x < 2n.
    ///
    /// Example 3:
    /// Input: a = 1, b = 6, n = 3
    /// Output: 12
    /// Explanation: For x = 5, (a XOR x) = 4 and (b XOR x) = 3. 
    /// Hence, (a XOR x) * (b XOR x) = 12.
    /// It can be shown that 12 is the maximum value of (a XOR x) * 
    /// (b XOR x) for all 0 <= x < 2^n.
    ///  
    /// Constraints:
    /// 1. 0 <= a, b < 2^50
    /// 2. 0 <= n <= 50
    /// </summary>
    int maximumXorProduct(long long a, long long b, int n);

    /// <summary>
    /// Leet Code 2980. Check if Bitwise OR Has Trailing Zeros
    ///  
    /// Easy
    ///
    /// You are given an array of positive integers nums.
    ///
    /// You have to check if it is possible to select two or more elements in the 
    /// array such that the bitwise OR of the selected elements has at least one 
    /// trailing zero in its binary representation.
    ///
    /// For example, the binary representation of 5, which is "101", does not 
    /// have any trailing zeros, whereas the binary representation of 4, which 
    /// is "100", has two trailing zeros.
    ///
    /// Return true if it is possible to select two or more elements whose bitwise 
    /// OR has trailing zeros, return false otherwise.
    ///
    /// Example 1:
    /// Input: nums = [1,2,3,4,5]
    /// Output: true
    /// Explanation: If we select the elements 2 and 4, their bitwise OR is 6, 
    /// which has the binary representation "110" with one trailing zero.
    ///
    /// Example 2:
    /// Input: nums = [2,4,8,16]
    /// Output: true
    /// Explanation: If we select the elements 2 and 4, their bitwise OR is 6, 
    /// which has the binary representation "110" with one trailing zero.
    /// Other possible ways to select elements to have trailing zeroes in the 
    /// binary representation of their bitwise OR are: (2, 8), (2, 16), (4, 8), 
    /// (4, 16), (8, 16), (2, 4, 8), (2, 4, 16), (2, 8, 16), (4, 8, 16), and 
    /// (2, 4, 8, 16).
    ///
    /// Example 3:
    /// Input: nums = [1,3,5,7,9]
    /// Output: false
    /// Explanation: There is no possible way to select two or more elements 
    /// to have trailing zeros in the binary representation of their bitwise OR.
    /// 
    /// Constraints:
    /// 1. 2 <= nums.length <= 100
    /// 2. 1 <= nums[i] <= 100
    /// </summary>
    bool hasTrailingZeros(vector<int>& nums);

    /// <summary>
    /// Leet Code 2997. Minimum Number of Operations to Make Array XOR Equal to K 
    ///                 
    /// Medium
    ///
    /// You are given a 0-indexed integer array nums and a positive integer k.
    ///
    /// You can apply the following operation on the array any number of times:
    ///
    /// Choose any element of the array and flip a bit in its binary 
    /// representation. Flipping a bit means changing a 0 to 1 or vice versa.
    /// Return the minimum number of operations required to make the bitwise XOR 
    /// of all elements of the final array equal to k.
    ///
    /// Note that you can flip leading zero bits in the binary representation of 
    /// elements. For example, for the number (101)2 you can flip the fourth bit 
    /// and obtain (1101)2.
    ///
    /// Example 1:
    /// Input: nums = [2,1,3,4], k = 1
    /// Output: 2
    /// Explanation: We can do the following operations:
    /// - Choose element 2 which is 3 == (011)2, we flip the first bit and we 
    ///   obtain (010)2 == 2. nums becomes [2,1,2,4].
    /// - Choose element 0 which is 2 == (010)2, we flip the third bit and we 
    ///   obtain (110)2 = 6. nums becomes [6,1,2,4].
    /// The XOR of elements of the final array is (6 XOR 1 XOR 2 XOR 4) == 1 == k.
    /// It can be shown that we cannot make the XOR equal to k in less than 2 
    /// operations.
    ///
    /// Example 2:
    /// Input: nums = [2,0,2,0], k = 0
    /// Output: 0
    /// Explanation: The XOR of elements of the array is (2 XOR 0 XOR 2 XOR 0) 
    /// == 0 == k. So no operation is needed.
    ///
    /// Constraints:
    /// 1. 1 <= nums.length <= 10^5
    /// 2. 0 <= nums[i] <= 10^6
    /// 3. 0 <= k <= 10^6
    /// </summary>
    int minOperations(vector<int>& nums, int k);

    /// <summary>
    /// Leet Code 3022. Minimize OR of Remaining Elements Using Operations
    ///
    /// Hard
    ///
    /// You are given a 0-indexed integer array nums and an integer k.
    ///
    /// In one operation, you can pick any index i of nums such that 
    /// 0 <= i < nums.length - 1 and replace nums[i] and nums[i + 1] with a 
    /// single occurrence of nums[i] & nums[i + 1], where & represents the 
    /// bitwise AND operator.
    ///
    /// Return the minimum possible value of the bitwise OR of the remaining 
    /// elements of nums after applying at most k operations.
    /// 
    /// Example 1:
    /// 
    /// Input: nums = [3,5,3,2,7], k = 2
    /// Output: 3
    /// Explanation: Let's do the following operations:
    /// 1. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that nums 
    ///    becomes equal to [1,3,2,7].
    /// 2. Replace nums[2] and nums[3] with (nums[2] & nums[3]) so that nums 
    ///    becomes equal to [1,3,2].
    ///    The bitwise-or of the final array is 3.
    /// It can be shown that 3 is the minimum possible value of the bitwise OR of 
    /// the remaining elements of nums after applying at most k operations.
    ///
    /// Example 2:
    /// Input: nums = [7,3,15,14,2,8], k = 4
    /// Output: 2
    /// Explanation: Let's do the following operations:
    /// 1. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that nums 
    ///    becomes equal to [3,15,14,2,8]. 
    /// 2. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that nums 
    ///    becomes equal to [3,14,2,8].
    /// 3. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that nums 
    ///    becomes equal to [2,2,8].
    /// 4. Replace nums[1] and nums[2] with (nums[1] & nums[2]) so that nums 
    ///    becomes equal to [2,0].
    /// The bitwise-or of the final array is 2.
    /// It can be shown that 2 is the minimum possible value of the bitwise OR 
    /// of the remaining elements of nums after applying at most k operations.
    ///
    /// Example 3:
    /// Input: nums = [10,7,10,3,9,14,9,4], k = 1
    /// Output: 15
    /// Explanation: Without applying any operations, the bitwise-or of nums is 15.
    /// It can be shown that 15 is the minimum possible value of the bitwise OR of 
    /// the remaining elements of nums after applying at most k operations.
    /// 
    /// Constraints:
    /// 1. 1 <= nums.length <= 10^5
    /// 2. 0 <= nums[i] < 2^30
    /// 3. 0 <= k < nums.length
    /// </summary>
    int minOrAfterOperations(vector<int>& nums, int k);

    /// <summary>
    /// Leet 3095. Shortest Subarray With OR at Least K I
    ///
    /// Easy
    ///
    /// You are given an array nums of non-negative integers and an integer k.
    ///
    /// An array is called special if the bitwise OR of all of its elements 
    /// is at least k.
    /// Return the length of the shortest special non-empty subarray of nums, 
    /// or return -1 if no special subarray exists.
    ///
    /// Example 1:
    /// Input: nums = [1,2,3], k = 2
    /// Output: 1
    /// Explanation:
    /// The subarray [3] has OR value of 3. Hence, we return 1.
    ///
    /// Example 2:
    /// Input: nums = [2,1,8], k = 10
    /// Output: 3
    /// Explanation:
    /// The subarray [2,1,8] has OR value of 11. Hence, we return 3.
    ///
    /// Example 3:
    /// Input: nums = [1,2], k = 0
    /// Output: 1
    /// Explanation:
    /// The subarray [1] has OR value of 1. Hence, we return 1.
    ///  
    /// Constraints:
    /// 1. 1 <= nums.length <= 50
    /// 2. 0 <= nums[i] <= 50
    /// 3. 0 <= k < 64
    /// </summary>
    int minimumSubarrayLengthI(vector<int>& nums, int k);

    /// <summary>
    /// Leet 3064. Guess the Number Using Bitwise Questions I
    ///
    /// Medium
    ///
    /// There is a number n that you have to find.
    ///
    /// There is also a pre-defined API int commonSetBits(int num), which 
    /// returns the number of bits where both n and num are 1 in that position 
    /// of their binary representation. In other words, it returns the number 
    /// of set bits in n & num, where & is the bitwise AND operator.
    /// 
    /// Return the number n.
    ///
    /// Example 1:
    /// Input: n = 31
    /// Output: 31
    /// Explanation: It can be proven that it's possible to find 31 using the 
    /// provided API.
    ///
    /// Example 2:
    /// Input: n = 33
    /// Output: 33
    /// Explanation: It can be proven that it's possible to find 33 using 
    /// the provided API.
    /// 
    /// Constraints:
    /// 1. 1 <= n <= 2^30 - 1
    /// 2. 0 <= num <= 2^30 - 1
    /// 3. If you ask for some num out of the given range, the output wouldn't 
    ///    be reliable.
    /// </summary>
    int findNumberI(int n);

    /// <summary>
    /// Leet 3094. Guess the Number Using Bitwise Questions II
    ///
    /// Medium
    ///
    /// There is a number n that you have to find.
    ///
    /// There is a number n between 0 and 23^0 - 1 (both inclusive) that you 
    /// have to find.
    ///
    /// There is a pre-defined API int commonBits(int num) that helps you with 
    /// your mission. But here is the challenge, every time you call this 
    /// function, n changes in some way. But keep in mind, that you have to 
    /// find the initial value of n.
    ///
    /// commonBits(int num) acts as follows:
    /// Calculate count which is the number of bits where both n and num have 
    /// the same value in that position of their binary representation.
    /// n = n XOR num
    /// Return count.
    /// Return the number n.
    ///
    /// Note: In this world, all numbers are between 0 and 2^30 - 1 (both 
    /// inclusive), thus for counting common bits, we see only the first 30 
    /// bits of those numbers.
    ///
    /// Example 1:
    /// Input: n = 31
    /// Output: 31
    ///
    /// Explanation: It can be proven that it's possible to find 31 using the 
    /// provided API.
    ///
    /// Example 2:
    /// Input: n = 33
    /// Output: 33
    /// Explanation: It can be proven that it's possible to find 33 using the 
    /// provided API.
    ///
    /// Constraints:
    /// 1. 0 <= n <= 2^30 - 1
    /// 2. 0 <= num <= 2^30 - 1
    /// 3. If you ask for some num out of the given range, the output wouldn't 
    ///    be reliable.
    /// </summary>
    int findNumberII(int n);

    /// <summary>
    /// Leet 3097. Shortest Subarray With OR at Least K II
    ///
    /// Medium
    ///
    /// There is a number n that you have to find.
    ///
    /// You are given an array nums of non-negative integers and an integer k.
    ///
    /// An array is called special if the bitwise OR of all of its elements 
    /// is at least k.
    ///
    /// Return the length of the shortest special non-empty subarray of nums, 
    /// or return -1 if no special subarray exists.
    /// 
    /// Example 1:
    /// Input: nums = [1,2,3], k = 2
    /// Output: 1
    /// Explanation:
    /// The subarray [3] has OR value of 3. Hence, we return 1.
    ///
    /// Example 2:
    /// Input: nums = [2,1,8], k = 10
    /// Output: 3
    /// Explanation:
    /// The subarray [2,1,8] has OR value of 11. Hence, we return 3.
    ///
    /// Example 3:
    /// Input: nums = [1,2], k = 0
    /// Output: 1
    /// Explanation:
    /// The subarray [1] has OR value of 1. Hence, we return 1.
    /// Constraints:
    /// 1. 1 <= nums.length <= 2 * 10^5
    /// 2. 0 <= nums[i] <= 10^9
    /// 3. 0 <= k <= 10^9
    /// </summary>
    int minimumSubarrayLengthII(vector<int>& nums, int k);

    /// <summary>
    /// LeetCode 3125. Maximum Number That Makes Result of Bitwise AND Zero
    ///                
    /// Medium
    ///
    /// Given an integer n, return the maximum integer x such that x <= n, and 
    /// the bitwise AND of all the numbers in the range [x, n] is 0.
    /// 
    /// Example 1:
    /// Input: n = 7
    /// Output: 3
    /// Explanation:
    /// The bitwise AND of [6, 7] is 6.
    /// The bitwise AND of [5, 6, 7] is 4.
    /// The bitwise AND of [4, 5, 6, 7] is 4.
    /// The bitwise AND of [3, 4, 5, 6, 7] is 0.
    ///
    /// Example 2:
    /// Input: n = 9
    /// Output: 7
    /// Explanation:
    /// The bitwise AND of [7, 8, 9] is 0.
    ///
    /// Example 3:
    /// Input: n = 17
    /// Output: 15
    /// Explanation:
    /// The bitwise AND of [15, 16, 17] is 0.
    /// 
    /// Constraints:
    /// 1. 1 <= n <= 10^15
    /// </summary>
    long long maxNumber(long long n);

    /// <summary>
    /// LeetCode 3133. Minimum Array End
    ///                
    /// Medium
    ///
    /// You are given two integers n and x. You have to construct an array of 
    /// positive integers nums of size n where for every 0 <= i < n - 1, 
    /// nums[i + 1] is greater than nums[i], and the result of the bitwise 
    /// AND operation between all elements of nums is x.
    ///
    /// Return the minimum possible value of nums[n - 1].
    ///
    /// Example 1:
    /// Input: n = 3, x = 4
    /// Output: 6
    /// Explanation:
    /// nums can be [4,5,6] and its last element is 6.
    ///
    /// Example 2:
    /// Input: n = 2, x = 7
    /// Output: 15
    /// Explanation:
    /// nums can be [7,15] and its last element is 15.
    /// 
    /// Constraints:
    /// 1. 1 <= n, x <= 10^8
    /// </summary>
    long long minEnd(int n, int x);

    /// <summary>
    /// LeetCode 3141. Maximum Hamming Distances
    /// 
    /// Hard
    /// 
    /// Given an array nums and an integer m, with each element nums[i] 
    /// satisfying 0 <= nums[i] < 2m, return an array answer. The answer 
    /// array should be of the same length as nums, where each element 
    /// answer[i] represents the maximum Hamming distance between nums[i] 
    /// and any other element nums[j] in the array.
    /// 
    /// The Hamming distance between two binary integers is defined as the 
    /// number of positions at which the corresponding bits differ (add 
    /// leading zeroes if needed).
    ///
    /// Example 1:
    /// Input: nums = [9,12,9,11], m = 4
    /// Output: [2,3,2,3]
    /// Explanation:
    /// The binary representation of nums = [1001,1100,1001,1011].
    /// The maximum hamming distances for each index are:
    /// nums[0]: 1001 and 1100 have a distance of 2.
    /// nums[1]: 1100 and 1011 have a distance of 3.
    /// nums[2]: 1001 and 1100 have a distance of 2.
    /// nums[3]: 1011 and 1100 have a distance of 3.
    ///
    /// Example 2:
    /// Input: nums = [3,4,6,10], m = 4
    /// Output: [3,3,2,3]
    /// Explanation:
    /// The binary representation of nums = [0011,0100,0110,1010].
    /// The maximum hamming distances for each index are:
    /// nums[0]: 0011 and 0100 have a distance of 3.
    /// nums[1]: 0100 and 0011 have a distance of 3.
    /// nums[2]: 0110 and 1010 have a distance of 2.
    /// nums[3]: 1010 and 0100 have a distance of 3.
    /// 
    ///
    /// Constraints:
    /// 1. 1 <= m <= 17
    /// 2. 2 <= nums.length <= 2^m
    /// 3. 0 <= nums[i] < 2^m
    /// </summary>
    vector<int> maxHammingDistances(vector<int>& nums, int m);

    /// <summary>
    /// LeetCode 3173. Bitwise OR of Adjacent Elements
    /// 
    /// Easy
    /// 
    /// Given an array nums of length n, return an array answer of length 
    /// n - 1 such that answer[i] = nums[i] | nums[i + 1] where | is the 
    /// bitwise OR operation.
    /// 
    /// Example 1:
    /// Input: nums = [1,3,7,15]
    /// Output: [3,7,15]
    ///
    /// Example 2:
    /// Input: nums = [8,4,2]
    /// Output: [12,6]
    ///
    /// Example 3:
    /// Input: nums = [5,4,9,11]
    /// Output: [5,13,11]
    /// Constraints:
    /// 1. 2 <= nums.length <= 100
    /// 2. 0 <= nums[i] <= 100
    /// </summary>
    vector<int> orArray(vector<int>& nums);

    /// <summary>
    /// LeetCode 3171. Find Subarray With Bitwise AND Closest to K
    /// 
    /// Hard
    /// 
    /// You are given an array nums and an integer k. You need to find a 
    /// subarray of nums such that the absolute difference between k and the 
    /// bitwise AND of the subarray elements is as small as possible. In other 
    /// words, select a subarray nums[l..r] such that |k - (nums[l] AND 
    /// nums[l + 1] ... AND nums[r])| is minimum.
    ///
    /// Return the minimum possible value of the absolute difference.
    /// A subarray is a contiguous non-empty sequence of elements within an 
    /// array.
    /// 
    /// Example 1:
    /// Input: nums = [1,2,4,5], k = 3
    /// Output: 1
    /// Explanation:
    /// The subarray nums[2..3] has AND value 4, which gives the minimum 
    /// absolute difference |3 - 4| = 1.
    ///
    /// Example 2:
    /// Input: nums = [1,2,1,2], k = 2
    /// Output: 0
    /// Explanation:
    /// The subarray nums[1..1] has AND value 2, which gives the minimum 
    /// absolute difference |2 - 2| = 0.
    ///
    /// Example 3:
    /// Input: nums = [1], k = 10
    /// Output: 9
    /// Explanation:
    /// There is a single subarray with AND value 1, which gives the minimum 
    /// absolute difference |10 - 1| = 9.
    /// 
    /// Constraints:
    /// 1 <= nums.length <= 10^5
    /// 2. 1 <= nums[i] <= 10^9
    /// 3. 1 <= k <= 10^9
    /// </summary>
    int minimumDifference(vector<int>& nums, int k);

    /// <summary>
    /// LeetCode 3199. Count Triplets with Even XOR Set Bits I 
    ///
    /// Easy
    ///
    /// Given three integer arrays a, b, and c, return the number of triplets 
    /// (a[i], b[j], c[k]), such that the bitwise XOR of the elements of each 
    /// triplet has an even number of set bits.
    ///
    /// Example 1:
    /// Input: a = [1], b = [2], c = [3]
    /// Output: 1
    /// Explanation:
    /// The only triplet is (a[0], b[0], c[0]) and their XOR is: 1 XOR 2 
    /// XOR 3 = 002.
    ///
    /// Example 2:
    /// Input: a = [1,1], b = [2,3], c = [1,5]
    /// Output: 4
    /// Explanation:
    /// Consider these four triplets:
    /// (a[0], b[1], c[0]): 1 XOR 3 XOR 1 = 0112
    /// (a[1], b[1], c[0]): 1 XOR 3 XOR 1 = 0112
    /// (a[0], b[0], c[1]): 1 XOR 2 XOR 5 = 1102
    /// (a[1], b[0], c[1]): 1 XOR 2 XOR 5 = 1102
    ///
    /// Constraints:
    /// 1. 1 <= a.length, b.length, c.length <= 100
    /// 2. 0 <= a[i], b[i], c[i] <= 100
    /// </summary>
    int tripletCountI(vector<int>& a, vector<int>& b, vector<int>& c);

    /// <summary>
    /// LeetCode 3209. Number of Subarrays With AND Value of K
    ///
    /// Hard
    ///
    /// Given an array of integers nums and an integer k, return the number of
    /// subarrays of nums where the bitwise AND of the elements of the 
    /// subarray equals k.
    ///
    /// Example 1:
    /// Input: nums = [1,1,1], k = 1
    /// Output: 6
    /// Explanation:
    /// All subarrays contain only 1's.
    ///
    /// Example 2:
    /// Input: nums = [1,1,2], k = 1
    /// Output: 3
    /// Explanation:
    /// Subarrays having an AND value of 1 are: [1,1,2], [1,1,2], [1,1,2].
    ///
    /// Example 3:
    /// Input: nums = [1,2,3], k = 2
    /// Output: 2
    /// Explanation:
    /// Subarrays having an AND value of 2 are: [1,2,3], [1,2,3].
    ///  
    /// Constraints:
    /// 1. 1 <= nums.length <= 10^5
    /// 2. 0 <= nums[i], k <= 10^9
    /// </summary>
    long long countSubarrays(vector<int>& nums, int k);

    /// <summary>
    /// LeetCode 3215. Count Triplets with Even XOR Set Bits II
    ///
    /// Easy
    ///
    /// Given three integer arrays a, b, and c, return the number of triplets 
    /// (a[i], b[j], c[k]), such that the bitwise XOR between the elements of 
    /// each triplet has an even number of set bits
    /// 
    /// Example 1:
    /// Input: a = [1], b = [2], c = [3]
    /// Output: 1
    /// Explanation:
    /// The only triplet is (a[0], b[0], c[0]) and their XOR is: 1 XOR 2 XOR 3 = 002.
    ///
    /// Example 2:
    /// Input: a = [1,1], b = [2,3], c = [1,5]
    /// Output: 4
    ///
    /// Explanation:
    /// 
    /// Consider these four triplets:
    /// (a[0], b[1], c[0]): 1 XOR 3 XOR 1 = 0112
    /// (a[1], b[1], c[0]): 1 XOR 3 XOR 1 = 0112
    /// (a[0], b[0], c[1]): 1 XOR 2 XOR 5 = 1102
    /// (a[1], b[0], c[1]): 1 XOR 2 XOR 5 = 1102
    /// 
    /// Constraints:
    /// 1. 1 <= a.length, b.length, c.length <= 10^5
    /// 2. 0 <= a[i], b[i], c[i] <= 10^9
    /// </summary>
    long long tripletCountII(vector<int>& a, vector<int>& b, vector<int>& c);

    /// <summary>
    /// Leet Code 3226. Number of Bit Changes to Make Two Integers Equal
    ///
    /// Easy
    ///
    /// You are given two positive integers n and k.
    /// You can choose any bit in the binary representation of n that is equal 
    /// to 1 and change it to 0.
    ///
    /// Return the number of changes needed to make n equal to k. If it is 
    /// impossible, return -1.
    /// 
    /// Example 1:
    /// Input: n = 13, k = 4
    /// Output: 2
    /// Explanation:
    /// Initially, the binary representations of n and k are n = (1101)2 and 
    /// k = (0100)2.
    /// We can change the first and fourth bits of n. The resulting integer is 
    /// n = (0100)2 = k.
    ///
    /// Example 2:
    /// Input: n = 21, k = 21
    /// Output: 0
    /// Explanation:
    /// n and k are already equal, so no changes are needed.
    ///
    /// Example 3:
    /// Input: n = 14, k = 13
    /// Output: -1
    /// Explanation:
    /// It is not possible to make n equal to k.
    ///
    /// Constraints:
    /// 1. 1 <= n, k <= 10^6
    /// </summary>
    int minChanges(int n, int k);

    /// <summary>
    /// Leet Code 3370. Smallest Number With All Set Bits 
    /// 
    /// Easy
    /// 
    /// You are given a positive number n.
    /// Return the smallest number x greater than or equal to n, such that the 
    /// binary representation of x contains only set bits.
    ///
    /// A set bit refers to a bit in the binary representation of a number 
    /// that has a value of 1.
    ///
    /// Example 1:
    /// Input: n = 5
    /// Output: 7
    /// Explanation:
    /// The binary representation of 7 is "111".
    ///
    /// Example 2:
    /// Input: n = 10
    /// Output: 15
    /// 
    /// Explanation:
    /// The binary representation of 15 is "1111".
    /// Example 3:
    /// Input: n = 3
    /// Output: 3
    /// Explanation:
    /// The binary representation of 3 is "11".
    /// 
    /// Constraints:
    /// 1. 1 <= n <= 1000
    /// </summary>
    int smallestNumber(int n);
#pragma endregion
};
#endif  // LeetCodeBit_H
