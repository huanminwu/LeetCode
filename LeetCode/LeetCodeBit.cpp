#pragma once
#include <ctype.h>  /* is space */
#include <stdio.h>     /* printf */
#include <stdlib.h>  
#include <time.h>  
#include <functional>
#include <algorithm> 
#include <unordered_map> 
#include <unordered_set> 
#include <map> 
#include <numeric>
#include <stack>
#include <set>
#include <queue> 
#include <vector>
#include <iostream>
#include <fstream>
#include "Leetcode.h"
#include "LeetcodeBit.h"
#pragma region BitOperation
/// <summary>
/// Leet code # 371. Sum of Two Integers 
/// 
/// Calculate the sum of two integers a and b, but you are not allowed to use 
/// the operator + and -. 
/// Example: 
/// Given a = 1 and b = 2, return 3. 
/// </summary>
int LeetCodeBit::getSum(int a, int b)
{
    int sum = a;
    int carry = 0;
    while (b != 0)
    {
        sum = a ^ b;
        carry = (a & b) << 1;
        a = sum;
        b = carry;
    }
    return sum;
}

/// <summary>
/// Leet code # 191. Number of 1 Bits
/// 
/// Write a function that takes an unsigned integer and returns the number of ¡¯1' 
/// bits it has (also known as the Hamming weight). 
/// For example, the 32-bit integer ¡¯11' has binary representation 
/// 00000000000000000000000000001011, so the function should return 3. 
/// </summary>
int LeetCodeBit::hammingWeight(uint32_t n)
{
    int result = 0;
    while (n != 0)
    {
        result += n & 1;
        n = n >> 1;
    }
    return result;
}

/// <summary>
/// Leet code #338. Counting Bits    
/// Given a non negative integer number num. For every numbers i in the range 0 ¡Ü i ¡Ü num 
/// calculate the number of 1's in their binary representation and return them as an array. 
/// Example:
/// For num = 5 you should return [0,1,1,2,1,2].
/// Follow up: 
/// It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?
/// Space complexity should be O(n).
/// Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.
/// Hint:
/// 1.You should make use of what you have produced already.
/// 2.Divide the numbers in ranges like [2-3], [4-7], [8-15] and so on. And try to generate new range from previous.
/// 3.Or does the odd/even status of the number help you in calculating the number of 1s?
/// </summary>
vector<int> LeetCodeBit::countBits(int num)
{
    vector<int> result;
    result.push_back(0);
    int index = 0;
    while (index < num)
    {
        size_t size = result.size();
        for (size_t i = 0; i < size; i++)
        {
            result.push_back(1 + result[i]);
            index++;
            if (index == num) break;
        }
    }
    return result;
}

/// <summary>
/// Leet code #342. Power of Four    
/// Given an integer (signed 32 bits), write a function to check whether it is a power of 4.
/// Example:
/// Given num = 16, return true. Given num = 5, return false. 
/// Follow up: Could you solve it without loops/recursion?
/// </summary>
bool LeetCodeBit::isPowerOfFour(int num)
{
    if (num == 0) return false;
    // mask in the right bits and only one bit
    if (((num & 0x55555555) == num) && (num == (num & -num)))
    {
        return true;
    }
    else
    {
        return false;
    }
}

/// <summary>
/// Leet code #136. Single Number
/// Given an array of integers, every element appears twice except for one. Find that single one.
/// Note:
/// Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 
/// </summary>
int LeetCodeBit::singleNumber(vector<int>& nums)
{
    int number = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        number = number ^ nums[i];
    }
    return number;
}

/// <summary>
/// Leet code #389. Find the Difference 
/// Given two strings s and t which consist of only lowercase letters.
/// String t is generated by random shuffling string s and then add one more letter at a random position.
/// Find the letter that was added in t.
/// Example: 
/// Input:
/// s = "abcd"
/// t = "abcde"
/// Output:
/// e
/// Explanation:
/// 'e' is the letter that was added.    
/// </summary>
char LeetCodeBit::findTheDifference(string s, string t)
{
    int number = 0;

    for (size_t i = 0; i < s.size(); i++)
    {
        number = number ^ s[i];
    }
    for (size_t i = 0; i < t.size(); i++)
    {
        number = number ^ t[i];
    }
    return (char)number;
}

/// <summary>
/// Leet code #89. Gray Code 
/// Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. 
/// A gray code sequence must begin with 0. 
/// For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:
/// 00 - 0
/// 01 - 1
/// 11 - 3
/// 10 - 2
///
/// Note:
///   For a given n, a gray code sequence is not uniquely defined. 
/// For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.
/// For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.
/// </summary>
vector<int> LeetCodeBit::grayCode(int n)
{
    vector<int> result;
    for (size_t i = 0; i < pow(2, n); i++)
    {
        result.push_back(i ^ (i >> 1));
    }
    return result;
}

/// <summary>
/// Leet code #405. Convert a Number to Hexadecimal 
/// Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two¡¯s complement method is used.  
/// Note: 
/// 1.All letters in hexadecimal (a-f) must be in lowercase.
/// 2.The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character '0'; otherwise, 
///   the first character in the hexadecimal string will not be the zero character.
/// 3.The given number is guaranteed to fit within the range of a 32-bit signed integer.
/// 4.You must not use any method provided by the library which converts/formats the number to hex directly.
/// Example 1: 
/// Input:
/// 26
/// Output:
/// "1a"
///
/// Example 2: 
/// Input:
/// -1
/// Output:
/// "ffffffff"
/// </summary>
string LeetCodeBit::toHex(int num)
{
    string result;
    unsigned int number = num;
    if (number == 0) return "0";

    while (number != 0)
    {
        int digit = number % 16;
        if (digit < 10)
        {
            result.insert(result.begin(), ('0' + digit - 0));
        }
        else
        {
            result.insert(result.begin(), ('a' + digit - 10));
        }
        number /= 16;
    }

    return result;
}

/// <summary>
/// Leet code #137. Single Number II 
/// Given an array of integers, every element appears three times except for 
/// one. Find that single one.   
/// Note: 
/// Your algorithm should have a linear runtime complexity. Could you implement 
/// it without using extra memory? 
/// </summary>
int LeetCodeBit::singleNumberII(vector<int>& nums)
{
    unsigned int result = 0;
    vector<int> bitCount(32);

    for (size_t i = 0; i < nums.size(); i++)
    {
        unsigned int x = nums[i];
        int index = 0;
        while (x != 0)
        {
            bitCount[31 - index] += x % 2;
            x /= 2;
            index++;
        }
    }
    for (size_t i = 0; i < 32; i++)
    {
        bitCount[i] %= 3;
        result <<= 1;
        result |= bitCount[i];
    }
    return (int)result;
}

/// <summary>
/// Leet code #190. Reverse Bits 
/// Reverse bits of a given 32 bits unsigned integer.
/// For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), 
/// return 964176192 (represented in binary as 00111001011110000010100101000000).
/// Follow up:
/// If this function is called many times, how would you optimize it? 
/// </summary>
uint32_t LeetCodeBit::reverseBits(uint32_t n)
{
    vector<int> bit_vector(32);
    size_t index = 0;
    while (n != 0)
    {
        bit_vector[index] = n % 2;
        index++;
        n >>= 1;
    }
    for (size_t i = 0; i < 32; i++)
    {
        n <<= 1;
        n |= bit_vector[i];
    }
    return n;
}

/// <summary>
/// Leet code #397. Integer Replacement 
/// Given a positive integer n and you can do operations as follow: 
/// 1.If n is even, replace n with n/2.
/// 2.If n is odd, you can replace n with either n + 1 or n - 1.
/// What is the minimum number of replacements needed for n to become 1? 
/// Example 1: 
/// Input:
/// 8
/// Output:
/// 3
/// Explanation:
/// 8 -> 4 -> 2 -> 1
///
/// Example 2: 
/// Input:
/// 7
/// Output:
/// 4
/// Explanation:
/// 7 -> 8 -> 4 -> 2 -> 1
/// or
/// 7 -> 6 -> 3 -> 2 -> 1
/// </summary>
int LeetCodeBit::integerReplacement(int n)
{
    if (n == INT_MAX) return 32;
    int result = 0;
    while (n != 1)
    {
        if (n % 2 == 0) n /= 2;
        else if ((n % 4 == 1) || (n == 3))
        {
            n -= 1;
        }
        else if (n % 4 == 3)
        {
            n += 1;
        }
        result++;
    }
    return result;
}

/// <summary>
/// Leet code #201. Bitwise AND of Numbers Range 
/// Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.
/// For example, given the range [5, 7], you should return 4. 
/// </summary>
int LeetCodeBit::rangeBitwiseAnd(int m, int n)
{
    int mask = 0xffffffff;
    while (m != n)
    {
        mask <<= 1;
        m = m & mask;
        n = n & mask;
    }
    return m;
}


/// <summary>
/// Leet code #318. Maximum Product of Word Lengths 
/// Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where 
/// the two words do not share common letters. You may assume that each word will contain only 
/// lower case letters. If no such two words exist, return 0. 
///
/// Example 1:
/// Given ["abcw", "baz", "foo", "bar", "xtfn", "abcdef"]
/// Return 16
/// The two words can be "abcw", "xtfn". 
///
/// Example 2:
/// Given ["a", "ab", "abc", "d", "cd", "bcd", "abcd"]
/// Return 4
/// The two words can be "ab", "cd". 
///
/// Example 3:
/// Given ["a", "aa", "aaa", "aaaa"]
/// Return 0
/// No such pair of words. 
/// </summary>
int LeetCodeBit::maxProductWordLength(vector<string>& words)
{
    size_t result = 0;
    vector<int> word_code;
    for (size_t i = 0; i < words.size(); i++)
    {
        uint32_t code = 0;
        for (char c : words[i])
        {
            code |= (1 << (c - 'a'));
        }
        word_code.push_back(code);
    }
    for (size_t i = 0; i < words.size(); i++)
    {
        for (size_t j = i + 1; j < words.size(); j++)
        {
            if ((word_code[i] & word_code[j]) == 0)
            {
                result = max(result, words[i].size() * words[j].size());
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #268. Missing Number  
/// Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.
/// For example, 
/// Given nums = [0, 1, 3] return 2. 
///
/// Note:
/// Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? 
/// </summary>
int LeetCodeBit::missingNumber(vector<int>& nums)
{
    int sum = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        sum = sum ^ nums[i];
        sum = sum ^ i;
    }
    sum = sum ^ nums.size();
    return sum;
}

/// <summary>
/// Leet code #260. Single Number III 
/// Given an array of numbers nums, in which exactly two elements appear only 
/// once and all the other elements 
/// appear exactly twice. Find the two elements that appear only once. 
///
/// Given nums = [1, 2, 1, 3, 2, 5], return [3, 5]. 
/// Note:
/// 1.The order of the result is not important. So in the above example, [5, 3] 
///   is also correct.
/// 2.Your algorithm should run in linear runtime complexity. Could you implement 
///   it using only constant space complexity?
/// </summary>
vector<int> LeetCodeBit::singleNumberIII(vector<int>& nums)
{
    vector<int> result(2, 0);
    int sum = 0;
    // get the XOR for these two distinct numbers
    for (int num : nums) sum = sum ^ num;

    // get last different bit for the two numbers
    sum = sum &(-sum);

    // divide the whole list of numbers into two, one with the bit set, 
    // another unset
    for (int num : nums)
    {
        if (num & sum)
        {
            result[0] ^= num;
        }
        else
        {
            result[1] ^= num;
        }
    }
    return result;
}

/// <summary>
/// Leet code #421. Maximum XOR of Two Numbers in an Array Add to List 
/// Given a non-empty array of numbers, a0, a1, a2, ¡­ , an-1, where 0 ¡Ü ai < 231.
/// Find the maximum result of ai XOR aj, where 0 ¡Ü i, j < n. 
///
/// Could you do this in O(n) runtime? 
/// Example:
/// Input: [3, 10, 5, 25, 2, 8]
/// Output: 28
/// Explanation: The maximum result is 5 ^ 25 = 28.
/// </summary>
int LeetCodeBit::findMaximumXOR(vector<int>& nums)
{
    int result = 0;
    int mask = 0;

    for (size_t bit_index = 0; bit_index < 32; bit_index++)
    {
        int bit_value = 1 << (31 - bit_index);
        mask |= bit_value;

        unordered_set<int> bits_set;
        for (size_t i = 0; i < nums.size(); i++)
        {
            bits_set.insert(nums[i] & mask);
        }

        int temp = result | bit_value;
        for (int bits : bits_set)
        {
            if (bits_set.find(temp ^ bits) != bits_set.end())
            {
                result = temp;
                break;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #461. Hamming Distance
/// The Hamming distance between two integers is the number of positions at which the 
/// corresponding bits are different.
/// Given two integers x and y, calculate the Hamming distance.
/// Note:
/// 0 ¡Ü x, y < 231. 
/// Example: 
/// Input: x = 1, y = 4
/// Output: 2
/// Explanation:
/// 1   (0 0 0 1)
/// 4   (0 1 0 0)
/// The above arrows point to positions where the corresponding bits are different.    
/// </summary>
int LeetCodeBit::hammingDistance(int x, int y)
{
    int count = 0;
    while ((x != 0) || (y != 0))
    {
        if ((x & 1) != (y & 1))
        {
            count++;
        }
        x >>= 1;
        y >>= 1;
    }
    return count;
}

/// <summary>
/// Leet code #477. Total Hamming Distance 
/// The Hamming distance between two integers is the number of positions at 
/// which the corresponding bits are different.
/// Now your job is to find the total Hamming distance between all pairs of 
/// the given numbers. 
/// Example:
/// Input: 4, 14, 2
/// Output: 6
/// 
/// Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 
/// is 0010 (just showing the four bits relevant in this case). So the answer 
/// will be:
/// HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 
/// 2 + 2 + 2 = 6.
/// Note:
/// 1.Elements of the given array are in the range of 0  to 10^9 
/// 2.Length of the array will not exceed 10^4. 
/// </summary>
int LeetCodeBit::totalHammingDistance(vector<int>& nums)
{
    int total = 0;
    for (size_t i = 0; i < 32; i++)
    {
        unsigned int bit = 1 << i;
        unsigned int zero = 0, one = 0;
        for (size_t j = 0; j < nums.size(); j++)
        {
            if ((nums[j] & bit) == 0) zero++;
            else one++;
        }
        total += one * zero;
    }
    return total;
}

/// <summary>
/// Leet code #390. Elimination Game   
/// 
/// There is a list of sorted integers from 1 to n. Starting from left to right, 
/// remove the first number and every other number afterward until you reach the end of the list.
/// Repeat the previous step again, but this time from right to left, remove the right most 
/// number and every other number from the remaining numbers.
/// We keep repeating the steps again, alternating left to right and right to left, until a single number remains.
/// Find the last number that remains starting with a list of length n.
/// Example: 
/// Input:
/// n = 9,
/// 1 2 3 4 5 6 7 8 9
/// 2 4 6 8
/// 2 6
/// 6
///
/// Output:
/// 6
/// </summary>
int LeetCodeBit::lastRemaining(int n)
{
    unsigned int number = 1;
    unsigned int bit = 1;
    unsigned int iteration = 1;
    while (n > 1)
    {
        if (iteration % 2 == 1)
        {
            number += bit;
        }
        else
        {
            if (n % 2 == 1)
            {
                number += bit;
            }
        }
        n /= 2;
        iteration++;
        bit <<= 1;
    }
    return number;
}

/// <summary>
/// Leet code #476. Number Complement    
/// 
/// Given a positive integer, output its complement number. The complement 
/// strategy is to flip the bits of its binary representation.
/// Note:
/// 1.The given integer is guaranteed to fit within the range of a 32-bit signed integer.
/// 2.You could assume no leading zero bit in the integer¡¯s binary representation.
/// Example 1:
/// Input: 5
/// Output: 2
/// Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.
/// Example 2:
/// Input: 1
/// Output: 0
/// Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.
/// </summary>
int LeetCodeBit::findComplement(int num)
{
    int n = num;
    int bit = 0;
    while (n > 0)
    {
        bit = (bit << 1) + 1;
        n >>= 1;
    }
    return num ^ bit;
}

/// <summary>
/// Leet code #693. Binary Number with Alternating Bits
/// Given a positive integer, check whether it has alternating bits: 
/// namely, if two adjacent bits will always have different values.
///  
/// Example 1:
/// Input: 5
/// Output: True
/// Explanation:
/// The binary representation of 5 is: 101
///
/// Example 2:
/// Input: 7
/// Output: False
/// Explanation:
/// The binary representation of 7 is: 111.
///
/// Example 3:
/// Input: 11
/// Output: False
/// Explanation:
/// The binary representation of 11 is: 1011.
///
/// Example 4:
/// Input: 10
/// Output: True
/// Explanation:
/// The binary representation of 10 is: 1010.
/// </summary>
bool LeetCodeBit::hasAlternatingBits(int n)
{
    int bit = -1;
    while (n > 0)
    {
        int new_bit = n % 2;
        n /= 2;
        if (bit == new_bit)
        {
            return false;
        }
        else
        {
            bit = new_bit;
        }
    }
    return true;
}

/// <summary>
/// Leet code #762. Prime Number of Set Bits in Binary Representation    
///
/// Given two integers L and R, find the count of numbers in the range 
/// [L, R] (inclusive) having a prime number of set bits in their binary 
/// representation. 
/// (Recall that the number of set bits an integer has is the number of 1s 
/// present when written in binary. For example, 21 written in binary is 
/// 10101 which has 3 set bits. Also, 1 is not a prime.) 
///
/// Example 1:
///
/// Input: L = 6, R = 10
/// Output: 4
/// Explanation:
/// 6 -> 110 (2 set bits, 2 is prime)
/// 7 -> 111 (3 set bits, 3 is prime)
/// 9 -> 1001 (2 set bits , 2 is prime)
/// 10->1010 (2 set bits , 2 is prime)
///
/// Example 2:
///
/// Input: L = 10, R = 15
/// Output: 5
/// Explanation:
/// 10 -> 1010 (2 set bits, 2 is prime)
/// 11 -> 1011 (3 set bits, 3 is prime)
/// 12 -> 1100 (2 set bits, 2 is prime)
/// 13 -> 1101 (3 set bits, 3 is prime)
/// 14 -> 1110 (3 set bits, 3 is prime)
/// 15 -> 1111 (4 set bits, 4 is not prime)
///
/// 
/// Note:
/// 1.L, R will be integers L <= R in the range [1, 10^6].
/// 2.R - L will be at most 10000.
/// </summary>
int LeetCodeBit::countPrimeSetBits(int L, int R)
{
    int result = 0;
    unordered_set<int> prime = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };
    for (int i = L; i <= R; i++)
    {
        int bit_count = 0;
        int v = i;
        while (v != 0)
        {
            if (v % 2 == 1) bit_count++;
            v /= 2;
        }
        if (prime.count(bit_count) > 0) result++;
    }
    return result;
}

/// <summary>
/// Leet code #805. Split Array With Same Average
/// 
/// In a given integer array A, we must move every element of A to either 
/// list B or list C. (B and C initially start empty.)
///
/// Return true if and only if after such a move, it is possible that the 
/// average value of B is equal to the average value of C, and B and C are 
/// both non-empty.
///
/// Example :
/// Input: 
/// [1,2,3,4,5,6,7,8]
/// Output: true
/// Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and 
/// both of them have the average of 4.5.
/// Note:
///
/// 1. The length of A will be in the range [1, 30].
/// 2. A[i] will be in the range of [0, 10000].
/// </summary>
bool LeetCodeBit::splitArraySameAverage(vector<int>& A)
{
    int N = A.size();
    int sum = 0;
    for (int num : A) sum += num;
    vector<int> sum_map(sum + 1);
    sum_map[0] = 1;
    for (int num : A)
    {
        for (int s = sum - num; s >= 0; s--)
        {
            sum_map[s + num] |= sum_map[s] << 1;
        }
    }
    for (int i = 1; i < N; i++)
    {
        if (sum * i % N == 0 && sum_map[sum * i / N] & (1 << i))
        {
            return true;
        }
    }
    return false;
}

/// <summary>
/// Leet code #805. Split Array With Same Average
/// 
/// In a given integer array A, we must move every element of A to either 
/// list B or list C. (B and C initially start empty.)
///
/// Return true if and only if after such a move, it is possible that the 
/// average value of B is equal to the average value of C, and B and C are 
/// both non-empty.
///
/// Example :
/// Input: 
/// [1,2,3,4,5,6,7,8]
/// Output: true
/// Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and 
/// both of them have the average of 4.5.
/// Note:
///
/// 1. The length of A will be in the range [1, 30].
/// 2. A[i] will be in the range of [0, 10000].
/// </summary>
bool LeetCodeBit::splitArraySameAverageII(vector<int>& A)
{
    unordered_map<int, int> sum_map;
    int sum = 0;
    sum_map[0] = 1;
    for (int num : A)
    {
        unordered_map<int, int> next_sum = sum_map;
        for (auto itr : sum_map)
        {
            next_sum[itr.first + num] |= itr.second << 1;
        }
        sum_map = next_sum;
        sum += num;
    }

    for (size_t i = 1; i < A.size(); i++)
    {
        if ((sum * i % A.size() == 0) && (sum_map[sum* i / A.size()] & (1 << i)))
        {
            return true;
        }
    }
    return false;
}

/// <summary>
/// Leet code #868. Binary Gap
/// 
/// Given a positive integer N, find and return the longest distance 
/// between two consecutive 1's in the binary representation of N.
///
/// If there aren't two consecutive 1's, return 0.
/// 
///
/// Example 1:
///
/// Input: 22
/// Output: 2
/// Explanation: 
/// 22 in binary is 0b10110.
/// In the binary representation of 22, there are three ones, and two 
/// consecutive pairs of 1's.
/// The first consecutive pair of 1's have distance 2.
/// The second consecutive pair of 1's have distance 1.
/// The answer is the largest of these two distances, which is 2.
///
/// Example 2:
/// Input: 5
/// Output: 2
/// Explanation: 
/// 5 in binary is 0b101.
///
/// Example 3:
/// Input: 6
/// Output: 1
/// Explanation: 
/// 6 in binary is 0b110.
///
/// Example 4:
/// Input: 8
/// Output: 0
/// Explanation: 
/// 8 in binary is 0b1000.
/// There aren't any consecutive pairs of 1's in the binary representation 
/// of 8, so we return 0.
/// Note:
/// 1 <= N <= 10^9
/// </summary>
int LeetCodeBit::binaryGap(int N)
{
    int result = 0;
    int last = -1;
    for (int i = 0; (i < 32) && (N != 0); i++)
    {
        if (N % 2 == 1)
        {
            if (last != -1) result = max(result, i - last);
            last = i;
        }
        N /= 2;
    }
    return result;
}

/// <summary>
/// Leet code #1009. Complement of Base 10 Integer
/// 
/// Every non-negative integer N has a binary representation.  For example, 
/// 5 can be represented as "101" in binary, 11 as "1011" in binary, and so on.
/// Note that except for N = 0, there are no leading zeroes in any binary 
/// representation.
///
/// The complement of a binary representation is the number in binary you get 
/// when changing every 1 to a 0 and 0 to a 1.  For example, the complement of 
/// "101" in binary is "010" in binary.
///
/// For a given number N in base-10, return the complement of it's binary 
/// representation as a base-10 integer.
///
/// 
///
/// Example 1:
///
/// Input: 5
/// Output: 2
/// Explanation: 5 is "101" in binary, with complement "010" in binary, which 
/// is 2 in base-10.
///
/// Example 2:
///
/// Input: 7
/// Output: 0
/// Explanation: 7 is "111" in binary, with complement "000" in binary, which 
/// is 0 in base-10.
///
/// Example 3:
///
/// Input: 10
/// Output: 5
/// Explanation: 10 is "1010" in binary, with complement "0101" in binary, 
/// which is 5 in base-10.
/// 
///
/// Note:
///
/// 1. 0 <= N < 10^9
/// </summary>
int LeetCodeBit::bitwiseComplement(int N)
{
    vector<int> bits;
    if (N == 0) bits.push_back(0);
    while (N > 0)
    {
        bits.push_back(N % 2);
        N /= 2;
    }
    int result = 0;
    while (!bits.empty())
    {
        result = 2 * result + (1 - bits.back());
        bits.pop_back();
    }
    return result;
}

/// <summary>
/// Leet code #1016. Binary String With Substrings Representing 1 To N
/// 
/// Given a binary string S (a string consisting only of '0' and '1's) and a 
/// positive integer N, return true if and only if for every integer X from 1 
/// to N, the binary representation of X is a substring of S.
///
/// Example 1:
///
/// Input: S = "0110", N = 3
/// Output: true
///
/// Example 2:
///
/// Input: S = "0110", N = 4
/// Output: false
/// 
///
/// Note:
/// 
/// 1 <= S.length <= 1000
/// 1 <= N <= 10^9
/// </summary>
bool LeetCodeBit::queryString(string S, int N) 
{
    for (int i = N; i > N / 2; i--)
    {
        std::bitset<32> bits(i);
        string str = bits.to_string();
        str = str.substr(str.find('1'));

        if (S.find(str) == string::npos)
        {
            return false;
        }
    }
    return true;
}

/// <summary>
/// Leet code #1017. Convert to Base -2
/// 
/// Given a number N, return a string consisting of "0"s and "1"s that 
/// represents its value in base -2 (negative two).
///
/// The returned string must have no leading zeroes, unless the string is "0".
///
/// Example 1:
/// Input: 2
/// Output: "110"
/// Explantion: (-2) ^ 2 + (-2) ^ 1 = 2
///
/// Example 2:
/// Input: 3
/// Output: "111"
/// Explantion: (-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3
///
/// Example 3:
/// Input: 4
/// Output: "100"
/// Explantion: (-2) ^ 2 = 4
/// 
///
/// Note:
/// 1. 0 <= N <= 10^9
/// </summary>
string LeetCodeBit::baseNeg2(int N)
{
    int sum = N;
    string result;
    int index = 0;
    int base = -2;
    if (sum == 0) result = "0";
    while (sum != 0)
    {
        int digit = sum % base;
        if (digit != 0)
        {
            result.push_back(abs(digit) + '0');
            sum -= abs(digit);
        }
        else
        {
            result.push_back('0');
        }
        sum /= base;
        index++;
    }
    std::reverse(result.begin(), result.end());
    return result;
}

/// <summary>
/// Leet code #1018. Binary Prefix Divisible By 5
/// 
/// Given an array A of 0s and 1s, consider N_i: the i-th subarray from A[0] 
/// to A[i] interpreted as a binary number (from most-significant-bit to 
/// least-significant-bit.)
///
/// Return a list of booleans answer, where answer[i] is true if and only 
/// if N_i is divisible by 5.
///
/// Example 1:
///
/// Input: [0,1,1]
/// Output: [true,false,false]
/// Explanation: 
/// The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in 
/// base-10.  Only the first number is divisible by 5, so answer[0] is true.
///
/// Example 2:
///
/// Input: [1,1,1]
/// Output: [false,false,false]
///
/// Example 3:
///
/// Input: [0,1,1,1,1,1]
/// Output: [true,false,false,false,true,false]
///
/// Example 4:
///
/// Input: [1,1,1,0,1]
/// Output: [false,false,false,false,false]
/// 
///
/// Note:
///
/// 1. 1 <= A.length <= 30000
/// 2. A[i] is 0 or 1
/// </summary>
vector<bool> LeetCodeBit::prefixesDivBy5(vector<int>& A)
{
    vector<bool> result;
    int sum = 0;
    for (size_t i = 0; i < A.size(); i++)
    {
        sum = (sum * 2 + A[i]) % 5;
        if (sum == 0)
        {
            result.push_back(true);
        }
        else
        {
            result.push_back(false);
        }
    }
    return result;
}

/// <summary>
/// Leet code #1072. Flip Columns For Maximum Number of Equal Rows
/// 
/// Given a matrix consisting of 0s and 1s, we may choose any number of 
/// columns in the matrix and flip every cell in that column.  Flipping 
/// a cell changes the value of that cell from 0 to 1 or from 1 to 0.
///
/// Return the maximum number of rows that have all values equal after 
/// some number of flips.
///
/// Example 1:
/// Input: [[0,1],[1,1]]
/// Output: 1
/// Explanation: After flipping no values, 1 row has all values equal.
///
/// Example 2:
///
/// Input: [[0,1],[1,0]]
/// Output: 2
/// Explanation: After flipping values in the first column, both rows have 
/// equal values.
///
/// Example 3:
///
/// Input: [[0,0,0],[0,0,1],[1,1,0]]
/// Output: 2
/// Explanation: After flipping values in the first two columns, the last 
/// two rows have equal values.
/// 
/// Note:
/// 1. 1 <= matrix.length <= 300
/// 2. 1 <= matrix[i].length <= 300
/// 3. All matrix[i].length's are equal
/// 4. matrix[i][j] is 0 or 1
/// </summary>
int LeetCodeBit::maxEqualRowsAfterFlips(vector<vector<int>>& matrix)
{
    int result = 0;
    unordered_map<string, int> str_map;

    for (size_t i = 0; i < matrix.size(); i++)
    {
        string bit_map, rev_map;
        for (size_t j = 0; j < matrix[i].size(); j++)
        {
            bit_map.push_back('0' + matrix[i][j]);
            rev_map.push_back('0' + 1 - matrix[i][j]);
        }
        str_map[bit_map]++;
        result = max(result, str_map[bit_map]);
        str_map[rev_map]++;
        result = max(result, str_map[rev_map]);
    }
    return result;
}

/// <summary>
/// Leet code #1073. Adding Two Negabinary Numbers
/// 
/// Given two numbers arr1 and arr2 in base -2, return the result of adding 
/// them together.
/// Each number is given in array format:  as an array of 0s and 1s, from 
/// most significant bit to least significant bit.  For example, 
/// arr = [1,1,0,1] represents the number (-2)^3 + (-2)^2 + (-2)^0 = -3.  
/// A number arr in array format is also guaranteed to have no leading 
/// zeros: either arr == [0] or arr[0] == 1.
/// Return the result of adding arr1 and arr2 in the same format: as an array 
/// of 0s and 1s with no leading zeros.
/// 
/// Example 1:
/// Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1]
/// Output: [1,0,0,0,0]
/// Explanation: arr1 represents 11, arr2 represents 5, the output 
/// represents 16.
/// 
/// Note:
/// 1. 1 <= arr1.length <= 1000
/// 2. 1 <= arr2.length <= 1000
/// 3. arr1 and arr2 have no leading zeros
/// 4. arr1[i] is 0 or 1
/// 5. arr2[i] is 0 or 1
/// </summary>
vector<int> LeetCodeBit::addNegabinary(vector<int>& arr1, vector<int>& arr2)
{
    vector<int> param1 = arr1;
    vector<int> param2 = arr2;
    std::reverse(param1.begin(), param1.end());
    std::reverse(param2.begin(), param2.end());
    
    vector<int> result;
    int carry = 0;
    for (size_t i = 0; (i < param1.size()) || (i < param2.size()) || (carry != 0); i++)
    {
        int bit1 = 0;
        if (i < param1.size()) bit1 = param1[i];
        int bit2 = 0;
        if (i < param2.size()) bit2 = param2[i];

        int result_bit = bit1 + bit2 + carry;

        if (result_bit == -1)
        {
            result.push_back(1);
            carry = 1;
        }
        else
        {
            result.push_back(result_bit % -2);
            carry = result_bit / -2;
        }
    }
    while (result.size() > 1 && result.back() == 0) result.pop_back();
    std::reverse(result.begin(), result.end());

    return result;
}

/// <summary>
/// Leet code #1238. Circular Permutation in Binary Representation
/// 
/// Given 2 integers n and start. Your task is return any permutation p of 
/// (0,1,2.....,2^n -1) such that :
///
/// p[0] = start
/// p[i] and p[i+1] differ by only one bit in their binary representation.
/// p[0] and p[2^n -1] must also differ by only one bit in their binary 
/// representation.
/// 
/// Example 1:
///
/// Input: n = 2, start = 3
/// Output: [3,2,0,1]
/// Explanation: The binary representation of the permutation is (11,10,00,01). 
/// All the adjacent element differ by one bit. Another valid permutation 
/// is [3,1,0,2]
///
/// Example 2:
///
/// Input: n = 3, start = 2
/// Output: [2,6,7,5,4,0,1,3]
/// Explanation: The binary representation of the permutation is 
/// (010,110,111,101,100,000,001,011).
/// 
/// Constraints:
/// 1. 1 <= n <= 16
/// 2. 0 <= start < 2 ^ n
/// </summary>
vector<int> LeetCodeBit::circularPermutation(int n, int start)
{
    vector<int> result;
    vector<int> buffer;
    int end = 1 << n;
    bool is_start = false;
    for (int i = 0; i < end; i++)
    {
        int num = (i ^ (i >> 1));
        if (num == start) is_start = true;
        if (is_start) result.push_back(num);
        else buffer.push_back(num);
    }
    result.insert(result.end(), buffer.begin(), buffer.end());
    
    return result;
}

/// <summary>
/// Leet code #1461. Check If a String Contains All Binary Codes of Size K
/// 
/// Medium
///
/// Given a binary string s and an integer k.
///
/// Return True if all binary codes of length k is a substring of s. 
/// Otherwise, return False.
///
/// Example 1:
/// Input: s = "00110110", k = 2
/// Output: true
/// Explanation: The binary codes of length 2 are "00", "01", "10" 
/// and "11". They can be all found as substrings at indicies 0, 1, 3 
/// and 2 respectively.
///
/// Example 2:
/// Input: s = "00110", k = 2
/// Output: true
///
/// Example 3:
/// Input: s = "0110", k = 1
/// Output: true
/// Explanation: The binary codes of length 1 are "0" and "1", it 
/// is clear that both exist as a substring. 
///
/// Example 4:
/// Input: s = "0110", k = 2
/// Output: false
/// Explanation: The binary code "00" is of length 2 and doesn't exist in 
/// the array.
///
/// Example 5:
/// Input: s = "0000000001011100", k = 4
/// Output: false
///
/// Constraints:
/// 1. 1 <= s.length <= 5 * 10^5
/// 2. s consists of 0's and 1's only.
/// 3. 1 <= k <= 20
/// </summary>
bool LeetCodeBit::hasAllCodes(string s, int k)
{
    int size = 1 << k;
    vector<int> check(size);
    int sum = 0;
    int result = 0;
    for (size_t i = 0; i < s.size(); i++)
    {
        sum = sum * 2 + (s[i] - '0');

        if ((int)i >= k) sum -= size * (s[i - k] - '0');
        if ((int)i >= k - 1)
        {
            if (check[sum] == 0)
            {
                check[sum] = 1;
                result++;
                if (result == size) return true;
            }
        }
    }
    return false;
}

/// <summary>
/// Leet code #861. Score After Flipping Matrix
/// 
/// We have a two dimensional matrix A where each value is 0 or 1.
///
/// A move consists of choosing any row or column, and toggling each value 
/// in that row or column: changing all 0s to 1s, and all 1s to 0s.
///
/// After making any number of moves, every row of this matrix is interpreted 
/// as a binary number, and the score of the matrix is the sum of these 
/// numbers.
///
/// Return the highest possible score.
///
/// 
///
/// Example 1:
///
/// Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]
/// Output: 39
/// Explanation:
/// Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].
/// 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
/// 
/// 
/// Note:
///
/// 1. 1 <= A.length <= 20
/// 2. 1 <= A[0].length <= 20
/// 3. A[i][j] is 0 or 1.
/// </summary>
int LeetCodeBit::matrixScore(vector<vector<int>>& A)
{
    vector<vector<int>> M = A;
    for (size_t row = 0; row < M.size(); row++)
    {
        if (M[row][0] == 0)
        {
            for (size_t col = 0; col < M[row].size(); col++)
            {
                M[row][col] = 1 - M[row][col];
            }
        }
    }

    for (size_t col = 0; col < M[0].size(); col++)
    {
        int count = 0;
        for (size_t row = 0; row < M.size(); row++)
        {
            if (M[row][col] == 1) count++;
        }
        if (count < ((int)M.size() - count))
        {
            for (size_t row = 0; row < M.size(); row++)
            {
                M[row][col] = 1 - M[row][col];
            }
        }
    }

    int result = 0;
    for (size_t row = 0; row < M.size(); row++)
    {
        int sum = 0;
        for (size_t col = 0; col < M[row].size(); col++)
        {
            sum = (sum << 1) + M[row][col];
        }
        result += sum;
    }
    return result;
}


/// <summary>
/// Leet code #1486. XOR Operation in an Array
/// 
/// Easy
///
/// Given an integer n and an integer start.
/// Define an array nums where nums[i] = start + 2*i (0-indexed) and 
/// n == nums.length.
///
/// Return the bitwise XOR of all elements of nums.
///
/// Example 1:
/// Input: n = 5, start = 0
/// Output: 8
/// Explanation: Array nums is equal to [0, 2, 4, 6, 8] where 
/// (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8.
/// Where "^" corresponds to bitwise XOR operator.
///
/// Example 2:
/// Input: n = 4, start = 3
/// Output: 8
/// Explanation: Array nums is equal to [3, 5, 7, 9] where 
/// (3 ^ 5 ^ 7 ^ 9) = 8.
///
/// Example 3:
/// Input: n = 1, start = 7
/// Output: 7
///
/// Example 4:
/// Input: n = 10, start = 5
/// Output: 2
///
/// Constraints:
/// 1. 1 <= n <= 1000
/// 2. 0 <= start <= 1000
/// 3. n == nums.length
/// </summary>
int LeetCodeBit::xorOperation(int n, int start)
{
    int result = 0;
    for (int i = 0; i < n; i++)
    {
        result = result ^ (start + (2 * i));
    }
    return result;
}

/// <summary>
/// Leet code #1521. Find a Value of a Mysterious Function Closest to 
///                  Target
/// 
/// Hard
///
/// Winston was given the above mysterious function func. He has an 
/// integer array arr and an integer target and he wants to find the 
/// values l and r that make the value |func(arr, l, r) - target| 
/// minimum possible.
///
/// Return the minimum possible value of |func(arr, l, r) - target|.
///
/// Notice that func should be called with the values l and r where 
/// 0 <= l, r < arr.length.
///
/// Example 1:
///
/// Input: arr = [9,12,3,7,15], target = 5
/// Output: 2
/// Explanation: Calling func with all the pairs of [l,r] =
/// [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],
/// [2,4],[0,3],[1,4],[0,4]], Winston got the following results 
/// [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0]. The value closest to 5 is 7 and 3, 
/// thus the minimum difference is 2.
///
/// Example 2:
/// Input: arr = [1000000,1000000,1000000], target = 1
/// Output: 999999
/// Explanation: Winston called the func with all possible values of 
/// [l,r] and he always got 1000000, thus the min difference is 999999.
///
/// Example 3:
/// Input: arr = [1,2,4,8,16], target = 0
/// Output: 0
///
/// Constraints:
/// 1. 1 <= arr.length <= 10^5
/// 2. 1 <= arr[i] <= 10^6
/// 3. 0 <= target <= 10^7
/// </summary>
int LeetCodeBit::closestToTarget(vector<int>& arr, int target)
{
    deque<int> *curr = new deque<int>();
    deque<int> *next = new deque<int>();
    int result = INT_MAX;
    for (size_t i = 0; i < arr.size(); i++)
    {
        result = min(result, abs(arr[i] - target));
        next->push_front(arr[i]);
        int last_bits = arr[i];
        while (!curr->empty())
        {
            int num = curr->back();
            curr->pop_back();
            if ((num & last_bits) == last_bits) continue;
            next->push_front(num);
            last_bits = num & last_bits;
            result = min(result, abs(last_bits - target));
            if (last_bits == 0) break;
        }
        swap(curr, next);
        next->clear();
    }
    delete curr;
    delete next;
    return result;
}

/// <summary>
/// Leet code #1529. Bulb Switcher IV
/// 
/// Medium
///
/// There is a room with n bulbs, numbered from 0 to n-1, arranged in a 
/// row from left to right. Initially all the bulbs are turned off.
///
/// Your task is to obtain the configuration represented by target where 
/// target[i] is '1' if the i-th bulb is turned on and is '0' if it is 
/// turned off.
///
/// You have a switch to flip the state of the bulb, a flip operation is 
/// defined as follows:
///
/// Choose any bulb (index i) of your current configuration.
/// Flip each bulb from index i to n-1.
/// When any bulb is flipped it means that if it is 0 it changes to 1 and 
/// if it is 1 it changes to 0.
///
/// Return the minimum number of flips required to form target.
/// 
/// Example 1:
///
/// Input: target = "10111"
/// Output: 3
/// Explanation: Initial configuration "00000".
/// flip from the third bulb:  "00000" -> "00111"
/// flip from the first bulb:  "00111" -> "11000"
/// flip from the second bulb:  "11000" -> "10111"
/// We need at least 3 flip operations to form target.
///
/// Example 2:
/// Input: target = "101"
/// Output: 3
/// Explanation: "000" -> "111" -> "100" -> "101".
///
/// Example 3:
/// Input: target = "00000"
/// Output: 0
///
/// Example 4:
/// Input: target = "001011101"
/// Output: 5
/// 
/// Constraints:
/// 1. 1 <= target.length <= 10^5
/// 2. target[i] == '0' or target[i] == '1'
/// </summary>
int LeetCodeBit::minFlips(string target)
{
    char prev = '0';
    int result = 0;
    for (size_t i = 0; i < target.size(); i++)
    {
        if (prev == target[i]) continue;
        result++;
        prev = target[i];
    }
    return result;
}

/// <summary>
/// Leet code #1545. Find Kth Bit in Nth Binary String
/// 
/// Medium
///
/// Given two positive integers n and k, the binary string  
/// Sn is formed as follows:
///
/// S1 = "0" 
/// s[i] and s[i + 1] where:
///
/// Si = Si-1 + "1" + reverse(invert(Si-1)) for i > 1
/// Where + denotes the concatenation operation, reverse(x) returns 
/// the reversed string x, and invert(x) inverts all the bits in 
/// x (0 changes to 1 and 1 changes to 0).
/// 
/// For example, the first 4 strings in the above sequence are:
/// S1 = "0"
/// S2 = "011"
/// S3 = "0111001"
/// S4 = "011100110110001"
/// Return the kth bit in Sn. It is guaranteed that k is valid for the given n.
///
/// Example 1:
/// Input: n = 3, k = 1
/// Output: "0"
/// Explanation: S3 is "0111001". The first bit is "0".
///
/// Example 2:
/// Input: n = 4, k = 11
/// Output: "1"
/// Explanation: S4 is "011100110110001". The 11th bit is "1".
/// Example 3:
/// Input: n = 1, k = 1
/// Output: "0"
///
/// Example 4:
/// Input: n = 2, k = 3
/// Output: "1"
/// Constraints:
/// 1. 1 <= n <= 20
/// 2. 1 <= k <= 2n - 1
/// 3. 0 <= i <= s.length - 2
/// </summary>
char LeetCodeBit::findKthBit(int n, int k)
{
    int reverse = 0;
    int len = 0;
    for (int i = 0; i < n; i++)
    {
        len = 1 + 2 * len;
    }
    k--;
    int bit = 0;
    while (k > 0)
    {
        len = len / 2;
        if (k < len) continue;
        else if (k == len)
        {
            bit = 1;
            break;
        }
        else
        {
            k = k - len - 1;
            k = len - 1 - k;
            reverse = 1 - reverse;
        }
    }
    return (abs(reverse - bit) + '0');
}

/// <summary>
/// Leet code #1707. Maximum XOR With an Element From Array
/// 
/// Hard
/// 
/// You are given an array nums consisting of non-negative integers. 
/// You are also given a queries array, where queries[i] = [xi, mi].
///
/// The answer to the ith query is the maximum bitwise XOR value of xi 
/// and any element of nums that does not exceed mi. In other words, the 
/// answer is max(nums[j] XOR xi) for all j such that nums[j] <= mi. If 
/// all elements in nums are larger than mi, then the answer is -1.
///
/// Return an integer array answer where answer.length == queries.length 
/// and answer[i] is the answer to the ith query.
///
/// Example 1:
/// Input: nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]
/// Output: [3,3,7]
/// Explanation:
/// 1) 0 and 1 are the only two integers not greater than 1. 0 XOR 
///    3 = 3 and 1 XOR 3 = 2. The larger of the two is 3.
/// 2) 1 XOR 2 = 3.
/// 3) 5 XOR 2 = 7.
/// Example 2:
/// 
/// Input: nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]
/// Output: [15,-1,5]
/// Constraints:
/// 1. 1 <= nums.length, queries.length <= 10^5
/// 2. queries[i].length == 2
/// 3. 0 <= nums[j], xi, mi <= 10^9
/// </summary>
vector<int> LeetCodeBit::maximizeXor(vector<int>& nums, vector<vector<int>>& queries)
{
    const int n = queries.size();
    vector<int> result;
    sort(nums.begin(), nums.end());

    for (int i = 0; i < n; i++) 
    {
        int end = upper_bound(nums.begin(), nums.end(), queries[i][1]) - nums.begin();
        int start = 0;
        if (end == 0)
        {
            result.push_back(-1);
            continue;
        }

        int low = 0;
        int bit = 1 << 30;
        int full = bit - 1;
        for (int j = 0; j < 31; j++) 
        {
            if (bit <= nums[end - 1])
            {
                if ((queries[i][0] & bit) != 0)
                {
                    // hope A[i] this bit == 0
                    if ((low | full) >= nums[start])
                    {
                        if ((low | full) < nums[end - 1])
                        {
                            end = upper_bound(nums.begin() + start, nums.begin() + end, low | full) - nums.begin();
                        }
                    }
                    else
                    {
                        low |= bit;
                    }
                }
                else
                {
                    // hope: A[i] this bit == 1
                    if ((low | bit) <= nums[end - 1])
                    {
                        low |= bit;
                        start = lower_bound(nums.begin() + start, nums.begin() + end, low) - nums.begin();
                    }
                }
            }
            bit >>= 1;
            full >>= 1;
        }
        result.push_back(queries[i][0] ^ low);
    }
    return result;
}

/// <summary>
/// Leet code 1734. Decode XORed Permutation
/// 
/// Medium
/// 
/// There is an integer array perm that is a permutation of the first n 
/// positive integers, where n is always odd.
///
/// It was encoded into another integer array encoded of length n - 1, 
/// such that encoded[i] = perm[i] XOR perm[i + 1]. For example, if 
/// perm = [1,3,2], then encoded = [2,1].
///
/// Given the encoded array, return the original array perm. It is 
/// guaranteed that the answer exists and is unique.
/// 
/// Example 1:
/// Input: encoded = [3,1]
/// Output: [1,2,3]
/// Explanation: If perm = [1,2,3], then encoded = [1 XOR 2,2 XOR 3] 
/// = [3,1]
///
/// Example 2:
/// Input: encoded = [6,5,4,6]
/// Output: [2,4,1,5,3]
/// Constraints:
/// 1. 3 <= n < 10^5
/// 2. n is odd.
/// 3. encoded.length == n - 1
/// </summary>
vector<int> LeetCodeBit::decode(vector<int>& encoded)
{
    int n = encoded.size() + 1;
    vector<int> result(n);
    int sum = 0;
    for (int i = 1; i <= n; i++)
    {
        sum = sum ^ i;
    }
    for (int i = 1; i < n; i += 2)
    {
        sum = sum ^encoded[i];
    }
    result[0] = sum;
    for (int i = 1; i < n; i++)
    { 
        result[i] = result[i - 1] ^ encoded[i - 1];
    }
    return result;
}


/// <summary>
/// Leet code 1803. Count Pairs With XOR in a Range
/// 
/// Hard
/// 
/// Given a (0-indexed) integer array nums and two integers low and 
/// high, return the number of nice pairs.
///
/// A nice pair is a pair (i, j) where 0 <= i < j < nums.length and 
/// low <= (nums[i] XOR nums[j]) <= high.
/// 
/// Example 1:
/// Input: nums = [1,4,2,7], low = 2, high = 6
/// Output: 6
/// Explanation: All nice pairs (i, j) are as follows:
/// - (0, 1): nums[0] XOR nums[1] = 5 
/// - (0, 2): nums[0] XOR nums[2] = 3
/// - (0, 3): nums[0] XOR nums[3] = 6
/// - (1, 2): nums[1] XOR nums[2] = 6
/// - (1, 3): nums[1] XOR nums[3] = 3
/// - (2, 3): nums[2] XOR nums[3] = 5
///
/// Example 2:
/// Input: nums = [9,8,4,2,1], low = 5, high = 14
/// Output: 8
/// Explanation: All nice pairs (i, j) are as follows:
/// - (0, 2): nums[0] XOR nums[2] = 13
/// - (0, 3): nums[0] XOR nums[3] = 11
/// - (0, 4): nums[0] XOR nums[4] = 8
/// - (1, 2): nums[1] XOR nums[2] = 12
/// - (1, 3): nums[1] XOR nums[3] = 10
/// - (1, 4): nums[1] XOR nums[4] = 9
/// - (2, 3): nums[2] XOR nums[3] = 6
/// - (2, 4): nums[2] XOR nums[4] = 5
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 2 * 10^4
/// 2. 1 <= nums[i] <= 2 * 10^4
/// 3. 1 <= low <= high <= 2 * 10^4
/// </summary>
int LeetCodeBit::countPairs(vector<int>& nums, int low, int high)
{
    vector<int> result(2);
    vector<int> limits = { low, high + 1 };
    for (size_t i = 0; i < 2; i++)
    {
        unordered_map<int, int> curr, next;
        for (auto n : nums)
        {
            curr[n]++;
        }
        int limit = limits[i];
        while (limit > 0)
        {            
            for (auto itr : curr)
            {
                if (limit % 2 == 1)
                {
                    int target = itr.first ^ (limit - 1);
                    if (curr.count(target) > 0)
                    {
                        result[i] += itr.second * curr[target];
                    }
                }
                next[itr.first >> 1] += itr.second;
            }
            curr = next;
            next.clear();
            limit /= 2;
        }
    }
    return (result[1] - result[0]) / 2;
}

/// <summary>
/// Leet code 1803. Count Pairs With XOR in a Range
/// Hard
/// </summary>
int LeetCodeBit::countPairs2(vector<int>& nums, int low, int high)
{
    vector<int> result(2);
    vector<int> limits = { low, high + 1 };
    vector<int> num_count(65536);
    for (size_t i = 0; i < nums.size(); i++)
    {
        int offset = 0;
        int base = 0;
        for (int j = 14; j >= 0; j--)
        {
            int bit = 1 << j;
            if ((nums[i] & bit) == 0)
            {
                num_count[base + offset]++;
                offset = offset * 2;
            }
            else
            {
                num_count[base + offset + 1]++;
                offset = (offset + 1) * 2;
            }
            base = base + (1 << (15 - j));
        }
    }
    for (size_t i = 0; i < 2; i++)
    {
        int limit = limits[i];
        for (size_t j = 0; j < nums.size(); j++)
        {
            int num = nums[j];
            int offset = 0;
            int base = 0;
            for (int j = 14; j >= 0; j--)
            {
                int bit = 1 << j;
                if ((limit & bit) == 0)
                {
                    if ((num & bit) == 0) offset = offset * 2;
                    else offset = (offset + 1) * 2;
                }
                else
                {
                    if ((num & bit) == 0)
                    {
                        result[i] += num_count[base + offset];
                        offset = (offset + 1) * 2;
                    }
                    else
                    {
                        result[i] += num_count[base + offset + 1];
                        offset = offset * 2;
                    }
                }
                base = base + (1 << (15 - j));
            }
        }
    }
    return (result[1] - result[0]) / 2;
}

/// <summary>
/// Leet code 1803. Count Pairs With XOR in a Range
/// </summary>
int LeetCodeBit::countPairs3(vector<int>& nums, int low, int high)
{
    struct TrieBit
    {
        int count;
        TrieBit * children[2];

        TrieBit()
        {
            count = 0;
            children[0] = nullptr;
            children[1] = nullptr;
        }
    };
    TrieBit * root = new TrieBit();
    for (size_t i = 0; i < nums.size(); i++)
    {
        TrieBit * ptr = root;
        for (int j = 14; j >= 0; j--)
        {
            int bit = 1 << j;
            if ((nums[i] & bit) == 0)
            {
                if (ptr->children[0] == nullptr)
                {
                    ptr->children[0] = new TrieBit();
                }
                ptr->children[0]->count++;
                ptr = ptr->children[0];
            }
            else
            {
                if (ptr->children[1] == nullptr)
                {
                    ptr->children[1] = new TrieBit();
                }
                ptr->children[1]->count++;
                ptr = ptr->children[1];
            }
        }
    }
    vector<int> result(2);
    vector<int> limits = { low, high + 1 };
    for (size_t i = 0; i < 2; i++)
    {
        int limit = limits[i];
        for (size_t j = 0; j < nums.size(); j++)
        {
            int num = nums[j];
            TrieBit* ptr = root;
            for (int j = 14; j >= 0; j--)
            {
                int bit = 1 << j;
                if ((limit & bit) == 0)
                {
                    if ((num & bit) == 0) ptr = ptr->children[0];
                    else ptr = ptr->children[1];
                }
                else
                {
                    if ((num & bit) == 0)
                    {
                        if (ptr->children[0] != nullptr) result[i] += ptr->children[0]->count;
                        ptr = ptr->children[1];
                    }
                    else
                    {
                        if (ptr->children[1] != nullptr) result[i] += ptr->children[1]->count;
                        ptr = ptr->children[0];
                    }
                }
                if (ptr == nullptr) break;
            }
        }
    }
    return (result[1] - result[0]) / 2;
}

/// <summary>
/// Leet code 1829. Maximum XOR for Each Query
/// 
/// Medium
/// 
/// You are given a sorted array nums of n non-negative integers and an 
/// integer maximumBit. You want to perform the following query n times:
///
/// Find a non-negative integer k < 2maximumBit such that nums[0] XOR 
/// nums[1] XOR ... XOR nums[nums.length-1] XOR k is maximized. k is the 
/// answer to the ith query.
/// Remove the last element from the current array nums.
/// Return an array answer, where answer[i] is the answer to the ith query.
/// 
/// Example 1:
/// Input: nums = [0,1,1,3], maximumBit = 2
/// Output: [0,3,2,3]
/// Explanation: The queries are answered as follows:
/// 1st query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.
/// 2nd query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.
/// 3rd query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3.
/// 4th query: nums = [0], k = 3 since 0 XOR 3 = 3.
///
/// Example 2:
/// Input: nums = [2,3,4,7], maximumBit = 3
/// Output: [5,2,6,5]
/// Explanation: The queries are answered as follows:
/// 1st query: nums = [2,3,4,7], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7.
/// 2nd query: nums = [2,3,4], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7.
/// 3rd query: nums = [2,3], k = 6 since 2 XOR 3 XOR 6 = 7.
/// 4th query: nums = [2], k = 5 since 2 XOR 5 = 7.
///
/// Example 3:
/// Input: nums = [0,1,2,2,5,7], maximumBit = 3
/// Output: [4,3,6,4,6,7]
/// Constraints:
/// 1. nums.length == n
/// 2. 1 <= n <= 10^5
/// 3. 1 <= maximumBit <= 20
/// 4. 0 <= nums[i] < 2^maximumBit
/// 5. nums is sorted in ascending order.
/// </summary>
vector<int> LeetCodeBit::getMaximumXor(vector<int>& nums, int maximumBit)
{
    vector<int> result(nums.size());
    int full = (1 << maximumBit) - 1;
    int bit = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        bit = bit ^ nums[i];
        result[nums.size() - 1 - i] = full ^ bit;
    }
    return result;
}

/// <summary>
/// Leet code 1835. Find XOR Sum of All Pairs Bitwise AND
/// 
/// Hard
/// 
/// The XOR sum of a list is the bitwise XOR of all its elements. If the 
/// list only contains one element, then its XOR sum will be equal to this 
/// element.
///
/// For example, the XOR sum of [1,2,3,4] is equal to 1 XOR 2 XOR 3 XOR 
/// 4 = 4, and the XOR sum of [3] is equal to 3.
/// You are given two 0-indexed arrays arr1 and arr2 that consist only of 
/// non-negative integers.
///
/// Consider the list containing the result of arr1[i] AND arr2[j] 
/// (bitwise AND) for every (i, j) pair where 0 <= i < arr1.length and 
/// 0 <= j < arr2.length.
///
/// Return the XOR sum of the aforementioned list.
/// Example 1:
/// Input: arr1 = [1,2,3], arr2 = [6,5]
/// Output: 0
/// Explanation: The list = [1 AND 6, 1 AND 5, 2 AND 6, 2 AND 5, 3 
/// AND 6, 3 AND 5] = [0,1,2,0,2,1].
/// The XOR sum = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0.
///
/// Example 2:
/// Input: arr1 = [12], arr2 = [4]
/// Output: 4
/// Explanation: The list = [12 AND 4] = [4]. The XOR sum = 4.
///
/// Constraints:
/// 1. 1 <= arr1.length, arr2.length <= 10^5
/// 2. 0 <= arr1[i], arr2[j] <= 10^9
/// </summary>
int LeetCodeBit::getXORSum(vector<int>& arr1, vector<int>& arr2)
{
    int bit1 = 0;
    int bit2 = 0;
    for (size_t i = 0; i < arr1.size(); i++)
    {
        bit1 = bit1 ^ arr1[i];
    }
    for (size_t i = 0; i < arr2.size(); i++)
    {
        bit2 = bit2 ^ arr2[i];
    }
    return bit1 & bit2;
}

/// <summary>
/// Leet code 1863. Sum of All Subset XOR Totals
/// 
/// Easy
/// 
/// The XOR total of an array is defined as the bitwise XOR of all its 
/// elements, or 0 if the array is empty.
///
/// For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
/// Given an array nums, return the sum of all XOR totals for every subset 
/// of nums. 
///
/// Note: Subsets with the same elements should be counted multiple times.
///
/// An array a is a subset of an array b if a can be obtained from b by 
/// deleting some (possibly zero) elements of b.
/// 
/// Example 1:
/// Input: nums = [1,3]
/// Output: 6
/// Explanation: The 4 subsets of [1,3] are:
/// - The empty subset has an XOR total of 0.
/// - [1] has an XOR total of 1.
/// - [3] has an XOR total of 3.
/// - [1,3] has an XOR total of 1 XOR 3 = 2.
/// 0 + 1 + 3 + 2 = 6
///
/// Example 2:
/// Input: nums = [5,1,6]
/// Output: 28
/// Explanation: The 8 subsets of [5,1,6] are:
/// - The empty subset has an XOR total of 0.
/// - [5] has an XOR total of 5.
/// - [1] has an XOR total of 1.
/// - [6] has an XOR total of 6.
/// - [5,1] has an XOR total of 5 XOR 1 = 4.
/// - [5,6] has an XOR total of 5 XOR 6 = 3.
/// - [1,6] has an XOR total of 1 XOR 6 = 7.
/// - [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.
/// 0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28
///
/// Example 3:
/// Input: nums = [3,4,5,6,7,8]
/// Output: 480
/// Explanation: The sum of all XOR totals for every subset is 480.
///
/// Constraints:
/// 1. 1 <= nums.length <= 12
/// 2. 1 <= nums[i] <= 20
/// </summary>
int LeetCodeBit::subsetXORSum(vector<int>& nums)
{
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        result = result | nums[i];
    }
    result = result * (1 << (nums.size() - 1));
    
    return result;
}

/// <summary>
/// Leet code 1938. Maximum Genetic Difference Query
/// </summary>
void LeetCodeBit::maxGeneticDifference(TrieBitNode* root, int node_id, vector<vector<int>>& tree,
    vector<vector<pair<int, int>>>& query_list, vector<int>& result)
{
    root->increase(node_id, 1);
    for (size_t i = 0; i < query_list[node_id].size(); i++)
    {
        int val = (int)root->findMax(query_list[node_id][i].first);
        result[query_list[node_id][i].second] = val;
    }
    for (size_t i = 0; i < tree[node_id].size(); i++)
    {
        maxGeneticDifference(root, tree[node_id][i], tree, query_list, result);
    }
    root->increase(node_id, -1);
}

/// <summary>
/// Leet code 1938. Maximum Genetic Difference Query
///                                  
/// Hard
/// 
/// There is a rooted tree consisting of n nodes numbered 0 to n - 1. 
/// Each node's number denotes its unique genetic value (i.e. the genetic 
/// value of node x is x). The genetic difference between two genetic 
/// values is defined as the bitwise-XOR of their values. You are given 
/// the integer array parents, where parents[i] is the parent for node i. 
/// If node x is the root of the tree, then parents[x] == -1.
///
/// You are also given the array queries where queries[i] = [nodei, vali]. 
/// For each query i, find the maximum genetic difference between vali and 
/// pi, where pi is the genetic value of any node that is on the path 
/// between nodei and the root (including nodei and the root). More 
/// formally, you want to maximize vali XOR pi.
///
/// Return an array ans where ans[i] is the answer to the ith query.
/// 
/// Example 1:
/// Input: parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]]
/// Output: [2,3,7]
/// Explanation: The queries are processed as follows:
/// - [0,2]: The node with the maximum genetic difference is 0, with a 
///   difference of 2 XOR 0 = 2.
/// - [3,2]: The node with the maximum genetic difference is 1, with 
///   a difference of 2 XOR 1 = 3.
/// - [2,5]: The node with the maximum genetic difference is 2, with 
///   a difference of 5 XOR 2 = 7.
///
/// Example 2:
/// Input: parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]]
/// Output: [6,14,7]
/// Explanation: The queries are processed as follows:
/// - [4,6]: The node with the maximum genetic difference is 0, with a 
///   difference of 6 XOR 0 = 6.
/// - [1,15]: The node with the maximum genetic difference is 1, with a 
///   difference of 15 XOR 1 = 14.
/// - [0,5]: The node with the maximum genetic difference is 2, with 
///   a difference of 5 XOR 2 = 7.
///
/// Constraints:
/// 1. 2 <= parents.length <= 10^5
/// 2. 0 <= parents[i] <= parents.length - 1 for every node i that is not 
///    the root.
/// 3. parents[root] == -1
/// 4. 1 <= queries.length <= 3 * 10^4
/// 5. 0 <= nodei <= parents.length - 1
/// 6. 0 <= vali <= 2 * 10^5
/// </summary>
vector<int> LeetCodeBit::maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries)
{
    vector<vector<int>> tree(parents.size(), vector<int>());
    int root_id = -1;
    for (size_t i = 0; i < parents.size(); i++)
    {
        if (parents[i] == -1) root_id = i;
        else tree[parents[i]].push_back(i);
    }
    vector<vector<pair<int, int>>> query_list(parents.size(), vector<pair<int, int>>());
    for (size_t i = 0; i < queries.size(); i++)
    {
        query_list[queries[i][0]].push_back(make_pair(queries[i][1], i));
    }
    TrieBitNode* root = new TrieBitNode(17);
    vector<int> result(queries.size());
    maxGeneticDifference(root, root_id, tree, query_list, result);
    return result;
}

/// <summary>
/// Leet 1980. Find Unique Binary String
///                                                                 
/// Medium
/// 
/// Given an array of strings nums containing n unique binary strings each 
/// of length n, return a binary string of length n that does not appear 
/// in nums. If there are multiple answers, you may return any of them.
///
/// Example 1:
/// Input: nums = ["01","10"]
/// Output: "11"
/// Explanation: "11" does not appear in nums. "00" would also be correct.
///
/// Example 2:
/// Input: nums = ["00","01"]
/// Output: "11"
/// Explanation: "11" does not appear in nums. "10" would also be correct.
///
/// Example 3:
/// Input: nums = ["111","011","001"]
/// Output: "101"
/// Explanation: "101" does not appear in nums. "000", "010", "100", 
/// and "110" would also be correct.
/// 
/// Constraints:
/// 1. n == nums.length
/// 2. 1 <= n <= 16
/// 3. nums[i].length == n
/// 4. nums[i] is either '0' or '1'.
/// 5. All the strings of nums are unique.
/// </summary>
string LeetCodeBit::findDifferentBinaryString(vector<string>& nums)
{
    unordered_set<int> bits(nums.size());

    for (size_t i = 0; i < nums.size(); i++)
    {
        int bit = 0;
        for (size_t j = 0; j < nums[i].size(); j++)
        {
            bit = bit * 2;
            if (nums[i][j] == '1') bit += 1;
        }
        bits.insert(bit);
    }

    int bit = 0;
    while (bit < (1 << nums.size()))
    {
        if (bits.count(bit) == 0) break;
        bit++;
    }
    string result;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (bit & (1 << (nums.size() - 1 - i)))
        {
            result.push_back('1');
        }
        else
        {
            result.push_back('0');
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2220. Minimum Bit Flips to Convert Number
///                                                                                   
/// Easy
///
/// A bit flip of a number x is choosing a bit in the binary 
/// representation of x and flipping it from either 0 to 1 or 1 to 0.
///
/// For example, for x = 7, the binary representation is 111 and we 
/// may choose any bit (including any leading zeros not shown) and 
/// flip it. We can flip the first bit from the right to get 110, flip 
/// the second bit from the right to get 101, flip the fifth bit from 
/// the right (a leading zero) to get 10111, etc.
/// Given two integers start and goal, return the minimum number of 
/// bit flips to convert start to goal.
/// 
/// Example 1:
/// Input: start = 10, goal = 7
/// Output: 3
/// Explanation: The binary representation of 10 and 7 are 1010 and 0111 
/// respectively. We can convert 10 to 7 in 3 steps:
/// - Flip the first bit from the right: 1010 -> 1011.
/// - Flip the third bit from the right: 1011 -> 1111.
/// - Flip the fourth bit from the right: 1111 -> 0111.
/// It can be shown we cannot convert 10 to 7 in less than 3 steps. 
/// Hence, we return 3.
///
/// Example 2:
/// Input: start = 3, goal = 4
/// Output: 3
/// Explanation: The binary representation of 3 and 4 are 011 and 100 
/// respectively. We can convert 3 to 4 in 3 steps:
/// - Flip the first bit from the right: 011 -> 010.
/// - Flip the second bit from the right: 010 -> 000.
/// - Flip the third bit from the right: 000 -> 100.
/// It can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, 
/// we return 3.
/// 
/// Constraints:
/// 1. 0 <= start, goal <= 10^9
/// </summary>
int LeetCodeBit::minBitFlips(int start, int goal)
{
    int result = 0;
    while (start != 0 || goal != 0)
    {
        result += (start % 2) ^ (goal % 2);
        start /= 2;
        goal /= 2;
    }
    return result;
}

/// <summary>
/// Leet Code 2275. Largest Combination With Bitwise AND Greater Than Zero
///                                                           
/// Medium
/// 
/// The bitwise AND of an array nums is the bitwise AND of all integers in 
/// nums.
///
/// For example, for nums = [1, 5, 3], the bitwise AND is equal 
/// to 1 & 5 & 3 = 1.
/// Also, for nums = [7], the bitwise AND is 7.
/// You are given an array of positive integers candidates. Evaluate the 
/// bitwise AND of every combination of numbers of candidates. Each 
/// number in candidates may only be used once in each combination.
///
/// Return the size of the largest combination of candidates with a 
/// bitwise AND greater than 0.
/// 
/// Example 1:
/// Input: candidates = [16,17,71,62,12,24,14]
/// Output: 4
/// Explanation: The combination [16,17,62,24] has a bitwise AND 
/// of 16 & 17 & 62 & 24 = 16 > 0.
/// The size of the combination is 4.
/// It can be shown that no combination with a size greater than 4 has a 
/// bitwise AND greater than 0.
/// Note that more than one combination may have the largest size.
/// For example, the combination [62,12,24,14] has a bitwise AND 
/// of 62 & 12 & 24 & 14 = 8 > 0.
///
/// Example 2:
/// Input: candidates = [8,8]
/// Output: 2
/// Explanation: The largest combination [8,8] has a bitwise AND 
/// of 8 & 8 = 8 > 0.
/// The size of the combination is 2, so we return 2.
/// 
/// Constraints:
/// 1. 1 <= candidates.length <= 10^5
/// 2. 1 <= candidates[i] <= 10^7
/// </summary>
int LeetCodeBit::largestCombination(vector<int>& candidates)
{
    int result = 0;
    for (int i = 0; i < 32; i++)
    {
        int bit = 1 << i;
        int count = 0;
        for (size_t j = 0; j < candidates.size(); j++)
        {
            if ((candidates[j] & bit) != 0)
            {
                count++;
            }
        }
        result = max(result, count);
    }
    return result;
}

/// <summary>
/// Leet Code 2317. Maximum XOR After Operations
///                                                           
/// Medium
///
/// You are given a 0-indexed integer array nums. In one operation, select 
/// any non-negative integer x and an index i, then update nums[i] to be 
/// equal to nums[i] AND (nums[i] XOR x).
///
/// Note that AND is the bitwise AND operation and XOR is the bitwise XOR 
/// operation.
///
/// Return the maximum possible bitwise XOR of all elements of nums after 
/// applying the operation any number of times.
///
/// Example 1:
/// Input: nums = [3,2,4,6]
/// Output: 7
/// Explanation: Apply the operation with x = 4 and i = 3, num[3] = 6 
/// AND (6 XOR 4) = 6 AND 2 = 2.
/// Now, nums = [3, 2, 4, 2] and the bitwise XOR of all the elements = 3 
/// XOR 2 XOR 4 XOR 2 = 7.
/// It can be shown that 7 is the maximum possible bitwise XOR.
/// Note that other operations may be used to achieve a bitwise XOR of 7.
///
/// Example 2:
/// Input: nums = [1,2,3,9,2]
/// Output: 11
/// Explanation: Apply the operation zero times.
/// The bitwise XOR of all the elements = 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11.
/// It can be shown that 11 is the maximum possible bitwise XOR.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 10^8
/// </summary>
int LeetCodeBit::maximumXOR(vector<int>& nums)
{
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        result = result | nums[i];
    }
    return result;
}

/// <summary>
/// Leet Code 2354. Number of Excellent Pairs
///                                                  
/// Hard
///
/// You are given a 0-indexed positive integer array nums and a positive 
/// integer k.
///
/// A pair of numbers (num1, num2) is called excellent if the following 
/// conditions are satisfied:
///
/// Both the numbers num1 and num2 exist in the array nums.
/// The sum of the number of set bits in num1 OR num2 and num1 AND num2 
/// is greater than or equal to k, where OR is the bitwise OR operation 
/// and AND is the bitwise AND operation.
/// Return the number of distinct excellent pairs.
///
/// Two pairs (a, b) and (c, d) are considered distinct if either a != c 
/// or b != d. For example, (1, 2) and (2, 1) are distinct.
///
/// Note that a pair (num1, num2) such that num1 == num2 can also be 
/// excellent if you have at least one occurrence of num1 in the array.
///
/// Example 1:
/// Input: nums = [1,2,3,1], k = 3
/// Output: 5
/// Explanation: The excellent pairs are the following:
/// - (3, 3). (3 AND 3) and (3 OR 3) are both equal to (11) in binary. 
///   The total number of set bits is 2 + 2 = 4, which is greater than 
///   or equal to k = 3.
/// - (2, 3) and (3, 2). (2 AND 3) is equal to (10) in binary, and 
///   (2 OR 3) is equal to (11) in binary. The total number of set bits 
///   is 1 + 2 = 3.
/// - (1, 3) and (3, 1). (1 AND 3) is equal to (01) in binary, and 
///   (1 OR 3) is equal to (11) in binary. The total number of set bits 
///   is 1 + 2 = 3.
/// So the number of excellent pairs is 5.
///
/// Example 2:
/// Input: nums = [5,1,1], k = 10
/// Output: 0
/// Explanation: There are no excellent pairs for this array.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^9
/// 3. 1 <= k <= 60
/// </summary>
long long LeetCodeBit::countExcellentPairs(vector<int>& nums, int k)
{
    unordered_map<int, int> bit_map;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (bit_map.count(nums[i]) > 0)
        {
            continue;
        }
        int num = nums[i];
        int bits = 0;
        while (num != 0)
        {
            if (num % 2 == 1) bits++;
            num /= 2;
        }
        bit_map[nums[i]] = bits;
    }
    vector<pair<int, int>> num_bits;
    for (auto itr : bit_map)
    {
        num_bits.push_back(make_pair(itr.second, itr.first));
    }
    sort(num_bits.begin(), num_bits.end());
    int left = 0, right = num_bits.size() - 1;
    long long result = 0;
    while (left <= right)
    {
        if (num_bits[left].first + num_bits[right].first >= k)
        {
            result += 2 * ((long long)right - (long long)left) + 1;
            right--;
        }
        else
        {
            left++;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2425. Bitwise XOR of All Pairings
///                                                  
/// Medium
///
/// You are given two 0-indexed arrays, nums1 and nums2, consisting of 
/// non-negative integers. There exists another array, nums3, which 
/// contains the bitwise XOR of all pairings of integers between nums1 
/// and nums2 (every integer in nums1 is paired with every integer in 
/// nums2 exactly once).
///
/// Return the bitwise XOR of all integers in nums3.
/// Example 1:
/// Input: nums1 = [2,1,3], nums2 = [10,2,5,0]
/// Output: 13
/// Explanation:
/// A possible nums3 array is [8,0,7,2,11,3,4,1,9,1,6,3].
/// The bitwise XOR of all these numbers is 13, so we return 13.
///
/// Example 2:
/// Input: nums1 = [1,2], nums2 = [3,4]
/// Output: 0
/// Explanation:
/// All possible pairs of bitwise XORs are nums1[0] ^ nums2[0], 
/// nums1[0] ^ nums2[1], nums1[1] ^ nums2[0],
/// and nums1[1] ^ nums2[1].
/// Thus, one possible nums3 array is [2,5,1,6].
/// 2 ^ 5 ^ 1 ^ 6 = 0, so we return 0.
/// 
/// Constraints:
/// 1. 1 <= nums1.length, nums2.length <= 10^5
/// 2. 0 <= nums1[i], nums2[j] <= 10^9
/// </summary>
int LeetCodeBit::xorAllNums(vector<int>& nums1, vector<int>& nums2)
{
    int xor1 = 0, count1 = 0, xor2 = 0, count2 = 0;
    for (size_t i = 0; i < nums1.size(); i++)
    {
        xor1 = xor1 ^ nums1[i];
        count1++;
    }
    for (size_t i = 0; i < nums2.size(); i++)
    {
        xor2 = xor2 ^ nums2[i];
        count2++;
    }
    if (count1 % 2 == 0) xor2 = 0;
    if (count2 % 2 == 0) xor1 = 0;
    return xor1 ^ xor2;
}

/// <summary>
/// Leet Code 2429. Minimize XOR
///                                                  
/// Medium
///
/// Given two positive integers num1 and num2, find the integer x such 
/// that:
///
/// x has the same number of set bits as num2, and
/// The value x XOR num1 is minimal.
/// Note that XOR is the bitwise XOR operation.
///
/// Return the integer x. The test cases are generated such that x 
/// is uniquely determined.
///
/// The number of set bits of an integer is the number of 1's in its 
/// binary representation.
/// 
/// Example 1:
/// Input: num1 = 3, num2 = 5
/// Output: 3
/// Explanation:
/// The binary representations of num1 and num2 are 0011 and 0101, 
/// respectively.
/// The integer 3 has the same number of set bits as num2, and the value 3 
/// XOR 3 = 0 is minimal.
///
/// Example 2:
/// Input: num1 = 1, num2 = 12
/// Output: 3
/// Explanation:
/// The binary representations of num1 and num2 are 0001 and 1100, 
/// respectively.
/// The integer 3 has the same number of set bits as num2, and the value 3 
/// XOR 1 = 2 is minimal.
/// 
/// Constraints:
///
/// 1. 1 <= num1, num2 <= 10^9
/// </summary>
int LeetCodeBit::minimizeXor(int num1, int num2)
{
    int count = 0;
    while (num2 > 0)
    {
        if (num2 % 2 == 1) count++;
        num2 /= 2;
    }
    vector<int> bits;
    while (num1 > 0)
    {
        bits.push_back(num1 % 2);
        num1 /= 2;
    }
    for (int i = bits.size() - 1; i >= 0; i--)
    {
        if (bits[i] == 1)
        {
            if (count > 0) count--;
            else bits[i] = 0;
        }
    }
    for (size_t i = 0; i < bits.size() && count > 0; i++)
    {
        if (bits[i] == 0)
        {
            bits[i] = 1;
            count--;
        }
    }
    for (int i = 0; i < count; i++)
    {
        bits.push_back(1);
    }
    int result = 0;
    for (size_t i = 0; i < bits.size(); i++)
    {
        result = result | (bits[i] << i);
    }
    return result;
}

/// <summary>
/// Leet Code 2433. Find The Original Array of Prefix Xor
///                                                  
/// Medium
///
/// You are given an integer array pref of size n. Find and return the 
/// array arr of size n that satisfies:
///
/// pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].
/// Note that ^ denotes the bitwise-xor operation.
///
/// It can be proven that the answer is unique.
/// 
/// Example 1:
/// Input: pref = [5,2,0,3,1]
/// Output: [5,7,2,3,2]
/// Explanation: From the array [5,7,2,3,2] we have the following:
/// - pref[0] = 5.
/// - pref[1] = 5 ^ 7 = 2.
/// - pref[2] = 5 ^ 7 ^ 2 = 0.
/// - pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.
/// - pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.
///
/// Example 2:
/// Input: pref = [13]
/// Output: [13]
/// Explanation: We have pref[0] = arr[0] = 13.
/// 
/// Constraints:
/// 1. 1 <= pref.length <= 10^5
/// 2. 0 <= pref[i] <= 10^6
/// </summary>
vector<int> LeetCodeBit::findArray(vector<int>& pref)
{
    vector<int> result(pref.size());
    for (size_t i = 0; i < pref.size(); i++)
    {
        if (i == 0) result[i] = pref[i];
        else
        {
            result[i] = pref[i - 1] ^ pref[i];
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2479. Maximum XOR of Two Non-Overlapping Subtrees
/// </summary>
long long LeetCodeBit::maxXorSum(int node, vector<vector<int>>& neighbors,
    vector<int>& values, vector<int>& visited, vector<long long>& sums)
{
    long long sum = values[node];
    visited[node] = 1;
    for (size_t i = 0; i < neighbors[node].size(); i++)
    {
        int child = neighbors[node][i];
        if (visited[child] == 1)
        {
            continue;
        }
        sum += maxXorSum(child, neighbors, values, visited, sums);
    }
    sums[node] = sum;
    return sum;
}

/// <summary>
/// Leet Code 2479. Maximum XOR of Two Non-Overlapping Subtrees
/// </summary>
void LeetCodeBit::maxXorFind(int node, vector<vector<int>>& neighbors,
    vector<int>& visited, vector<long long>& sums, TrieBitNode* trie, 
    long long& result)
{
    long long sum = sums[node];
    visited[node] = 1;
    result = max(result, trie->findMax(sum));
    for (size_t i = 0; i < neighbors[node].size(); i++)
    {
        int child = neighbors[node][i];
        if (visited[child] == 1)
        {
            continue;
        }
        maxXorFind(child, neighbors, visited, sums, trie, result);
    }
    trie->increase(sum, 1);
}

/// <summary>
/// Leet Code 2479. Maximum XOR of Two Non-Overlapping Subtrees
/// 
/// Hard
///	
/// There is an undirected tree with n nodes labeled from 0 to n - 1. 
/// You are given the integer n and a 2D integer array edges of length 
/// n - 1, where edges[i] = [ai, bi] indicates that there is an edge 
/// between nodes ai and bi in the tree. The root of the tree is the node 
/// labeled 0.
///
/// Each node has an associated value. You are given an array values of 
/// length n, where values[i] is the value of the ith node.
///
/// Select any two non-overlapping subtrees. Your score is the bitwise 
/// XOR of the sum of the values within those subtrees.
///
/// Return the maximum possible score you can achieve. If it is impossible 
/// to find two nonoverlapping subtrees, return 0.
///
/// Note that:
/// 1. The subtree of a node is the tree consisting of that node and all 
///    of its descendants.
/// 2. Two subtrees are non-overlapping if they do not share any common 
///    node.
/// 
/// Example 1:
/// 1. Input: n = 6, edges = [[0,1],[0,2],[1,3],[1,4],[2,5]], 
///    values = [2,8,3,6,2,5] 
/// Output: 24
/// Explanation: Node 1's subtree has sum of values 16, while node 2's 
/// subtree has sum of values 8, so choosing these nodes will yield a 
/// score of 16 XOR 8 = 24. It can be proved that is the maximum possible 
/// score we can obtain.
///
/// Example 2:
/// Input: n = 3, edges = [[0,1],[1,2]], values = [4,6,1]
/// Output: 0
/// Explanation: There is no possible way to select two non-overlapping 
/// subtrees, so we just return 0.
/// 
/// Constraints:
/// 1. 2 <= n <= 5 * 10^4
/// 2. edges.length == n - 1
/// 3. 0 <= ai, bi < n
/// 4. values.length == n
/// 5. 1 <= values[i] <= 10^9
/// 6. It is guaranteed that edges represents a valid tree.
/// </summary>
long long LeetCodeBit::maxXor(int n, vector<vector<int>>& edges, vector<int>& values)
{
    vector<vector<int>> neighbors(n);
    for (size_t i = 0; i < edges.size(); i++)
    {
        neighbors[edges[i][0]].push_back(edges[i][1]);
        neighbors[edges[i][1]].push_back(edges[i][0]);
    }
    vector<long long> sums(n);
    vector<int> visited(n);
    maxXorSum(0, neighbors, values, visited, sums);
    visited = vector<int>(n);
    TrieBitNode* trie = new TrieBitNode(63);
    long long result = 0;
    maxXorFind(0, neighbors, visited, sums, trie, result);
    return result;
}

/// <summary>
/// Leet Code 2505. Bitwise OR of All Subsequence Sums
/// 
/// Medium
///	
/// Given an integer array nums, return the value of the bitwise OR of 
/// the sum of all possible subsequences in the array.
///
/// A subsequence is a sequence that can be derived from another 
/// sequence by removing zero or more elements without changing the 
/// order of the remaining elements.
///
/// Example 1:
/// Input: nums = [2,1,0,3]
/// Output: 7
/// Explanation: All possible subsequence sums that we can have 
/// are: 0, 1, 2, 3, 4, 5, 6.
/// And we have 0 OR 1 OR 2 OR 3 OR 4 OR 5 OR 6 = 7, so we return 7.
///
/// Example 2:
/// Input: nums = [0,0,0]
/// Output: 0
/// Explanation: 0 is the only possible subsequence sum we can have, 
/// so we return 0.
///
/// Constraints:
/// 
/// 1. 1 <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 10^9
/// </summary>
long long LeetCodeBit::subsequenceSumOr(vector<int>& nums)
{
    long long result = 0;
    long long sum = 0;
    for (int i = 0; i < 64; i++)
    {
        if (i < 32)
        {
            for (size_t j = 0; j < nums.size(); j++)
            {
                long long num = nums[j];
                if ((num & (((long long)1) << i)) != 0)
                {
                    sum++;
                }
            }
        }
        if (sum > 0) result = result | (((long long)1) << i);
        sum /= 2;
    }
    return result;
}

/// <summary>
/// Leet Code 2527. Find Xor-Beauty of Array
/// 
/// Medium
///	
/// You are given a 0-indexed integer array nums.
///
/// The effective value of three indices i, j, and k is defined as 
/// ((nums[i] | nums[j]) & nums[k]).
///
/// The xor-beauty of the array is the XORing of the effective values of 
/// all the possible triplets of indices (i, j, k) where 0 <= i, j, k < n.
///
/// Return the xor-beauty of nums.
///
/// Note that:
/// val1 | val2 is bitwise OR of val1 and val2.
/// val1 & val2 is bitwise AND of val1 and val2.
/// 
/// Example 1:
/// Input: nums = [1,4]
/// Output: 5
/// Explanation: 
/// The triplets and their corresponding effective values are listed below:
/// - (0,0,0) with effective value ((1 | 1) & 1) = 1
/// - (0,0,1) with effective value ((1 | 1) & 4) = 0
/// - (0,1,0) with effective value ((1 | 4) & 1) = 1
/// - (0,1,1) with effective value ((1 | 4) & 4) = 4
/// - (1,0,0) with effective value ((4 | 1) & 1) = 1
/// - (1,0,1) with effective value ((4 | 1) & 4) = 4
/// - (1,1,0) with effective value ((4 | 4) & 1) = 0
/// - (1,1,1) with effective value ((4 | 4) & 4) = 4 
/// Xor-beauty of array will be bitwise XOR of all beauties 
/// = 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5.
///
/// Example 2:
/// Input: nums = [15,45,20,2,34,35,5,44,32,30]
/// Output: 34
/// Explanation: The xor-beauty of the given array is 34.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^9
/// </summary>
int LeetCodeBit::xorBeauty(vector<int>& nums)
{
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        result = result ^ nums[i];
    }
    return result;
}

/// <summary>
/// Leet Code 2546. Apply Bitwise Operations to Make Strings Equal
/// 
/// Medium
///	
/// You are given two 0-indexed binary strings s and target of the same 
/// length n. You can do the following operation on s any number of times:
///
/// Choose two different indices i and j where 0 <= i, j < n.
/// Simultaneously, replace s[i] with (s[i] OR s[j]) and s[j] with (s[i] 
/// XOR s[j]).
/// For example, if s = "0110", you can choose i = 0 and j = 2, then 
/// simultaneously replace s[0] with (s[0] OR s[2] = 0 OR 1 = 1), and 
/// s[2] with (s[0] XOR s[2] = 0 XOR 1 = 1), so we will have s = "1110".
///
/// Return true if you can make the string s equal to target, or false 
/// otherwise.
/// 
/// Example 1:
/// Input: s = "1010", target = "0110"
/// Output: true
/// Explanation: We can do the following operations:
/// - Choose i = 2 and j = 0. We have now s = "0010".
/// - Choose i = 2 and j = 1. We have now s = "0110".
/// Since we can make s equal to target, we return true.
///
/// Example 2:
/// Input: s = "11", target = "00"
/// Output: false
/// Explanation: It is not possible to make s equal to target with any 
/// number of operations.
///
/// Constraints:
/// 1. n == s.length == target.length
/// 2. 2 <= n <= 10^5
/// 3. s and target consist of only the digits 0 and 1.
/// </summary>
bool LeetCodeBit::makeStringsEqual(string s, string target)
{
    if (s == target) return true;
    unordered_set<string> bit_set;
    for (size_t i = 0; i < s.size(); i++)
    {
        string str;
        str.push_back(s[i]);
        str.push_back(target[i]);
        bit_set.insert(str);
        if (bit_set.count("11") > 0) return true;
        if (bit_set.count("01") && bit_set.count("10") > 0)
        {
            return true;
        }
    }
    return false;
}

/// <summary>
/// Leet Code 2564. Substring XOR Queries
/// 
/// Medium
///	
/// You are given a binary string s, and a 2D integer array queries where 
/// queries[i] = [firsti, secondi].
///
/// For the ith query, find the shortest substring of s whose decimal 
/// value, val, yields secondi when bitwise XORed with firsti. In other 
/// words, val ^ firsti == secondi.
///
/// The answer to the ith query is the endpoints (0-indexed) of the 
/// substring [lefti, righti] or [-1, -1] if no such substring exists. 
/// If there are multiple answers, choose the one with the minimum lefti.
///
/// Return an array ans where ans[i] = [lefti, righti] is the answer to 
/// the ith query.
///
/// A substring is a contiguous non-empty sequence of characters within 
/// a string.
/// 
/// Example 1:
/// Input: s = "101101", queries = [[0,5],[1,2]]
/// Output: [[0,2],[2,3]]
/// Explanation: For the first query the substring in range [0,2] is "101" 
/// which has a decimal value of 5, and 5 ^ 0 = 5, hence the answer to the 
/// first query is [0,2]. In the second query, the substring in 
/// range [2,3] is "11", and has a decimal value of 3, and 3 ^ 1 = 2. 
/// So, [2,3] is returned for the second query. 
///
/// Example 2:
/// Input: s = "0101", queries = [[12,8]]
/// Output: [[-1,-1]]
/// Explanation: In this example there is no substring that answers 
/// the query, hence [-1,-1] is returned.
///
/// Example 3:
/// Input: s = "1", queries = [[4,5]]
/// Output: [[0,0]]
/// Explanation: For this example, the substring in range [0,0] has a 
/// decimal value of 1, and 1 ^ 4 = 5. So, the answer is [0,0].
/// 
/// Constraints:
/// 1. 1 <= s.length <= 10^4
/// 2. s[i] is either '0' or '1'.
/// 3. 1 <= queries.length <= 10^5
/// 4. 0 <= firsti, secondi <= 10^9
/// </summary>
vector<vector<int>> LeetCodeBit::substringXorQueries(string s, vector<vector<int>>& queries)
{
    vector<vector<int>> result(queries.size(), { -1, -1 });
    unordered_map<int, vector<int>> num_map;
    for (size_t i = 0; i < queries.size(); i++)
    {
        int val = queries[i][0] ^ queries[i][1];
        num_map[val].push_back(i);
    }
    for (int i = 0; i < 31; i++)
    {
        int val = 0;
        for (int j = 0; j + i < (int)s.size(); j++)
        {
            int val = 0;
            for (int k = 0; k <= i; k++)
            {
                val *= 2;
                val = val + s[j + k] - '0';
            }
            if (num_map.count(val) > 0)
            {
                for (size_t k = 0; k < num_map[val].size(); k++)
                {
                    result[num_map[val][k]] = { j, i + j };
                }
                num_map.erase(val);
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2568. Minimum Impossible OR
/// 
/// Medium
///	
/// You are given a 0-indexed integer array nums.
///
/// We say that an integer x is expressible from nums if there exist 
/// some integers 0 <= index1 < index2 < ... < indexk < nums.length 
/// for which nums[index1] | nums[index2] | ... | nums[indexk] = x. 
/// In other words, an integer is expressible if it can be written as 
/// the bitwise OR of some subsequence of nums.
///
/// Return the minimum positive non-zero integer that is not 
/// expressible from nums.
/// 
/// Example 1:
/// Input: nums = [2,1]
/// Output: 4
/// Explanation: 1 and 2 are already present in the array. We know 
/// that 3 is expressible, since nums[0] | nums[1] = 2 | 1 = 3. 
/// Since 4 is not expressible, we return 4.
///
/// Example 2:
/// Input: nums = [5,3,2]
/// Output: 1
/// Explanation: We can show that 1 is the smallest number that is not 
/// expressible.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^9
/// </summary>
int LeetCodeBit::minImpossibleOR(vector<int>& nums)
{
    unordered_set<int> num_set;
    for (size_t i = 0; i < nums.size(); i++)
    {
        num_set.insert(nums[i]);
    }
    int result = 1;
    for (int i = 0; i < 31; i++)
    {
        if (num_set.count(result) == 0) return result;
        result <<= 1;
    }
    return result;
}

/// <summary>
/// Leet Code 2571. Minimum Operations to Reduce an Integer to 0
/// 
/// Medium
///	
/// You are given a positive integer n, you can do the following operation 
/// any number of times:
///
/// Add or subtract a power of 2 from n.
/// Return the minimum number of operations to make n equal to 0.
///
/// A number x is power of 2 if x == 2^i where i >= 0.
/// 
/// Example 1:
/// Input: n = 39
/// Output: 3
/// Explanation: We can do the following operations:
/// - Add 2^0 = 1 to n, so now n = 40.
/// - Subtract 2^3 = 8 from n, so now n = 32.
/// - Subtract 2^5 = 32 from n, so now n = 0.
/// It can be shown that 3 is the minimum number of operations we need 
/// to make n equal to 0.
///
/// Example 2:
/// Input: n = 54
/// Output: 3
/// Explanation: We can do the following operations:
/// - Add 2^1 = 2 to n, so now n = 56.
/// - Add 2^3 = 8 to n, so now n = 64.
/// - Subtract 2^6 = 64 from n, so now n = 0.
/// So the minimum number of operations is 3.
///
/// Constraints:
/// 1. 1 <= n <= 10^5
/// </summary>
int LeetCodeBit::minOperations(int n)
{
    int result = 0, count = 0;
    while (n > 0)
    {
        int bit = n % 2;
        n /= 2;
        if (bit == 1) count++;
        else
        {
            if (count > 1)
            {
                result++;
                count = 1;
            }
            else if (count == 1)
            {
                result++;
                count = 0;
            }
        }
    }
    if (count > 1) result += 2;
    else if (count == 1) result++;
    return result;
}

/// <summary>
/// Leet Code 2569. Handling Sum Queries After Update
/// 
/// Hard
///	
/// You are given two 0-indexed arrays nums1 and nums2 and a 2D array 
/// queries of queries. There are three types of queries:
///
/// For a query of type 1, queries[i] = [1, l, r]. Flip the values 
/// from 0 to 1 and from 1 to 0 in nums1 from index l to index r. 
/// Both l and r are 0-indexed.
/// For a query of type 2, queries[i] = [2, p, 0]. For every 
/// index 0 <= i < n, set nums2[i] = nums2[i] + nums1[i] * p.
/// For a query of type 3, queries[i] = [3, 0, 0]. Find the sum of the 
/// elements in nums2.
/// Return an array containing all the answers to the third type queries.
///
/// Example 1:
/// Input: nums1 = [1,0,1], nums2 = [0,0,0], 
/// queries = [[1,1,1],[2,1,0],[3,0,0]]
/// Output: [3]
/// Explanation: After the first query nums1 becomes [1,1,1]. After the 
/// second query, nums2 becomes [1,1,1], so the answer to the third 
/// query is 3. Thus, [3] is returned.
///
/// Example 2:
/// Input: nums1 = [1], nums2 = [5], queries = [[2,0,0],[3,0,0]]
/// Output: [5]
/// Explanation: After the first query, nums2 remains [5], so 
/// the answer to the second query is 5. Thus, [5] is returned.
///
/// Constraints:
/// 1. 1 <= nums1.length,nums2.length <= 10^5
/// 2. nums1.length = nums2.length
/// 3. 1 <= queries.length <= 10^5
/// </summary>
vector<long long> LeetCodeBit::handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries)
{
    vector<long long> result;
    size_t n = nums1.size();
    #define N 10005
    std::bitset<N> bit_set;
    std::bitset<N> full_bits(0);
    full_bits.flip();

    long long sum = 0;
    for (size_t i = 0; i < nums1.size(); i++)
    {
        if (nums1[i] == 1) bit_set.set(i);
        sum += (long long)nums2[i];
    }
    for (size_t i = 0; i < queries.size(); i++)
    {
        vector<int> q = queries[i];
        if (q[0] == 1)
        {
            int sz = q[2] - q[1] + 1;
            std::bitset<N> mask(full_bits << sz);
            mask = ~mask;
            mask <<= q[1];
            bit_set ^= mask;
        }
        else if (q[0] == 2)
        {
            sum += (long long)q[1] * (long long)bit_set.count();
        }
        else
        {
            result.push_back(sum);
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2683. Neighboring Bitwise XOR
/// 
/// Medium
///	
/// A 0-indexed array derived with length n is derived by computing the 
/// bitwise XOR (^) of adjacent values in a binary array original of 
/// length n.
///
/// Specifically, for each index i in the range [0, n - 1]:
///
/// If i = n - 1, then derived[i] = original[i] xor original[0].
/// Otherwise, derived[i] = original[i] xor original[i + 1].
/// Given an array derived, your task is to determine whether there exists 
/// a valid binary array original that could have formed derived.
///
/// Return true if such an array exists or false otherwise.
///
/// A binary array is an array containing only 0's and 1's
/// 
/// Example 1:
/// Input: derived = [1,1,0]
/// Output: true
/// Explanation: A valid original array that gives derived is [0,1,0].
/// derived[0] = original[0] xor original[1] = 0 xor 1 = 1 
/// derived[1] = original[1] xor original[2] = 1 xor 0 = 1
/// derived[2] = original[2] xor original[0] = 0 xor 0 = 0
///
/// Example 2:
/// Input: derived = [1,1]
/// Output: true
/// Explanation: A valid original array that gives derived is [0,1].
/// derived[0] = original[0] xor original[1] = 1
/// derived[1] = original[1] xor original[0] = 1
///
/// Example 3:
/// Input: derived = [1,0]
/// Output: false
/// Explanation: There is no valid original array that gives derived.
///
/// Constraints:
/// 1. n == derived.length
/// 2. 1 <= n <= 10^5
/// 3. The values in derived are either 0's or 1's
/// </summary>
bool LeetCodeBit::doesValidArrayExist(vector<int>& derived)
{
    int n = derived.size();
    vector<int> origin(n);
    for (int i = 0; i < 2; i++)
    {
        origin[0] = i;
        for (int j = 1; j < n; j++)
        {
            origin[j] = origin[j - 1] ^ derived[j - 1];
        }
        if ((origin[0] ^ origin[n - 1]) == derived[n - 1])
        {
            return true;
        }
    }
    return false;
}

/// <summary>
/// Leet Code 2680. Maximum OR
/// 
/// Medium
///	
/// You are given a 0-indexed integer array nums of length n and an 
/// integer k. In an operation, you can choose an element and 
/// multiply it by 2.
///
/// Return the maximum possible value of nums[0] | 
/// nums[1] | ... | nums[n - 1] that can be obtained after applying 
/// the operation on nums at most k times.
///
/// Note that a | b denotes the bitwise or between two integers a 
/// and b.
///
/// Example 1:
///
/// Input: nums = [12,9], k = 1
/// Output: 30
/// Explanation: If we apply the operation to index 1, our new 
/// array nums will be equal to [12,18]. Thus, we return the bitwise or 
/// of 12 and 18, which is 30.
///
/// Example 2:
/// Input: nums = [8,1,2], k = 2
/// Output: 35
/// Explanation: If we apply the operation twice on index 0, we yield a 
/// new array of [32,1,2]. Thus, we return 32|1|2 = 35.
/// 
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^9
/// 3. 1 <= k <= 15
/// </summary>
long long LeetCodeBit::maximumOr(vector<int>& nums, int k)
{
    vector<vector<int>> num_bits(nums.size(), vector<int>(64));
    vector<int> sum(64);
    for (size_t i = 0; i < nums.size(); i++)
    {
        int num = nums[i];
        for (int j = 0; j < 64; j++)
        {
            num_bits[i][j] = num % 2;
            num /= 2;
            sum[j] += num_bits[i][j];
        }
    }
    long long max_bit = -1;
    int max_index = -1;
    for (size_t i = 0; i < nums.size(); i++)
    {
        long long bit = 0;
        for (int j = 0; j < 64; j++)
        {
            int v = sum[j] - num_bits[i][j];
            if (j >= k)
            {
                v = v + num_bits[i][j-k];
            }
            if (v > 0)
            {
                bit |= (long long)1 << j;
            }
        }
        if (bit > max_bit)
        {
            max_bit = bit;
            max_index = i;
        }
    }
    long long result = max_bit;
    return result;
}

/// <summary>
/// Leet Code 2732. Find a Good Subset of the Matrix
/// 
/// Hard
///
/// You are given a 0-indexed m x n binary matrix grid.
///
/// Let us call a non-empty subset of rows good if the sum of each column 
/// of the subset is at most half of the length of the subset.
///
/// More formally, if the length of the chosen subset of rows is k, then 
/// the sum of each column should be at most floor(k / 2).
///
/// Return an integer array that contains row indices of a good subset 
/// sorted in ascending order.
///
/// If there are multiple good subsets, you can return any of them. If 
/// there are no good subsets, return an empty array.
///
/// A subset of rows of the matrix grid is any matrix that can be obtained 
/// by deleting some (possibly none or all) rows from grid.
///
/// Example 1:
/// Input: grid = [[0,1,1,0],[0,0,0,1],[1,1,1,1]]
/// Output: [0,1]
/// Explanation: We can choose the 0th and 1st rows to create a good 
/// subset of rows.
/// The length of the chosen subset is 2.
/// - The sum of the 0th column is 0 + 0 = 0, which is at most half of the 
///   length of the subset.
/// - The sum of the 1st column is 1 + 0 = 1, which is at most half of the 
///   length of the subset.
/// - The sum of the 2nd column is 1 + 0 = 1, which is at most half of the 
///   length of the subset.
/// - The sum of the 3rd column is 0 + 1 = 1, which is at most half of the 
///   length of the subset.
///
/// Example 2:
/// Input: grid = [[0]]
/// Output: [0]
/// Explanation: We can choose the 0th row to create a good subset of rows.
/// The length of the chosen subset is 1.
/// - The sum of the 0th column is 0, which is at most half of the length 
///   of the subset.
///
/// Example 3:
/// Input: grid = [[1,1,1],[1,1,1]]
/// Output: []
/// Explanation: It is impossible to choose any subset of rows to create 
/// a good subset.
///
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 1 <= m <= 10^4
/// 4. 1 <= n <= 5
/// 5. grid[i][j] is either 0 or 1.
/// </summary>
vector<int> LeetCodeBit::goodSubsetofBinaryMatrix(vector<vector<int>>& grid)
{
    vector<int> result;
    vector<int> visited(32, -1);
    for (size_t i = 0; i < grid.size(); i++)
    {
        int bits = 0;
        for (size_t j = 0; j < grid[i].size(); j++)
        {
            if (grid[i][j] == 1) bits |= (1 << j);
        }
        if (bits == 0)
        {
            result.push_back(i);
            return result;
        }
        for (int j = 0; j < 32; j++)
        {
            if (visited[j] == -1) continue;
            if ((j & bits) == 0)
            {
                result.push_back(visited[j]);
                result.push_back(i);
                return result;
            }
        }
        visited[bits] = i;
    }
    return result;
}

/// <summary>
/// Leet Code 2859. Sum of Values at Indices With K Set Bits
/// 
/// Easy
///
/// You are given a 0-indexed integer array nums and an integer k.
///
/// Return an integer that denotes the sum of elements in nums whose 
/// corresponding indices have exactly k set bits in their binary 
/// representation.
///
/// The set bits in an integer are the 1's present when it is written 
/// in binary.
///
/// For example, the binary representation of 21 is 10101, which has 3 
/// set bits.
///
///
/// Example 1:
/// Input: nums = [5,10,1,5,2], k = 1
/// Output: 13
/// Explanation: The binary representation of the indices are: 
/// 0 = 000
/// 1 = 001
/// 2 = 010
/// 3 = 011
/// 4 = 100
/// Indices 1, 2, and 4 have k = 1 set bits in their binary representation.
/// Hence, the answer is nums[1] + nums[2] + nums[4] = 13.
///
/// Example 2:
/// Input: nums = [4,3,2,1], k = 2
 /// Output: 1
/// Explanation: The binary representation of the indices are:
/// 0 = 00
/// 1 = 01
/// 2 = 10
/// 3 = 11
/// Only index 3 has k = 2 set bits in its binary representation.
/// Hence, the answer is nums[3] = 1.
///
/// Constraints:
/// 1. 1 <= nums.length <= 1000
/// 2. 1 <= nums[i] <= 10^5
/// 3. 0 <= k <= 10
/// </summary>
int LeetCodeBit::sumIndicesWithKSetBits(vector<int>& nums, int k)
{
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        int n = i;
        int count = 0;
        while (n > 0)
        {
            if (n % 2 == 1) count++;
            n /= 2;
        }
        if (count == k) result += nums[i];
    }

    return result;
}
#pragma endregion
