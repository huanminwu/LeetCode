#pragma once
#include <ctype.h>  /* is space */
#include <stdio.h>     /* printf */
#include <stdlib.h>  
#include <time.h>  
#include <functional>
#include <algorithm> 
#include <unordered_map> 
#include <unordered_set> 
#include <map> 
#include <numeric>
#include <stack>
#include <set>
#include <queue> 
#include <vector>
#include <iostream>
#include <fstream>
#include "Leetcode.h"
#include "LeetcodeBit.h"
#pragma region BitOperation
/// <summary>
/// Leet code # 371. Sum of Two Integers 
/// 
/// Calculate the sum of two integers a and b, but you are not allowed to use 
/// the operator + and -. 
/// Example: 
/// Given a = 1 and b = 2, return 3. 
/// </summary>
int LeetCodeBit::getSum(int a, int b)
{
    int sum = a;
    int carry = 0;
    while (b != 0)
    {
        sum = a ^ b;
        carry = (a & b) << 1;
        a = sum;
        b = carry;
    }
    return sum;
}

/// <summary>
/// Leet code # 191. Number of 1 Bits
/// 
/// Write a function that takes an unsigned integer and returns the number of ¡¯1' 
/// bits it has (also known as the Hamming weight). 
/// For example, the 32-bit integer ¡¯11' has binary representation 
/// 00000000000000000000000000001011, so the function should return 3. 
/// </summary>
int LeetCodeBit::hammingWeight(uint32_t n)
{
    int result = 0;
    while (n != 0)
    {
        result += n & 1;
        n = n >> 1;
    }
    return result;
}

/// <summary>
/// Leet code #338. Counting Bits    
/// Given a non negative integer number num. For every numbers i in the range 0 ¡Ü i ¡Ü num 
/// calculate the number of 1's in their binary representation and return them as an array. 
/// Example:
/// For num = 5 you should return [0,1,1,2,1,2].
/// Follow up: 
/// It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?
/// Space complexity should be O(n).
/// Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.
/// Hint:
/// 1.You should make use of what you have produced already.
/// 2.Divide the numbers in ranges like [2-3], [4-7], [8-15] and so on. And try to generate new range from previous.
/// 3.Or does the odd/even status of the number help you in calculating the number of 1s?
/// </summary>
vector<int> LeetCodeBit::countBits(int num)
{
    vector<int> result;
    result.push_back(0);
    int index = 0;
    while (index < num)
    {
        size_t size = result.size();
        for (size_t i = 0; i < size; i++)
        {
            result.push_back(1 + result[i]);
            index++;
            if (index == num) break;
        }
    }
    return result;
}

/// <summary>
/// Leet code #342. Power of Four    
/// Given an integer (signed 32 bits), write a function to check whether it is a power of 4.
/// Example:
/// Given num = 16, return true. Given num = 5, return false. 
/// Follow up: Could you solve it without loops/recursion?
/// </summary>
bool LeetCodeBit::isPowerOfFour(int num)
{
    if (num == 0) return false;
    // mask in the right bits and only one bit
    if (((num & 0x55555555) == num) && (num == (num & -num)))
    {
        return true;
    }
    else
    {
        return false;
    }
}

/// <summary>
/// Leet code #136. Single Number
/// Given an array of integers, every element appears twice except for one. Find that single one.
/// Note:
/// Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 
/// </summary>
int LeetCodeBit::singleNumber(vector<int>& nums)
{
    int number = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        number = number ^ nums[i];
    }
    return number;
}

/// <summary>
/// Leet code #389. Find the Difference 
/// Given two strings s and t which consist of only lowercase letters.
/// String t is generated by random shuffling string s and then add one more letter at a random position.
/// Find the letter that was added in t.
/// Example: 
/// Input:
/// s = "abcd"
/// t = "abcde"
/// Output:
/// e
/// Explanation:
/// 'e' is the letter that was added.    
/// </summary>
char LeetCodeBit::findTheDifference(string s, string t)
{
    int number = 0;

    for (size_t i = 0; i < s.size(); i++)
    {
        number = number ^ s[i];
    }
    for (size_t i = 0; i < t.size(); i++)
    {
        number = number ^ t[i];
    }
    return (char)number;
}

/// <summary>
/// Leet code #89. Gray Code 
/// Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. 
/// A gray code sequence must begin with 0. 
/// For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:
/// 00 - 0
/// 01 - 1
/// 11 - 3
/// 10 - 2
///
/// Note:
///   For a given n, a gray code sequence is not uniquely defined. 
/// For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.
/// For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.
/// </summary>
vector<int> LeetCodeBit::grayCode(int n)
{
    vector<int> result;
    for (size_t i = 0; i < pow(2, n); i++)
    {
        result.push_back(i ^ (i >> 1));
    }
    return result;
}

/// <summary>
/// Leet code #405. Convert a Number to Hexadecimal 
/// Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two¡¯s complement method is used.  
/// Note: 
/// 1.All letters in hexadecimal (a-f) must be in lowercase.
/// 2.The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character '0'; otherwise, 
///   the first character in the hexadecimal string will not be the zero character.
/// 3.The given number is guaranteed to fit within the range of a 32-bit signed integer.
/// 4.You must not use any method provided by the library which converts/formats the number to hex directly.
/// Example 1: 
/// Input:
/// 26
/// Output:
/// "1a"
///
/// Example 2: 
/// Input:
/// -1
/// Output:
/// "ffffffff"
/// </summary>
string LeetCodeBit::toHex(int num)
{
    string result;
    unsigned int number = num;
    if (number == 0) return "0";

    while (number != 0)
    {
        int digit = number % 16;
        if (digit < 10)
        {
            result.insert(result.begin(), ('0' + digit - 0));
        }
        else
        {
            result.insert(result.begin(), ('a' + digit - 10));
        }
        number /= 16;
    }

    return result;
}

/// <summary>
/// Leet code #137. Single Number II 
/// Given an array of integers, every element appears three times except for 
/// one. Find that single one.   
/// Note: 
/// Your algorithm should have a linear runtime complexity. Could you implement 
/// it without using extra memory? 
/// </summary>
int LeetCodeBit::singleNumberII(vector<int>& nums)
{
    unsigned int result = 0;
    vector<int> bitCount(32);

    for (size_t i = 0; i < nums.size(); i++)
    {
        unsigned int x = nums[i];
        int index = 0;
        while (x != 0)
        {
            bitCount[31 - index] += x % 2;
            x /= 2;
            index++;
        }
    }
    for (size_t i = 0; i < 32; i++)
    {
        bitCount[i] %= 3;
        result <<= 1;
        result |= bitCount[i];
    }
    return (int)result;
}

/// <summary>
/// Leet code #190. Reverse Bits 
/// Reverse bits of a given 32 bits unsigned integer.
/// For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), 
/// return 964176192 (represented in binary as 00111001011110000010100101000000).
/// Follow up:
/// If this function is called many times, how would you optimize it? 
/// </summary>
uint32_t LeetCodeBit::reverseBits(uint32_t n)
{
    vector<int> bit_vector(32);
    size_t index = 0;
    while (n != 0)
    {
        bit_vector[index] = n % 2;
        index++;
        n >>= 1;
    }
    for (size_t i = 0; i < 32; i++)
    {
        n <<= 1;
        n |= bit_vector[i];
    }
    return n;
}

/// <summary>
/// Leet code #397. Integer Replacement 
/// Given a positive integer n and you can do operations as follow: 
/// 1.If n is even, replace n with n/2.
/// 2.If n is odd, you can replace n with either n + 1 or n - 1.
/// What is the minimum number of replacements needed for n to become 1? 
/// Example 1: 
/// Input:
/// 8
/// Output:
/// 3
/// Explanation:
/// 8 -> 4 -> 2 -> 1
///
/// Example 2: 
/// Input:
/// 7
/// Output:
/// 4
/// Explanation:
/// 7 -> 8 -> 4 -> 2 -> 1
/// or
/// 7 -> 6 -> 3 -> 2 -> 1
/// </summary>
int LeetCodeBit::integerReplacement(int n)
{
    if (n == INT_MAX) return 32;
    int result = 0;
    while (n != 1)
    {
        if (n % 2 == 0) n /= 2;
        else if ((n % 4 == 1) || (n == 3))
        {
            n -= 1;
        }
        else if (n % 4 == 3)
        {
            n += 1;
        }
        result++;
    }
    return result;
}

/// <summary>
/// Leet code #201. Bitwise AND of Numbers Range 
/// Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.
/// For example, given the range [5, 7], you should return 4. 
/// </summary>
int LeetCodeBit::rangeBitwiseAnd(int m, int n)
{
    int mask = 0xffffffff;
    while (m != n)
    {
        mask <<= 1;
        m = m & mask;
        n = n & mask;
    }
    return m;
}


/// <summary>
/// Leet code #318. Maximum Product of Word Lengths 
/// Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where 
/// the two words do not share common letters. You may assume that each word will contain only 
/// lower case letters. If no such two words exist, return 0. 
///
/// Example 1:
/// Given ["abcw", "baz", "foo", "bar", "xtfn", "abcdef"]
/// Return 16
/// The two words can be "abcw", "xtfn". 
///
/// Example 2:
/// Given ["a", "ab", "abc", "d", "cd", "bcd", "abcd"]
/// Return 4
/// The two words can be "ab", "cd". 
///
/// Example 3:
/// Given ["a", "aa", "aaa", "aaaa"]
/// Return 0
/// No such pair of words. 
/// </summary>
int LeetCodeBit::maxProductWordLength(vector<string>& words)
{
    size_t result = 0;
    vector<int> word_code;
    for (size_t i = 0; i < words.size(); i++)
    {
        uint32_t code = 0;
        for (char c : words[i])
        {
            code |= (1 << (c - 'a'));
        }
        word_code.push_back(code);
    }
    for (size_t i = 0; i < words.size(); i++)
    {
        for (size_t j = i + 1; j < words.size(); j++)
        {
            if ((word_code[i] & word_code[j]) == 0)
            {
                result = max(result, words[i].size() * words[j].size());
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #268. Missing Number  
/// Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.
/// For example, 
/// Given nums = [0, 1, 3] return 2. 
///
/// Note:
/// Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? 
/// </summary>
int LeetCodeBit::missingNumber(vector<int>& nums)
{
    int sum = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        sum = sum ^ nums[i];
        sum = sum ^ i;
    }
    sum = sum ^ nums.size();
    return sum;
}

/// <summary>
/// Leet code #260. Single Number III 
/// Given an array of numbers nums, in which exactly two elements appear only 
/// once and all the other elements 
/// appear exactly twice. Find the two elements that appear only once. 
///
/// Given nums = [1, 2, 1, 3, 2, 5], return [3, 5]. 
/// Note:
/// 1.The order of the result is not important. So in the above example, [5, 3] 
///   is also correct.
/// 2.Your algorithm should run in linear runtime complexity. Could you implement 
///   it using only constant space complexity?
/// </summary>
vector<int> LeetCodeBit::singleNumberIII(vector<int>& nums)
{
    vector<int> result(2, 0);
    int sum = 0;
    // get the XOR for these two distinct numbers
    for (int num : nums) sum = sum ^ num;

    // get last different bit for the two numbers
    sum = sum &(-sum);

    // divide the whole list of numbers into two, one with the bit set, 
    // another unset
    for (int num : nums)
    {
        if (num & sum)
        {
            result[0] ^= num;
        }
        else
        {
            result[1] ^= num;
        }
    }
    return result;
}

/// <summary>
/// Leet code #421. Maximum XOR of Two Numbers in an Array Add to List 
/// Given a non-empty array of numbers, a0, a1, a2, ¡­ , an-1, where 0 ¡Ü ai < 231.
/// Find the maximum result of ai XOR aj, where 0 ¡Ü i, j < n. 
///
/// Could you do this in O(n) runtime? 
/// Example:
/// Input: [3, 10, 5, 25, 2, 8]
/// Output: 28
/// Explanation: The maximum result is 5 ^ 25 = 28.
/// </summary>
int LeetCodeBit::findMaximumXOR(vector<int>& nums)
{
    int result = 0;
    int mask = 0;

    for (size_t bit_index = 0; bit_index < 32; bit_index++)
    {
        int bit_value = 1 << (31 - bit_index);
        mask |= bit_value;

        unordered_set<int> bits_set;
        for (size_t i = 0; i < nums.size(); i++)
        {
            bits_set.insert(nums[i] & mask);
        }

        int temp = result | bit_value;
        for (int bits : bits_set)
        {
            if (bits_set.find(temp ^ bits) != bits_set.end())
            {
                result = temp;
                break;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #461. Hamming Distance
/// The Hamming distance between two integers is the number of positions at which the 
/// corresponding bits are different.
/// Given two integers x and y, calculate the Hamming distance.
/// Note:
/// 0 ¡Ü x, y < 231. 
/// Example: 
/// Input: x = 1, y = 4
/// Output: 2
/// Explanation:
/// 1   (0 0 0 1)
/// 4   (0 1 0 0)
/// The above arrows point to positions where the corresponding bits are different.    
/// </summary>
int LeetCodeBit::hammingDistance(int x, int y)
{
    int count = 0;
    while ((x != 0) || (y != 0))
    {
        if ((x & 1) != (y & 1))
        {
            count++;
        }
        x >>= 1;
        y >>= 1;
    }
    return count;
}

/// <summary>
/// Leet code #477. Total Hamming Distance 
/// The Hamming distance between two integers is the number of positions at 
/// which the corresponding bits are different.
/// Now your job is to find the total Hamming distance between all pairs of 
/// the given numbers. 
/// Example:
/// Input: 4, 14, 2
/// Output: 6
/// 
/// Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 
/// is 0010 (just showing the four bits relevant in this case). So the answer 
/// will be:
/// HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 
/// 2 + 2 + 2 = 6.
/// Note:
/// 1.Elements of the given array are in the range of 0  to 10^9 
/// 2.Length of the array will not exceed 10^4. 
/// </summary>
int LeetCodeBit::totalHammingDistance(vector<int>& nums)
{
    int total = 0;
    for (size_t i = 0; i < 32; i++)
    {
        unsigned int bit = 1 << i;
        unsigned int zero = 0, one = 0;
        for (size_t j = 0; j < nums.size(); j++)
        {
            if ((nums[j] & bit) == 0) zero++;
            else one++;
        }
        total += one * zero;
    }
    return total;
}

/// <summary>
/// Leet code #390. Elimination Game   
/// 
/// There is a list of sorted integers from 1 to n. Starting from left to right, 
/// remove the first number and every other number afterward until you reach the end of the list.
/// Repeat the previous step again, but this time from right to left, remove the right most 
/// number and every other number from the remaining numbers.
/// We keep repeating the steps again, alternating left to right and right to left, until a single number remains.
/// Find the last number that remains starting with a list of length n.
/// Example: 
/// Input:
/// n = 9,
/// 1 2 3 4 5 6 7 8 9
/// 2 4 6 8
/// 2 6
/// 6
///
/// Output:
/// 6
/// </summary>
int LeetCodeBit::lastRemaining(int n)
{
    unsigned int number = 1;
    unsigned int bit = 1;
    unsigned int iteration = 1;
    while (n > 1)
    {
        if (iteration % 2 == 1)
        {
            number += bit;
        }
        else
        {
            if (n % 2 == 1)
            {
                number += bit;
            }
        }
        n /= 2;
        iteration++;
        bit <<= 1;
    }
    return number;
}

/// <summary>
/// Leet code #476. Number Complement    
/// 
/// Given a positive integer, output its complement number. The complement 
/// strategy is to flip the bits of its binary representation.
/// Note:
/// 1.The given integer is guaranteed to fit within the range of a 32-bit signed integer.
/// 2.You could assume no leading zero bit in the integer¡¯s binary representation.
/// Example 1:
/// Input: 5
/// Output: 2
/// Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.
/// Example 2:
/// Input: 1
/// Output: 0
/// Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.
/// </summary>
int LeetCodeBit::findComplement(int num)
{
    int n = num;
    int bit = 0;
    while (n > 0)
    {
        bit = (bit << 1) + 1;
        n >>= 1;
    }
    return num ^ bit;
}

/// <summary>
/// Leet code #693. Binary Number with Alternating Bits
/// Given a positive integer, check whether it has alternating bits: 
/// namely, if two adjacent bits will always have different values.
///  
/// Example 1:
/// Input: 5
/// Output: True
/// Explanation:
/// The binary representation of 5 is: 101
///
/// Example 2:
/// Input: 7
/// Output: False
/// Explanation:
/// The binary representation of 7 is: 111.
///
/// Example 3:
/// Input: 11
/// Output: False
/// Explanation:
/// The binary representation of 11 is: 1011.
///
/// Example 4:
/// Input: 10
/// Output: True
/// Explanation:
/// The binary representation of 10 is: 1010.
/// </summary>
bool LeetCodeBit::hasAlternatingBits(int n)
{
    int bit = -1;
    while (n > 0)
    {
        int new_bit = n % 2;
        n /= 2;
        if (bit == new_bit)
        {
            return false;
        }
        else
        {
            bit = new_bit;
        }
    }
    return true;
}

/// <summary>
/// Leet code #762. Prime Number of Set Bits in Binary Representation    
///
/// Given two integers L and R, find the count of numbers in the range 
/// [L, R] (inclusive) having a prime number of set bits in their binary 
/// representation. 
/// (Recall that the number of set bits an integer has is the number of 1s 
/// present when written in binary. For example, 21 written in binary is 
/// 10101 which has 3 set bits. Also, 1 is not a prime.) 
///
/// Example 1:
///
/// Input: L = 6, R = 10
/// Output: 4
/// Explanation:
/// 6 -> 110 (2 set bits, 2 is prime)
/// 7 -> 111 (3 set bits, 3 is prime)
/// 9 -> 1001 (2 set bits , 2 is prime)
/// 10->1010 (2 set bits , 2 is prime)
///
/// Example 2:
///
/// Input: L = 10, R = 15
/// Output: 5
/// Explanation:
/// 10 -> 1010 (2 set bits, 2 is prime)
/// 11 -> 1011 (3 set bits, 3 is prime)
/// 12 -> 1100 (2 set bits, 2 is prime)
/// 13 -> 1101 (3 set bits, 3 is prime)
/// 14 -> 1110 (3 set bits, 3 is prime)
/// 15 -> 1111 (4 set bits, 4 is not prime)
///
/// 
/// Note:
/// 1.L, R will be integers L <= R in the range [1, 10^6].
/// 2.R - L will be at most 10000.
/// </summary>
int LeetCodeBit::countPrimeSetBits(int L, int R)
{
    int result = 0;
    unordered_set<int> prime = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };
    for (int i = L; i <= R; i++)
    {
        int bit_count = 0;
        int v = i;
        while (v != 0)
        {
            if (v % 2 == 1) bit_count++;
            v /= 2;
        }
        if (prime.count(bit_count) > 0) result++;
    }
    return result;
}

/// <summary>
/// Leet code #805. Split Array With Same Average
/// 
/// In a given integer array A, we must move every element of A to either 
/// list B or list C. (B and C initially start empty.)
///
/// Return true if and only if after such a move, it is possible that the 
/// average value of B is equal to the average value of C, and B and C are 
/// both non-empty.
///
/// Example :
/// Input: 
/// [1,2,3,4,5,6,7,8]
/// Output: true
/// Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and 
/// both of them have the average of 4.5.
/// Note:
///
/// 1. The length of A will be in the range [1, 30].
/// 2. A[i] will be in the range of [0, 10000].
/// </summary>
bool LeetCodeBit::splitArraySameAverage(vector<int>& A)
{
    int N = A.size();
    int sum = 0;
    for (int num : A) sum += num;
    vector<int> sum_map(sum + 1);
    sum_map[0] = 1;
    for (int num : A)
    {
        for (int s = sum - num; s >= 0; s--)
        {
            sum_map[s + num] |= sum_map[s] << 1;
        }
    }
    for (int i = 1; i < N; i++)
    {
        if (sum * i % N == 0 && sum_map[sum * i / N] & (1 << i))
        {
            return true;
        }
    }
    return false;
}

/// <summary>
/// Leet code #805. Split Array With Same Average
/// 
/// In a given integer array A, we must move every element of A to either 
/// list B or list C. (B and C initially start empty.)
///
/// Return true if and only if after such a move, it is possible that the 
/// average value of B is equal to the average value of C, and B and C are 
/// both non-empty.
///
/// Example :
/// Input: 
/// [1,2,3,4,5,6,7,8]
/// Output: true
/// Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and 
/// both of them have the average of 4.5.
/// Note:
///
/// 1. The length of A will be in the range [1, 30].
/// 2. A[i] will be in the range of [0, 10000].
/// </summary>
bool LeetCodeBit::splitArraySameAverageII(vector<int>& A)
{
    unordered_map<int, int> sum_map;
    int sum = 0;
    sum_map[0] = 1;
    for (int num : A)
    {
        unordered_map<int, int> next_sum = sum_map;
        for (auto itr : sum_map)
        {
            next_sum[itr.first + num] |= itr.second << 1;
        }
        sum_map = next_sum;
        sum += num;
    }

    for (size_t i = 1; i < A.size(); i++)
    {
        if ((sum * i % A.size() == 0) && (sum_map[sum* i / A.size()] & (1 << i)))
        {
            return true;
        }
    }
    return false;
}

/// <summary>
/// Leet code #868. Binary Gap
/// 
/// Given a positive integer N, find and return the longest distance 
/// between two consecutive 1's in the binary representation of N.
///
/// If there aren't two consecutive 1's, return 0.
/// 
///
/// Example 1:
///
/// Input: 22
/// Output: 2
/// Explanation: 
/// 22 in binary is 0b10110.
/// In the binary representation of 22, there are three ones, and two 
/// consecutive pairs of 1's.
/// The first consecutive pair of 1's have distance 2.
/// The second consecutive pair of 1's have distance 1.
/// The answer is the largest of these two distances, which is 2.
///
/// Example 2:
/// Input: 5
/// Output: 2
/// Explanation: 
/// 5 in binary is 0b101.
///
/// Example 3:
/// Input: 6
/// Output: 1
/// Explanation: 
/// 6 in binary is 0b110.
///
/// Example 4:
/// Input: 8
/// Output: 0
/// Explanation: 
/// 8 in binary is 0b1000.
/// There aren't any consecutive pairs of 1's in the binary representation 
/// of 8, so we return 0.
/// Note:
/// 1 <= N <= 10^9
/// </summary>
int LeetCodeBit::binaryGap(int N)
{
    int result = 0;
    int last = -1;
    for (int i = 0; (i < 32) && (N != 0); i++)
    {
        if (N % 2 == 1)
        {
            if (last != -1) result = max(result, i - last);
            last = i;
        }
        N /= 2;
    }
    return result;
}

/// <summary>
/// Leet code #1009. Complement of Base 10 Integer
/// 
/// Every non-negative integer N has a binary representation.  For example, 
/// 5 can be represented as "101" in binary, 11 as "1011" in binary, and so on.
/// Note that except for N = 0, there are no leading zeroes in any binary 
/// representation.
///
/// The complement of a binary representation is the number in binary you get 
/// when changing every 1 to a 0 and 0 to a 1.  For example, the complement of 
/// "101" in binary is "010" in binary.
///
/// For a given number N in base-10, return the complement of it's binary 
/// representation as a base-10 integer.
///
/// 
///
/// Example 1:
///
/// Input: 5
/// Output: 2
/// Explanation: 5 is "101" in binary, with complement "010" in binary, which 
/// is 2 in base-10.
///
/// Example 2:
///
/// Input: 7
/// Output: 0
/// Explanation: 7 is "111" in binary, with complement "000" in binary, which 
/// is 0 in base-10.
///
/// Example 3:
///
/// Input: 10
/// Output: 5
/// Explanation: 10 is "1010" in binary, with complement "0101" in binary, 
/// which is 5 in base-10.
/// 
///
/// Note:
///
/// 1. 0 <= N < 10^9
/// </summary>
int LeetCodeBit::bitwiseComplement(int N)
{
    vector<int> bits;
    if (N == 0) bits.push_back(0);
    while (N > 0)
    {
        bits.push_back(N % 2);
        N /= 2;
    }
    int result = 0;
    while (!bits.empty())
    {
        result = 2 * result + (1 - bits.back());
        bits.pop_back();
    }
    return result;
}

/// <summary>
/// Leet code #1016. Binary String With Substrings Representing 1 To N
/// 
/// Given a binary string S (a string consisting only of '0' and '1's) and a 
/// positive integer N, return true if and only if for every integer X from 1 
/// to N, the binary representation of X is a substring of S.
///
/// Example 1:
///
/// Input: S = "0110", N = 3
/// Output: true
///
/// Example 2:
///
/// Input: S = "0110", N = 4
/// Output: false
/// 
///
/// Note:
/// 
/// 1 <= S.length <= 1000
/// 1 <= N <= 10^9
/// </summary>
bool LeetCodeBit::queryString(string S, int N) 
{
    for (int i = N; i > N / 2; i--)
    {
        std::bitset<32> bits(i);
        string str = bits.to_string();
        str = str.substr(str.find('1'));

        if (S.find(str) == string::npos)
        {
            return false;
        }
    }
    return true;
}

/// <summary>
/// Leet code #1017. Convert to Base -2
/// 
/// Given a number N, return a string consisting of "0"s and "1"s that 
/// represents its value in base -2 (negative two).
///
/// The returned string must have no leading zeroes, unless the string is "0".
///
/// Example 1:
/// Input: 2
/// Output: "110"
/// Explantion: (-2) ^ 2 + (-2) ^ 1 = 2
///
/// Example 2:
/// Input: 3
/// Output: "111"
/// Explantion: (-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3
///
/// Example 3:
/// Input: 4
/// Output: "100"
/// Explantion: (-2) ^ 2 = 4
/// 
///
/// Note:
/// 1. 0 <= N <= 10^9
/// </summary>
string LeetCodeBit::baseNeg2(int N)
{
    int sum = N;
    string result;
    int index = 0;
    int base = -2;
    if (sum == 0) result = "0";
    while (sum != 0)
    {
        int digit = sum % base;
        if (digit != 0)
        {
            result.push_back(abs(digit) + '0');
            sum -= abs(digit);
        }
        else
        {
            result.push_back('0');
        }
        sum /= base;
        index++;
    }
    std::reverse(result.begin(), result.end());
    return result;
}

/// <summary>
/// Leet code #1018. Binary Prefix Divisible By 5
/// 
/// Given an array A of 0s and 1s, consider N_i: the i-th subarray from A[0] 
/// to A[i] interpreted as a binary number (from most-significant-bit to 
/// least-significant-bit.)
///
/// Return a list of booleans answer, where answer[i] is true if and only 
/// if N_i is divisible by 5.
///
/// Example 1:
///
/// Input: [0,1,1]
/// Output: [true,false,false]
/// Explanation: 
/// The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in 
/// base-10.  Only the first number is divisible by 5, so answer[0] is true.
///
/// Example 2:
///
/// Input: [1,1,1]
/// Output: [false,false,false]
///
/// Example 3:
///
/// Input: [0,1,1,1,1,1]
/// Output: [true,false,false,false,true,false]
///
/// Example 4:
///
/// Input: [1,1,1,0,1]
/// Output: [false,false,false,false,false]
/// 
///
/// Note:
///
/// 1. 1 <= A.length <= 30000
/// 2. A[i] is 0 or 1
/// </summary>
vector<bool> LeetCodeBit::prefixesDivBy5(vector<int>& A)
{
    vector<bool> result;
    int sum = 0;
    for (size_t i = 0; i < A.size(); i++)
    {
        sum = (sum * 2 + A[i]) % 5;
        if (sum == 0)
        {
            result.push_back(true);
        }
        else
        {
            result.push_back(false);
        }
    }
    return result;
}

/// <summary>
/// Leet code #1072. Flip Columns For Maximum Number of Equal Rows
/// 
/// Given a matrix consisting of 0s and 1s, we may choose any number of 
/// columns in the matrix and flip every cell in that column.  Flipping 
/// a cell changes the value of that cell from 0 to 1 or from 1 to 0.
///
/// Return the maximum number of rows that have all values equal after 
/// some number of flips.
///
/// Example 1:
/// Input: [[0,1],[1,1]]
/// Output: 1
/// Explanation: After flipping no values, 1 row has all values equal.
///
/// Example 2:
///
/// Input: [[0,1],[1,0]]
/// Output: 2
/// Explanation: After flipping values in the first column, both rows have 
/// equal values.
///
/// Example 3:
///
/// Input: [[0,0,0],[0,0,1],[1,1,0]]
/// Output: 2
/// Explanation: After flipping values in the first two columns, the last 
/// two rows have equal values.
/// 
/// Note:
/// 1. 1 <= matrix.length <= 300
/// 2. 1 <= matrix[i].length <= 300
/// 3. All matrix[i].length's are equal
/// 4. matrix[i][j] is 0 or 1
/// </summary>
int LeetCodeBit::maxEqualRowsAfterFlips(vector<vector<int>>& matrix)
{
    int result = 0;
    unordered_map<string, int> str_map;

    for (size_t i = 0; i < matrix.size(); i++)
    {
        string bit_map, rev_map;
        for (size_t j = 0; j < matrix[i].size(); j++)
        {
            bit_map.push_back('0' + matrix[i][j]);
            rev_map.push_back('0' + 1 - matrix[i][j]);
        }
        str_map[bit_map]++;
        result = max(result, str_map[bit_map]);
        str_map[rev_map]++;
        result = max(result, str_map[rev_map]);
    }
    return result;
}

/// <summary>
/// Leet code #1073. Adding Two Negabinary Numbers
/// 
/// Given two numbers arr1 and arr2 in base -2, return the result of adding 
/// them together.
/// Each number is given in array format:  as an array of 0s and 1s, from 
/// most significant bit to least significant bit.  For example, 
/// arr = [1,1,0,1] represents the number (-2)^3 + (-2)^2 + (-2)^0 = -3.  
/// A number arr in array format is also guaranteed to have no leading 
/// zeros: either arr == [0] or arr[0] == 1.
/// Return the result of adding arr1 and arr2 in the same format: as an array 
/// of 0s and 1s with no leading zeros.
/// 
/// Example 1:
/// Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1]
/// Output: [1,0,0,0,0]
/// Explanation: arr1 represents 11, arr2 represents 5, the output 
/// represents 16.
/// 
/// Note:
/// 1. 1 <= arr1.length <= 1000
/// 2. 1 <= arr2.length <= 1000
/// 3. arr1 and arr2 have no leading zeros
/// 4. arr1[i] is 0 or 1
/// 5. arr2[i] is 0 or 1
/// </summary>
vector<int> LeetCodeBit::addNegabinary(vector<int>& arr1, vector<int>& arr2)
{
    vector<int> param1 = arr1;
    vector<int> param2 = arr2;
    std::reverse(param1.begin(), param1.end());
    std::reverse(param2.begin(), param2.end());
    
    vector<int> result;
    int carry = 0;
    for (size_t i = 0; (i < param1.size()) || (i < param2.size()) || (carry != 0); i++)
    {
        int bit1 = 0;
        if (i < param1.size()) bit1 = param1[i];
        int bit2 = 0;
        if (i < param2.size()) bit2 = param2[i];

        int result_bit = bit1 + bit2 + carry;

        if (result_bit == -1)
        {
            result.push_back(1);
            carry = 1;
        }
        else
        {
            result.push_back(result_bit % -2);
            carry = result_bit / -2;
        }
    }
    while (result.size() > 1 && result.back() == 0) result.pop_back();
    std::reverse(result.begin(), result.end());

    return result;
}

/// <summary>
/// Leet code #1238. Circular Permutation in Binary Representation
/// 
/// Given 2 integers n and start. Your task is return any permutation p of 
/// (0,1,2.....,2^n -1) such that :
///
/// p[0] = start
/// p[i] and p[i+1] differ by only one bit in their binary representation.
/// p[0] and p[2^n -1] must also differ by only one bit in their binary 
/// representation.
/// 
/// Example 1:
///
/// Input: n = 2, start = 3
/// Output: [3,2,0,1]
/// Explanation: The binary representation of the permutation is (11,10,00,01). 
/// All the adjacent element differ by one bit. Another valid permutation 
/// is [3,1,0,2]
///
/// Example 2:
///
/// Input: n = 3, start = 2
/// Output: [2,6,7,5,4,0,1,3]
/// Explanation: The binary representation of the permutation is 
/// (010,110,111,101,100,000,001,011).
/// 
/// Constraints:
/// 1. 1 <= n <= 16
/// 2. 0 <= start < 2 ^ n
/// </summary>
vector<int> LeetCodeBit::circularPermutation(int n, int start)
{
    vector<int> result;
    vector<int> buffer;
    int end = 1 << n;
    bool is_start = false;
    for (int i = 0; i < end; i++)
    {
        int num = (i ^ (i >> 1));
        if (num == start) is_start = true;
        if (is_start) result.push_back(num);
        else buffer.push_back(num);
    }
    result.insert(result.end(), buffer.begin(), buffer.end());
    
    return result;
}

/// <summary>
/// Leet code #1461. Check If a String Contains All Binary Codes of Size K
/// 
/// Medium
///
/// Given a binary string s and an integer k.
///
/// Return True if all binary codes of length k is a substring of s. 
/// Otherwise, return False.
///
/// Example 1:
/// Input: s = "00110110", k = 2
/// Output: true
/// Explanation: The binary codes of length 2 are "00", "01", "10" 
/// and "11". They can be all found as substrings at indicies 0, 1, 3 
/// and 2 respectively.
///
/// Example 2:
/// Input: s = "00110", k = 2
/// Output: true
///
/// Example 3:
/// Input: s = "0110", k = 1
/// Output: true
/// Explanation: The binary codes of length 1 are "0" and "1", it 
/// is clear that both exist as a substring. 
///
/// Example 4:
/// Input: s = "0110", k = 2
/// Output: false
/// Explanation: The binary code "00" is of length 2 and doesn't exist in 
/// the array.
///
/// Example 5:
/// Input: s = "0000000001011100", k = 4
/// Output: false
///
/// Constraints:
/// 1. 1 <= s.length <= 5 * 10^5
/// 2. s consists of 0's and 1's only.
/// 3. 1 <= k <= 20
/// </summary>
bool LeetCodeBit::hasAllCodes(string s, int k)
{
    int size = 1 << k;
    vector<int> check(size);
    int sum = 0;
    int result = 0;
    for (size_t i = 0; i < s.size(); i++)
    {
        sum = sum * 2 + (s[i] - '0');

        if ((int)i >= k) sum -= size * (s[i - k] - '0');
        if ((int)i >= k - 1)
        {
            if (check[sum] == 0)
            {
                check[sum] = 1;
                result++;
                if (result == size) return true;
            }
        }
    }
    return false;
}

/// <summary>
/// Leet code #861. Score After Flipping Matrix
/// 
/// We have a two dimensional matrix A where each value is 0 or 1.
///
/// A move consists of choosing any row or column, and toggling each value 
/// in that row or column: changing all 0s to 1s, and all 1s to 0s.
///
/// After making any number of moves, every row of this matrix is interpreted 
/// as a binary number, and the score of the matrix is the sum of these 
/// numbers.
///
/// Return the highest possible score.
///
/// 
///
/// Example 1:
///
/// Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]
/// Output: 39
/// Explanation:
/// Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].
/// 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
/// 
/// 
/// Note:
///
/// 1. 1 <= A.length <= 20
/// 2. 1 <= A[0].length <= 20
/// 3. A[i][j] is 0 or 1.
/// </summary>
int LeetCodeBit::matrixScore(vector<vector<int>>& A)
{
    vector<vector<int>> M = A;
    for (size_t row = 0; row < M.size(); row++)
    {
        if (M[row][0] == 0)
        {
            for (size_t col = 0; col < M[row].size(); col++)
            {
                M[row][col] = 1 - M[row][col];
            }
        }
    }

    for (size_t col = 0; col < M[0].size(); col++)
    {
        int count = 0;
        for (size_t row = 0; row < M.size(); row++)
        {
            if (M[row][col] == 1) count++;
        }
        if (count < ((int)M.size() - count))
        {
            for (size_t row = 0; row < M.size(); row++)
            {
                M[row][col] = 1 - M[row][col];
            }
        }
    }

    int result = 0;
    for (size_t row = 0; row < M.size(); row++)
    {
        int sum = 0;
        for (size_t col = 0; col < M[row].size(); col++)
        {
            sum = (sum << 1) + M[row][col];
        }
        result += sum;
    }
    return result;
}


/// <summary>
/// Leet code #1486. XOR Operation in an Array
/// 
/// Easy
///
/// Given an integer n and an integer start.
/// Define an array nums where nums[i] = start + 2*i (0-indexed) and 
/// n == nums.length.
///
/// Return the bitwise XOR of all elements of nums.
///
/// Example 1:
/// Input: n = 5, start = 0
/// Output: 8
/// Explanation: Array nums is equal to [0, 2, 4, 6, 8] where 
/// (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8.
/// Where "^" corresponds to bitwise XOR operator.
///
/// Example 2:
/// Input: n = 4, start = 3
/// Output: 8
/// Explanation: Array nums is equal to [3, 5, 7, 9] where 
/// (3 ^ 5 ^ 7 ^ 9) = 8.
///
/// Example 3:
/// Input: n = 1, start = 7
/// Output: 7
///
/// Example 4:
/// Input: n = 10, start = 5
/// Output: 2
///
/// Constraints:
/// 1. 1 <= n <= 1000
/// 2. 0 <= start <= 1000
/// 3. n == nums.length
/// </summary>
int LeetCodeBit::xorOperation(int n, int start)
{
    int result = 0;
    for (int i = 0; i < n; i++)
    {
        result = result ^ (start + (2 * i));
    }
    return result;
}

/// <summary>
/// Leet code #1521. Find a Value of a Mysterious Function Closest to 
///                  Target
/// 
/// Hard
///
/// Winston was given the above mysterious function func. He has an 
/// integer array arr and an integer target and he wants to find the 
/// values l and r that make the value |func(arr, l, r) - target| 
/// minimum possible.
///
/// Return the minimum possible value of |func(arr, l, r) - target|.
///
/// Notice that func should be called with the values l and r where 
/// 0 <= l, r < arr.length.
///
/// Example 1:
///
/// Input: arr = [9,12,3,7,15], target = 5
/// Output: 2
/// Explanation: Calling func with all the pairs of [l,r] =
/// [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],
/// [2,4],[0,3],[1,4],[0,4]], Winston got the following results 
/// [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0]. The value closest to 5 is 7 and 3, 
/// thus the minimum difference is 2.
///
/// Example 2:
/// Input: arr = [1000000,1000000,1000000], target = 1
/// Output: 999999
/// Explanation: Winston called the func with all possible values of 
/// [l,r] and he always got 1000000, thus the min difference is 999999.
///
/// Example 3:
/// Input: arr = [1,2,4,8,16], target = 0
/// Output: 0
///
/// Constraints:
/// 1. 1 <= arr.length <= 10^5
/// 2. 1 <= arr[i] <= 10^6
/// 3. 0 <= target <= 10^7
/// </summary>
int LeetCodeBit::closestToTarget(vector<int>& arr, int target)
{
    deque<int> *curr = new deque<int>();
    deque<int> *next = new deque<int>();
    int result = INT_MAX;
    for (size_t i = 0; i < arr.size(); i++)
    {
        result = min(result, abs(arr[i] - target));
        next->push_front(arr[i]);
        int last_bits = arr[i];
        while (!curr->empty())
        {
            int num = curr->back();
            curr->pop_back();
            if ((num & last_bits) == last_bits) continue;
            next->push_front(num);
            last_bits = num & last_bits;
            result = min(result, abs(last_bits - target));
            if (last_bits == 0) break;
        }
        swap(curr, next);
        next->clear();
    }
    delete curr;
    delete next;
    return result;
}

/// <summary>
/// Leet code #1529. Bulb Switcher IV
/// 
/// Medium
///
/// There is a room with n bulbs, numbered from 0 to n-1, arranged in a 
/// row from left to right. Initially all the bulbs are turned off.
///
/// Your task is to obtain the configuration represented by target where 
/// target[i] is '1' if the i-th bulb is turned on and is '0' if it is 
/// turned off.
///
/// You have a switch to flip the state of the bulb, a flip operation is 
/// defined as follows:
///
/// Choose any bulb (index i) of your current configuration.
/// Flip each bulb from index i to n-1.
/// When any bulb is flipped it means that if it is 0 it changes to 1 and 
/// if it is 1 it changes to 0.
///
/// Return the minimum number of flips required to form target.
/// 
/// Example 1:
///
/// Input: target = "10111"
/// Output: 3
/// Explanation: Initial configuration "00000".
/// flip from the third bulb:  "00000" -> "00111"
/// flip from the first bulb:  "00111" -> "11000"
/// flip from the second bulb:  "11000" -> "10111"
/// We need at least 3 flip operations to form target.
///
/// Example 2:
/// Input: target = "101"
/// Output: 3
/// Explanation: "000" -> "111" -> "100" -> "101".
///
/// Example 3:
/// Input: target = "00000"
/// Output: 0
///
/// Example 4:
/// Input: target = "001011101"
/// Output: 5
/// 
/// Constraints:
/// 1. 1 <= target.length <= 10^5
/// 2. target[i] == '0' or target[i] == '1'
/// </summary>
int LeetCodeBit::minFlips(string target)
{
    char prev = '0';
    int result = 0;
    for (size_t i = 0; i < target.size(); i++)
    {
        if (prev == target[i]) continue;
        result++;
        prev = target[i];
    }
    return result;
}

/// <summary>
/// Leet code #1545. Find Kth Bit in Nth Binary String
/// 
/// Medium
///
/// Given two positive integers n and k, the binary string  
/// Sn is formed as follows:
///
/// S1 = "0" 
/// s[i] and s[i + 1] where:
///
/// Si = Si-1 + "1" + reverse(invert(Si-1)) for i > 1
/// Where + denotes the concatenation operation, reverse(x) returns 
/// the reversed string x, and invert(x) inverts all the bits in 
/// x (0 changes to 1 and 1 changes to 0).
/// 
/// For example, the first 4 strings in the above sequence are:
/// S1 = "0"
/// S2 = "011"
/// S3 = "0111001"
/// S4 = "011100110110001"
/// Return the kth bit in Sn. It is guaranteed that k is valid for the given n.
///
/// Example 1:
/// Input: n = 3, k = 1
/// Output: "0"
/// Explanation: S3 is "0111001". The first bit is "0".
///
/// Example 2:
/// Input: n = 4, k = 11
/// Output: "1"
/// Explanation: S4 is "011100110110001". The 11th bit is "1".
/// Example 3:
/// Input: n = 1, k = 1
/// Output: "0"
///
/// Example 4:
/// Input: n = 2, k = 3
/// Output: "1"
/// Constraints:
/// 1. 1 <= n <= 20
/// 2. 1 <= k <= 2n - 1
/// 3. 0 <= i <= s.length - 2
/// </summary>
char LeetCodeBit::findKthBit(int n, int k)
{
    int reverse = 0;
    int len = 0;
    for (int i = 0; i < n; i++)
    {
        len = 1 + 2 * len;
    }
    k--;
    int bit = 0;
    while (k > 0)
    {
        len = len / 2;
        if (k < len) continue;
        else if (k == len)
        {
            bit = 1;
            break;
        }
        else
        {
            k = k - len - 1;
            k = len - 1 - k;
            reverse = 1 - reverse;
        }
    }
    return (abs(reverse - bit) + '0');
}

/// <summary>
/// Leet code #1707. Maximum XOR With an Element From Array
/// 
/// Hard
/// 
/// You are given an array nums consisting of non-negative integers. 
/// You are also given a queries array, where queries[i] = [xi, mi].
///
/// The answer to the ith query is the maximum bitwise XOR value of xi 
/// and any element of nums that does not exceed mi. In other words, the 
/// answer is max(nums[j] XOR xi) for all j such that nums[j] <= mi. If 
/// all elements in nums are larger than mi, then the answer is -1.
///
/// Return an integer array answer where answer.length == queries.length 
/// and answer[i] is the answer to the ith query.
///
/// Example 1:
/// Input: nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]
/// Output: [3,3,7]
/// Explanation:
/// 1) 0 and 1 are the only two integers not greater than 1. 0 XOR 
///    3 = 3 and 1 XOR 3 = 2. The larger of the two is 3.
/// 2) 1 XOR 2 = 3.
/// 3) 5 XOR 2 = 7.
/// Example 2:
/// 
/// Input: nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]
/// Output: [15,-1,5]
/// Constraints:
/// 1. 1 <= nums.length, queries.length <= 10^5
/// 2. queries[i].length == 2
/// 3. 0 <= nums[j], xi, mi <= 10^9
/// </summary>
vector<int> LeetCodeBit::maximizeXor(vector<int>& nums, vector<vector<int>>& queries)
{
    const int n = queries.size();
    vector<int> result;
    sort(nums.begin(), nums.end());

    for (int i = 0; i < n; i++) 
    {
        int end = upper_bound(nums.begin(), nums.end(), queries[i][1]) - nums.begin();
        int start = 0;
        if (end == 0)
        {
            result.push_back(-1);
            continue;
        }

        int low = 0;
        int bit = 1 << 30;
        int full = bit - 1;
        for (int j = 0; j < 31; j++) 
        {
            if (bit <= nums[end - 1])
            {
                if ((queries[i][0] & bit) != 0)
                {
                    // hope A[i] this bit == 0
                    if ((low | full) >= nums[start])
                    {
                        if ((low | full) < nums[end - 1])
                        {
                            end = upper_bound(nums.begin() + start, nums.begin() + end, low | full) - nums.begin();
                        }
                    }
                    else
                    {
                        low |= bit;
                    }
                }
                else
                {
                    // hope: A[i] this bit == 1
                    if ((low | bit) <= nums[end - 1])
                    {
                        low |= bit;
                        start = lower_bound(nums.begin() + start, nums.begin() + end, low) - nums.begin();
                    }
                }
            }
            bit >>= 1;
            full >>= 1;
        }
        result.push_back(queries[i][0] ^ low);
    }
    return result;
}

/// <summary>
/// Leet code 1734. Decode XORed Permutation
/// 
/// Medium
/// 
/// There is an integer array perm that is a permutation of the first n 
/// positive integers, where n is always odd.
///
/// It was encoded into another integer array encoded of length n - 1, 
/// such that encoded[i] = perm[i] XOR perm[i + 1]. For example, if 
/// perm = [1,3,2], then encoded = [2,1].
///
/// Given the encoded array, return the original array perm. It is 
/// guaranteed that the answer exists and is unique.
/// 
/// Example 1:
/// Input: encoded = [3,1]
/// Output: [1,2,3]
/// Explanation: If perm = [1,2,3], then encoded = [1 XOR 2,2 XOR 3] 
/// = [3,1]
///
/// Example 2:
/// Input: encoded = [6,5,4,6]
/// Output: [2,4,1,5,3]
/// Constraints:
/// 1. 3 <= n < 10^5
/// 2. n is odd.
/// 3. encoded.length == n - 1
/// </summary>
vector<int> LeetCodeBit::decode(vector<int>& encoded)
{
    int n = encoded.size() + 1;
    vector<int> result(n);
    int sum = 0;
    for (int i = 1; i <= n; i++)
    {
        sum = sum ^ i;
    }
    for (int i = 1; i < n; i += 2)
    {
        sum = sum ^encoded[i];
    }
    result[0] = sum;
    for (int i = 1; i < n; i++)
    { 
        result[i] = result[i - 1] ^ encoded[i - 1];
    }
    return result;
}


/// <summary>
/// Leet code 1803. Count Pairs With XOR in a Range
/// 
/// Hard
/// 
/// Given a (0-indexed) integer array nums and two integers low and 
/// high, return the number of nice pairs.
///
/// A nice pair is a pair (i, j) where 0 <= i < j < nums.length and 
/// low <= (nums[i] XOR nums[j]) <= high.
/// 
/// Example 1:
/// Input: nums = [1,4,2,7], low = 2, high = 6
/// Output: 6
/// Explanation: All nice pairs (i, j) are as follows:
/// - (0, 1): nums[0] XOR nums[1] = 5 
/// - (0, 2): nums[0] XOR nums[2] = 3
/// - (0, 3): nums[0] XOR nums[3] = 6
/// - (1, 2): nums[1] XOR nums[2] = 6
/// - (1, 3): nums[1] XOR nums[3] = 3
/// - (2, 3): nums[2] XOR nums[3] = 5
///
/// Example 2:
/// Input: nums = [9,8,4,2,1], low = 5, high = 14
/// Output: 8
/// Explanation: All nice pairs (i, j) are as follows:
/// - (0, 2): nums[0] XOR nums[2] = 13
/// - (0, 3): nums[0] XOR nums[3] = 11
/// - (0, 4): nums[0] XOR nums[4] = 8
/// - (1, 2): nums[1] XOR nums[2] = 12
/// - (1, 3): nums[1] XOR nums[3] = 10
/// - (1, 4): nums[1] XOR nums[4] = 9
/// - (2, 3): nums[2] XOR nums[3] = 6
/// - (2, 4): nums[2] XOR nums[4] = 5
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 2 * 10^4
/// 2. 1 <= nums[i] <= 2 * 10^4
/// 3. 1 <= low <= high <= 2 * 10^4
/// </summary>
int LeetCodeBit::countPairs(vector<int>& nums, int low, int high)
{
    vector<int> result(2);
    vector<int> limits = { low, high + 1 };
    for (size_t i = 0; i < 2; i++)
    {
        unordered_map<int, int> curr, next;
        for (auto n : nums)
        {
            curr[n]++;
        }
        int limit = limits[i];
        while (limit > 0)
        {            
            for (auto itr : curr)
            {
                if (limit % 2 == 1)
                {
                    int target = itr.first ^ (limit - 1);
                    if (curr.count(target) > 0)
                    {
                        result[i] += itr.second * curr[target];
                    }
                }
                next[itr.first >> 1] += itr.second;
            }
            curr = next;
            next.clear();
            limit /= 2;
        }
    }
    return (result[1] - result[0]) / 2;
}

/// <summary>
/// Leet code 1803. Count Pairs With XOR in a Range
/// Hard
/// </summary>
int LeetCodeBit::countPairs2(vector<int>& nums, int low, int high)
{
    vector<int> result(2);
    vector<int> limits = { low, high + 1 };
    vector<int> num_count(65536);
    for (size_t i = 0; i < nums.size(); i++)
    {
        int offset = 0;
        int base = 0;
        for (int j = 14; j >= 0; j--)
        {
            int bit = 1 << j;
            if ((nums[i] & bit) == 0)
            {
                num_count[base + offset]++;
                offset = offset * 2;
            }
            else
            {
                num_count[base + offset + 1]++;
                offset = (offset + 1) * 2;
            }
            base = base + (1 << (15 - j));
        }
    }
    for (size_t i = 0; i < 2; i++)
    {
        int limit = limits[i];
        for (size_t j = 0; j < nums.size(); j++)
        {
            int num = nums[j];
            int offset = 0;
            int base = 0;
            for (int j = 14; j >= 0; j--)
            {
                int bit = 1 << j;
                if ((limit & bit) == 0)
                {
                    if ((num & bit) == 0) offset = offset * 2;
                    else offset = (offset + 1) * 2;
                }
                else
                {
                    if ((num & bit) == 0)
                    {
                        result[i] += num_count[base + offset];
                        offset = (offset + 1) * 2;
                    }
                    else
                    {
                        result[i] += num_count[base + offset + 1];
                        offset = offset * 2;
                    }
                }
                base = base + (1 << (15 - j));
            }
        }
    }
    return (result[1] - result[0]) / 2;
}

/// <summary>
/// Leet code 1803. Count Pairs With XOR in a Range
/// </summary>
int LeetCodeBit::countPairs3(vector<int>& nums, int low, int high)
{
    struct TrieBit
    {
        int count;
        TrieBit * children[2];

        TrieBit()
        {
            count = 0;
            children[0] = nullptr;
            children[1] = nullptr;
        }
    };
    TrieBit * root = new TrieBit();
    for (size_t i = 0; i < nums.size(); i++)
    {
        TrieBit * ptr = root;
        for (int j = 14; j >= 0; j--)
        {
            int bit = 1 << j;
            if ((nums[i] & bit) == 0)
            {
                if (ptr->children[0] == nullptr)
                {
                    ptr->children[0] = new TrieBit();
                }
                ptr->children[0]->count++;
                ptr = ptr->children[0];
            }
            else
            {
                if (ptr->children[1] == nullptr)
                {
                    ptr->children[1] = new TrieBit();
                }
                ptr->children[1]->count++;
                ptr = ptr->children[1];
            }
        }
    }
    vector<int> result(2);
    vector<int> limits = { low, high + 1 };
    for (size_t i = 0; i < 2; i++)
    {
        int limit = limits[i];
        for (size_t j = 0; j < nums.size(); j++)
        {
            int num = nums[j];
            TrieBit* ptr = root;
            for (int j = 14; j >= 0; j--)
            {
                int bit = 1 << j;
                if ((limit & bit) == 0)
                {
                    if ((num & bit) == 0) ptr = ptr->children[0];
                    else ptr = ptr->children[1];
                }
                else
                {
                    if ((num & bit) == 0)
                    {
                        if (ptr->children[0] != nullptr) result[i] += ptr->children[0]->count;
                        ptr = ptr->children[1];
                    }
                    else
                    {
                        if (ptr->children[1] != nullptr) result[i] += ptr->children[1]->count;
                        ptr = ptr->children[0];
                    }
                }
                if (ptr == nullptr) break;
            }
        }
    }
    return (result[1] - result[0]) / 2;
}

/// <summary>
/// Leet code 1829. Maximum XOR for Each Query
/// 
/// Medium
/// 
/// You are given a sorted array nums of n non-negative integers and an 
/// integer maximumBit. You want to perform the following query n times:
///
/// Find a non-negative integer k < 2maximumBit such that nums[0] XOR 
/// nums[1] XOR ... XOR nums[nums.length-1] XOR k is maximized. k is the 
/// answer to the ith query.
/// Remove the last element from the current array nums.
/// Return an array answer, where answer[i] is the answer to the ith query.
/// 
/// Example 1:
/// Input: nums = [0,1,1,3], maximumBit = 2
/// Output: [0,3,2,3]
/// Explanation: The queries are answered as follows:
/// 1st query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.
/// 2nd query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.
/// 3rd query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3.
/// 4th query: nums = [0], k = 3 since 0 XOR 3 = 3.
///
/// Example 2:
/// Input: nums = [2,3,4,7], maximumBit = 3
/// Output: [5,2,6,5]
/// Explanation: The queries are answered as follows:
/// 1st query: nums = [2,3,4,7], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7.
/// 2nd query: nums = [2,3,4], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7.
/// 3rd query: nums = [2,3], k = 6 since 2 XOR 3 XOR 6 = 7.
/// 4th query: nums = [2], k = 5 since 2 XOR 5 = 7.
///
/// Example 3:
/// Input: nums = [0,1,2,2,5,7], maximumBit = 3
/// Output: [4,3,6,4,6,7]
/// Constraints:
/// 1. nums.length == n
/// 2. 1 <= n <= 10^5
/// 3. 1 <= maximumBit <= 20
/// 4. 0 <= nums[i] < 2^maximumBit
/// 5. nums is sorted in ascending order.
/// </summary>
vector<int> LeetCodeBit::getMaximumXor(vector<int>& nums, int maximumBit)
{
    vector<int> result(nums.size());
    int full = (1 << maximumBit) - 1;
    int bit = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        bit = bit ^ nums[i];
        result[nums.size() - 1 - i] = full ^ bit;
    }
    return result;
}

/// <summary>
/// Leet code 1835. Find XOR Sum of All Pairs Bitwise AND
/// 
/// Hard
/// 
/// The XOR sum of a list is the bitwise XOR of all its elements. If the 
/// list only contains one element, then its XOR sum will be equal to this 
/// element.
///
/// For example, the XOR sum of [1,2,3,4] is equal to 1 XOR 2 XOR 3 XOR 
/// 4 = 4, and the XOR sum of [3] is equal to 3.
/// You are given two 0-indexed arrays arr1 and arr2 that consist only of 
/// non-negative integers.
///
/// Consider the list containing the result of arr1[i] AND arr2[j] 
/// (bitwise AND) for every (i, j) pair where 0 <= i < arr1.length and 
/// 0 <= j < arr2.length.
///
/// Return the XOR sum of the aforementioned list.
/// Example 1:
/// Input: arr1 = [1,2,3], arr2 = [6,5]
/// Output: 0
/// Explanation: The list = [1 AND 6, 1 AND 5, 2 AND 6, 2 AND 5, 3 
/// AND 6, 3 AND 5] = [0,1,2,0,2,1].
/// The XOR sum = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0.
///
/// Example 2:
/// Input: arr1 = [12], arr2 = [4]
/// Output: 4
/// Explanation: The list = [12 AND 4] = [4]. The XOR sum = 4.
///
/// Constraints:
/// 1. 1 <= arr1.length, arr2.length <= 10^5
/// 2. 0 <= arr1[i], arr2[j] <= 10^9
/// </summary>
int LeetCodeBit::getXORSum(vector<int>& arr1, vector<int>& arr2)
{
    int bit1 = 0;
    int bit2 = 0;
    for (size_t i = 0; i < arr1.size(); i++)
    {
        bit1 = bit1 ^ arr1[i];
    }
    for (size_t i = 0; i < arr2.size(); i++)
    {
        bit2 = bit2 ^ arr2[i];
    }
    return bit1 & bit2;
}

/// <summary>
/// Leet code 1863. Sum of All Subset XOR Totals
/// 
/// Easy
/// 
/// The XOR total of an array is defined as the bitwise XOR of all its 
/// elements, or 0 if the array is empty.
///
/// For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
/// Given an array nums, return the sum of all XOR totals for every subset 
/// of nums. 
///
/// Note: Subsets with the same elements should be counted multiple times.
///
/// An array a is a subset of an array b if a can be obtained from b by 
/// deleting some (possibly zero) elements of b.
/// 
/// Example 1:
/// Input: nums = [1,3]
/// Output: 6
/// Explanation: The 4 subsets of [1,3] are:
/// - The empty subset has an XOR total of 0.
/// - [1] has an XOR total of 1.
/// - [3] has an XOR total of 3.
/// - [1,3] has an XOR total of 1 XOR 3 = 2.
/// 0 + 1 + 3 + 2 = 6
///
/// Example 2:
/// Input: nums = [5,1,6]
/// Output: 28
/// Explanation: The 8 subsets of [5,1,6] are:
/// - The empty subset has an XOR total of 0.
/// - [5] has an XOR total of 5.
/// - [1] has an XOR total of 1.
/// - [6] has an XOR total of 6.
/// - [5,1] has an XOR total of 5 XOR 1 = 4.
/// - [5,6] has an XOR total of 5 XOR 6 = 3.
/// - [1,6] has an XOR total of 1 XOR 6 = 7.
/// - [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.
/// 0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28
///
/// Example 3:
/// Input: nums = [3,4,5,6,7,8]
/// Output: 480
/// Explanation: The sum of all XOR totals for every subset is 480.
///
/// Constraints:
/// 1. 1 <= nums.length <= 12
/// 2. 1 <= nums[i] <= 20
/// </summary>
int LeetCodeBit::subsetXORSum(vector<int>& nums)
{
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        result = result | nums[i];
    }
    result = result * (1 << (nums.size() - 1));
    
    return result;
}

/// <summary>
/// Leet code 1938. Maximum Genetic Difference Query
/// </summary>
void LeetCodeBit::maxGeneticDifference(TrieBitNode* root, int node_id, vector<vector<int>>& tree,
    vector<vector<pair<int, int>>>& query_list, vector<int>& result)
{
    root->increase(node_id, 1);
    for (size_t i = 0; i < query_list[node_id].size(); i++)
    {
        int val = root->findMax(query_list[node_id][i].first);
        result[query_list[node_id][i].second] = val;
    }
    for (size_t i = 0; i < tree[node_id].size(); i++)
    {
        maxGeneticDifference(root, tree[node_id][i], tree, query_list, result);
    }
    root->increase(node_id, -1);
}

/// <summary>
/// Leet code 1938. Maximum Genetic Difference Query
///                                  
/// Hard
/// 
/// There is a rooted tree consisting of n nodes numbered 0 to n - 1. 
/// Each node's number denotes its unique genetic value (i.e. the genetic 
/// value of node x is x). The genetic difference between two genetic 
/// values is defined as the bitwise-XOR of their values. You are given 
/// the integer array parents, where parents[i] is the parent for node i. 
/// If node x is the root of the tree, then parents[x] == -1.
///
/// You are also given the array queries where queries[i] = [nodei, vali]. 
/// For each query i, find the maximum genetic difference between vali and 
/// pi, where pi is the genetic value of any node that is on the path 
/// between nodei and the root (including nodei and the root). More 
/// formally, you want to maximize vali XOR pi.
///
/// Return an array ans where ans[i] is the answer to the ith query.
/// 
/// Example 1:
/// Input: parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]]
/// Output: [2,3,7]
/// Explanation: The queries are processed as follows:
/// - [0,2]: The node with the maximum genetic difference is 0, with a 
///   difference of 2 XOR 0 = 2.
/// - [3,2]: The node with the maximum genetic difference is 1, with 
///   a difference of 2 XOR 1 = 3.
/// - [2,5]: The node with the maximum genetic difference is 2, with 
///   a difference of 5 XOR 2 = 7.
///
/// Example 2:
/// Input: parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]]
/// Output: [6,14,7]
/// Explanation: The queries are processed as follows:
/// - [4,6]: The node with the maximum genetic difference is 0, with a 
///   difference of 6 XOR 0 = 6.
/// - [1,15]: The node with the maximum genetic difference is 1, with a 
///   difference of 15 XOR 1 = 14.
/// - [0,5]: The node with the maximum genetic difference is 2, with 
///   a difference of 5 XOR 2 = 7.
///
/// Constraints:
/// 1. 2 <= parents.length <= 10^5
/// 2. 0 <= parents[i] <= parents.length - 1 for every node i that is not 
///    the root.
/// 3. parents[root] == -1
/// 4. 1 <= queries.length <= 3 * 10^4
/// 5. 0 <= nodei <= parents.length - 1
/// 6. 0 <= vali <= 2 * 10^5
/// </summary>
vector<int> LeetCodeBit::maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries)
{
    vector<vector<int>> tree(parents.size(), vector<int>());
    int root_id = -1;
    for (size_t i = 0; i < parents.size(); i++)
    {
        if (parents[i] == -1) root_id = i;
        else tree[parents[i]].push_back(i);
    }
    vector<vector<pair<int, int>>> query_list(parents.size(), vector<pair<int, int>>());
    for (size_t i = 0; i < queries.size(); i++)
    {
        query_list[queries[i][0]].push_back(make_pair(queries[i][1], i));
    }
    TrieBitNode* root = new TrieBitNode(17);
    vector<int> result(queries.size());
    maxGeneticDifference(root, root_id, tree, query_list, result);
    return result;
}

/// <summary>
/// Leet 1980. Find Unique Binary String
///                                                                 
/// Medium
/// 
/// Given an array of strings nums containing n unique binary strings each 
/// of length n, return a binary string of length n that does not appear 
/// in nums. If there are multiple answers, you may return any of them.
///
/// Example 1:
/// Input: nums = ["01","10"]
/// Output: "11"
/// Explanation: "11" does not appear in nums. "00" would also be correct.
///
/// Example 2:
/// Input: nums = ["00","01"]
/// Output: "11"
/// Explanation: "11" does not appear in nums. "10" would also be correct.
///
/// Example 3:
/// Input: nums = ["111","011","001"]
/// Output: "101"
/// Explanation: "101" does not appear in nums. "000", "010", "100", 
/// and "110" would also be correct.
/// 
/// Constraints:
/// 1. n == nums.length
/// 2. 1 <= n <= 16
/// 3. nums[i].length == n
/// 4. nums[i] is either '0' or '1'.
/// 5. All the strings of nums are unique.
/// </summary>
string LeetCodeBit::findDifferentBinaryString(vector<string>& nums)
{
    unordered_set<int> bits(nums.size());

    for (size_t i = 0; i < nums.size(); i++)
    {
        int bit = 0;
        for (size_t j = 0; j < nums[i].size(); j++)
        {
            bit = bit * 2;
            if (nums[i][j] == '1') bit += 1;
        }
        bits.insert(bit);
    }

    int bit = 0;
    while (bit < (1 << nums.size()))
    {
        if (bits.count(bit) == 0) break;
        bit++;
    }
    string result;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (bit & (1 << (nums.size() - 1 - i)))
        {
            result.push_back('1');
        }
        else
        {
            result.push_back('0');
        }
    }
    return result;
}
#pragma endregion
