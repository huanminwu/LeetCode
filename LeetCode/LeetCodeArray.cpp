#pragma once
#include <ctype.h>  /* is space */
#include <stdio.h>     /* printf */
#include <stdlib.h>  
#include <time.h>  
#include <functional>
#include <algorithm> 
#include <unordered_map> 
#include <unordered_set> 
#include <map> 
#include <numeric>
#include <stack>
#include <set>
#include <queue> 
#include <vector>
#include <iostream>
#include <fstream>
#include "Leetcode.h"
#include "LeetCodeArray.h"
#pragma region Array

struct BinaryIndexTree
{
    vector<int> m_arr;
    int m_count;
    BinaryIndexTree(int n)
    {
        m_arr = vector<int>(n + 1, 0);
        m_count = n + 1;
    }
    void add(int index, int val)
    {
        if (index == 0) return;
        while (index < m_count)
        {
            m_arr[index] += val;
            index += (index & -index);
        }
    }
    int sum(int index)
    {
        int sum = 0;
        while (index != 0)
        {
            sum += m_arr[index];
            index -= index & -index;
        }
        return sum;
    }
};

struct SegmentTreeMax
{
    vector<int> m_arr;
    string m_type;
    int m_count;
    SegmentTreeMax(int n)
    {
        m_count = n;
        m_arr = vector<int>( 4 * n, INT_MIN);
    }
    
    void set(int index, int start, int end, int pos, int val)
    {
        if (start == end)
        {
            m_arr[index] = val;
            return;
        }
        int mid = start + (end - start) / 2;
        if (pos <= mid)
        {
            set(2 * index + 1, start, mid, pos, val);
        }
        else
        {
            set(2 * index + 2, mid + 1, end, pos, val);
        }
        m_arr[index] = max(m_arr[2 * index + 1], m_arr[2 * index + 2]);
    }

    int query(int index, int start, int end, int val)
    {
        if (m_arr[index] < val) return -1;
        if (start == end)
        {
            return start;
        }
        int mid = start + (end - start) / 2;
        if (m_arr[2 * index + 1] >= val)
        {
            return query(2 * index + 1, start, mid, val);
        }
        else 
        {
            return query(2 * index + 2, mid + 1, end, val);
        }
    }
};


/// <summary>
/// Leet code #16. 3Sum Closest 
/// Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. 
/// Return the sum of the three integers. You may assume that each input would have exactly one solution.
/// For example, given array S = {-1 2 1 -4}, and target = 1.
/// The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
/// </summary>
int LeetCodeArray::threeSumClosest(vector<int>& nums, int target)
{
    int global_diff = INT_MAX;
    int global_sum = 0;
    sort(nums.begin(), nums.end());
    for (size_t i = 0; i < nums.size() - 2; i++)
    {
        int l = i + 1;
        int r = nums.size() - 1;
        while (l < r)
        {
            int sum = nums[i] + nums[l] + nums[r];
            int diff = sum - target;
            if (abs(diff) < global_diff)
            {
                global_diff = abs(diff);
                global_sum = sum;
            }
            if (sum == target)
            {
                return sum;
            }
            else if (sum < target)
            {
                l++;
            }
            else
            {
                r--;
            }
        }
    }
    return global_sum;
}

/// <summary>
/// Leet code #27. Remove Element
/// Given an array and a value, remove all instances of that value in place 
/// and return the new length. 
/// Do not allocate extra space for another array, you must do this in place 
/// with constant memory.
/// The order of elements can be changed. It doesn't matter what you leave 
/// beyond the new length.
/// Example:
/// Given input array nums = [3,2,2,3], val = 3 
/// Your function should return length = 2, with the first two elements of 
/// nums being 2.
/// </summary> 
int LeetCodeArray::removeArrayElement(vector<int>& nums, int val)
{
    if (nums.size() == 0)  return nums.size();
    int last = nums.size() - 1;
    int first = 0;
    while (first < last)
    {
        if (nums[first] == val)
        {
            std::swap(nums[first], nums[last]);
            last--;
        }
        else
        {
            first++;
        }
    }
    if (nums[first] != val) first++;
    nums.erase(nums.begin() + first, nums.end());
    return nums.size();
}

/// <summary>
/// Leet code #283. Move Zeroes
///
/// Given an array nums, write a function to move all 0's to the end of it 
/// while maintaining the relative order of the non-zero elements.
/// For example, given nums = [0, 1, 0, 3, 12], after calling your function, 
/// nums should be [1, 3, 12, 0, 0].  
/// Note:
/// 1.You must do this in-place without making a copy of the array.
/// 2.Minimize the total number of operations
/// </summary>
void LeetCodeArray::moveZeroes(vector<int>& nums)
{
    size_t first = 0;
    size_t last = 1;
    while (last < nums.size())
    {
        if (nums[last] == 0)
        {
            last++;
            continue;
        }
        if (nums[first] == 0)
        {
            std::swap(nums[first], nums[last]);
            last++;
        }
        if (nums[first] != 0) first++;
        if (first >= last) last = first + 1;
    }
}

/// <summary>
/// Leet code #345. Reverse Vowels of a String 
/// Write a function that takes a string as input and reverse only the vowels of a string.
/// Example 1:
/// Given s = "hello", return "holle". 
/// Example 2:
/// Given s = "leetcode", return "leotcede". 
/// Note:
/// The vowels does not include the letter "y". 
/// </summary>
string LeetCodeArray::reverseVowels(string s)
{
    int first = 0;
    int last = s.size() - 1;
    unordered_set<char> vowels = { 'a', 'e', 'i', 'o', 'u' };
    while (first < last)
    {
        if (vowels.find(tolower(s[first])) == vowels.end())
        {
            first++;
        }
        else if (vowels.find(tolower(s[last])) == vowels.end())
        {
            last--;
        }
        else
        {
            std::swap(s[first], s[last]);
            first++; last--;
        }
    }
    return s;
}

// <summary>
/// Leet code #167. Two Sum II - Input array is sorted
/// Given an array of integers that is already sorted in ascending order, 
/// find two numbers such that they add up to a specific target number.
/// The function twoSum should return indices of the two numbers such that 
/// they add up to the target, 
/// where index1 must be less than index2. Please note that your returned 
/// answers (both index1 and index2) are not zero-based.
///
/// You may assume that each input would have exactly one solution. 
/// Input: numbers={2, 7, 11, 15}, target=9
///
/// Output: index1=1, index2=2 
/// </summary>
vector<int> LeetCodeArray::twoSumII(vector<int>& numbers, int target)
{
    vector<int> result;
    int first = 0, last = numbers.size() - 1;
    while (first < last)
    {
        if (numbers[first] + numbers[last] == target)
        {
            result.push_back(first + 1);
            result.push_back(last + 1);
            break;
        }
        else if (numbers[first] + numbers[last] < target)
        {
            first++;
        }
        else
        {
            last--;
        }
    }
    return result;
}

/// <summary>
/// Leet code #209. Minimum Size Subarray Sum   
/// 
/// Medium
///
/// Given an array of n positive integers and a positive integer s, find 
/// the minimal length of a contiguous subarray of which the sum ≥ s. If 
/// there isn't one, return 0 instead.
///
/// Example: 
/// Input: s = 7, nums = [2,3,1,2,4,3]
/// Output: 2
/// Explanation: the subarray [4,3] has the minimal length under the 
/// problem constraint.
/// Follow up:
/// If you have figured out the O(n) solution, try coding another 
/// solution of which the time complexity is O(n log n). 
/// </summary>
int LeetCodeArray::minSubArrayLen(int s, vector<int>& nums)
{
    int result = 0;
    int first = 0;
    int last = -1;
    int sum = 0;
    while (last < (int)nums.size())
    {
        if (sum < s)
        {
            last++;
            if (last < (int)nums.size()) sum += nums[last];
        }
        while (sum >= s && first <= last)
        {
            result = (result == 0) ? last - first + 1 : min(result, last - first + 1);
            sum -= nums[first];
            first++;
        }
    }
    return result;
}


/// <summary>
/// Leet code #259. 3Sum Smaller  
/// 
/// Given an array of n integers nums and a target, find the number of index 
/// triplets i, j, k with 0 <= i < j < k < n that satisfy the condition 
/// nums[i] + nums[j] + nums[k] < target.
/// For example, given nums = [-2, 0, 1, 3], and target = 2.
/// Return 2. Because there are two triplets which sums are less than 2:
/// [-2, 0, 1]
/// [-2, 0, 3]
/// Follow up:
/// Could you solve it in O(n2) runtime? 
/// </summary>
int LeetCodeArray::threeSumSmaller(vector<int>& nums, int target)
{
    sort(nums.begin(), nums.end());
    int result = 0;
    for (int i = 0; i < (int)nums.size() - 2; i++)
    {
        int k = nums.size() - 1;
        for (int j = i + 1; j < (int)nums.size() - 1; j++)
        {
            while ((k > j) && (nums[i] + nums[j] + nums[k] >= target))
            {
                k--;
            }
            if (k > j)
            {
                result += k - j;
            }
            else
            {
                break;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #487. Max Consecutive Ones II       
/// 
/// Given a binary array, find the maximum number of consecutive 1s in this 
/// array if you can flip at most one 0.  
/// Example 1: 
/// Input: [1,0,1,1,0]
///
/// Output: 4 
/// Explanation: Flip the first zero will get the the maximum number of 
/// consecutive 1s.
/// After flipping, the maximum number of consecutive 1s is 4.
///	Note:
/// The input array will only contain 0 and 1.
/// The length of input array is a positive integer and will not exceed 10,000
/// Follow up:
/// What if the input numbers come in one by one as an infinite stream? In other words, 
/// you can't store all numbers coming from the stream as it's too large to hold in memory. 
/// Could you solve it efficiently? 
/// </summary>
int LeetCodeArray::findMaxConsecutiveOnesII(vector<int>& nums)
{
    size_t first = 0, last = 0, max_length = 0, count = 0;
    while (last <= nums.size())
    {
        if (count > 1)
        {
            if (nums[first] == 0)
            {
                count--;
            }
            first++;
        }
        else
        {
            max_length = max(max_length, last - first);
            if (last < nums.size())
            {
                if (nums[last] == 0) count++;
            }
            last++;
        }
    }
    return max_length;
}

/// <summary>
/// Leet code #544. Output Contest Matches       
/// 
/// During the NBA playoffs, we always arrange the rather strong team to 
/// play with the rather weak team, like make the rank 1 team play with 
/// the rank nth team, which is a good strategy to make the contest more 
/// interesting. Now, you're given n teams, you need to output their final 
/// contest matches in the form of a string.
///
/// The n teams are given in the form of positive integers from 1 to n, 
/// which represents their initial rank. (Rank 1 is the strongest team 
/// and Rank n is the weakest team.) We'll use parentheses('(', ')') and 
/// commas(',') to represent the contest team pairing - parentheses
/// ('(' , ')') for pairing and commas(',') for partition. During the 
/// pairing process in each round, you always need to follow the strategy 
/// of making the rather strong one pair with the rather weak one.
/// 
/// Example 1:
/// Input: 2
/// Output: (1,2)
/// Explanation: 
/// Initially, we have the team 1 and the team 2, placed like: 1,2.
/// Then we pair the team (1,2) together with '(', ')' and ',', which is 
/// the final answer.
/// Example 2:
/// Input: 4
/// Output: ((1,4),(2,3))
/// Explanation: 
/// In the first round, we pair the team 1 and 4, the team 2 and 3 
/// together, as we need to make the strong team and weak team together.
/// And we got (1,4),(2,3).
/// In the second round, the winners of (1,4) and (2,3) need to play again 
/// to generate the final winner, so you need to add the paratheses outside 
/// them.
/// And we got the final answer ((1,4),(2,3)).
/// Example 3:
/// Input: 8
/// Output: (((1,8),(4,5)),((2,7),(3,6)))
/// Explanation: 
/// First round: (1,8),(2,7),(3,6),(4,5)
/// Second round: ((1,8),(4,5)),((2,7),(3,6))
/// Third round: (((1,8),(4,5)),((2,7),(3,6)))
/// Since the third round will generate the final winner, you need to 
/// output the answer (((1,8),(4,5)),((2,7),(3,6))).
/// Note:
/// The n is in range [2, 212].
/// We ensure that the input n can be converted into the form 2^k, where k is a positive integer.
/// </summary>
string LeetCodeArray::findContestMatch(int n)
{
    vector<string> match(n);
    for (size_t i = 0; i < (size_t)n; i++)
    {
        match[i] = to_string(i + 1);
    }
    while (n > 1)
    {
        int index = n - 1;
        while (index >= n / 2)
        {
            match[n - 1 - index] = "(" + match[n - 1 - index] + "," + match[index] + ")";
            index--;
        }
        n = n / 2;
    }
    return match[0];
}

/// <summary>
/// Leet code #713. Subarray Product Less Than K
/// Your are given an array of positive integers nums.
/// 
/// Count and print the number of (contiguous) subarrays where the product 
/// of all the elements in the subarray is less than k.
///
/// Example 1:
/// Input: nums = [10, 5, 2, 6], k = 100
/// Output: 8
/// Explanation: The 8 subarrays that have product less than 100 are: 
/// [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].
/// Note that [10, 5, 2] is not included as the product of 100 is not 
/// strictly less than k.
/// Note:
/// 
/// 0 < nums.length <= 50000.
/// 0 < nums[i] < 1000.
/// 0 <= k < 10^6.
/// </summary>
int LeetCodeArray::numSubarrayProductLessThanK(vector<int>& nums, int k)
{
    int product = 1;
    int first = 0, last = 0;
    unsigned long result = 0;
    unsigned long prev_dist = 0, distance = 0;
    while (last <= (int)nums.size())
    {
        if ((last < (int)nums.size()) && (product * nums[last] < k))
        {
            product *= nums[last];
            last++;
            distance = last - first;
        }
        else
        {
            if (distance > 0)
            {
                result = result + (distance) * (distance + 1) / 2 - prev_dist * (prev_dist + 1) / 2;
                prev_dist = distance;
                distance = 0;
            }
            if (first < last)
            {
                product /= nums[first];
            }
            first++;
            if (prev_dist > 0) prev_dist--;
            last = max(first, last);
        }
    }
    return (int)result;
}

/// <summary>
/// Leet code #443. String Compression
///
/// Given an array of characters, compress it in-place.
///
/// The length after compression must always be smaller than or equal to 
/// the original array.
/// Every element of the array should be a character (not int) of length 1.
/// After you are done modifying the input array in-place, return the new 
/// length of the array.
///
/// Follow up:
/// Could you solve it using only O(1) extra space?
///
/// Example 1:
/// Input:
/// ["a","a","b","b","c","c","c"]
/// Output:
/// Return 6, and the first 6 characters of the input array should be: 
/// ["a","2","b","2","c","3"]
///
/// Explanation:
/// "aa" is replaced by "a2". "bb" is replaced by "b2". "ccc" is replaced 
/// by "c3".
///
/// Example 2:
/// Input:
/// ["a"]
/// Output:
/// Return 1, and the first 1 characters of the input array should be: 
/// ["a"]
///
/// Explanation:
/// Nothing is replaced.
/// Example 3:
/// Input:
/// ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
///
/// Output:
/// Return 4, and the first 4 characters of the input array should be: 
/// ["a","b","1","2"].
///
/// Explanation:
/// Since the character "a" does not repeat, it is not compressed. 
/// "bbbbbbbbbbbb" is replaced by "b12".
/// Notice each digit has it's own entry in the array.
/// Note:
/// All characters have an ASCII value in [35, 126].
/// 1 <= len(chars) <= 1000.
/// </summary>
int LeetCodeArray::compress(vector<char>& chars)
{
    int pos = 0, count = 0;
    for (int i = 0; i <= (int)chars.size(); i++)
    {
        if ((i > 0) && (i < (int)chars.size()) && (chars[i] == chars[i - 1]))
        {
            count++;
        }
        else
        {
            if (count > 1)
            {
                string str = to_string(count);
                for (char ch : str)
                {
                    chars[pos] = ch;
                    pos++;
                }
            }
            if (i < (int)chars.size())
            {
                chars[pos] = chars[i];
                pos++;
                count = 1;
            }
        }
    }
    return pos;
}

/// <summary>
/// Leet code #755. Pour Water    
/// We are given an elevation map, heights[i] representing the height of the 
/// terrain at that index. The width at each index is 1. After V units of 
/// water fall at index K, how much water is at each index?
///
/// Water first drops at index K and rests on top of the highest terrain or 
/// water at that index. Then, it flows according to the following rules:
///
/// If the droplet would eventually fall by moving left, then move left.
/// Otherwise, if the droplet would eventually fall by moving right, then 
/// move right.
/// Otherwise, rise at it's current position.
/// Here, "eventually fall" means that the droplet will eventually be at a 
/// lower level if it moves in that direction. Also, "level" means the height 
/// of the terrain plus any water in that column.
/// We can assume there's infinitely high terrain on the two sides out of 
/// bounds of the array. Also, there could not be partial water being spread 
/// out evenly on more than 1 grid block - each unit of water has to be in 
/// exactly one block.
///
/// Example 1:
/// Input: heights = [2,1,1,2,1,2,2], V = 4, K = 3
/// Output: [2,2,2,3,2,2,2]
/// Explanation:
/// #       #
/// #       #
/// ##  # ###
/// #########
///  0123456    <- index
///
/// The first drop of water lands at index K = 3:
/// 
/// #       #
/// #   w   #
/// ##  # ###
/// #########
///  0123456    
/// 
/// When moving left or right, the water can only move to the same level or a 
/// lower level.
/// (By level, we mean the total height of the terrain plus any water in that 
/// column.)
/// Since moving left will eventually make it fall, it moves left.
/// (A droplet "made to fall" means go to a lower height than it was at 
/// previously.)
///
/// #       #
/// #       #
/// ## w# ###
/// #########
///  0123456    
///
/// Since moving left will not make it fall, it stays in place.  The next 
/// droplet falls:
///
/// #       #
/// #   w   #
/// ## w# ###
/// #########
///  0123456  
///
/// Since the new droplet moving left will eventually make it fall, it moves 
/// left.
/// Notice that the droplet still preferred to move left,
/// even though it could move right (and moving right makes it fall quicker.)
/// 
/// #       #
/// #  w    #
/// ## w# ###
/// #########
/// 0123456  
///
/// #       #
/// #       #
/// ##ww# ###
/// #########
///  0123456  
///
/// After those steps, the third droplet falls.
/// Since moving left would not eventually make it fall, it tries to move 
/// right.
/// Since moving right would eventually make it fall, it moves right.
///
/// #       #
/// #   w   #
/// ##ww# ###
/// #########
///  0123456  
/// 
/// #       #
/// #       #
/// ##ww#w###
/// #########
///  0123456  
/// 
/// Finally, the fourth droplet falls.
/// Since moving left would not eventually make it fall, it tries to move 
/// right.
/// Since moving right would not eventually make it fall, it stays in place:
/// 
/// #       #
/// #   w   #
/// ##ww#w###
/// #########
///  0123456  
///
/// The final answer is [2,2,2,3,2,2,2]:
///
///    #    
/// ####### 
/// ####### 
///  0123456 
/// Example 2:
/// Input: heights = [1,2,3,4], V = 2, K = 2
/// Output: [2,3,3,4]
/// Explanation:
/// The last droplet settles at index 1, since moving further left would not 
/// cause it to eventually fall to a lower height.
/// Example 3:
/// Input: heights = [3,1,3], V = 5, K = 1
/// Output: [4,4,4]
/// Note:
///
/// heights will have length in [1, 100] and contain integers in [0, 99].
/// 1. V will be in range [0, 2000].
/// 2. K will be in range [0, heights.length - 1].
/// </summary>
vector<int> LeetCodeArray::pourWater(vector<int>& heights, int V, int K)
{
    vector<int> result = heights;
    for (size_t i = 0; i < (size_t)V; i++)
    {
        int index = K - 1;
        int low_index = K;
        while ((index >= 0) && (result[index] <= result[low_index]))
        {
            if (result[index] < result[low_index])
            {
                low_index = index;
            }
            index--;
        }
        if (low_index != K)
        {
            result[low_index]++;
            continue;
        }
        index = K + 1;
        low_index = K;
        while ((index < (int)result.size()) && (result[index] <= result[low_index]))
        {
            if (result[index] < result[low_index])
            {
                low_index = index;
            }
            index++;
        }
        if (low_index != K)
        {
            result[low_index]++;
            continue;
        }
        result[K]++;
    }
    return result;
}

/// <summary>
/// Leet code #904. Fruit Into Baskets
/// 
/// In a row of trees, the i-th tree produces fruit with type tree[i].
///
/// You start at any tree of your choice, then repeatedly perform the 
/// following steps:
///
/// 1. Add one piece of fruit from this tree to your baskets.  If you cannot, 
/// stop.
/// 2. Move to the next tree to the right of the current tree.  If there is no 
/// tree to the right, stop.
/// Note that you do not have any choice after the initial choice of starting 
/// tree: you must perform step 1, then step 2, then back to step 1, then 
/// step 2, and so on until you stop.
///
/// You have two baskets, and each basket can carry any quantity of fruit, but 
/// you want each basket to only carry one type of fruit each.
///
/// What is the total amount of fruit you can collect with this procedure?
///
/// Example 1:
/// Input: [1,2,1]
/// Output: 3
/// Explanation: We can collect [1,2,1].
///
/// Example 2:
/// Input: [0,1,2,2]
/// Output: 3
/// Explanation: We can collect [1,2,2].
/// If we started at the first tree, we would only collect [0, 1].
///
/// Example 3:
/// Input: [1,2,3,2,2]
/// Output: 4
/// Explanation: We can collect [2,3,2,2].
/// If we started at the first tree, we would only collect [1, 2].
///
/// Example 4:
/// Input: [3,3,3,1,2,1,1,2,3,3,4]
/// Output: 5
/// Explanation: We can collect [1,2,1,1,2].
/// If we started at the first tree or the eighth tree, we would only collect 
/// 4 fruits.
/// 
/// Note:
///
/// 1. 1 <= tree.length <= 40000
/// 2. 0 <= tree[i] < tree.length
/// </summary>
int LeetCodeArray::totalFruit(vector<int>& tree)
{
    int first = 0;
    int result = 0;
    unordered_map<int, int> hash_table;
    for (size_t i = 0; i < tree.size(); i++)
    {
        int last = i;
        hash_table[tree[last]]++;
        if (hash_table.size() <= 2)
        {
            result = max(result, last - first + 1);
        }
        else
        {
            while (hash_table.size() > 2)
            {
                hash_table[tree[first]]--;
                if (hash_table[tree[first]] == 0)
                {
                    hash_table.erase(tree[first]);
                }
                first++;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #917. Reverse Only Letters
/// 
/// Given a string S, return the "reversed" string where all characters that 
/// are not a letter stay in the same place, and all letters reverse their 
/// positions.
///
/// Example 1:
///
/// Input: "ab-cd"
/// Output: "dc-ba"
/// Example 2:
///
/// Input: "a-bC-dEf-ghIj"
/// Output: "j-Ih-gfE-dCba"
///
/// Example 3:
/// Input: "Test1ng-Leet=code-Q!"
/// Output: "Qedo1ct-eeLg=ntse-T!"
///  
/// Note:
/// 
/// 1. S.length <= 100
/// 2. 33 <= S[i].ASCIIcode <= 122 
/// 3. S doesn't contain \ or "
/// </summary>
string LeetCodeArray::reverseOnlyLetters(string S)
{
    string result = S;
    int first = 0;
    int last = S.size() - 1;
    while (first < last)
    {
        if (isalpha(result[first]) && isalpha(result[last]))
        {
            std::swap(result[first], result[last]);
            first++;
            last--;
        }
        else if (!isalpha(result[first]))
        {
            first++;
        }
        else if (!isalpha(result[last]))
        {
            last--;
        }
    }
    return result;
}

/// <summary>
/// Leet code #915. Partition Array into Disjoint Intervals
/// 
/// Given an array A, partition it into two (contiguous) subarrays left and 
/// right so that:
///
/// Every element in left is less than or equal to every element in right.
/// left and right are non-empty.
/// left has the smallest possible size.
/// Return the length of left after such a partitioning.  It is guaranteed 
/// that such a partitioning exists.
///
/// 
/// Example 1:
///
/// Input: [5,0,3,8,6]
/// Output: 3
/// Explanation: left = [5,0,3], right = [8,6]
///
/// Example 2:
///
/// Input: [1,1,1,0,6,12]
/// Output: 4
/// Explanation: left = [1,1,1,0], right = [6,12]
/// 
///
/// Note:
///
/// 2 <= A.length <= 30000
/// 0 <= A[i] <= 10^6
/// It is guaranteed there is at least one way to partition A as described.
/// </summary>
int LeetCodeArray::partitionDisjoint(vector<int>& A)
{
    size_t first = 0;
    size_t second = first + 1;
    int max_left = A[first];
    int min_right = A[second];
    int max_right = A[second];
    while (second < A.size())
    {
        if (min_right >= max_left)
        {
            second++;
            if (second < A.size())
            {
                min_right = min(min_right, A[second]);
                max_right = max(max_right, A[second]);
            }
        }
        else
        {
            first = second;
            max_left = max(max_left, max_right);
            second++;
            if (second < A.size())
            {
                min_right = A[second];
                max_right = A[second];
            }
        }
    }
    return first + 1;
}

/// <summary>
/// Leet code #1150. Check If a Number Is Majority Element in a Sorted Array
/// 
/// Given an array nums sorted in non-decreasing order, and a number target, 
/// return True if and only if target is a majority element.
/// A majority element is an element that appears more than N/2 times in an 
/// array of length N.
/// 
/// Example 1:
/// Input: nums = [2,4,5,5,5,5,5,6,6], target = 5
/// Output: true
/// Explanation: 
/// The value 5 appears 5 times and the length of the array is 9.
/// Thus, 5 is a majority element because 5 > 9/2 is true.
///
/// Example 2:
/// Input: nums = [10,100,101,101], target = 101
/// Output: false
/// Explanation: 
/// The value 101 appears 2 times and the length of the array is 4.
/// Thus, 101 is not a majority element because 2 > 4/2 is false.
/// 
/// Note:
/// 1. 1 <= nums.length <= 1000
/// 2. 1 <= nums[i] <= 10^9
/// 3. 1 <= target <= 10^9
/// </summary>
bool LeetCodeArray::isMajorityElement(vector<int>& nums, int target)
{
    int first = lower_bound(nums.begin(), nums.end(), target) - nums.begin();
    int last = first;

    while ((last < (int)nums.size()) && (nums[first] == nums[last])) last++;
    if ((last - first) > (int)nums.size() / 2) return true;
    else return false;
}

/// <summary>
/// Leet code #1180. Count Substrings with Only One Distinct Letter
/// 
/// Given a string S, return the number of substrings that have only one 
/// distinct letter.
/// 
/// Example 1:
/// Input: S = "aaaba"
/// Output: 8
/// Explanation: The substrings with one distinct letter are 
/// "aaa", "aa", "a", "b".
/// "aaa" occurs 1 time.
/// "aa" occurs 2 times.
/// "a" occurs 4 times.
/// "b" occurs 1 time.
/// So the answer is 1 + 2 + 4 + 1 = 8.
///
/// Example 2:
/// Input: S = "aaaaaaaaaa"
/// Output: 55
/// 
/// Constraints:
/// 1. 1 <= S.length <= 1000
/// 2. S[i] consists of only lowercase English letters.
/// </summary>
int LeetCodeArray::countLetters(string S)
{
    int first = 0;
    int result = 0;
    for (size_t i = 0; i < S.size(); i++)
    {
        if (S[first] != S[i]) first = i;
        result += i - first + 1;
    }
    return result;
}

/// <summary>
/// Leet code #53. Maximum Subarray
/// 
/// Given an integer array nums, find the contiguous subarray (containing 
/// at least one number) which has the largest sum and return its sum.
///
/// Example:
///
/// Input: [-2,1,-3,4,-1,2,1,-5,4],
/// Output: 6
/// Explanation: [4,-1,2,1] has the largest sum = 6.
///
/// Follow up:
/// If you have figured out the O(n) solution, try coding another solution 
/// using the divide and conquer approach, which is more subtle.
/// </summary>
int LeetCodeArray::maxSubArray(vector<int>& nums)
{
    int min_sum = 0;
    int max_sum = INT_MIN;
    int sum = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        sum += nums[i];
        // calculate max_sum first because min_sum is for previous ones.
        max_sum = max(max_sum, sum - min_sum);
        min_sum = min(min_sum, sum);
    }
    return max_sum;
}

/// <summary>
/// Leet code #134. Gas Station
/// 
/// There are N gas stations along a circular route, where the amount of gas 
/// at station i is gas[i].
///
/// You have a car with an unlimited gas tank and it costs cost[i] of gas to 
/// travel from station i to its next station (i+1). You begin the journey 
/// with an empty tank at one of the gas stations.
///
/// Return the starting gas station's index if you can travel around the 
/// circuit once in the clockwise direction, otherwise return -1.
///
/// Note:
///
/// If there exists a solution, it is guaranteed to be unique.
/// Both input arrays are non-empty and have the same length.
/// Each element in the input arrays is a non-negative integer.
///
/// Example 1:
/// Input: 
/// gas  = [1,2,3,4,5]
/// cost = [3,4,5,1,2]
/// Output: 3
///
/// Explanation:
/// 1. Start at station 3 (index 3) and fill up with 4 unit of gas. 
///    Your tank = 0 + 4 = 4
/// 2. Travel to station 4. Your tank = 4 - 1 + 5 = 8
/// 3. Travel to station 0. Your tank = 8 - 2 + 1 = 7
/// 4. Travel to station 1. Your tank = 7 - 3 + 2 = 6
/// 5. Travel to station 2. Your tank = 6 - 4 + 3 = 5
/// 6. Travel to station 3. The cost is 5. Your gas is just enough to travel 
///    back to station 3.
/// 7. Therefore, return 3 as the starting index.
///
/// Example 2:
/// Input: 
/// gas  = [2,3,4]
/// cost = [3,4,3]
/// Output: -1
/// 
/// Explanation:
/// 1. You can't start at station 0 or 1, as there is not enough gas to travel 
///    to the next station.
/// 2. Let's start at station 2 and fill up with 4 unit of gas. Your 
///    tank = 0 + 4 = 4
/// 3. Travel to station 0. Your tank = 4 - 3 + 2 = 3
/// 4. Travel to station 1. Your tank = 3 - 3 + 3 = 3
/// 5. You cannot travel back to station 2, as it requires 4 unit of gas but 
///    you only have 3.
/// 6. Therefore, you can't travel around the circuit once no matter where 
///    you start.
/// </summary>
int LeetCodeArray::canCompleteCircuit(vector<int>& gas, vector<int>& cost)
{
    vector<int> sum(gas.size());
    int start_index = -1;
    int min_sum = INT_MAX;
    for (size_t i = 0; i < gas.size(); i++)
    {
        if (i == 0)
        {
            sum[i] = gas[i] - cost[i];
        }
        else
        {
            sum[i] = sum[i - 1] + gas[i] - cost[i];
        }
        if (sum[i] < min_sum)
        {
            min_sum = sum[i];
            start_index = (i + 1 == gas.size()) ? 0 : i + 1;
        }
    }
    if (sum[gas.size() - 1] >= 0)
    {
        return start_index;
    }
    else
    {
        return -1;
    }
}

/// <summary>
/// Leet code #169. Majority Element
/// 
/// Given an array of size n, find the majority element. The majority element
/// is the element that appears more than n/2 times.
///
/// You may assume that the array is non-empty and the majority element 
/// always exist in the array.
///
/// Example 1:
///
/// Input: [3,2,3]
/// Output: 3
///
/// Example 2:
///
/// Input: [2,2,1,1,1,2,2]
/// Output: 2
/// </summary>
int LeetCodeArray::majorityElement(vector<int>& nums)
{
    int count = 0;
    int major_number = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (count == 0)
        {
            major_number = nums[i];
            count++;
        }
        else
        {
            if (major_number == nums[i])
            {
                count++;
            }
            else
            {
                count--;
            }
        }
    }
    return major_number;
}

/// <summary>
/// Leet code #229. Majority Element II
/// 
/// Given an integer array of size n, find all elements that appear more than
/// n/3 times.
///
/// Note: The algorithm should run in linear time and in O(1) space.
///
/// Example 1:
/// 
/// Input: [3,2,3]
/// Output: [3]
///
/// Example 2:
/// 
/// Input: [1,1,1,3,3,2,2,2]
/// Output: [1,2]
/// </summary>
vector<int> LeetCodeArray::majorityElementII(vector<int>& nums)
{
    vector<int> result;
    if (nums.size() < 3) return nums;
    int count1 = 1, count2 = 1;
    int number1 = nums[0], number2 = nums[1];
    for (size_t i = 2; i < nums.size(); i++)
    {
        if (number1 == nums[i])
        {
            count1++;
        }
        else if (number2 == nums[i])
        {
            count2++;
        }
        else if (count1 == 0)
        {
            number1 = nums[i];
            count1++;
        }
        else if (count2 == 0)
        {
            number2 = nums[i];
            count2++;
        }
        else
        {
            count1--;
            count2--;
        }
    }
    count1 = count(nums.begin(), nums.end(), number1);
    count2 = count(nums.begin(), nums.end(), number2);
    if (count1 > (int)nums.size() / 3)
    {
        result.push_back(number1);
    }
    if (count2 > (int)nums.size() / 3)
    {
        if (number2 != number1) result.push_back(number2);
    }
    return result;
}

/// <summary>
/// Leet code #287. Find the Duplicate Number
/// 
/// Given an array nums containing n + 1 integers where each integer is 
/// between 1 and n (inclusive), prove that at least one duplicate number 
/// must exist. Assume that there is only one duplicate number, find the 
/// duplicate one.
///
/// Example 1:
///
/// Input: [1,3,4,2,2]
/// Output: 2
///
/// Example 2:
///
/// Input: [3,1,3,4,2]
/// Output: 3
///
/// Note:
///
/// 1. You must not modify the array (assume the array is read only).
/// 2. You must use only constant, O(1) extra space.
/// 3. Your runtime complexity should be less than O(n2).
/// 4. There is only one duplicate number in the array, but it could be 
///    repeated more than once.
/// </summary>
int LeetCodeArray::findDuplicate(vector<int>& nums)
{
    // protect empty array
    if (nums.size() == 0) return -1;

    // tortoise
    int slow = 0;
    int fast = 0;

    while (true)
    {
        slow = nums[slow];
        fast = nums[nums[fast]];
        if (slow == fast) break;
    }
    fast = 0;

    while (true)
    {
        slow = nums[slow];
        fast = nums[fast];
        if (slow == fast) break;
    }
    return slow;
}

/// <summary>
/// Leet code #41. First Missing Positive
/// 
/// Given an unsorted integer array, find the smallest missing positive 
/// integer.
///
/// Example 1:
///
/// Input: [1,2,0]
/// Output: 3
///
/// Example 2:
///
/// Input: [3,4,-1,1]
/// Output: 2
///
/// Example 3:
///
/// Input: [7,8,9,11,12]
/// Output: 1
///
/// Note:
/// 
/// Your algorithm should run in O(n) time and uses constant extra space.
/// </summary>
int LeetCodeArray::firstMissingPositive(vector<int>& nums)
{
    if (nums.size() == 0)
    {
        return 1;
    }
    size_t index = 0;
    while (index < nums.size())
    {
        // non-positive or out of range, skip it.
        if ((nums[index] <= 0) || (nums[index] >= (int)nums.size()))
        {
            index++;
        }
        // already in order, skip it
        else if (nums[index] == index + 1)
        {
            index++;
        }
        // already same data so no need to swap
        else if (nums[index] == nums[nums[index] - 1])
        {
            index++;
        }
        else
        {
            std::swap(nums[index], nums[nums[index] - 1]);
        }
    }
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] != i + 1)
        {
            return i + 1;
        }
    }
    return nums.size() + 1;
}

/// <summary>
/// Leet code #26. Remove Duplicates from Sorted Array
/// Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.
/// Do not allocate extra space for another array, you must do this in place with constant memory. 
/// For example,
/// Given input array nums = [1,1,2], 
/// Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. 
/// It doesn't matter what you leave beyond the new length. 
/// </summary>
int LeetCodeArray::removeDuplicateSortedArray(vector<int>& nums)
{
    vector<int>::iterator new_end = std::unique(nums.begin(), nums.end());
    nums.erase(new_end, nums.end());
    return nums.size();
}

/// <summary>
/// LeetCode #80. Remove Duplicates from Sorted Array II  
/// Follow up for "Remove Duplicates": 
/// What if duplicates are allowed at most twice? 
/// For example, 
/// Given sorted array nums = [1,1,1,2,2,3], 
/// Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. 
/// It doesn't matter what you leave beyond the new length.  
/// </summary>
int LeetCodeArray::removeDuplicatesII(vector<int>& nums)
{
    size_t first = 0, last = 0;
    int count = 0;
    while (last < nums.size())
    {
        if ((last > 0) && (nums[last] == nums[last - 1]))
        {
            count++;
            if (count >= 2)
            {
                last++;
                continue;
            }
        }
        else
        {
            count = 0;
        }
        if (first < last)
        {
            nums[first] = nums[last];
        }
        first++;
        last++;
    }
    nums.erase(nums.begin() + first, nums.end());
    return first;
}

/// <summary>
/// Leet code #54. Spiral Matrix
/// 
/// Given a matrix of m x n elements (m rows, n columns), return all elements 
/// of the matrix in spiral order.
///
/// Example 1:
///
/// Input:
/// [
///  [ 1, 2, 3 ],
///  [ 4, 5, 6 ],
///  [ 7, 8, 9 ]
/// ]
/// Output: [1,2,3,6,9,8,7,4,5]
///
/// Example 2:
///
/// Input:
/// [
///  [1, 2, 3, 4],
///   [5, 6, 7, 8],
///  [9,10,11,12]
/// ]
/// Output: [1,2,3,4,8,12,11,10,9,5,6,7]
/// You are given an n x n 2D matrix representing an image.
/// </summary>
vector<int> LeetCodeArray::spiralOrder(vector<vector<int>>& matrix)
{
    vector<int> result;
    if (matrix.empty() || matrix[0].empty()) return result;
    int begin_row = 0;
    int end_row = matrix.size() - 1;
    int begin_col = 0;
    int end_col = matrix[0].size() - 1;
    int direction = 0;
    while ((begin_row <= end_row) && (begin_col <= end_col))
    {
        switch (direction)
        {
        case 0:
            for (int i = begin_col; i <= end_col; i++)
            {
                result.push_back(matrix[begin_row][i]);
            }
            begin_row++;
            break;
        case 1:
            for (int i = begin_row; i <= end_row; i++)
            {
                result.push_back(matrix[i][end_col]);
            }
            end_col--;
            break;
        case 2:
            for (int i = end_col; i >= begin_col; i--)
            {
                result.push_back(matrix[end_row][i]);
            }
            end_row--;
            break;
        case 3:
            for (int i = end_row; i >= begin_row; i--)
            {
                result.push_back(matrix[i][begin_col]);
            }
            begin_col++;
            break;
        }
        direction = (direction + 1) % 4;
    }
    return result;
}

/// <summary>
/// Leet code #59. Spiral Matrix II
/// 
/// Medium
/// 
/// Given a positive integer n, generate a square matrix filled with elements
/// from 1 to n2 in spiral order.
///
/// Example:
///
/// Input: 3
/// Output:
/// [
///  [ 1, 2, 3 ],
///  [ 8, 9, 4 ],
///  [ 7, 6, 5 ]
/// ]
/// </summary>
vector<vector<int>> LeetCodeArray::generateMatrix(int n)
{
    vector<vector<int>> result(n, vector<int>(n, 0));
    if (n <= 0) return result;
    int begin_row = 0;
    int end_row = n - 1;
    int begin_col = 0;
    int end_col = n - 1;
    int direction = 0;
    int index = 0;
    while ((begin_row <= end_row) && (begin_col <= end_col))
    {
        switch (direction)
        {
        case 0:
            for (int i = begin_col; i <= end_col; i++)
            {
                index++;
                result[begin_row][i] = index;
            }
            begin_row++;
            break;
        case 1:
            for (int i = begin_row; i <= end_row; i++)
            {
                index++;
                result[i][end_col] = index;
            }
            end_col--;
            break;
        case 2:
            for (int i = end_col; i >= begin_col; i--)
            {
                index++;
                result[end_row][i] = index;
            }
            end_row--;
            break;
        case 3:
            for (int i = end_row; i >= begin_row; i--)
            {
                index++;
                result[i][begin_col] = index;
            }
            begin_col++;
            break;
        }
        direction = (direction + 1) % 4;
    }
    return result;
}

/// <summary>
/// Leet code #48. Rotate Image
/// 
/// You are given an n x n 2D matrix representing an image.
///
/// Rotate the image by 90 degrees (clockwise).
///
/// Note:
///
/// You have to rotate the image in-place, which means you have to 
/// modify the input 2D matrix directly. DO NOT allocate another 2D 
/// matrix and do the rotation.
///
/// Example 1:
///
/// Given input matrix = 
/// [
///   [1,2,3],
///  [4,5,6],
///  [7,8,9]
/// ],
///
/// rotate the input matrix in-place such that it becomes:
/// [
///  [7,4,1],
///  [8,5,2],
///  [9,6,3]
/// ]
///
/// Example 2:
///
/// Given input matrix =
/// [
///   [ 5, 1, 9,11],
///   [ 2, 4, 8,10],
///   [13, 3, 6, 7],
///   [15,14,12,16]
/// ], 
///
/// rotate the input matrix in-place such that it becomes:
/// [
///   [15,13, 2, 5],
///   [14, 3, 4, 1],
//    [12, 6, 8, 9],
///   [16, 7,10,11]
/// ]
/// </summary>
void LeetCodeArray::rotate(vector<vector<int>>& matrix)
{
    if (matrix.empty() || matrix[0].empty()) return;
    int begin_row = 0;
    int end_row = matrix.size() - 1;
    int begin_col = 0;
    int end_col = matrix[0].size() - 1;
    while ((begin_row <= end_row) && (begin_col <= end_col))
    {
        for (int i = 0; i < (end_col - begin_col); i++)
        {
            std::swap(matrix[begin_row][begin_col + i], matrix[begin_row + i][end_col]);
            std::swap(matrix[begin_row][begin_col + i], matrix[end_row][end_col - i]);
            std::swap(matrix[begin_row][begin_col + i], matrix[end_row - i][begin_col]);
        }
        begin_row++;
        end_row--;
        begin_col++;
        end_col--;
    }
}

/// <summary>
/// LeetCode #73. Set Matrix Zeroes
///
/// Given a m x n matrix, if an element is 0, set its entire row and column 
/// to 0. Do it in place. 
/// Did you use extra space?
/// A straight forward solution using O(mn) space is probably a bad idea.
/// A simple improvement uses O(m + n) space, but still not the best 
/// solution.
/// Could you devise a constant space solution? 
/// </summary>
void LeetCodeArray::setZeroes(vector<vector<int>>& matrix)
{
    int row0 = -1, col0 = -1;
    if ((matrix.size() == 0) || (matrix[0].size() == 0)) return;
    for (size_t i = 0; i < matrix.size(); i++)
    {
        for (size_t j = 0; j < matrix[0].size(); j++)
        {
            if (matrix[i][j] == 0)
            {
                if ((row0 == -1) && (col0 == -1))
                {
                    row0 = i; col0 = j;
                }
                else
                {
                    matrix[row0][j] = 0; matrix[i][col0] = 0;
                }
            }
        }
    }
    if ((row0 == -1) && (col0 == -1)) return;

    for (size_t i = 0; i < matrix.size(); i++)
    {
        if (i == row0) continue;
        if (matrix[i][col0] == 0)
        {
            for (size_t j = 0; j < matrix[0].size(); j++)
            {
                matrix[i][j] = 0;
            }
        }
    }

    for (size_t i = 0; i < matrix[0].size(); i++)
    {
        if (i == col0) continue;
        if (matrix[row0][i] == 0)
        {
            for (size_t j = 0; j < matrix.size(); j++)
            {
                matrix[j][i] = 0;
            }
        }
    }

    for (size_t i = 0; i < matrix.size(); i++)
    {
        matrix[i][col0] = 0;
    }
    for (size_t i = 0; i < matrix[0].size(); i++)
    {
        matrix[row0][i] = 0;
    }
}

/// <summary>
/// Leet code #189. Rotate Array
///
/// Rotate an array of n elements to the right by k steps.
/// For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is 
/// rotated to [5,6,7,1,2,3,4]. 
/// Note:
/// Try to come up as many solutions as you can, there are at least 3 
/// different ways to solve this problem. 
/// Hint:
/// Could you do it in-place with O(1) extra space? 
/// Related problem: Reverse Words in a String II
/// </summary>
void LeetCodeArray::rotateArray(vector<int>& nums, int k)
{
    if ((nums.size() == 0) || (k == 0)) return;
    size_t a = nums.size(), b = k;
    if (a < b) std::swap(a, b);
    while (b != 0)
    {
        a = a % b;
        std::swap(a, b);
    }
    for (size_t i = 0; i < a; i++)
    {
        size_t index = i, next = (index + k) % nums.size();
        while (next != index)
        {
            std::swap(nums[index], nums[next]);
            next = (next + k) % nums.size();
        }
    }
}

/// <summary>
/// Leet Code 419. Battleships in a Board
///  
/// Medium
///
/// Given an m x n matrix board where each cell is a battleship 'X' or empty 
/// '.', return the number of the battleships on board.
///
/// Battleships can only be placed horizontally or vertically on board. In 
/// other words, they can only be made of the shape 1 x k (1 row, k columns) 
/// or k x 1 (k rows, 1 column), where k can be of any size. At least one 
/// horizontal or vertical cell separates between two battleships (i.e., 
/// there are no adjacent battleships).
///
/// Example 1:
/// Input: board = [["X",".",".","X"],[".",".",".","X"],[".",".",".","X"]]
/// Output: 2
///
/// Example 2:
/// Input: board = [["."]]
/// Output: 0
/// 
/// Constraints:
/// 1. m == board.length
/// 2. n == board[i].length
/// 3. 1 <= m, n <= 200
/// 4. board[i][j] is either '.' or 'X'.
/// Follow up: Could you do it in one-pass, using only O(1) extra memory and 
/// without modifying the values board?
/// </summary> 
int LeetCodeArray::countBattleships(vector<vector<char>>& board)
{
    int count = 0;
    for (size_t i = 0; i < board.size(); i++)
    {
        for (size_t j = 0; j < board[0].size(); j++)
        {
            if ((board[i][j] == 'X') && ((i == 0) || (board[i - 1][j] == '.')) &&
                ((j == 0) || (board[i][j - 1] == '.')))
            {
                count++;
            }
        }
    }
    return count;
}


/// <summary>
/// Leet code #448. Find All Numbers Disappeared in an Array
///
/// Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), 
/// some elements appear twice and others appear once.
/// Find all the elements of [1, n] inclusive that do not appear in this 
/// array.
/// Could you do it without extra space and in O(n) runtime? You may 
/// assume the returned list does not count as extra space.
///
/// Example:
///
/// Input:
/// [4,3,2,7,8,2,3,1]
/// Output:
/// [5,6]
/// </summary>
vector<int> LeetCodeArray::findDisappearedNumbers(vector<int>& nums)
{
    vector<int> result;
    for (size_t i = 0; i < nums.size(); i++)
    {
        int index = abs(nums[i]) - 1;
        if (nums[index] > 0) nums[index] = - nums[index];
    }
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] > 0) result.push_back(i + 1);
    }
    return result;
}

/// <summary>
/// Leet code #442. Find All Duplicates in an Array
///
/// Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some 
/// elements appear twice and others appear once.
/// Find all the elements that appear twice in this array.
/// Could you do it without extra space and in O(n) runtime?
/// Example:
/// Input:
/// [4,3,2,7,8,2,3,1]
/// Output:
/// [2,3]
/// </summary>
vector<int> LeetCodeArray::findDuplicates(vector<int>& nums)
{
    vector<int> result;
    size_t index = 0;
    while (index < nums.size())
    {
        if (nums[index] == index + 1)
        {
            index++;
        }
        else if (nums[index] == nums[nums[index] - 1])
        {
            index++;
        }
        else
        {
            std::swap(nums[index], nums[nums[index] - 1]);
        }
    }

    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] != i + 1)
        {
            result.push_back(nums[i]);
        }
    }
    return result;
}

/// <summary>
/// Leet code #475. Heaters 
/// Winter is coming! Your first job during the contest is to design a standard heater with 
/// fixed warm radius to warm all the houses.
/// Now, you are given positions of houses and heaters on a horizontal line, find out minimum 
/// radius of heaters so that all houses could be covered by those heaters.
///
/// So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.
/// Note:
/// Numbers of houses and heaters you are given are non-negative and will not exceed 25000.
/// Positions of houses and heaters you are given are non-negative and will not exceed 10^9.
/// As long as a house is in the heaters' warm radius range, it can be warmed.
/// All the heaters follow your radius standard and the warm radius will the same.
/// Example 1:
/// Input: [1,2,3],[2]
/// Output: 1
/// Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.
/// Example 2:
/// Input: [1,2,3,4],[1,4]
/// Output: 1
/// Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.
/// </summary>
int LeetCodeArray::findRadius(vector<int>& houses, vector<int>& heaters)
{
    int result = 0;
    sort(heaters.begin(), heaters.end());
    for (int house : houses)
    {
        vector<int>::iterator next = lower_bound(heaters.begin(), heaters.end(), house);
        vector<int>::iterator prev;
        if (next == heaters.begin())
        {
            prev = next;
        }
        else
        {
            prev = next - 1;
        }
        if (next == heaters.end())
        {
            next = next - 1;
        }

        result = max(result, min(abs(house - *next), abs(house - *prev)));
    }
    return result;
}


/// <summary>
/// Leet code #364. Nested List Weight Sum II   
/// </summary>
int LeetCodeArray::countDepth(vector<NestedInteger>& nestedList)
{
    int depth = 1;
    for (NestedInteger ni : nestedList)
    {
        if (ni.isInteger()) continue;
        vector<NestedInteger> nextList = ni.getList();
        depth = max(depth, 1 + countDepth(nextList));
    }
    return depth;
}

/// <summary>
/// Leet code #364. Nested List Weight Sum II   
/// </summary>
int LeetCodeArray::depthSumInverse(vector<NestedInteger>& nestedList, int depth)
{
    int sum = 0;
    for (NestedInteger ni : nestedList)
    {
        if (ni.isInteger())
        {
            sum += ni.getInteger() * depth;
        }
        else
        {
            vector<NestedInteger> nextList = ni.getList();
            sum += depthSumInverse(nextList, depth - 1);
        }
    }
    return sum;
}

/// <summary>
/// Leet code #364. Nested List Weight Sum II  
/// 
/// Given a nested list of integers, return the sum of all integers in the list weighted by their depth.
/// Each element is either an integer, or a list -- whose elements may also be integers or other lists.
/// Different from the previous question where weight is increasing from root to leaf, now the weight is 
/// defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight.
/// Example 1:
/// Given the list [[1,1],2,[1,1]], return 10. (four 1's at depth 2, one 2 at depth 1)
/// Example 2:
/// Given the list [1,[4,[6]]], return 27. (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4*2 + 6*3 = 27) 
/// </summary>
int LeetCodeArray::depthSumInverse(vector<NestedInteger>& nestedList)
{
    int depth = countDepth(nestedList);
    return depthSumInverse(nestedList, depth);
}

/// <summary>
/// Leet code #289. Game of Life 
///
/// According to the Wikipedia's article: "The Game of Life, also known 
/// simply as Life, is a cellular automaton devised by the British 
/// mathematician John Horton Conway in 1970." 
/// Given a board with m by n cells, each cell has an initial state 
/// live (1) or dead (0). 
/// Each cell interacts with its eight neighbors (horizontal, vertical, 
/// diagonal) using the 
/// following four rules (taken from the above Wikipedia article): 	
/// 1.Any live cell with fewer than two live neighbors dies, as if caused 
///   by under-population.
/// 2.Any live cell with two or three live neighbors lives on to the next 
///   generation.
/// 3.Any live cell with more than three live neighbors dies, as if by 
///   over-population..
/// 4.Any dead cell with exactly three live neighbors becomes a live cell, 
///   as if by reproduction.
/// Write a function to compute the next state (after one update) of the 
/// board given its current state.
/// Follow up: 
/// 1.Could you solve it in-place? Remember that the board needs to be 
///   updated at the same time: You cannot update some cells first and 
///   then use their updated values to update other cells.
/// 2.In this question, we represent the board using a 2D array. In 
///   principle, the board is infinite, which would cause problems when 
///   the active area encroaches the border of the array. How would you 
///   address these problems?
/// </summary>
void LeetCodeArray::gameOfLife(vector<vector<int>>& board)
{
    for (int i = 0; i < (int)board.size(); i++)
    {
        for (int j = 0; j < (int)board[i].size(); j++)
        {
            int count = 0;
            int next = 0;
            if (i > 0)
            {
                count += (board[i - 1][j]) % 10;
                if (j > 0) count += board[i - 1][j - 1] % 10;
                if (j < (int)board[i].size() - 1) count += board[i - 1][j + 1] % 10;
            }
            if (i < (int)board.size() - 1)
            {
                count += (board[i + 1][j]) % 10;
                if (j > 0) count += board[i + 1][j - 1] % 10;
                if (j < (int)board[i].size() - 1) count += board[i + 1][j + 1] % 10;
            }
            if (j > 0) count += board[i][j - 1] % 10;
            if (j < (int)board[i].size() - 1) count += board[i][j + 1] % 10;
            // 1. Any live cell with fewer than two live neighbors dies, as if caused by under-population.
            if ((count < 2) && (board[i][j] % 10 == 1))
            {
                next = 0;
            }
            // 2. Any live cell with two or three live neighbors lives on to the next generation.
            else if (((count == 2) || (count == 3)) && (board[i][j] % 10 == 1))
            {
                next = 1;
            }
            // 3. Any live cell with more than three live neighbors dies, as if by over-population.
            else if ((count > 3) && (board[i][j] % 10 == 1))
            {
                next = 0;
            }
            // 4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.
            else if ((count == 3) && (board[i][j] % 10 == 0))
            {
                next = 1;
            }
            board[i][j] = next * 10 + board[i][j];
        }
    }

    for (size_t i = 0; i < board.size(); i++)
    {
        for (size_t j = 0; j < board[i].size(); j++)
        {
            board[i][j] /= 10;
        }
    }
}

/// <summary>
/// Leet code #311. Sparse Matrix Multiplication       
/// 
/// Given two sparse matrices A and B, return the result of AB.
/// You may assume that A's column number is equal to B's row number.
/// Example:
/// A = 
/// [
///  [ 1, 0, 0],
///  [-1, 0, 3]
/// ]
/// B = 
/// [
///  [ 7, 0, 0 ],
///  [ 0, 0, 0 ],
///  [ 0, 0, 1 ]
/// ]
///
///      |  1 0 0 |   | 7 0 0 |   |  7 0 0 |
/// AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |
///                   | 0 0 1 |
/// </summary>
vector<vector<int>> LeetCodeArray::multiply(vector<vector<int>>& A, vector<vector<int>>& B)
{
    if (A.size() == 0 || A[0].size() == 0 || B.size() == 0 || B[0].size() == 0)
    {
        return vector<vector<int>>();
    }
    vector<map<int, int>> matrixA(A.size()), matrixB(B[0].size());
    vector<vector<int>> C(A.size(), vector<int>(B.size()));
    for (size_t i = 0; i < A.size(); i++)
    {
        for (size_t j = 0; j < A[i].size(); j++)
        {
            if (A[i][j] != 0) matrixA[i][j] = A[i][j];
        }
    }
    for (size_t i = 0; i < B.size(); i++)
    {
        for (size_t j = 0; j < B[i].size(); j++)
        {
            if (B[i][j] != 0) matrixB[i][j] = B[i][j];
        }
    }
    for (size_t i = 0; i < matrixA.size(); i++)
    {
        int rowA = i;
        for (auto& itrA : matrixA[i])
        {
            int colA = itrA.first;
            int valA = itrA.second;
            int rowB = colA;
            for (auto &itrB : matrixB[rowB])
            {
                int colB = itrB.first;
                int valB = itrB.second;
                C[rowA][colB] += valA * valB;
            }
        }
    }
    return C;
}


/// <summary>
/// Leet code #498. Diagonal Traverse
/// 
/// Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix 
/// in diagonal order as shown in the below image. 
///
/// Example:
///
/// Input:
/// [
///   [ 1, 2, 3 ],
///   [ 4, 5, 6 ],
///   [ 7, 8, 9 ]
/// ]
/// Output:  [1,2,4,7,5,3,6,8,9]
/// Explanation:
/// Note:
/// 1.The total number of elements of the given matrix will not exceed 10,000.
/// </summary>
vector<int> LeetCodeArray::findDiagonalOrder(vector<vector<int>>& matrix)
{
    int direction = 1;
    pair<int, int> pos = { 0,0 };
    vector<int> result;
    if ((matrix.size() == 0) || (matrix[0].size() == 0)) return result;
    while (result.size() < matrix.size() * matrix[0].size())
    {
        result.push_back(matrix[pos.first][pos.second]);
        if (direction == 1)
        {
            if ((pos.first > 0) && (pos.second < (int)matrix[0].size() - 1))
            {
                pos.first--;
                pos.second++;
            }
            else
            {
                if (pos.second < (int)matrix[0].size() - 1)
                {
                    pos.second++;
                }
                else if (pos.first < (int)matrix.size() - 1)
                {
                    pos.first++;
                }
                direction = 0 - direction;
            }
        }
        else
        {
            if ((pos.first < (int)matrix.size() - 1) && (pos.second > 0))
            {
                pos.first++;
                pos.second--;
            }
            else
            {
                if (pos.first < (int)matrix.size() - 1)
                {
                    pos.first++;
                }
                else if (pos.second < (int)matrix[0].size() - 1)
                {
                    pos.second++;
                }
                direction = 0 - direction;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code # 531. Lonely Pixel I
///
/// Given a picture consisting of black and white pixels,
///	find the number of black lonely pixels.
///
/// The picture is represented by a 2D char array consisting
/// of 'B' and 'W', which means black and white pixels respectively.
///
/// A black lonely pixel is character 'B' that located at a specific 
/// position where the same row and same column don't have any 
/// other black pixels.
///
/// Example:
/// Input: 
/// [
///   ['W', 'W', 'B'],
///   ['W', 'B', 'W'],
///   ['B', 'W', 'W']
/// ]
///
/// Output: 3
/// Explanation: All the three 'B's are black lonely pixels.
/// Note:
/// The range of width and height of the input 2D array is [1,500].
/// </summary>
int LeetCodeArray::findLonelyPixel(vector<vector<char>>& picture)
{
    if (picture.empty() || picture[0].empty()) return 0;
    vector<vector<int>> row_map(picture.size());
    vector<vector<int>> col_map(picture[0].size());
    for (size_t i = 0; i < picture.size(); i++)
    {
        for (size_t j = 0; j < picture[i].size(); j++)
        {
            if (picture[i][j] == 'B')
            {
                row_map[i].push_back(j);
                col_map[j].push_back(i);
            }
        }
    }
    int result = 0;
    for (size_t i = 0; i < row_map.size(); i++)
    {
        if (row_map[i].size() == 1)
        {
            int j = row_map[i][0];
            if ((col_map[j].size() == 1) && (col_map[j][0] == i))
            {
                result++;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code # 533. Lonely Pixel II
///
/// Given a picture consisting of black and white pixels, and a positive 
/// integer N, find the number of black pixels located at some specific 
/// row R and column C that align with all the following rules:
///
/// Row R and column C both contain exactly N black pixels.
/// For all rows that have a black pixel at column C, they should be 
/// exactly the same as row R
///
/// The picture is represented by a 2D char array consisting of 'B' and 'W', 
/// which means black and white pixels respectively.
///
/// Example:
/// Input:                                            
/// [
///   ['W', 'B', 'W', 'B', 'B', 'W'],    
///   ['W', 'B', 'W', 'B', 'B', 'W'],    
///   ['W', 'B', 'W', 'B', 'B', 'W'],    
///   ['W', 'W', 'B', 'W', 'B', 'W']
/// ] 
///
/// N = 3
/// Output: 6
/// Explanation: All the bold 'B' are the black pixels we need 
/// (all 'B's at column 1 and 3).
///        0    1    2    3    4    5         column index                                            
/// 0    [['W', 'B', 'W', 'B', 'B', 'W'],    
/// 1     ['W', 'B', 'W', 'B', 'B', 'W'],    
/// 2     ['W', 'B', 'W', 'B', 'B', 'W'],    
/// 3     ['W', 'W', 'B', 'W', 'B', 'W']]    
/// row index
///
/// Take 'B' at row R = 0 and column C = 1 as an example:
/// Rule 1, row R = 0 and column C = 1 both have exactly N = 3 black pixels. 
/// Rule 2, the rows have black pixel at column C = 1 are row 0, row 1 and 
/// row 2. They are exactly the same as row R = 0.
///
/// Note:
/// The range of width and height of the input 2D array is [1,200].	
/// </summary>
int LeetCodeArray::findLonelyPixel(vector<vector<char>>& picture, int N)
{
    if (picture.empty() || picture[0].empty()) return 0;
    vector<vector<int>> row_map(picture.size());
    vector<vector<int>> col_map(picture[0].size());
    for (size_t i = 0; i < picture.size(); i++)
    {
        for (size_t j = 0; j < picture[i].size(); j++)
        {
            if (picture[i][j] == 'B')
            {
                row_map[i].push_back(j);
                col_map[j].push_back(i);
            }
        }
    }

    int result = 0;
    for (size_t i = 0; i < col_map.size(); i++)
    {
        if (col_map[i].size() != N) continue;
        vector<int> first_row;
        for (size_t j = 0; j < col_map[i].size(); j++)
        {
            if (first_row.empty())
            {
                if (row_map[col_map[i][j]].size() != N)
                {
                    result -= N;
                    break;
                }
                first_row = row_map[col_map[i][j]];
            }
            else if (row_map[col_map[i][j]] != first_row)
            {
                result -= N;
                break;
            }
        }
        result += N;
    }
    return result;
}

/// <summary>
/// Leet code #539. Minimum Time Difference
///
/// Given a list of 24-hour clock time points in "Hour:Minutes" format, 
/// find the minimum minutes difference between any two time points in 
/// the list.
/// 
/// Example 1:
/// Input: ["23:59","00:00"]
/// Output: 1
/// Note:
/// The number of time points in the given list is at least 2 and won't exceed 20000.
/// The input time is legal and ranges from 00:00 to 23:59.
/// </summary>
int LeetCodeArray::findMinDifference(vector<string>& timePoints)
{
    priority_queue<int> time_line;
    for (size_t i = 0; i < timePoints.size(); i++)
    {
        string time_stamp = timePoints[i];
        size_t index = 0;
        string str;
        while (time_stamp[index] != ':')
        {
            str.push_back(time_stamp[index]);
            index++;
        }
        index++;
        int minutes = atoi(str.c_str()) * 60;
        str.clear();
        while (index != time_stamp.size())
        {
            str.push_back(time_stamp[index]);
            index++;
        }
        minutes += atoi(str.c_str());
        time_line.push(minutes);
    }
    int first = time_line.top();
    int prev = first;
    time_line.pop();
    int diff = INT_MAX;
    while (!time_line.empty())
    {
        int curr = time_line.top();
        time_line.pop();
        diff = min(diff, prev - curr);
        prev = curr;
    }
    diff = min(diff, prev + 24 * 60 - first);
    return diff;
}

/// <summary>
/// Leet code # 363. Max Sum of Rectangle No Larger Than K  
///
/// Given a non-empty 2D matrix matrix and an integer k, find the max sum of a 
/// rectangle in the matrix such that its sum is no larger than k.
/// 
/// Example:
/// Given matrix = 
/// [
///  [1,  0, 1],
///  [0, -2, 3]
/// ]
/// k = 2
/// The answer is 2. Because the sum of rectangle [[0, 1], [-2, 3]] is 2 and 2 is the max number no larger than k (k = 2).
/// Note:
/// 1.The rectangle inside the matrix must have an area > 0.
/// 2.What if the number of rows is much larger than the number of columns?
/// </summary>
int LeetCodeArray::maxSumSubmatrix(vector<vector<int>>& matrix, int k)
{
    int max_value = INT_MIN;
    if (matrix.empty() || matrix[0].empty()) return 0;
    vector<vector<int>>sum(matrix.size(), vector<int>(matrix[0].size()));
    for (size_t col1 = 0; col1 < matrix[0].size(); col1++)
    {
        vector<int> sum(matrix.size());
        for (size_t col2 = col1; col2 < matrix[0].size(); col2++)
        {
            set<int> accumulate_set;
            accumulate_set.insert(0);
            int accumulate = 0;
            for (size_t row = 0; row < matrix.size(); row++)
            {
                sum[row] += matrix[row][col2];
                accumulate += sum[row];
                set<int>::iterator itr = accumulate_set.lower_bound(accumulate - k);
                if (itr != accumulate_set.end())
                {
                    max_value = max(max_value, accumulate - *itr);
                    if (max_value == k) return max_value;
                }
                accumulate_set.insert(accumulate);
            }
        }
    }
    return max_value;
}

/// <summary>
/// Leet code #548. Split Array with Equal Sum       
/// 
/// Given an array with n integers, you need to find if there are 
/// triplets (i, j, k) which satisfies following conditions:
/// 0 < i, i + 1 < j, j + 1 < k < n - 1
/// Sum of subarrays (0, i - 1), (i + 1, j - 1), (j + 1, k - 1) 
/// and (k + 1, n - 1) should be equal.
/// where we define that subarray (L, R) represents a slice of the 
/// original array starting from the element indexed L to the element 
/// indexed R.
/// Example:
/// Input: [1,2,1,2,1,2,1]
/// Output: True
/// Explanation:
/// i = 1, j = 3, k = 5. 
/// sum(0, i - 1) = sum(0, 0) = 1
/// sum(i + 1, j - 1) = sum(2, 2) = 1
/// sum(j + 1, k - 1) = sum(4, 4) = 1
/// sum(k + 1, n - 1) = sum(6, 6) = 1
/// Note:
/// 1 <= n <= 2000.
/// Elements in the given array will be in range [-1,000,000, 1,000,000].
/// </summary>
bool LeetCodeArray::splitArray(vector<int>& nums)
{
    vector<int> sum(nums.size());
    for (int i = 0; i < (int)nums.size(); i++)
    {
        if (i == 0) sum[i] = nums[i];
        else (sum[i] = sum[i - 1] + nums[i]);
    }

    for (int j = 3; j < (int)nums.size() - 3; j++)
    {
        unordered_set<int> sum_set;
        for (int i = 1; i < j - 1; i++)
        {
            if (sum[i - 1] == sum[j - 1] - sum[i])
            {
                sum_set.insert(sum[i - 1]);
            }
        }
        for (int k = j + 2; k < (int)nums.size() - 1; k++)
        {
            if (sum[k - 1] - sum[j] == sum[sum.size() - 1] - sum[k])
            {
                if (sum_set.count(sum[k - 1] - sum[j]) > 0)
                {
                    return true;
                }
            }
        }
    }
    return false;
}

/// <summary>
/// Leet code #566. Reshape the Matrix       
/// 
/// In MATLAB, there is a very useful function called 'reshape', which 
/// can reshape a matrix into a new one with different size but keep its 
/// original data. 
/// You're given a matrix represented by a two-dimensional array, and two 
/// positive integers r and c representing the row number and column number 
/// of the wanted reshaped matrix, respectively.
/// The reshaped matrix need to be filled with all the elements of the 
/// original matrix in the same row-traversing order as they were. 
/// If the 'reshape' operation with given parameters is possible and legal, 
/// output the new reshaped matrix; Otherwise, output the original matrix. 
/// Example 1:
/// Input: 
/// nums = 
/// [[1,2],
/// [3,4]]
/// r = 1, c = 4
/// Output: 
/// [[1,2,3,4]]
/// Explanation:
/// The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 
/// 1 * 4 matrix, fill it row by row by using the previous list.
///
/// Example 2:
/// Input: 
/// nums = 
/// [[1,2],
/// [3,4]]
/// r = 2, c = 4
/// Output: 
/// [[1,2],
/// [3,4]]
/// Explanation:
/// There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output 
/// the original matrix.
/// </summary>
vector<vector<int>> LeetCodeArray::matrixReshape(vector<vector<int>>& nums, int r, int c)
{
    if (nums.empty() || nums[0].empty())
    {
        return nums;
    }
    if (nums.size() * nums[0].size() != r * c)
    {
        return nums;
    }
    vector<vector<int>> result(r, vector<int>(c));
    for (size_t i = 0; i < nums.size(); i++)
    {
        for (size_t j = 0; j < nums[0].size(); j++)
        {
            int index = i * nums[0].size() + j;
            int row = index / c;
            int col = index % c;
            result[row][col] = nums[i][j];
        }
    }
    return result;
}


/// <summary>
/// Leet code #565. Array Nesting   
/// 
/// A zero-indexed array A consisting of N different integers is given. 
/// The array contains all integers in the range [0, N - 1]. 
/// Sets S[K] for 0 <= K < N are defined as follows:
/// S[K] = { A[K], A[A[K]], A[A[A[K]]], ... }.
/// Sets S[K] are finite for each K and should NOT contain duplicates.
/// Write a function that given an array A consisting of N integers, 
/// return the size of the largest set S[K] for this array.
/// Example 1:
/// Input: A = [5,4,0,3,1,6,2]
/// Output: 4
/// Explanation: 
/// A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.
///
/// One of the longest S[K]:
/// S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}
/// 
/// Note:
/// N is an integer within the range [1, 20,000].
/// The elements of A are all distinct.
/// Each element of array A is an integer within the range [0, N-1].
/// </summary>
int LeetCodeArray::arrayNesting(vector<int>& nums)
{
    vector<int> lens(nums.size());
    int max_length = 0;

    for (size_t i = 0; i < nums.size(); i++)
    {
        if (lens[i] != 0) continue;

        unordered_set<int> nums_set;
        vector<int> nums_list;
        int index = i;
        while ((nums_set.count(index) == 0) && (lens[index] == 0))
        {
            nums_set.insert(index);
            nums_list.push_back(index);
            index = nums[index];
        }
        int base = lens[index];
        for (int num : nums_list)
        {
            lens[num] = nums_list.size() + base;
        }
        max_length = max(max_length, lens[nums_list[0]]);
    }
    return max_length;
}

/// <summary>
/// Leet code #605. Can Place Flowers    
/// 
/// Suppose you have a long flowerbed in which some of the plots are 
/// planted and some are not. However, flowers cannot be planted in 
/// adjacent plots - they would compete for water and both would die.
/// Given a flowerbed (represented as an array containing 0 and 1, 
/// where 0 means empty and 1 means not empty), and a number n, return
/// if n new flowers can be planted in it without violating the 
/// no-adjacent-flowers rule.
/// Example 1:
/// Input: flowerbed = [1,0,0,0,1], n = 1
/// Output: True
///
/// Example 2:
/// Input: flowerbed = [1,0,0,0,1], n = 2
/// Output: False
/// 
/// Note:
/// 1. The input array won't violate no-adjacent-flowers rule.
/// 2. The input array size is in the range of [1, 20000].
/// 3. n is a non-negative integer which won't exceed the input array size.
/// </summary>
bool LeetCodeArray::canPlaceFlowers(vector<int>& flowerbed, int n)
{
    int zero_count = 0;
    for (size_t i = 0; i < flowerbed.size(); i++)
    {
        if (flowerbed[i] == 0) zero_count++;
        else
        {
            if (zero_count == i)
            {
                n -= zero_count / 2;
            }
            else
            {
                n -= (zero_count - 1) / 2;
            }
            zero_count = 0;
        }
    }
    if (zero_count == flowerbed.size())
    {
        n -= (zero_count + 1) / 2;
    }
    else
    {
        n -= zero_count / 2;
    }
    if (n <= 0) return true;
    else return false;
}

/// <summary>
/// Leet code #624. Maximum Distance in Arrays
/// 
/// Given m arrays, and each array is sorted in ascending order. Now you 
/// can pick up two integers from two different arrays (each array picks 
/// one) and calculate the distance. We define the distance between two 
/// integers a and b to be their absolute difference |a-b|. Your task 
/// is to find the maximum distance. 
/// Example 1:
/// Input: 
/// [
///   [1,2,3],
///   [4,5],
///   [1,2,3]
/// ]
/// Output: 4
/// Explanation: 
/// One way to reach the maximum distance 4 is to pick 1 in the first or 
/// third array and pick 5 in the second array.
/// Note:
/// 1.Each given array will have at least 1 number. There will be at least 
///   two non-empty arrays.
/// 2.The total number of the integers in all the m arrays will be in the 
///   range of [2, 10000].
/// 3.The integers in the m arrays will be in the range of [-10000, 10000].
/// </summary>
int LeetCodeArray::maxDistance(vector<vector<int>>& arrays)
{
    priority_queue<pair<int, int>> min_queue, max_queue;
    int max_distance;
    for (size_t i = 0; i < arrays.size(); i++)
    {
        if (arrays[i].empty()) continue;
        min_queue.push(make_pair(arrays[i][0], i));
        max_queue.push(make_pair(-arrays[i][arrays[i].size() - 1], i));
        if (min_queue.size() > 2) min_queue.pop();
        if (max_queue.size() > 2) max_queue.pop();
    }
    vector<pair<int, int>> min_pairs, max_pairs;
    for (size_t i = 0; i < 2; i++)
    {
        min_pairs.push_back(min_queue.top());
        min_queue.pop();
        max_pairs.push_back(max_queue.top());
        max_queue.pop();
    }

    if (min_pairs[1].second != max_pairs[1].second)
    {
        max_distance = abs((int)(min_pairs[1].first + max_pairs[1].first));
    }
    else
    {
        max_distance = max(abs((int)(min_pairs[1].first + max_pairs[0].first)), abs((int)(min_pairs[0].first + max_pairs[1].first)));
    }
    return max_distance;
}

/// <summary>
/// Leet code #644. Maximum Average Subarray II
/// </summary>
double LeetCodeArray::density(vector<double>& sum, int l, int r)
{
    if (l == 0)
    {
        return sum[r] / ((double)r + 1);
    }
    else
    {
        return (sum[r] - sum[l - 1]) / ((double)r - (double)l + 1);
    }
}

/// <summary>
/// Leet code #644. Maximum Average Subarray II
/// 
/// Given an array consisting of n integers, find the contiguous subarray 
/// whose length is greater than or equal to k that has the maximum average 
/// value. And you need to output the maximum average value. 
///
/// Example 1:
/// Input: [1,12,-5,-6,50,3], k = 4
/// Output: 12.75
/// Explanation:
/// when length is 5, maximum average value is 10.8,
/// when length is 6, maximum average value is 9.16667.
/// Thus return 12.75.
///
/// Note:
/// 1 <= k <= n <= 10,000.
/// Elements of the given array will be in range [-10,000, 10,000].
/// The answer with the calculation error less than 10^-5 will be accepted.
/// </summary>
double LeetCodeArray::findMaxAverageII(vector<int>& nums, int k)
{
    int n = nums.size();
    vector<double> sum(n, 0);
    for (int i = 0; i < n; i++)
    {
        // sum[i] is accumulated sum
        sum[i] += nums[i];
        if (i > 0) sum[i] += sum[i - 1];
    }

    deque<int> q;
    double result = sum[n - 1] / n;
    for (int j = k - 1; j < n; ++j)
    {
        while (q.size() >= 2 && density(sum, q[q.size() - 2], q.back() - 1) >= density(sum, q.back(), j - k))
        {
            q.pop_back();
        }
        q.push_back(j - k + 1);
        while (q.size() >= 2 && density(sum, q[0], j) <= density(sum, q[1], j))
        {
            q.pop_front();
        }
        result = max(result, density(sum, q.front(), j));
    }
    return result;
}

/// <summary>
/// Leet code #645. Set Mismatch
/// 
/// The set S originally contains numbers from 1 to n. But unfortunately, 
/// due to the data error, one of the numbers in the set got duplicated 
/// to another number in the set, which results in repetition of one number
/// and loss of another number. 
/// Given an array nums representing the data status of this set after the 
/// error. Your task is to firstly find the number occurs twice and then 
/// find the number that is missing. Return them in the form of an array. 
///
/// Example 1:
/// Input: nums = [1,2,2,4]
/// Output: [2,3]
/// Note:
/// The given array size will in the range [2, 10000].
/// The given array's numbers won't have any order.
/// </summary>
vector<int> LeetCodeArray::findErrorNums(vector<int>& nums)
{
    vector<int> result(2);
    unordered_map<int, int> num_map;
    for (size_t i = 0; i < nums.size(); i++) num_map[nums[i]]++;
    for (size_t i = 1; i <= nums.size(); i++)
    {
        if (num_map.count(i) == 0) result[1] = i;
        else if (num_map[i] > 1)  result[0] = i;
    }
    return result;
}

/// <summary>
/// Leet code #649. Dota2 Senate
/// 
/// In the world of Dota2, there are two parties: the Radiant and the Dire. 
/// The Dota2 senate consists of senators coming from two parties. Now the 
/// senate wants to make a decision about a change in the Dota2 game. The 
/// voting for this change is a round-based procedure. In each round, each 
/// senator can exercise one of the two rights: 
/// 1. Ban one senator's right: 
///    A senator can make another senator lose all his rights in this and 
///    all the following rounds.
/// 2. Announce the victory: 
///    If this senator found the senators who still have rights to vote are 
///    all from the same party, he can announce the victory and make the 
///    decision about the change in the game.
///
/// Given a string representing each senator's party belonging. The 
/// character 'R' and 'D' represent the Radiant party and the Dire party 
/// respectively. Then if there are n senators, the size of the given 
/// string will be n. 
/// The round-based procedure starts from the first senator to the last 
/// senator in the given order. This procedure will last until the end of 
/// voting. All the senators who have lost their rights will be skipped 
/// during the procedure. 
/// Suppose every senator is smart enough and will play the best strategy 
/// for his own party, you need to predict which party will finally 
/// announce the victory and make the change in the Dota2 game. The output 
/// should be Radiant or Dire. 
/// Example 1:
/// Input: "RD"
/// Output: "Radiant"
/// Explanation: The first senator comes from Radiant and he can just ban 
/// the next senator's right in the round 1. 
/// And the second senator can't exercise any rights any more since his 
/// right has been banned. 
/// And in the round 2, the first senator can just announce the victory 
/// since he is the only guy in the senate who can vote.
///
/// Example 2:
/// Input: "RDD"
/// Output: "Dire"
/// Explanation: 
/// The first senator comes from Radiant and he can just ban the next 
/// senator's right in the round 1. 
/// And the second senator can't exercise any rights anymore since his 
/// right has been banned. 
/// And the third senator comes from Dire and he can ban the first 
/// senator's right in the round 1. 
/// And in the round 2, the third senator can just announce the victory 
/// since he is the only guy in the senate who can vote.
///
/// Note:
/// The length of the given string will in the range [1, 10,000].
/// </summary>
string LeetCodeArray::predictPartyVictory(string senate)
{
    vector<int> count_map(2);
    while (true)
    {
        string temp;
        for (auto ch : senate)
        {
            int index = (ch == 'R' ? 0 : 1);
            if (count_map[index] > 0)
            {
                count_map[index]--;
            }
            else
            {
                temp.push_back(ch);
                count_map[1 - index]++;
            }
        }
        if (temp.size() == senate.size()) break;
        senate = temp;
    }
    if (senate[0] == 'D') return "Dire";
    else return "Radiant";
}

/// <summary>
/// Leet code #661. Image Smoother 
/// 
/// Given a 2D integer matrix M representing the gray scale of an image, 
/// you need to design a smoother to make the gray scale of each cell 
/// becomes the average gray scale (rounding down) of all the 8 
/// surrounding cells and itself. If a cell has less than 8 surrounding 
/// cells, then use as many as you can.
/// Example 1:
/// Input:
/// [
///   [1,1,1],
///   [1,0,1],
///   [1,1,1]
/// ]
/// Output:
/// [
///   [0, 0, 0],
///   [0, 0, 0],
///   [0, 0, 0]
/// ]
/// Explanation:
/// For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0
/// For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = 
/// floor(0.83333333) = 0
/// For the point (1,1): floor(8/9) = floor(0.88888889) = 0
///
/// Note:
/// The value in the given matrix is in the range of [0, 255].
/// The length and width of the given matrix are in the range of [1, 150].
/// </summary>
vector<vector<int>> LeetCodeArray::imageSmoother(vector<vector<int>>& M)
{
    vector<vector<int>> result;
    vector<pair<int, int>> step_map =
    { { -1, -1 },{ 0, -1 },{ 1, -1 },{ -1, 0 },{ 0, 0 },{ 1, 0 },{ -1, 1, },{ 0, 1 },{ 1, 1 } };
    for (size_t i = 0; i < M.size(); i++)
    {
        result.push_back(vector<int>(M[i].size()));
        for (size_t j = 0; j < M[i].size(); j++)
        {
            int count = 0, sum = 0;
            for (size_t k = 0; k < step_map.size(); k++)
            {
                int y = i + step_map[k].second;
                int x = j + step_map[k].first;
                if (x < 0 || y < 0 || y >= (int)M.size() || x >= (int)M[i].size()) continue;
                sum += M[y][x];
                count++;
            }
            result[i][j] = sum / count;
        }
    }
    return result;
}

/// <summary>
/// Leet code #667. Beautiful Arrangement II 
/// 
/// Given two integers n and k, you need to construct a list which 
/// contains n different positive integers ranging from 1 to n and 
/// obeys the following requirement: 
/// Suppose this list is [a1, a2, a3, ... , an], then the list 
/// [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly 
/// k distinct integers.
///
/// If there are multiple answers, print any of them.
///
/// Example 1:
/// Input: n = 3, k = 1
/// Output: [1, 2, 3]
/// Explanation: The [1, 2, 3] has three different positive integers 
/// ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.
/// 
/// Example 2:
/// Input: n = 3, k = 2
/// Output: [1, 3, 2]
/// Explanation: The [1, 3, 2] has three different positive integers 
/// ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 
/// and 2.
/// Note:
/// 1. The n and k are in the range 1 <= k < n <= 104.
/// </summary>
vector<int> LeetCodeArray::constructArray(int n, int k)
{
    vector<int> result;
    int first = 1, last = n;

    for (int i = 0; i < n - 1 - k; i++)
    {
        result.push_back(first);
        first++;
    }
    while (first <= last)
    {
        result.push_back(first);
        first++;
        if (first <= last) result.push_back(last);
        last--;
    }
    return result;
}

/// <summary>
/// Leet code #238. Product of Array Except Self    
/// Given an array of n integers where n > 1, nums, return an array output such 
/// that output[i] is equal to the product of all the elements of nums except 
/// nums[i]. 
///
/// Solve it without division and in O(n). 
/// For example, given [1,2,3,4], return [24,12,8,6]. 
/// 
/// Follow up:
/// Could you solve it with constant space complexity? 
/// (Note: The output array does not count as extra space for the purpose of 
/// space complexity analysis.)
/// </summary>
vector<int> LeetCodeArray::productExceptSelf(vector<int>& nums)
{
    vector<int> result(nums.size());
    int product = 1;
    for (size_t i = 0; i < nums.size(); i++)
    {
        result[i] = product;
        product = product * nums[i];
    }
    product = 1;
    for (int i = nums.size() - 1; i >= 0; i--)
    {
        result[i] = result[i] * product;
        product *= nums[i];
    }
    return result;
}

/// <summary>
/// Leet code #682. Baseball Game
/// 
/// Given a list of strings, each string can be one of the 4 following 
/// types:
///
/// Integer (one round's score): Directly represents the number of points 
/// you get in this round.
/// "+" (one round's score): Represents that the points you get in this 
///  round are the sum of the last two valid round's points.
/// "D" (one round's score): Represents that the points you get in this 
/// round are the doubled data of the last valid round's points.
/// "C" (an operation, which isn't a round's score): Represents the last 
/// valid round's points you get were invalid and should be removed.
/// Each round's operation is permanent and could have an impact on the 
/// round before and the round after.
///
/// You need to return the sum of the points you could get in all the 
/// rounds.
///
/// Example 1:
/// Input: ["5","2","C","D","+"]
/// Output: 30
/// Explanation: 
/// Round 1: You could get 5 points. The sum is: 5.
/// Round 2: You could get 2 points. The sum is: 7.
/// Operation 1: The round 2's data was invalid. The sum is: 5.  
/// Round 3: You could get 10 points (the round 2's data has been 
/// removed). The sum is: 15.
/// Round 4: You could get 5 + 10 = 15 points. The sum is: 30.
/// Example 2:
/// Input: ["5","-2","4","C","D","9","+","+"]
/// Output: 27
/// Explanation: 
/// Round 1: You could get 5 points. The sum is: 5.
/// Round 2: You could get -2 points. The sum is: 3.
/// Round 3: You could get 4 points. The sum is: 7.
/// Operation 1: The round 3's data is invalid. The sum is: 3.  
/// Round 4: You could get -4 points (the round 3's data has been removed). 
/// The sum is: -1.
/// Round 5: You could get 9 points. The sum is: 8.
/// Round 6: You could get -4 + 9 = 5 points. The sum is 13.
/// Round 7: You could get 9 + 5 = 14 points. The sum is 27.
/// Note:
/// 1.The size of the input list will be between 1 and 1000.
/// 2.Every integer represented in the list will be between -30000 
///   and 30000.
/// </summary>
int LeetCodeArray::calPoints(vector<string>& ops)
{
    vector<int> nums;
    int sum = 0;
    for (size_t i = 0; i < ops.size(); i++)
    {
        if (ops[i] == "C")
        {
            if (!nums.empty())
            {
                sum -= nums.back();
                nums.pop_back();
            }
        }
        else if (ops[i] == "D")
        {
            if (!nums.empty())
            {
                nums.push_back(nums.back() * 2);
                sum += nums.back();
            }
        }
        else if (ops[i] == "+")
        {
            if (!nums.empty())
            {
                int sub_total = 0;
                for (int j = (int)nums.size() - 1; j >= 0 && j >= (int)nums.size() - 2; j--)
                {
                    sub_total += nums[j];
                }
                nums.push_back(sub_total);
                sum += nums.back();
            }
        }
        else
        {
            nums.push_back(atoi(ops[i].c_str()));
            sum += nums.back();
        }
    }
    return sum;
}

/// <summary>
/// Leet code #659. Split Array into Consecutive Subsequences 
/// 
/// You are given an integer array sorted in ascending order (may contain 
/// duplicates), you need to split them into several subsequences, where 
/// each subsequences consist of at least 3 consecutive integers. 
/// Return whether you can make such a split.
///
/// Example 1:
/// Input: [1,2,3,3,4,5]
/// Output: True
/// Explanation:
/// You can split them into two consecutive subsequences : 
/// 1, 2, 3
/// 3, 4, 5
///
/// Example 2:
/// Input: [1,2,3,3,4,4,5,5]
/// Output: True
/// Explanation:
/// You can split them into two consecutive subsequences : 
/// 1, 2, 3, 4, 5
/// 3, 4, 5
/// 
/// Example 3:
/// Input: [1,2,3,4,4,5]
/// Output: False
///
/// Note:
/// 1. The length of the input is in range of [1, 10000]
/// </summary>
bool LeetCodeArray::isPossible(vector<int>& nums)
{
    unordered_map<int, priority_queue<int, std::vector<int>, std::greater<int>>> heap_map;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (heap_map.count(nums[i] - 1) == 0)
        {
            heap_map[nums[i]].push(1);
        }
        else
        {
            int length = heap_map[nums[i] - 1].top();
            heap_map[nums[i] - 1].pop();
            if (heap_map[nums[i] - 1].empty())
            {
                heap_map.erase(nums[i] - 1);
            }
            heap_map[nums[i]].push(length + 1);
        }
    }

    for (auto &itr : heap_map)
    {
        if (itr.second.top() < 3) return false;
    }
    return true;
}

/// <summary>
/// Leet code #696. Count Binary Substrings
///
/// Give a string s, count the number of non-empty (contiguous) substrings 
/// that have the same number of 0's and 1's, and all the 0's and all the 
/// 1's in these substrings are grouped consecutively.
///
/// Substrings that occur multiple times are counted the number of times 
/// they occur.
///
/// Example 1:
/// Input: "00110011"
/// Output: 6
/// Explanation: There are 6 substrings that have equal number of 
/// consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01".
///
/// Notice that some of these substrings repeat and are counted the number 
/// of times they occur.
/// 
/// Also, "00110011" is not a valid substring because all the 0's 
/// (and 1's) are not grouped together.
/// Example 2:
/// Input: "10101"
/// Output: 4
/// Explanation: There are 4 substrings: "10", "01", "10", "01" that have 
/// equal number of consecutive 1's and 0's.
/// Note:
///
/// s.length will be between 1 and 50,000.
/// s will only consist of "0" or "1" characters.
/// </summary>
int LeetCodeArray::countBinarySubstrings(string s)
{
    int prev = 0, count = 0;
    int result = 0;
    for (size_t i = 0; i < s.size(); i++)
    {
        if ((i > 0) && (s[i] != s[i - 1]))
        {
            prev = count;
            count = 1;
        }
        else
        {
            count++;
        }
        if (prev >= count)
        {
            result++;
        }
    }
    return result;
}

/// <summary>
/// Leet code #697. Degree of an Array
///
/// Given a non-empty array of non-negative integers nums, the degree of 
/// this array is defined as the maximum frequency of any one of its 
/// elements.
/// 
/// Your task is to find the smallest possible length of a (contiguous) 
/// subarray of nums, that has the same degree as nums.
///
/// Example 1:
/// Input: [1, 2, 2, 3, 1]
/// Output: 2
/// Explanation: 
/// The input array has a degree of 2 because both elements 1 and 2 appear 
/// twice.
/// Of the subarrays that have the same degree:
/// [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
/// The shortest length is 2. So return 2.
///
/// Example 2:
/// Input: [1,2,2,3,1,4,2]
/// Output: 6
/// Note:
/// 
/// nums.length will be between 1 and 50,000.
/// nums[i] will be an integer between 0 and 49,999.
/// </summary>
int LeetCodeArray::findShortestSubArray(vector<int>& nums)
{
    int min_len = 0;
    int max_degree = 0;
    unordered_map<int, pair<int, int>> num_map;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (num_map.count(nums[i]) == 0)
        {
            num_map[nums[i]] = make_pair(i, 1);
        }
        else
        {
            num_map[nums[i]].second++;
        }

        if (num_map[nums[i]].second > max_degree)
        {
            max_degree = num_map[nums[i]].second;
            min_len = i - num_map[nums[i]].first + 1;
        }
        else if (num_map[nums[i]].second == max_degree)
        {
            min_len = min(min_len, (int)i - num_map[nums[i]].first + 1);
        }
    }
    return min_len;
}

/// <summary>
/// Leet code #717. 1-bit and 2-bit Characters
///
/// We have two special characters. The first character can be 
/// represented by one bit 0. The second character can be represented 
/// by two bits (10 or 11).
///
/// Now given a string represented by several bits. Return whether the 
/// last character must be a one-bit character or not. The given string 
/// will always end with a zero.
///
/// Example 1:
/// Input: 
/// bits = [1, 0, 0]
/// Output: True
/// Explanation: 
/// The only way to decode it is two-bit character and one-bit character. 
/// So the last character is one-bit character.
///
/// Example 2:
/// Input: 
/// bits = [1, 1, 1, 0]
/// Output: False
/// Explanation:  
/// The only way to decode it is two-bit character and two-bit character. 
/// So the last character is NOT one-bit character.
/// Note:
///
/// 1 <= len(bits) <= 1000.
/// bits[i] is always 0 or 1.
/// </summary>
bool LeetCodeArray::isOneBitCharacter(vector<int>& bits)
{
    for (size_t i = 0; i < bits.size(); i++)
    {
        // two bits
        if (bits[i] == 1)
        {
            i++;
        }
        else if (i == bits.size() - 1)
        {
            return true;
        }
    }
    return false;
}

/// <summary>
/// Leet code #723. Candy Crush
/// Count candy
/// </summary>
void LeetCodeArray::countCandy(vector<vector<int>>& board, vector<vector<pair<int, int>>>& match)
{
    for (size_t i = 0; i < board.size(); i++)
    {
        for (size_t j = 0; j < board[i].size(); j++)
        {
            int first = 0, second = 0;
            if (board[i][j] != 0)
            {
                if ((i == 0) || (board[i][j] != board[i - 1][j]))
                {
                    first = 1;
                }
                else
                {
                    first = match[i - 1][j].first + 1;
                }
                if ((j == 0) || (board[i][j] != board[i][j - 1]))
                {
                    second = 1;
                }
                else
                {
                    second = match[i][j - 1].second + 1;
                }
            }
            match[i][j] = make_pair(first, second);
        }
    }
}

/// <summary>
/// Leet code #723. Candy Crush
/// Remove candy
/// </summary>
bool LeetCodeArray::removeCandy(vector<vector<int>>& board, vector<vector<pair<int, int>>>& match)
{
    bool result = false;
    for (int i = match.size() - 1; i >= 0; i--)
    {
        for (int j = match[i].size() - 1; j >= 0; j--)
        {
            if (match[i][j].first >= 3)
            {
                int size = match[i][j].first;
                for (int k = 0; k < size; k++)
                {
                    board[i - k][j] = 0;
                    match[i - k][j].first = 0;
                    result = true;
                }
            }
            if (match[i][j].second >= 3)
            {
                int size = match[i][j].second;
                for (int k = 0; k < size; k++)
                {
                    board[i][j - k] = 0;
                    match[i][j - k].second = 0;
                    result = true;
                }
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #723. Candy Crush
/// Drop candy
/// </summary>
void LeetCodeArray::dropCandy(vector<vector<int>>& board)
{
    vector<int> bottom(board[0].size(), board.size() - 1);
    for (int i = board.size() - 1; i >= 0; i--)
    {
        for (int j = board[i].size() - 1; j >= 0; j--)
        {
            if (board[i][j] != 0)
            {
                if (i < bottom[j]) std::swap(board[i][j], board[bottom[j]][j]);
                bottom[j]--;
            }
        }
    }
}

/// <summary>
/// Leet code #723. Candy Crush
///
/// This question is about implementing a basic elimination algorithm for 
/// Candy Crush. 
/// 
/// Given a 2D integer array board representing the grid of candy, 
/// different positive integers board[i][j] represent different types of 
/// candies. A value of board[i][j] = 0 represents that the cell at 
/// position (i, j) is empty. The given board represents the state of the 
/// game following the player's move. Now, you need to restore the board 
/// to a stable state by crushing candies according to the following rules:
///
/// 1. If three or more candies of the same type are adjacent vertically or 
/// horizontally, "crush" them all at the same time - these positions 
/// become empty.
/// 2. After crushing all candies simultaneously, if an empty space on the 
/// board has candies on top of itself, then these candies will drop until 
/// they hit a candy or bottom at the same time. (No new candies will drop 
/// outside the top boundary.)
/// 3. After the above steps, there may exist more candies that can be 
/// crushed. If so, you need to repeat the above steps.
/// 4. If there does not exist more candies that can be crushed (ie. the board 
/// is stable), then return the current board.
/// 
/// You need to perform the above rules until the board becomes stable, 
/// then return the current board.
///
/// Example 1:
/// Input:
/// board = 
/// [[110,5,112,113,114],[210,211,5,213,214],[310,311,3,313,314],
/// [410,411,412,5,414], [5,1,512,3,3],[610,4,1,613,614],[710,1,2,713,714], 
/// [810,1,2,1,1],[1,1,2,2,2],[4,1,4,4,1014]]
/// Output:
/// [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[110,0,0,0,114],[210,0,0,0,214],
/// [310,0,0,113,314],[410,0,0,213,414],[610,211,112,313,614],
/// [710,311,412,613,714],[810,411,512,713,1014]]
/// Explanation: 
///
/// Note:
/// 1. The length of board will be in the range [3, 50].
/// 2. The length of board[i] will be in the range [3, 50].
/// Each board[i][j] will initially start as an integer in the range 
/// [1, 2000].
/// </summary>
vector<vector<int>> LeetCodeArray::candyCrush(vector<vector<int>>& board)
{
    vector<vector<pair<int, int>>> match(board.size(), vector<pair<int, int>>(board[0].size()));
    countCandy(board, match);
    while (removeCandy(board, match))
    {
        dropCandy(board);
        countCandy(board, match);
    }
    return board;
}

/// <summary>
/// Leet code #724. Find Pivot Index
///
/// Given an array of integers nums, write a method that returns the 
/// "pivot" index of this array.
///
/// We define the pivot index as the index where the sum of the numbers 
/// to the left of the index is equal to the sum of the numbers to the 
/// right of the index.
///
/// If no such index exists, we should return -1. If there are multiple 
/// pivot indexes, you should return the left-most pivot index.
///
/// Example 1:
/// Input: 
/// nums = [1, 7, 3, 6, 5, 6]
/// Output: 3
/// Explanation: 
/// The sum of the numbers to the left of index 3 (nums[3] = 6) is equal 
/// to the sum of numbers to the right of index 3.
/// Also, 3 is the first index where this occurs.
///
/// Example 2:
/// Input: 
/// nums = [1, 2, 3]
/// Output: -1
/// Explanation: 
/// There is no index that satisfies the conditions in the problem 
/// statement.
/// Note:
///
/// 1. The length of nums will be in the range [0, 10000].
/// 2. Each element nums[i] will be an integer in the range [-1000, 1000].
/// </summary>
int LeetCodeArray::pivotIndex(vector<int>& nums)
{
    if (nums.empty()) return -1;
    vector<int> sum(nums.size());
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (i == 0) sum[i] = nums[i];
        else sum[i] = sum[i - 1] + nums[i];
    }
    for (size_t i = 0; i < nums.size(); i++)
    {
        int left = 0;
        if (i != 0) left = sum[i - 1];
        if (left == sum[nums.size() - 1] - left - nums[i])
        {
            return (int)i;
        }
    }
    return -1;
}

/// <summary>
/// Leet code #750. Number Of Corner Rectangles
///
/// Given a grid where each entry is only 0 or 1, find the number of corner
/// rectangles.
/// A corner rectangle is 4 distinct 1s on the grid that form an 
/// axis-aligned rectangle. Note that only the corners need to have the 
/// value 1. Also, all four 1s used must be distinct.
///
/// Example 1:
/// Input: grid = 
/// [[1, 0, 0, 1, 0],
///  [0, 0, 1, 0, 1],
///  [0, 0, 0, 1, 0],
///  [1, 0, 1, 0, 1]]
/// Output: 1
/// Explanation: There is only one corner rectangle, with corners 
/// grid[1][2], grid[1][4], grid[3][2], grid[3][4].
/// Example 2:
/// Input: grid = 
/// [[1, 1, 1],
///  [1, 1, 1],
/// [1, 1, 1]]
/// Output: 9
/// Explanation: There are four 2x2 rectangles, four 2x3 and 3x2 
/// rectangles, and one 3x3 rectangle.
/// Example 3:
/// Input: grid = 
/// [[1, 1, 1, 1]]
/// Output: 0
/// Explanation: Rectangles must have four distinct corners.
/// Note:
/// 1. The number of rows and columns of grid will each be in the range 
///    [1, 200].
/// 2. Each grid[i][j] will be either 0 or 1.
/// 3. The number of 1s in the grid will be at most 6000.
/// </summary>
int LeetCodeArray::countCornerRectangles(vector<vector<int>>& grid)
{
    int result = 0;
    for (size_t i = 0; i < grid[0].size(); i++)
    {
        for (size_t j = i + 1; j < grid[0].size(); j++)
        {
            int count = 0;
            for (size_t k = 0; k < grid.size(); k++)
            {
                if (grid[k][i] == 1 && grid[k][j] == 1)
                {
                    count++;
                }
            }
            result += count * (count - 1) / 2;
        }
    }
    return result;
}

/// <summary>
/// Leet code #747. Largest Number Greater Than Twice of Others
///
/// In a given integer array nums, there is always exactly one largest 
/// element.
///
/// Find whether the largest element in the array is at least twice as 
/// much as every other number in the array.
///
/// If it is, return the index of the largest element, otherwise return -1.
///
/// Example 1:
/// Input: nums = [3, 6, 1, 0]
/// Output: 1
/// Explanation: 6 is the largest integer, and for every other number in 
/// the array x,
/// 6 is more than twice as big as x.  The index of value 6 is 1, so we 
/// return 1.
/// Example 2:
/// Input: nums = [1, 2, 3, 4]
/// Output: -1
/// Explanation: 4 isn't at least as big as twice the value of 3, so we 
/// return -1.
/// Note:
/// nums will have a length in the range [1, 50].
/// Every nums[i] will be an integer in the range [0, 99].
/// </summary>
int LeetCodeArray::dominantIndex(vector<int>& nums)
{
    multiset<int> double_num;
    int max_index = -1;
    int max_num = INT_MIN;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (max_num < nums[i])
        {
            max_index = i;
            max_num = nums[i];
        }
        double_num.insert(nums[i] * 2);
        if (double_num.size() > 2) double_num.erase(double_num.begin());
    }
    if (max_num >= *double_num.begin()) return max_index;
    else return -1;
}

/// <summary>
/// Leet code #766. Toeplitz Matrix
///
/// A matrix is Toeplitz if every diagonal from top-left to bottom-right 
/// has the same element.
///
/// Now given an M x N matrix, return True if and only if the matrix is 
/// Toeplitz.
///
///
/// Example 1:
///
/// Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]
/// Output: True
/// Explanation:
/// 1234
/// 5123
/// 9512
///
/// In the above grid, the diagonals are "[9]", "[5, 5]", "[1, 1, 1]", 
/// "[2, 2, 2]", "[3, 3]", "[4]", and in each diagonal all elements are 
/// the same, so the answer is True.
///
/// Example 2:
///
/// Input: matrix = [[1,2],[2,2]]
/// Output: False
/// Explanation:
/// The diagonal "[1, 2]" has different elements.
/// Note:
/// 1. matrix will be a 2D array of integers.
/// 2. matrix will have a number of rows and columns in range [1, 20].
/// 3. matrix[i][j] will be integers in range [0, 99].
/// </summary>
bool LeetCodeArray::isToeplitzMatrix(vector<vector<int>>& matrix)
{
    if (matrix.empty() || matrix[0].empty()) return false;
    for (size_t i = 1; i < matrix.size(); i++)
    {
        for (size_t j = 1; j < matrix[i].size(); j++)
        {
            if (matrix[i][j] != matrix[i - 1][j - 1])
            {
                return false;
            }
        }
    }
    return true;
}

/// <summary>
/// Leetcode #779. K-th Symbol in Grammar
///
/// On the first row, we write a 0. Now in every subsequent row, we look 
/// at the previous row and replace each occurrence of 0 with 01, and each 
/// occurrence of 1 with 10.
///
/// Given row N and index K, return the K-th indexed symbol in row N. 
/// (The values of K are 1-indexed.) (1 indexed).
///
/// Examples:
/// Input: N = 1, K = 1
/// Output: 0
/// 
/// Input: N = 2, K = 1
/// Output: 0
///
/// Input: N = 2, K = 2
/// Output: 1
///
/// Input: N = 4, K = 5 
/// Output: 1
/// 
/// Explanation:
/// row 1: 0
/// row 2: 01
/// row 3: 0110
/// row 4: 01101001
/// row 5: 0110100110010110
/// Note:
/// 1. N will be an integer in the range [1, 30].
/// 2. K will be an integer in the range [1, 2^(N-1)].
/// </summary>
int LeetCodeArray::kthGrammar(int N, int K)
{
    int length = (int)pow(2, N - 1);
    int index = K - 1;
    int result = 0;
    while (N > 1)
    {
        int half = length / 2;
        if (index >= length / 2)
        {
            index = index - length / 2;
            result ^= 1;
        }
        length /= 2;
        N--;
    }
    return result;
}

/// <summary>
/// Leet code #807. Max Increase to Keep City Skyline
/// 
/// In a 2 dimensional array grid, each value grid[i][j] represents the 
/// height of a building located there. We are allowed to increase the 
/// height of any number of buildings, by any amount (the amounts can be 
/// different for different buildings). Height 0 is considered to be a 
/// building as well. 
///
/// At the end, the "skyline" when viewed from all four directions of the 
/// grid, i.e. top, bottom, left, and right, must be the same as the 
/// skyline of the original grid. A city's skyline is the outer contour 
/// of the rectangles formed by all the buildings when viewed from a 
/// distance. See the following example.
///
/// What is the maximum total sum that the height of the buildings can be 
/// increased?
/// 
/// Example:
/// Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]
/// Output: 35
/// Explanation: 
/// The grid is:
/// [ 
///   [3, 0, 8, 4], 
///   [2, 4, 5, 7],
///   [9, 2, 6, 3],
///   [0, 3, 1, 0] 
/// ]
///
/// The skyline viewed from top or bottom is: [9, 4, 8, 7]
/// The skyline viewed from left or right is: [8, 7, 9, 3]
///
/// The grid after increasing the height of buildings without affecting 
/// skylines is:
/// gridNew = 
/// [ 
///   [8, 4, 8, 7],
///   [7, 4, 7, 7],
///   [9, 4, 8, 7],
///   [3, 3, 3, 3] 
/// ]
///
/// Notes:
///
/// 1. 1 < grid.length = grid[0].length <= 50.
/// 2. All heights grid[i][j] are in the range [0, 100].
/// 3. All buildings in grid[i][j] occupy the entire grid cell: that is, they 
///   are a 1 x 1 x grid[i][j] rectangular prism.
/// </summary>
int LeetCodeArray::maxIncreaseKeepingSkyline(vector<vector<int>>& grid)
{
    int result = 0;
    vector<int> row(grid.size()), col(grid[0].size());

    for (size_t i = 0; i < grid.size(); i++)
    {
        for (size_t j = 0; j < grid[i].size(); j++)
        {
            row[i] = max(row[i], grid[i][j]);
            col[j] = max(col[j], grid[i][j]);
        }
    }

    for (size_t i = 0; i < grid.size(); i++)
    {
        for (size_t j = 0; j < grid[i].size(); j++)
        {
            result += min(row[i], col[j]) - grid[i][j];
        }
    }

    return result;
}

/// <summary>
/// Leet code #821. Shortest Distance to a Character
/// 
/// Given a string S and a character C, return an array of integers   
/// representing the shortest distance from the character C in the string.
///
/// Example 1: 
/// 1. Input: S = "loveleetcode", C = 'e'
/// 2. Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] 
/// 3. All letters in S and C are lowercase.
/// </summary>
vector<int> LeetCodeArray::shortestToChar(string S, char C)
{
    int last_pos = -1;
    vector<int> result(S.size());
    for (size_t i = 0; i < S.size(); i++)
    {
        if (S[i] == C)
        {
            for (int j = i - 1; j >= 0; j--)
            {
                if ((result[j] != -1) && (result[j] <= (int)(i - j)))
                {
                    break;
                }
                result[j] = i - j;
            }
            last_pos = i;
        }
        else
        {
            if (last_pos == -1) result[i] = -1;
            else result[i] = i - last_pos;
        }
    }
    return result;
}



/// <summary>
/// Leet code #822. Card Flipping Game
/// 
/// On a table are N cards, with a positive integer printed on the front 
/// and back of each card (possibly different).
///
/// We flip any number of cards, and after we choose one card. 
///
/// If the number X on the back of the chosen card is not on the front of 
/// any card, then this number X is good.
///
/// What is the smallest number that is good?  If no number is good, 
/// output 0.
///
/// Here, fronts[i] and backs[i] represent the number on the front and 
/// back of card i. 
///
/// A flip swaps the front and back numbers, so the value on the front is 
/// now on the back and vice versa.
///
/// Example:
///
/// Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]
/// Output: 2
/// Explanation: If we flip the second card, the fronts are [1,3,4,4,7] 
/// and the backs are [1,2,4,1,3].
/// We choose the second card, which has number 2 on the back, and it 
/// isn't on the front of any card, so 2 is good.
///
/// Note:
/// 1.1 <= fronts.length == backs.length <= 1000.
/// 2.1 <= fronts[i] <= 2000.
/// 3.1 <= backs[i] <= 2000.
/// </summary>
int LeetCodeArray::flipgame(vector<int>& fronts, vector<int>& backs)
{
    int result = 0;
    unordered_set<int> bad_numbers;
    for (size_t i = 0; i < fronts.size(); i++)
    {
        if (fronts[i] == backs[i])
        {
            bad_numbers.insert(fronts[i]);
        }
    }

    for (size_t i = 0; i < fronts.size(); i++)
    {
        if (bad_numbers.count(fronts[i]) == 0)
        {
            if (result == 0) result = fronts[i];
            else
            {
                result = min(result, fronts[i]);
            }
        }
        if (bad_numbers.count(backs[i]) == 0)
        {
            if (result == 0) result = backs[i];
            else
            {
                result = min(result, backs[i]);
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #832. Flipping an Image
/// 
/// Given a binary matrix A, we want to flip the image horizontally, then 
/// invert it, and return the resulting image.
///
/// To flip an image horizontally means that each row of the image is 
/// reversed.  For example, flipping [1, 1, 0] horizontally results in 
/// [0, 1, 1].
///
/// To invert an image means that each 0 is replaced by 1, and each 1 is 
/// replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0].
///
/// Example 1:
///
/// Input: [[1,1,0],[1,0,1],[0,0,0]]
/// Output: [[1,0,0],[0,1,0],[1,1,1]]
/// Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].
/// Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]
///
/// Example 2:
///
/// Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
/// Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
/// Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],
/// [0,1,0,1]].
/// Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
/// Notes:
/// 1. 1 <= A.length = A[0].length <= 20
/// 2. 0 <= A[i][j] <= 1
/// </summary>
vector<vector<int>> LeetCodeArray::flipAndInvertImage(vector<vector<int>>& A)
{
    vector<vector<int>> result = A;
    for (size_t i = 0; i < result.size(); i++)
    {
        int first = 0;
        int last = result[i].size() - 1;
        while (first < last)
        {
            result[i][first] = 1 - result[i][first];
            result[i][last] = 1 - result[i][last];
            std::swap(result[i][first], result[i][last]);
            first++;
            last--;
        }
        if (first == last)
        {
            result[i][first] = 1 - result[i][first];
        }
    }
    return result;
}

/// <summary>
/// Leet code #835. Image Overlap
/// 
/// Two images A and B are given, represented as binary, square matrices 
/// of the same size.  (A binary matrix has only 0s and 1s as values.)
///
/// We translate one image however we choose (sliding it left, right, up, 
/// or down any number of units), and place it on top of the other image.  
/// After, the overlap of this translation is the number of positions that 
/// have a 1 in both images.
///
/// (Note also that a translation does not include any kind of rotation.)
///
/// What is the largest possible overlap?
///
/// Example 1:
///
/// Input: A = [[1,1,0],
///             [0,1,0],
///             [0,1,0]]
///        B = [[0,0,0],
///             [0,1,1],
///             [0,0,1]]
/// Output: 3
/// Explanation: We slide A to right by 1 unit and down by 1 unit.
/// Notes: 
///
/// 1. 1 <= A.length = A[0].length = B.length = B[0].length <= 30
/// 2. 0 <= A[i][j], B[i][j] <= 1
/// </summary>
int LeetCodeArray::largestOverlap(vector<vector<int>>& A, vector<vector<int>>& B)
{
    int size = A.size();
    int result = 0;
    for (int delta_r = -(size - 1); delta_r <= size - 1; delta_r++)
    {
        for (int delta_c = -(size - 1); delta_c <= (size - 1); delta_c++)
        {
            int score = 0;
            for (int i = 0; i < size; i++)
            {
                if (i + delta_r < 0 || i + delta_r >= size) continue;
                for (int j = 0; j < size; j++)
                {
                    if (j + delta_c < 0 || j + delta_c >= size) continue;
                    if (A[i][j] & B[i + delta_r][j + delta_c]) score++;
                }
            }
            result = max(result, score);
        }
    }
    return result;
}

/// <summary>
/// Leet code #838. Push Dominoes
/// 
/// There are N dominoes in a line, and we place each domino vertically 
/// upright.
/// In the beginning, we simultaneously push some of the dominoes either 
/// to the left or to the right.
///
/// After each second, each domino that is falling to the left pushes the 
/// adjacent domino on the left.
///
/// Similarly, the dominoes falling to the right push their adjacent 
/// dominoes standing on the right.
///
/// When a vertical domino has dominoes falling on it from both sides, it 
/// stays still due to the balance of the forces.
///
/// For the purposes of this question, we will consider that a falling 
/// domino expends no additional force to a falling or already fallen 
/// domino.
///
/// Given a string "S" representing the initial state. S[i] = 'L', if the 
/// i-th domino has been pushed to the left; S[i] = 'R', if the i-th domino 
/// has been pushed to the right; S[i] = '.', if the i-th domino has not 
/// been pushed.
///
/// Return a string representing the final state. 
/// 
/// Example 1:
///
/// Input: ".L.R...LR..L.."
/// Output: "LL.RR.LLRRLL.."
/// Example 2:
/// 
/// Input: "RR.L"
/// Output: "RR.L"
/// Explanation: The first domino expends no additional force on the second
/// domino.
/// Note:
/// 
/// 1. 0 <= N <= 10^5
/// 2. String dominoes contains only 'L', 'R' and '.'
/// </summary>
string LeetCodeArray::pushDominoes(string dominoes)
{
    queue<int> process_queue;
    for (size_t i = 0; i < dominoes.size(); i++)
    {
        if (dominoes[i] != '.') process_queue.push(i);
    }
    string next = dominoes;
    while (!process_queue.empty())
    {
        size_t size = process_queue.size();
        string current = next;
        for (size_t i = 0; i < size; i++)
        {
            size_t k = process_queue.front();
            process_queue.pop();
            if (current[k] == 'L')
            {
                if ((k == 0) || ((k > 0) && (current[k - 1] != '.')) || ((k > 1) && (current[k - 2] == 'R')))
                {
                    continue;
                }
                else
                {
                    next[k - 1] = 'L';
                    process_queue.push(k - 1);
                }
            }
            else if (current[k] == 'R')
            {
                if ((k == current.size() - 1) ||
                    ((k < current.size() - 1) && (current[k + 1] != '.')) ||
                    ((k < current.size() - 2) && (current[k + 2] == 'L')))
                {
                    continue;
                }
                else
                {
                    next[k + 1] = 'R';
                    process_queue.push(k + 1);
                }
            }
        }
    }
    return next;
}

/// <summary>
/// Leet code #840. Magic Squares In Grid
/// 
/// A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers 
/// from 1 to 9 such that each row, column, and both diagonals all have 
/// the same sum.
///
/// Given an grid of integers, how many 3 x 3 "magic square" subgrids are 
/// there?  (Each subgrid is contiguous).
///
/// Example 1:
///
/// Input: [
///         [4,3,8,4],
///         [9,5,1,9],
///         [2,7,6,2]
///        ]
/// Output: 1
/// Explanation: 
/// The following subgrid is a 3 x 3 magic square:
/// 438
/// 951
/// 276
///
/// while this one is not:
/// 384
/// 519
/// 762
///
/// In total, there is only one magic square inside the given grid.
/// Note:
///
/// 1. 1 <= grid.length <= 10
/// 2. 1 <= grid[0].length <= 10
/// 3. 0 <= grid[i][j] <= 15
/// </summary>
int LeetCodeArray::numMagicSquaresInside(vector<vector<int>>& grid)
{
    int result = 0;

    for (int i = 0; i < (int)grid.size() - 2; i++)
    {
        for (int j = 0; j < (int)grid[i].size() - 2; j++)
        {
            vector<int> sum(8);
            unordered_set<int> digit_map;
            for (size_t r = 0; r < 3; r++)
            {
                for (size_t c = 0; c < 3; c++)
                {
                    sum[r] += grid[i + r][j + c];
                    if (grid[i + r][j + c] >= 1 && grid[i + r][j + c] <= 9)
                    {
                        digit_map.insert(grid[i + r][j + c]);
                    }
                    sum[3+c] += grid[i + r][j + c];
                    if (r == c) sum[6] += grid[i + r][j + c];
                    if (r + c == 2) sum[7] += grid[i + r][j + c];
                }
            }
            
            for (size_t k = 0; k < sum.size(); k++)
            {
                if (sum[k] != 15) digit_map.clear();
            }
            if (digit_map.size() != 9) continue;
            result++;
        }
    }
    return result;
}

/// <summary>
/// Leet code #845. Longest Mountain in Array
/// 
/// Let's call any (contiguous) subarray B (of A) a mountain if the 
/// following properties hold:
///
/// B.length >= 3
/// There exists some 0 < i < B.length - 1 such that B[0] < B[1] < ... 
/// B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]
/// (Note that B could be any subarray of A, including the entire array A.)
///
/// Given an array A of integers, return the length of the longest 
/// mountain.
///  
/// Return 0 if there is no mountain.
/// 
/// Example 1:
/// Input: [2,1,4,7,3,2,5]
/// Output: 5
/// Explanation: The largest mountain is [1,4,7,3,2] which has length 5.
/// 
/// Example 2:
/// Input: [2,2,2]
/// Output: 0
/// Explanation: There is no mountain.
///
/// Note:
/// 1. 0 <= A.length <= 10000
/// 2. 0 <= A[i] <= 10000
/// </summary>
int LeetCodeArray::longestMountain(vector<int>& A)
{
    int result = 0;
    deque<int> mountain;
    for (size_t i = 0; i < A.size(); i++)
    {
        if ((i == 0) || (A[i] == A[i - 1]))
        {
            mountain.clear();
        }
        else if (A[i] > A[i - 1])
        {
            if (mountain.size() == 2) mountain.pop_back();
            else if (mountain.size() == 3)
            {
                mountain.pop_front();
                mountain.pop_front();
            }
        }
        else if (A[i] < A[i - 1])
        {
            if ((mountain.size() == 1) || (mountain.size() == 3)) mountain.pop_back();
        }
        mountain.push_back(i);
        if (mountain.size() == 3)
        {
            result = max(result, mountain[2] - mountain[0] + 1);
        }
    }
    return result;
}

/// <summary>
/// Leet code #849. Maximize Distance to Closest Person
/// 
/// In a row of seats, 1 represents a person sitting in that seat, and 0 
/// represents that the seat is empty. 
/// 
/// There is at least one empty seat, and at least one person sitting.
///
/// Alex wants to sit in the seat such that the distance between him and the 
/// closest person to him is maximized. 
///
/// Return that maximum distance to closest person.
///
/// Example 1:
///
/// Input: [1,0,0,0,1,0,1]
/// Output: 2
/// Explanation: 
/// If Alex sits in the second open seat (seats[2]), then the closest person 
/// has distance 2.
/// If Alex sits in any other open seat, the closest person has distance 1.
/// Thus, the maximum distance to the closest person is 2.
/// Example 2:
///
/// Input: [1,0,0,0]
/// Output: 3
/// Explanation: 
/// If Alex sits in the last seat, the closest person is 3 seats away.
/// This is the maximum distance possible, so the answer is 3.
/// Note:
///
/// 1. 1 <= seats.length <= 20000
/// 2. seats contains only 0s or 1s, at least one 0, and at least one 1.
/// </summary>
int LeetCodeArray::maxDistToClosest(vector<int>& seats)
{
    int result = 0;
    int last = 0;
    for (int i = 0; i < (int)seats.size(); i++)
    {
        if (seats[i] == 1)
        {
            if (seats[last] == 0)
            {
                result = max(i - last, result);
            }
            else
            {
                result = max((i - last) / 2, result);
            }
            last = i;
        }
        else if (i == seats.size() - 1)
        {
            result = max(i - last, result);
        }
    }
    return result;
}

/// <summary>
/// Leet code #860. Lemonade Change
/// 
/// At a lemonade stand, each lemonade costs $5. 
///
/// Customers are standing in a queue to buy from you, and order one at a time 
/// (in the order specified by bills).
///
/// Each customer will only buy one lemonade and pay with either a $5, $10, or 
/// $20 bill.  You must provide the correct change to each customer, so that 
/// the net transaction is that the customer pays $5.
///
/// Note that you don't have any change in hand at first.
///
/// Return true if and only if you can provide every customer with correct 
/// change.
/// 
/// Example 1:
/// Input: [5,5,5,10,20]
/// Output: true
/// Explanation: 
/// From the first 3 customers, we collect three $5 bills in order.
/// From the fourth customer, we collect a $10 bill and give back a $5.
/// From the fifth customer, we give a $10 bill and a $5 bill.
/// Since all customers got correct change, we output true.
///
/// Example 2:
/// Input: [5,5,10]
/// Output: true
///
/// Example 3: 
/// Input: [10,10]
/// Output: false
///
/// Example 4:
/// Input: [5,5,10,10,20]
/// Output: false
/// Explanation: 
/// From the first two customers in order, we collect two $5 bills.
/// For the next two customers in order, we collect a $10 bill and give back a 
/// $5 bill.
/// For the last customer, we can't give change of $15 back because we only 
/// have two $10 bills.
/// Since not every customer received correct change, the answer is false.
/// 
/// Note:
///
/// 1. 0 <= bills.length <= 10000
/// 2. bills[i] will be either 5, 10, or 20.
/// </summary>
bool LeetCodeArray::lemonadeChange(vector<int>& bills)
{
    vector<int> changes(2);
    for (size_t i = 0; i < bills.size(); i++)
    {
        if (bills[i] == 5) changes[0]++;
        else if (bills[i] == 10)
        {
            if (changes[0] < 1) return false;
            changes[0]--;
            changes[1]++;			
        }
        else  // 20
        {
            if (changes[1] > 0)
            {
                changes[1]--;
                if (changes[0] < 1) return false;
                changes[0]--;
            }
            else
            {
                if (changes[0] < 3) return false;
                changes[0]-=3;
            }
        }
    }
    return true;
}

/// <summary>
/// Leet code #867. Transpose Matrix
/// 
/// Given a matrix A, return the transpose of A.
///
/// The transpose of a matrix is the matrix flipped over it's main 
/// diagonal, switching the row and column indices of the matrix.
///
/// Example 1:
///
/// Input: [[1,2,3],[4,5,6],[7,8,9]]
/// Output: [[1,4,7],[2,5,8],[3,6,9]]
///
/// Example 2:
///
/// Input: [[1,2,3],[4,5,6]]
/// Output: [[1,4],[2,5],[3,6]]
///
/// Note:
///
/// 1. 1 <= A.length <= 1000
/// 2. 1 <= A[0].length <= 1000
/// </summary>
vector<vector<int>> LeetCodeArray::transpose(vector<vector<int>>& A)
{
    vector<vector<int>> result(A[0].size(), vector<int>(A.size()));
    for (size_t i = 0; i < A[0].size(); i++)
    {
        for (size_t j = 0; j < A.size(); j++)
        {
            result[i][j] = A[j][i];
        }
    }
    return result;
}

/// <summary>
/// Leet code #874. Walking Robot Simulation
/// 
/// A robot on an infinite grid starts at point (0, 0) and faces north.  
/// The robot can receive one of three possible types of commands:
///
/// -2: turn left 90 degrees
/// -1: turn right 90 degrees
/// 1 <= x <= 9: move forward x units
/// Some of the grid squares are obstacles. 
///
/// The i-th obstacle is at grid point (obstacles[i][0], obstacles[i][1])
///
/// If the robot would try to move onto them, the robot stays on the 
/// previous grid square instead (but still continues following the rest 
/// of the route.)
///
/// Return the square of the maximum Euclidean distance that the robot 
/// will be from the origin.
///  
/// Example 1:
///
/// Input: commands = [4,-1,3], obstacles = []
/// Output: 25
/// Explanation: robot will go to (3, 4)
/// 
/// Example 2:
///
/// Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]]
/// Output: 65
/// Explanation: robot will be stuck at (1, 4) before turning left and 
/// going to (1, 8)
///
/// Note:
/// 1. 0 <= commands.length <= 10000
/// 2. 0 <= obstacles.length <= 10000
/// 3. -30000 <= obstacle[i][0] <= 30000
/// 4. -30000 <= obstacle[i][1] <= 30000
/// 5. The answer is guaranteed to be less than 2 ^ 31.
/// </summary>
int LeetCodeArray::robotSim(vector<int>& commands, vector<vector<int>>& obstacles)
{
    int result = 0;
    vector<vector<int>> directions = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} };
    int direction = 0;
    unordered_set<string> obstacles_map;
    for (size_t i = 0; i < obstacles.size(); i++)
    {
        obstacles_map.insert(to_string(obstacles[i][0]) + "_" + to_string(obstacles[i][1]));
    }
    vector<int> pos = { 0,0 };
    for (size_t i = 0; i < commands.size(); i++)
    {
        if (commands[i] == -1)
        {
            direction = (direction + 1) % 4;
        }
        else if (commands[i] == -2)
        {
            direction = (direction + 3) % 4;
        }
        else
        {
            int step = commands[i];
            while (step > 0)
            {
                step--;
                vector<int> next_pos = pos;
                next_pos[0] += directions[direction][0];
                next_pos[1] += directions[direction][1];
                if (obstacles_map.count(to_string(next_pos[0]) + "_" + to_string(next_pos[1])) > 0)
                {
                    break;
                }
                pos = next_pos;
                result = max(pos[0] * pos[0] + pos[1] * pos[1], result);
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #883. Projection Area of 3D Shapes
/// 
/// On a N * N grid, we place some 1 * 1 * 1 cubes that are axis-aligned 
/// with the x, y, and z axes.
///
/// Each value v = grid[i][j] represents a tower of v cubes placed on top 
/// of grid cell (i, j).
///
/// Now we view the projection of these cubes onto the xy, yz, and zx planes.
///
/// A projection is like a shadow, that maps our 3 dimensional figure to a 2 
/// dimensional plane. 
///
/// Here, we are viewing the "shadow" when looking at the cubes from the top, 
/// the front, and the side.
///
/// Return the total area of all three projections.
///
/// Example 1:
/// Input: [[2]]
/// Output: 5
///
/// Example 2:
/// Input: [[1,2],[3,4]]
/// Output: 17
/// Explanation: 
/// Here are the three projections ("shadows") of the shape made with each 
/// axis-aligned plane.
///
/// Example 3:
/// Input: [[1,0],[0,2]]
/// Output: 8
///
/// Example 4:
/// Input: [[1,1,1],[1,0,1],[1,1,1]]
/// Output: 14
///
/// Example 5:
/// Input: [[2,2,2],[2,1,2],[2,2,2]]
/// Output: 21
///  
/// Note:
/// 1. 1 <= grid.length = grid[0].length <= 50
/// 2. 0 <= grid[i][j] <= 50
/// </summary>
int LeetCodeArray::projectionArea(vector<vector<int>>& grid)
{
    vector<int> rows(grid.size());
    vector<int> cols(grid[0].size());
    int result = 0;
    for (size_t i = 0; i < grid.size(); i++)
    {
        for (size_t j = 0; j < grid[i].size(); j++)
        {
            if (grid[i][j] != 0)
            {
                result++;
                rows[i] = max(rows[i], grid[i][j]);
                cols[j] = max(cols[j], grid[i][j]);
            }
        }
    }
    for (size_t i = 0; i < rows.size(); i++)
    {
        result += rows[i];
    }
    for (size_t i = 0; i < cols.size(); i++)
    {
        result += cols[i];
    }
    return result;
}

/// <summary>
/// Leet code #457. Circular Array Loop
/// 
/// You are given an array of positive and negative integers. If a number n 
/// at an index is positive, then move forward n steps. Conversely, if 
/// it's negative (-n), move backward n steps. Assume the first element of 
/// the array is forward next to the last element, and the last element is 
/// backward next to the first element. Determine if there is a loop in this 
/// array. A loop starts and ends at a particular index with more than 1 
/// element along the loop. The loop must be "forward" or "backward'.
///
/// Example 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 
/// 0 -> 2 -> 3 -> 0.
///
/// Example 2: Given the array [-1, 2], there is no loop.
///
/// Note: The given array is guaranteed to contain no element "0".
/// Can you do it in O(n) time complexity and O(1) space complexity?
/// </summary>
bool LeetCodeArray::circularArrayLoop(vector<int>& nums)
{
    int slow = 0;
    int fast = 0;
    int start = 0;
    int size = nums.size();
    for (size_t i = 0; i < nums.size(); i++)
    {
        if ((nums[start] > 0) != (nums[slow] > 0)) return false;
        int prev = slow;
        slow = (slow + nums[slow] + size) % size;
        if (slow == prev)
        {
            start = (slow + 1) % size;
            slow = start;
            fast = start;
        }
        else
        {
            fast = (fast + nums[fast] + size) % size;
            if ((nums[start] > 0) != (nums[slow] > 0)) return false;
            int prev = fast;
            fast = (fast + nums[fast] + size) % size;
            if ((nums[start] > 0) != (nums[slow] > 0)) return false;
            if (fast == prev) continue;
            if (slow == fast) return true;
        }
    }
    return false;
}

/// <summary>
/// Leet code #885. Spiral Matrix III
/// 
/// On a 2 dimensional grid with R rows and C columns, we start at (r0, c0) 
/// facing east.
///
/// Here, the north-west corner of the grid is at the first row and column, 
/// and the south-east corner of the grid is at the last row and column.
///
/// Now, we walk in a clockwise spiral shape to visit every position in this 
/// grid. 
///
/// Whenever we would move outside the boundary of the grid, we continue our 
/// walk outside the grid (but may return to the grid boundary later.) 
///
/// Eventually, we reach all R * C spaces of the grid.
///
/// Return a list of coordinates representing the positions of the grid in 
/// the order they were visited.
///
/// Example 1:
///
/// Input: R = 1, C = 4, r0 = 0, c0 = 0
/// Output: [[0,0],[0,1],[0,2],[0,3]]
///
/// Example 2:
///
/// Input: R = 5, C = 6, r0 = 1, c0 = 4
/// Output: 
/// [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],
///  [3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],
///  [0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]
///
/// Note:
/// 1. 1 <= R <= 100
/// 2. 1 <= C <= 100
/// 3. 0 <= r0 < R
/// 4. 0 <= c0 < C
/// </summary>
vector<vector<int>> LeetCodeArray::spiralMatrixIII(int R, int C, int r0, int c0)
{
    vector<vector<int>> result;
    vector<vector<int>> directions = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} };
    size_t step = 1;
    int direction = 0;
    int row = r0;
    int col = c0;
    while (result.size() < (size_t)(R * C))
    {
        for (size_t i = 0; i < step; i++)
        {
            if ((row >= 0) && (col >= 0) && (row < R) && (col < C))
            {
                result.push_back({ row, col });
            }
            row += directions[direction][0];
            col += directions[direction][1];
        }
        direction = (direction + 1) % 4;
        if (direction == 0 || direction == 2) step++;
    }
    return result;
}

/// <summary>
/// Leet code #888. Fair Candy Swap
/// 
/// Alice and Bob have candy bars of different sizes: A[i] is the size of the 
/// i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of 
/// candy that Bob has.
///
/// Since they are friends, they would like to exchange one candy bar each so 
/// that after the exchange, they both have the same total amount of candy.  
/// (The total amount of candy a person has is the sum of the sizes of candy 
/// bars they have.)
///
/// Return an integer array ans where ans[0] is the size of the candy bar that 
/// Alice must exchange, and ans[1] is the size of the candy bar that Bob must 
/// exchange.
///
/// If there are multiple answers, you may return any one of them.  It is 
/// guaranteed an answer exists.
///
/// Example 1:
/// Input: A = [1,1], B = [2,2]
/// Output: [1,2]
///
/// Example 2:
/// Input: A = [1,2], B = [2,3]
/// Output: [1,2]
///
/// Example 3:
/// Input: A = [2], B = [1,3]
/// Output: [2,3]
///
/// Example 4:
/// Input: A = [1,2,5], B = [2,4]
/// Output: [5,4]
/// 
/// Note:
/// 1. 1 <= A.length <= 10000
/// 2. 1 <= B.length <= 10000
/// 3. 1 <= A[i] <= 100000
/// 4. 1 <= B[i] <= 100000
/// 5. It is guaranteed that Alice and Bob have different total amounts of 
///    candy.
/// 6. It is guaranteed there exists an answer.
/// </summary>
vector<int> LeetCodeArray::fairCandySwap(vector<int>& A, vector<int>& B)
{
    vector<int> result;
    unordered_set<int> A_set;
    int sum_a = 0;
    int sum_b = 0;
    for (size_t i = 0; i < A.size(); i++)
    {
        sum_a += A[i];
        A_set.insert(A[i]);
    }

    for (size_t i = 0; i < B.size(); i++)
    {
        sum_b += B[i];
    }

    for (size_t i = 0; i < B.size(); i++)
    {
        int target_a = B[i] - (sum_b - sum_a) / 2;
        if (A_set.count(target_a) > 0)
        {
            result.push_back(target_a);
            result.push_back(B[i]);
            break;
        }
    }
    return result;
}

/// <summary>
/// Leet code #892. Surface Area of 3D Shapes
/// 
/// On a N * N grid, we place some 1 * 1 * 1 cubes.
///
/// Each value v = grid[i][j] represents a tower of v cubes placed on top of 
/// grid cell (i, j).
///
/// Return the total surface area of the resulting shapes. 
///
/// Example 1:
/// Input: [[2]]
/// Output: 10
///
/// Example 2: 
/// Input: [[1,2],[3,4]]
/// Output: 34
///
/// Example 3:
/// Input: [[1,0],[0,2]]
/// Output: 16
///
/// Example 4:
/// Input: [[1,1,1],[1,0,1],[1,1,1]]
/// Output: 32
///
/// Example 5: 
/// Input: [[2,2,2],[2,1,2],[2,2,2]]
/// Output: 46
/// 
/// Note:
/// 
/// 1. 1 <= N <= 50
/// 2. 0 <= grid[i][j] <= 50
/// </summary>
int LeetCodeArray::surfaceArea(vector<vector<int>>& grid)
{
    int result = 0;
    for (size_t i = 0; i < grid.size(); i++)
    {
        for (size_t j = 0; j < grid[i].size(); j++)
        {
            if (grid[i][j] == 0) continue;
            // top and bottom
            result += 2;
            // front 
            if (i == 0) result += grid[i][j];
            else if (grid[i][j] > grid[i - 1][j]) result += grid[i][j] - grid[i - 1][j];

            // back
            if (i == grid.size() - 1) result += grid[i][j];
            else if (grid[i][j] > grid[i + 1][j]) result += grid[i][j] - grid[i + 1][j];

            // left
            if (j == 0) result += grid[i][j];
            else if (grid[i][j] > grid[i][j - 1]) result += grid[i][j] - grid[i][j - 1];

            // right
            if (j == grid[0].size() - 1) result += grid[i][j];
            else if (grid[i][j] > grid[i][j + 1]) result += grid[i][j] - grid[i][j + 1];
        }
    }
    return result;
}

/// <summary>
/// Leet code #896. Monotonic Array 
/// 
/// An array is monotonic if it is either monotone increasing or monotone 
/// decreasing.
///
/// An array A is monotone increasing if for all i <= j, A[i] <= A[j].  
/// An array A is monotone decreasing if for all i <= j, A[i] >= A[j].
///
/// Return true if and only if the given array A is monotonic.
///
/// Example 1:
/// Input: [1,2,2,3]
/// Output: true
///
/// Example 2:
/// Input: [6,5,4,4]
/// Output: true
///
/// Example 3:
/// Input: [1,3,2]
/// Output: false
///
/// Example 4:
/// Input: [1,2,4,5]
/// Output: true
///
/// Example 5:
/// Input: [1,1,1]
/// Output: true
/// Note:
/// 1. 1 <= A.length <= 50000
/// 2. -100000 <= A[i] <= 100000
/// </summary>
bool LeetCodeArray::isMonotonic(vector<int>& A)
{
    int trend = 0;
    for (size_t i = 1; i < A.size(); i++)
    {
        if (A[i - 1] < A[i])
        {
            if (trend == -1) return false;
            trend = 1;
        }
        else if (A[i - 1] > A[i])
        {
            if (trend == 1) return false;
            trend = -1;
        }
    }
    return true;
}

/// <summary>
/// Leet code #905. Sort Array By Parity
/// 
/// Given an array A of non-negative integers, return an array 
/// consisting of all the even elements of A, followed by all 
/// the odd elements of A.
///
/// You may return any answer array that satisfies this condition.
///
/// Example 1:
/// Input: [3,1,2,4]
/// Output: [2,4,3,1]
/// The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.
/// 
/// Note:
/// 1. 1 <= A.length <= 5000
/// 2. 0 <= A[i] <= 5000
/// </summary>
vector<int> LeetCodeArray::sortArrayByParity(vector<int>& A)
{
    vector<int> result(A.size());
    int first = 0;
    int last = A.size() - 1;
    for (size_t i = 0; i < A.size(); i++)
    {
        if (A[i] % 2 == 0)
        {
            result[first] = A[i];
            first++;
        }
        else
        {
            result[last] = A[i];
            last--;
        }
    }
    return result;
}

/// <summary>
/// Leet code #918. Maximum Sum Circular Subarray
/// 
/// Given a circular array C of integers represented by A, find the maximum 
/// possible sum of a non-empty subarray of C.
///
/// Here, a circular array means the end of the array connects to the 
/// beginning of the array.  (Formally, C[i] = A[i] when 0 <= i < A.length, 
/// and C[i+A.length] = C[i] when i >= 0.)
///
/// Also, a subarray may only include each element of the fixed buffer A at 
/// most once.  (Formally, for a subarray C[i], C[i+1], ..., C[j], there does 
/// not exist i <= k1, k2 <= j with k1 % A.length = k2 % A.length.)
///
///
/// Example 1:
/// Input: [1,-2,3,-2]
/// Output: 3
/// Explanation: Subarray [3] has maximum sum 3
///
/// Example 2:
/// Input: [5,-3,5]
/// Output: 10
/// Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10
///
/// Example 3: 
/// Input: [3,-1,2,-1]
/// Output: 4
/// Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4
///
/// Example 4:
/// Input: [3,-2,2,-3]
/// Output: 3
/// Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3
//
/// Example 5:
/// Input: [-2,-3,-1]
/// Output: -1
/// Explanation: Subarray [-1] has maximum sum -1
///  
///
/// Note:
///
/// 1. -30000 <= A[i] <= 30000
/// 2. 1 <= A.length <= 30000
/// 
/// </summary>
int LeetCodeArray::maxSubarraySumCircular(vector<int>& A)
{
    int sum = 0;
    int min_left = 0;
    int max_left = 0;
    int max_sum = INT_MIN;
    int min_sum = INT_MAX;
    for (size_t i = 0; i < A.size(); i++)
    {
        sum += A[i];
        max_sum = max(max_sum, sum - min_left);
        min_sum = min(min_sum, sum - max_left);
        min_left = min(min_left, sum);
        max_left = max(max_left, sum);
    }
    int result = max_sum;
    if (sum != min_sum) result = max(result, sum-min_sum);
    return result;
}

/// <summary>
/// Leet code #926. Flip String to Monotone Increasing 
/// 
/// A string of '0's and '1's is monotone increasing if it consists of some 
/// number of '0's (possibly 0), followed by some number of '1's (also 
/// possibly 0.)
///
/// We are given a string S of '0's and '1's, and we may flip any '0' to a '1' 
/// or a '1' to a '0'.
///
/// Return the minimum number of flips to make S monotone increasing.
///
/// 
/// Example 1:
/// Input: "00110"
/// Output: 1
/// Explanation: We flip the last digit to get 00111.
///
/// Example 2:
/// Input: "010110"
/// Output: 2
/// Explanation: We flip to get 011111, or alternatively 000111.
///
/// Example 3:
/// Input: "00011000"
/// Output: 2
/// Explanation: We flip to get 00000000.
/// 
/// Note:
///
/// 1. 1 <= S.length <= 20000
/// 2. S only consists of '0' and '1' characters.
/// </summary>
int LeetCodeArray::minFlipsMonoIncr(string S)
{
    int zero = 0;
    int one = 0;
    for (size_t i = 0; i < S.size(); i++)
    {
        if (S[i] == '0') zero++;
        else one++;
    }
    int first = 0;
    int last = S.size() - 1;
    int result = 0;
    while (first < last)
    {
        if (S[first] == '0')
        {
            zero--;
            first++;
        }
        else if (S[last] == '1')
        {
            one--;
            last--;
        }
        else
        {
            result++;
            if (zero < one)
            {
                zero--;
                last--;
            }
            else
            {
                one--;
                first++;
            }
        };
    }
    return result;
}

/// <summary>
/// Leet code #927. Three Equal Parts
/// 
/// Given an array A of 0s and 1s, divide the array into 3 non-empty parts 
/// such that all of these parts represent the same binary value.
///
/// If it is possible, return any [i, j] with i+1 < j, such that:
///
/// A[0], A[1], ..., A[i] is the first part;
/// A[i+1], A[i+2], ..., A[j-1] is the second part, and
/// A[j], A[j+1], ..., A[A.length - 1] is the third part.
/// All three parts have equal binary value.
/// If it is not possible, return [-1, -1].
///
/// Note that the entire part is used when considering what binary value it 
/// represents.  For example, [1,1,0] represents 6 in decimal, not 3.  Also, 
/// leading zeros are allowed, so [0,1,1] and [1,1] represent the same value.
///
/// Example 1:
/// Input: [1,0,1,0,1]
/// Output: [0,3]
///
/// Example 2:
/// Input: [1,1,0,1,1]
/// Output: [-1,-1]
///
/// Note:
/// 
/// 1. 3 <= A.length <= 30000
/// 2. A[i] == 0 or A[i] == 1
/// </summary>
vector<int> LeetCodeArray::threeEqualParts(vector<int>& A)
{
    vector<int> ones;
    for (size_t i = 0; i < A.size(); i++)
    {
        if (A[i] == 1) ones.push_back(i);
    }

    if (ones.size() % 3 != 0)
    {
        return { -1, -1 };
    }
    else if (ones.empty())
    {
        return { 0, 2 };
    }
    else
    {
        // calculate end position
        int first = ones[ones.size() / 3 - 1];
        int second = ones[ones.size() / 3 * 2 - 1];
        int third = ones[ones.size() - 1];
        int tail = A.size() - 1 - third;
        int j = second + tail + 1;
        if (j > third)
        {
            return { -1, -1 };
        }
        else
        {
            int i = first + j - second - 1;
            if (i >= second)
            {
                return { -1, -1 };
            }
            else
            {
                vector<vector<int>> dp;
                int k = 0;
                for (k = 0; k <= i; k++)
                {
                    if (A[k] != 0) break;
                }
                vector<int> one (A.begin() + k, A.begin() + i + 1);

                for (k = i+1; k < j; k++)
                {
                    if (A[k] != 0) break;
                }
                vector<int> two(A.begin() + k, A.begin() + j);
                
                for (k = j; k < (int)A.size(); k++)
                {
                    if (A[k] != 0) break;
                }
                vector<int> three(A.begin() + k, A.end());

                if (one == two && two == three)
                {
                    return{ i, j };
                }
                else
                {
                    return{ -1, -1 };
                }
            }
        }
    }
}

/// <summary>
/// Leet code #944. Delete Columns to Make Sorted
/// 
/// We are given an array A of N lowercase letter strings, all of the same 
/// length.
///
/// Now, we may choose any set of deletion indices, and for each string, we 
/// delete all the characters in those indices.
///
/// For example, if we have a string "abcdef" and deletion indices {0, 2, 3}, 
/// then the final string after deletion is "bef".
///
/// Suppose we chose a set of deletion indices D such that after deletions, 
/// each remaining column in A is in non-decreasing sorted order.
///
/// Formally, the c-th column is [A[0][c], A[1][c], ..., A[A.length-1][c]]
///
/// Return the minimum possible value of D.length.
///
/// 
/// Example 1:
/// Input: ["cba","daf","ghi"]
/// Output: 1
///
/// Example 2:
/// Input: ["a","b"]
/// Output: 0
///
/// Example 3:
/// Input: ["zyx","wvu","tsr"]
/// Output: 3
/// Note:
/// 1. 1 <= A.length <= 100
/// 2. 1 <= A[i].length <= 1000
/// </summary>
int LeetCodeArray::minDeletionSize(vector<string>& A)
{
    int result = 0;
    for (size_t i = 0; i < A[0].size(); i++)
    {
        for (size_t j = 1; j < A.size(); j++)
        {
            if (A[j][i] < A[j -1][i])
            {
                result++;
                break;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #945. Minimum Increment to Make Array Unique
/// 
/// Given an array of integers A, a move consists of choosing any A[i], 
/// and incrementing it by 1.
///
/// Return the least number of moves to make every value in A unique.
///
/// Example 1:
/// Input: [1,2,2]
/// Output: 1
/// Explanation:  After 1 move, the array could be [1, 2, 3].
///
/// Example 2:
/// Input: [3,2,1,2,1,7]
/// Output: 6
/// Explanation:  After 6 moves, the array could be [3, 4, 1, 2, 5, 7].
/// It can be shown with 5 or less moves that it is impossible for the 
/// array to have all unique values.
/// 
/// Note:
/// 1. 0 <= A.length <= 40000
/// 2. 0 <= A[i] < 40000
/// </summary>
int LeetCodeArray::minIncrementForUnique(vector<int>& A)
{
    map<int, int> num_count;	
    for (auto x : A) num_count[x]++;
    int result = 0;
    auto itr = num_count.begin();
    int empty = itr->first;
    while (itr != num_count.end())
    {
        if (itr->second < 2)
        {
            itr++;
            continue;
        }
        if (itr->second > 1)
        {
            if (empty <= itr->first) empty = itr->first + 1;
            while (num_count.count(empty) != 0)
            {
                empty++;
            }
            result += empty - itr->first;
            empty++;
            itr->second --;
        }
    }
    return result;
}

/// <summary>
/// Leet code #950. Reveal Cards In Increasing Order
/// 
/// In a deck of cards, every card has a unique integer.  You can order 
/// the deck in any order you want.
///
/// Initially, all the cards start face down (unrevealed) in one deck.
///
/// Now, you do the following steps repeatedly, until all cards are 
/// revealed:
///
/// Take the top card of the deck, reveal it, and take it out of the deck.
/// If there are still cards in the deck, put the next top card of the  
/// deck at the bottom of the deck.
/// If there are still unrevealed cards, go back to step 1.  Otherwise, 
/// stop.
/// Return an ordering of the deck that would reveal the cards in 
/// increasing order.
/// 
/// The first entry in the answer is considered to be the top of the deck.
///
///
///
/// Example 1:
///
/// Input: [17,13,11,2,3,5,7]
/// Output: [2,13,3,11,5,17,7]
/// Explanation: 
/// We get the deck in the order [17,13,11,2,3,5,7] (this order doesn't 
/// matter), and reorder it.
/// After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is 
/// the top of the deck.
/// We reveal 2, and move 13 to the bottom.  The deck is now 
/// [3,11,5,17,7,13].
/// We reveal 3, and move 11 to the bottom.  The deck is now 
/// [5,17,7,13,11].
/// We reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].
/// We reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].
/// We reveal 11, and move 17 to the bottom.  The deck is now [13,17].
/// We reveal 13, and move 17 to the bottom.  The deck is now [17].
/// We reveal 17.
/// Since all the cards revealed are in increasing order, the answer is 
/// correct.
///
///
/// Note:
/// 1. 1 <= A.length <= 1000
/// 2. 1 <= A[i] <= 10^6
/// 3. A[i] != A[j] for all i != j
/// </summary>
vector<int> LeetCodeArray::deckRevealedIncreasing(vector<int>& deck)
{
    vector<int> index;
    sort(deck.begin(), deck.end());
    queue<int> search;
    for (size_t i = 0; i < deck.size(); i++) search.push(i);

    while (!search.empty())
    {
        index.push_back(search.front());
        search.pop();
        if (!search.empty())
        {
            search.push(search.front());
            search.pop();
        }
    }
    vector<int> result(deck.size());
    for (size_t i = 0; i < result.size(); i++)
    {
        result[index[i]] = deck[i];
    }
    return result;
}

/// <summary>
/// Leet code #961. N-Repeated Element in Size 2N Array
/// 
/// In a array A of size 2N, there are N+1 unique elements, and exactly one 
/// of these elements is repeated N times.
///
/// Return the element repeated N times.
///
/// Example 1:
/// Input: [1,2,3,3]
/// Output: 3
///
/// Example 2:
/// Input: [2,1,2,5,3,2]
/// Output: 2
///
/// Example 3:
/// Input: [5,1,5,2,5,3,5,4]
/// Output: 5 
///
/// Note:
/// 1. 4 <= A.length <= 10000
/// 2. 0 <= A[i] < 10000
/// 3. A.length is even
/// </summary>
int LeetCodeArray::repeatedNTimes(vector<int>& A)
{
    deque<int> line;
    for (size_t i = 0; i < A.size(); i ++)
    {
        if (line.size() < 2)
        {
            line.push_back(A[i]);
        }
        else
        {
            if (line[0] == A[i] || line[1] == A[i])
            {
                return A[i];
            }
            line.pop_front();
            line.push_back(A[i]);
        }
    }
    return line[1];
}

/// <summary>
/// Leet code #985. Sum of Even Numbers After Queries
/// 
/// We have an array A of integers, and an array queries of queries.
/// For the i-th query val = queries[i][0], index = queries[i][1], we 
/// add val to A[index].  Then, the answer to the i-th query is the 
/// sum of the even values of A.
///
/// (Here, the given index = queries[i][1] is a 0-based index, and 
/// each query permanently modifies the array A.)
///
/// Return the answer to all queries.  Your answer array should have 
/// answer[i] as the answer to the i-th query.
///
/// Example 1:
/// 
/// Input: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]
/// Output: [8,6,2,4]
/// Explanation: 
/// At the beginning, the array is [1,2,3,4].
/// 1. After adding 1 to A[0], the array is [2,2,3,4], and the sum of 
///    even values is 2 + 2 + 4 = 8.
/// 2. After adding -3 to A[1], the array is [2,-1,3,4], and the sum 
///    of even values is 2 + 4 = 6.
/// 3. After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of 
///    even values is -2 + 4 = 2.
/// 4. After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of 
///    even values is -2 + 6 = 4.
/// 
/// Note:
/// 1. 1 <= A.length <= 10000
/// 2. -10000 <= A[i] <= 10000
/// 3. 1 <= queries.length <= 10000
/// 4. -10000 <= queries[i][0] <= 10000
/// 5. 0 <= queries[i][1] < A.length
/// </summary>
vector<int> LeetCodeArray::sumEvenAfterQueries(vector<int>& A, vector<vector<int>>& queries)
{
    int sum = 0;
    vector<int> result;
    for (size_t i = 0; i < A.size(); i++)
    {
        if (A[i] % 2 == 0) sum += A[i];
    }

    for (size_t i = 0; i < queries.size(); i++)
    {
        int index = queries[i][1];
        if (A[index] % 2 == 0) sum -= A[index];
        A[index] += queries[i][0];
        if (A[index] % 2 == 0) sum += A[index];
        result.push_back(sum);
    }
    return result;
}

/// <summary>
/// Leet code #989. Add to Array-Form of Integer
/// 
/// For a non-negative integer X, the array-form of X is an array of its 
/// digits in left to right order.  For example, if X = 1231, then the 
/// array form is [1,2,3,1].
///
/// Given the array-form A of a non-negative integer X, return the 
/// array-form of the integer X+K.
///
/// Example 1:
/// Input: A = [1,2,0,0], K = 34
/// Output: [1,2,3,4]
/// Explanation: 1200 + 34 = 1234
///
/// Example 2:
/// Input: A = [2,7,4], K = 181
/// Output: [4,5,5]
/// Explanation: 274 + 181 = 455
///
/// Example 3:
/// Input: A = [2,1,5], K = 806
/// Output: [1,0,2,1]
/// Explanation: 215 + 806 = 1021
///
/// Example 4:
/// Input: A = [9,9,9,9,9,9,9,9,9,9], K = 1
/// Output: [1,0,0,0,0,0,0,0,0,0,0]
/// Explanation: 9999999999 + 1 = 10000000000
/// 
/// Note：
/// 1. 1 <= A.length <= 10000
/// 2. 0 <= A[i] <= 9
/// 3. 0 <= K <= 10000
/// 4. If A.length > 1, then A[0] != 0
/// </summary>
vector<int> LeetCodeArray::addToArrayForm(vector<int>& A, int K)
{
    vector<int> result;
    std::reverse(A.begin(), A.end());

    int sum = K;
    for (size_t i = 0; i < A.size(); i++)
    {
        sum += A[i];
        result.push_back(sum % 10);
        sum /= 10;
    }

    while (sum > 0)
    {
        result.push_back(sum % 10);
        sum /= 10;
    }

    std::reverse(result.begin(), result.end());
    return result;
}

/// <summary>
/// Leet code #992. Subarrays with K Different Integers
/// 
/// Given an array A of positive integers, call a (contiguous, not 
/// necessarily distinct) subarray of A good if the number of different 
/// integers in that subarray is exactly K.
/// 
/// (For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.)
///
/// Return the number of good subarrays of A.
///
/// 
/// Example 1:
///
/// Input: A = [1,2,1,2,3], K = 2
/// Output: 7
/// Explanation: Subarrays formed with exactly 2 different integers: 
/// [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].
///
/// Example 2:
///
/// Input: A = [1,2,1,3,4], K = 3
/// Output: 3
/// Explanation: Subarrays formed with exactly 3 different integers: 
/// [1,2,1,3], [2,1,3], [1,3,4].
///
///
/// Note:
/// 1. 1 <= A.length <= 20000
/// 2. 1 <= A[i] <= A.length
/// 3. 1 <= K <= A.length
/// </summary>
int LeetCodeArray::subarraysWithKDistinct(vector<int>& A, int K)
{
    unordered_map<size_t, size_t> num_map;
    size_t head = 0, tail = 0, next = 0;
    int result = 0;
    while (head < A.size())
    {
        if (num_map.size() < (size_t)K)
        {
            if (tail == A.size()) break;
            num_map[A[tail]]++;
            tail++;
        }
        if (num_map.size() == K)
        {
            next = max(next, tail);
            while (next < A.size() && num_map.count(A[next]) > 0) next++;
            result += next - tail + 1;

            num_map[A[head]]--;
            if (num_map[A[head]] == 0) num_map.erase(A[head]);
            head++;
        }
    }
    return result;
}

/// <summary>
/// Leet code #995. Minimum Number of K Consecutive Bit Flips
/// 
/// In an array A containing only 0s and 1s, a K-bit flip consists of choosing 
/// a (contiguous) subarray of length K and simultaneously changing every 0 in 
/// the subarray to 1, and every 1 in the subarray to 0.
///
/// Return the minimum number of K-bit flips required so that there is no 0 in 
/// the array.  If it is not possible, return -1.
///
/// Example 1:
///
/// Input: A = [0,1,0], K = 1
/// Output: 2
/// Explanation: Flip A[0], then flip A[2].
///
/// Example 2:
///
/// Input: A = [1,1,0], K = 2
/// Output: -1
/// Explanation: No matter how we flip subarrays of size 2, we can't make the 
/// array become [1,1,1].
///
/// Example 3:
///
/// Input: A = [0,0,0,1,0,1,1,0], K = 3
/// Output: 3
/// Explanation:
/// Flip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]
/// Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]
/// Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]
///
///
/// Note:
///
/// 1. 1 <= A.length <= 30000
/// 2. 1 <= K <= A.length
/// </summary>
int LeetCodeArray::minKBitFlips(vector<int>& A, int K)
{
    vector<int> flip_count(A.size());
    int flip = 0;
    int result = 0;
    for (size_t i = 0; i < A.size(); i++)
    {
        flip ^= (flip_count[i] % 2);
        if ((A[i] ^ flip) == 0)
        {
            flip ^= 1;
            result++;
            if (i + K < A.size()) flip_count[i + K]++;
            if (i + K - 1 >= A.size())
            {
                result = -1;
                break;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #1001. Grid Illumination
/// 
/// On a N x N grid of cells, each cell (x, y) with 0 <= x < N and 
/// 0 <= y < N has a lamp.
/// Initially, some number of lamps are on.  lamps[i] tells us the 
/// location of the i-th lamp that is on.  Each lamp that is on 
/// illuminates every square on its x-axis, y-axis, and both diagonals 
/// (similar to a Queen in chess).
/// For the i-th query queries[i] = (x, y), the answer to the query is 1 
/// if the cell (x, y) is illuminated, else 0.
/// After each query (x, y) [in the order given by queries], we turn off 
/// any lamps that are at cell (x, y) or are adjacent 8-directionally 
/// (ie., share a corner or edge with cell (x, y).)
/// Return an array of answers.  Each value answer[i] should be equal 
/// to the answer of the i-th query queries[i].
///
/// Example 1:
/// Input: N = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]
/// Output: [1,0]
/// Explanation: 
/// Before performing the first query we have both lamps [0,0] and [4,4] 
/// on.
/// The grid representing which cells are lit looks like this, where [0,0] 
/// is the top left corner, and [4,4] is the bottom right corner:
/// 1 1 1 1 1
/// 1 1 0 0 1
/// 1 0 1 0 1
/// 1 0 0 1 1
/// 1 1 1 1 1
/// Then the query at [1, 1] returns 1 because the cell is lit.  After 
/// this query, the lamp at [0, 0] turns off, and the grid now looks 
/// like this:
/// 1 0 0 0 1
/// 0 1 0 0 1
/// 0 0 1 0 1
/// 0 0 0 1 1
/// 1 1 1 1 1
/// Before performing the second query we have only the lamp [4,4] on.  
/// Now the query at [1,0] returns 0, because the cell is no longer lit.
/// 
/// Note:
/// 1. 1 <= N <= 10^9
/// 2. 0 <= lamps.length <= 20000
/// 3. 0 <= queries.length <= 20000
/// 4. lamps[i].length == queries[i].length == 2
/// </summary>
vector<int> LeetCodeArray::gridIllumination(int N, vector<vector<int>>& lamps, vector<vector<int>>& queries)
{
    unordered_map<int, int> row_map, col_map, diag_map, a_diag_map;
    unordered_map<int, unordered_set<int>> lamp_map;
    vector<int> result;
    for (size_t i = 0; i < lamps.size(); i++)
    {
        row_map[lamps[i][0]]++;
        col_map[lamps[i][1]]++;
        diag_map[lamps[i][0] + lamps[i][1]]++;
        a_diag_map[lamps[i][0] - lamps[i][1]]++;
        lamp_map[lamps[i][0]].insert(lamps[i][1]);
    }

    for (size_t i = 0; i < queries.size(); i++)
    {
        if (row_map[queries[i][0]] > 0 || col_map[queries[i][1]] > 0 ||
            diag_map[queries[i][0] + queries[i][1]] > 0 || 
            a_diag_map[queries[i][0] - queries[i][1]] > 0)
        {
            result.push_back(1);
        }
        else
        {
            result.push_back(0);
        }

        for (int row = queries[i][0] - 1; row < queries[i][0] + 2; row++)
        {
            if (row < 0 || row >= N) continue;
            for (int col = queries[i][1] - 1; col < queries[i][1] + 2; col++)
            {
                if (col < 0 || col >= N) continue;
                if (lamp_map[row].count(col) == 0) continue;
                lamp_map[row].erase(col);
                row_map[row]--;
                col_map[col]--;
                diag_map[row + col]--;
                a_diag_map[row - col]--;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #999. Available Captures for Rook
/// 
/// On an 8 x 8 chessboard, there is one white rook.  There also may be 
/// empty squares, white bishops, and black pawns.  These are given as 
/// characters 'R', '.', 'B', and 'p' respectively. Uppercase characters 
/// represent white pieces, and lowercase characters represent black 
/// pieces.
///
/// The rook moves as in the rules of Chess: it chooses one of four 
/// cardinal directions (north, east, west, and south), then moves in that 
/// direction until it chooses to stop, reaches the edge of the board, or 
/// captures an opposite colored pawn by moving to the same square it 
/// occupies.  Also, rooks cannot move into the same square as other 
/// friendly bishops.
/// 
/// Return the number of pawns the rook can capture in one move.
/// 
/// Example 1:
///
/// Input: [
/// [".",".",".",".",".",".",".","."],
/// [".",".",".","p",".",".",".","."],
/// [".",".",".","R",".",".",".","p"],
/// [".",".",".",".",".",".",".","."],
/// [".",".",".",".",".",".",".","."],
/// [".",".",".","p",".",".",".","."],
/// [".",".",".",".",".",".",".","."],
/// [".",".",".",".",".",".",".","."]]
/// Output: 3
/// Explanation: 
/// In this example the rook is able to capture all the pawns.
///
/// Example 2:
/// 
/// Input: [
/// [".",".",".",".",".",".",".","."],
/// [".","p","p","p","p","p",".","."],
/// [".","p","p","B","p","p",".","."],
/// [".","p","B","R","B","p",".","."],
/// [".","p","p","B","p","p",".","."],
/// [".","p","p","p","p","p",".","."],
/// [".",".",".",".",".",".",".","."],
/// [".",".",".",".",".",".",".","."]]
/// Output: 0
/// Explanation: 
/// Bishops are blocking the rook to capture any pawn.
///
/// Example 3:
/// Input:[
/// [".",".",".",".",".",".",".","."],
/// [".",".",".","p",".",".",".","."],
/// [".",".",".","p",".",".",".","."],
/// ["p","p",".","R",".","p","B","."],
/// [".",".",".",".",".",".",".","."],
/// [".",".",".","B",".",".",".","."],
/// [".",".",".","p",".",".",".","."],
/// [".",".",".",".",".",".",".","."]]
/// Output: 3
/// Explanation: 
/// The rook can capture the pawns at positions b5, d6 and f5.
///
/// Note:
///  
/// board.length == board[i].length == 8
/// board[i][j] is either 'R', '.', 'B', or 'p'
/// There is exactly one cell with board[i][j] == 'R'
/// </summary>
int LeetCodeArray::numRookCaptures(vector<vector<char>>& board)
{
    int result = 0;
    for (size_t i = 0; i < board.size(); i++)
    {
        for (size_t j = 0; j < board[i].size(); j++)
        {
            if (board[i][j] == 'R')
            {
                vector<vector<int>> directions = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };
                for (size_t d = 0; d < directions.size(); d++)
                {
                    int r = i;
                    int c = j;
                    while (r >= 0 && r < (int)board.size() && c >= 0 && c < (int)board[i].size())
                    {
                        if (board[r][c] == '.' || board[r][c] == 'R')
                        {
                            r += directions[d][0];
                            c += directions[d][1];
                        }
                        else 
                        {
                            if (board[r][c] == 'p') result++;
                            break;
                        }
                    }
                }
                return result;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #1005. Maximize Sum Of Array After K Negations
/// 
/// Given an array A of integers, we must modify the array in the 
/// following way: we choose an i and replace A[i] with -A[i], and we 
/// repeat this process K times in total.  (We may choose the same index 
/// i multiple times.)
/// 
/// Return the largest possible sum of the array after modifying it in 
/// this way.
///
/// Example 1:
///
/// Input: A = [4,2,3], K = 1
/// Output: 5
/// Explanation: Choose indices (1,) and A becomes [4,-2,3].
///
/// Example 2:
///
/// Input: A = [3,-1,0,2], K = 3
/// Output: 6
/// Explanation: Choose indices (1, 2, 2) and A becomes [3,1,0,2].
///
/// Example 3:
///
/// Input: A = [2,-3,-1,5,-4], K = 2
/// Output: 13
/// Explanation: Choose indices (1, 4) and A becomes [2,3,-1,5,4].
///
///
/// Note:
/// 1. 1 <= A.length <= 10000
/// 2. 1 <= K <= 10000
/// 3. -100 <= A[i] <= 100
/// </summary>
int LeetCodeArray::largestSumAfterKNegations(vector<int>& A, int K)
{
    multiset<int> negative;
    int sum = 0;
    int smallest_positive = INT_MAX;
    for (size_t i = 0; i < A.size(); i++)
    {
        if (A[i] < 0) negative.insert(A[i]);
        else
        {
            smallest_positive = min(smallest_positive, A[i]);
        }
        sum += A[i];
    }
    while (K > 0)
    {
        if (negative.empty()) break;
        int x = 0 - *negative.begin();
        smallest_positive = min(x, smallest_positive);
        negative.erase(negative.begin());
        sum += 2 * x;
        K--;
    }
    if (K % 2 == 1)
    {
        sum -= 2 * smallest_positive;
    }
    return sum;
}

/// <summary>
/// Leet code #1007. Minimum Domino Rotations For Equal Row
/// 
/// In a row of dominoes, A[i] and B[i] represent the top and bottom 
/// halves of the i-th domino.  (A domino is a tile with two numbers 
/// from 1 to 6 - one on each half of the tile.)
///
/// We may rotate the i-th domino, so that A[i] and B[i] swap values.
/// 
/// Return the minimum number of rotations so that all the values in A 
/// are the same, or all the values in B are the same.
///
/// If it cannot be done, return -1.
/// 
/// Example 1:
/// Input: A = [2,1,2,4,2,2], B = [5,2,6,2,3,2]
/// Output: 2
/// Explanation: 
/// The first figure represents the dominoes as given by A and B: before 
/// we do any rotations.
/// If we rotate the second and fourth dominoes, we can make every 
/// value in the top row equal to 2, as indicated by the second figure.
///
/// Example 2:
///
/// Input: A = [3,5,1,2,3], B = [3,6,3,3,4]
/// Output: -1
/// Explanation: 
/// In this case, it is not possible to rotate the dominoes to make one 
/// row of values equal.
/// 
///
/// Note:
///
/// 1. 1 <= A[i], B[i] <= 6
/// 2. 2 <= A.length == B.length <= 20000
/// 
/// </summary>
int LeetCodeArray::minDominoRotations(vector<int>& A, vector<int>& B)
{
    vector<int> domino(7);

    for (size_t i = 0; i < A.size(); i++)
    {
        domino[A[i]]++;
        if (A[i] != B[i]) domino[B[i]]++;
    }
    int value = -1;
    for (int i = 1; i < 7; i++)
    {
        if (domino[i] == A.size())
        {
            value = i;
            break;
        }
    }
    if (value == -1) return -1;
    int a = 0;
    int b = 0;
    for (size_t i = 0; i < A.size(); i++)
    {
        if (A[i] == value) a++;
        if (B[i] == value) b++;
    }
    int result = min(a, (int)A.size() - a);
    result = min(result, b);
    result = min(result, (int)B.size() - b);
    return result;
}

/// <summary>
/// Leet code #1013. Partition Array Into Three Parts With Equal Sum
/// 
/// Given an array A of integers, return true if and only if we can 
/// partition the array into three non-empty parts with equal sums.
///
/// Formally, we can partition the array if we can find indexes i+1 < j with 
/// (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + 
/// A[j-1] + ... + A[A.length - 1])
///
///
/// Example 1:
///
/// Input: [0,2,1,-6,6,-7,9,1,2,0,1]
/// Output: true
/// Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1
/// Example 2:
///
/// Input: [0,2,1,-6,6,7,9,-1,2,0,1]
/// Output: false
/// Example 3:
///
/// Input: [3,3,6,5,-2,2,5,1,-9,4]
/// Output: true
/// Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4
/// 
/// Note:
///
/// 1. 3 <= A.length <= 50000
/// 2. -10000 <= A[i] <= 10000
/// </summary>
bool LeetCodeArray::canThreePartsEqualSum(vector<int>& A)
{
    int sum = 0;
    for (size_t i = 0; i < A.size(); i++)
    {
        sum += A[i];
    }
    if (sum % 3 != 0) return false;

    int first = sum / 3;
    sum = 0;
    int result = 0;
    for (size_t i = 0; i < A.size(); i++)
    {
        sum += A[i];
        if ((sum == first) && (result == 0))
        {
            result++;
        }
        else if ((sum == first * 2) && (result == 1) && (i != A.size() - 1))
        {
            result++;
            break;
        }
    }
    if (result == 2) return true;
    else return false;
}

/// <summary>
/// Leet code #1014. Best Sightseeing Pair
/// 
/// Given an array A of positive integers, A[i] represents the value of the 
/// i-th sightseeing spot, and two sightseeing spots i and j have distance 
/// j - i between them.
///
/// The score of a pair (i < j) of sightseeing spots is (A[i] + A[j] + i - j) 
/// : the sum of the values of the sightseeing spots, minus the distance 
/// between them.
///
/// Return the maximum score of a pair of sightseeing spots.
///
/// 
///
/// Example 1:
///
/// Input: [8,1,5,2,6]
/// Output: 11
/// Explanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11
///
/// 
/// Note:
/// 
/// 1. 2 <= A.length <= 50000
/// 2. 1 <= A[i] <= 1000
/// </summary>
int LeetCodeArray::maxScoreSightseeingPair(vector<int>& A)
{
    int i = 0; 
    int j = 1;
    int result = A[i] + A[j] + i - j;
    for (int k = j + 1; k < (int)A.size(); k++)
    {
        int sum0 = A[i] + A[j] + i - j;
        int sum1 = A[j] + A[k] + j - k;
        int sum2 = A[i] + A[k] + i - k;
        result = max(result, sum1);
        result = max(result, sum2);
        if (A[i] + i -j < A[j])
        {
            i = j;
            j = k;
        }
        else if (A[j] + j - k < A[k])
        {
            j = k;
        }
    }
    return result;
}

/// <summary>
/// Leet code #1036. Escape a Large Maze
/// 
/// In a 1 million by 1 million grid, the coordinates of each grid square
/// are (x, y) with 0 <= x, y < 10^6.
///
/// We start at the source square and want to reach the target square.  
/// Each move, we can walk to a 4-directionally adjacent square in the grid
/// that isn't in the given list of blocked squares.
///
/// Return true if and only if it is possible to reach the target square 
/// through a sequence of moves.
///
/// Example 1:
///
/// Input: blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]
/// Output: false
/// Explanation: 
/// The target square is inaccessible starting from the source square, 
/// because we can't walk outside the grid.
///
/// Example 2:
///
/// Input: blocked = [], source = [0,0], target = [999999,999999]
/// Output: true
/// Explanation: 
/// Because there are no blocked cells, it's possible to reach the target 
/// square.
/// 
/// Note:
/// 1. 0 <= blocked.length <= 200
/// 2. blocked[i].length == 2
/// 3. 0 <= blocked[i][j] < 10^6
/// 4. source.length == target.length == 2
/// 5. 0 <= source[i][j], target[i][j] < 10^6
/// 6. source != target
/// </summary>
bool LeetCodeArray::isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target)
{
    unordered_map<int, int> row_map, col_map;
    vector<int> row, col;
    for (size_t i = 0; i < blocked.size(); i++)
    {
        row.push_back(blocked[i][0]);
        col.push_back(blocked[i][1]);
    }
    row.push_back(source[0]);
    col.push_back(source[1]);
    row.push_back(target[0]);
    col.push_back(target[1]);
    sort(row.begin(), row.end());
    sort(col.begin(), col.end());

    int row_id = 0;
    int col_id = 0;
    for (size_t i = 0; i < row.size(); i++)
    {
        if (i == 0)
        {
            if (row[0] > 0) row_id++;
            if (col[0] > 0) col_id++;
        }
        else 
        {
            if (row[i] == row[i - 1] + 1)
            {
                row_id++;
            }
            else if (row[i] > row[i - 1] + 1)
            {
                row_id += 2;
            }
            if (col[i] == col[i - 1] + 1)
            {
                col_id++;
            }
            else if (col[i] > col[i - 1] + 1)
            {
                col_id += 2;
            }
        }
        row_map[row[i]] = row_id;
        col_map[col[i]] = col_id;
    }
    if (row[row.size()-1] < 999999) row_id++;
    if (col[col.size() - 1] < 999999) col_id++;
    vector<vector<int>> grid(row_id + 1, vector<int>(col_id + 1));
    for (size_t i = 0; i < blocked.size(); i++)
    {
        grid[row_map[blocked[i][0]]][col_map[blocked[i][1]]] = 1;
    }
    int x = row_map[source[0]];
    int y = col_map[source[1]];
    grid[row_map[target[0]]][col_map[target[1]]] = 2;
 
    vector<vector<int>> directions = { {-1, 0}, {0, -1}, {1, 0}, {0, 1} };
    queue<vector<int>> search;
    search.push({ x, y });
    grid[x][y] = 1;
    while (!search.empty())
    {
        vector<int> pos = search.front();
        if (grid[pos[0]][pos[1]] == 2) return true;
        search.pop();
        for (int d = 0; d < 4; d++)
        {
            vector<int> next_pos = pos;
            next_pos[0] += directions[d][0];
            next_pos[1] += directions[d][1];
            if (next_pos[0] < 0 || next_pos[0] > row_id || next_pos[1] < 0 || next_pos[1] > col_id)
            {
                continue;
            }
            if (grid[next_pos[0]][next_pos[1]] == 1)
            {
                continue;
            }
            if (grid[next_pos[0]][next_pos[1]] == 0) grid[next_pos[0]][next_pos[1]] = 1;
            search.push(next_pos);
        }
    }
    return false;
}

/// <summary>
/// Leet code #1052. Grumpy Bookstore Owner
/// 
/// Today, the bookstore owner has a store open for customers.length minutes.  
/// Every minute, some number of customers (customers[i]) enter the store, 
/// and all those customers leave after the end of that minute.
///
/// On some minutes, the bookstore owner is grumpy.  If the bookstore owner 
/// is grumpy on the i-th minute, grumpy[i] = 1, otherwise grumpy[i] = 0.  
/// When the bookstore owner is grumpy, the customers of that minute are not 
/// satisfied, otherwise they are satisfied.
///
/// The bookstore owner knows a secret technique to keep themselves not grumpy 
/// for X minutes straight, but can only use it once.
///
/// Return the maximum number of customers that can be satisfied throughout 
/// the day.
/// 
/// Example 1:
///
/// Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3
/// Output: 16
/// Explanation: The bookstore owner keeps themselves not grumpy for the last 
/// 3 minutes. 
/// The maximum number of customers that can be 
/// satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.
/// 
/// Note:
///
/// 1. 1 <= X <= customers.length == grumpy.length <= 20000
/// 2. 0 <= customers[i] <= 1000
/// 3. 0 <= grumpy[i] <= 1
/// </summary>
int LeetCodeArray::maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X)
{
    int result = 0, grumpy_sum = 0, grumpy_max = 0;

    for (size_t i = 0; i < customers.size(); i++)
    {
        if (grumpy[i] == 0) result += customers[i];
        else
        {
            grumpy_sum += customers[i];
        }
        if (i >= (size_t)X)
        {
            if (grumpy[i - X] == 1)
            {
                grumpy_sum -= customers[i - X];
            }
        }
        grumpy_max = max(grumpy_max, grumpy_sum);
    }
    result += grumpy_max;
    return result;
}

/// <summary>
/// Leet code #1074. Number of Submatrices That Sum to Target
/// 
/// Given a matrix, and a target, return the number of non-empty submatrices 
/// that sum to target.
///
/// A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with 
/// x1 <= x <= x2 and y1 <= y <= y2.
///
/// Two submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different 
/// if they have some coordinate that is different: for example, if x1 != x1'.
///
/// Example 1:
///
/// Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
/// Output: 4
/// Explanation: The four 1x1 submatrices that only contain 0.
///
/// Example 2:
///
/// Input: matrix = [[1,-1],[-1,1]], target = 0
/// Output: 5
/// Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus 
/// the 2x2 submatrix.
/// 
///
/// Note:
///
/// 1. 1 <= matrix.length <= 300
/// 2. 1 <= matrix[0].length <= 300
/// 3. -1000 <= matrix[i] <= 1000
/// 4. -10^8 <= target <= 10^8
/// </summary>
int LeetCodeArray::numSubmatrixSumTarget(vector<vector<int>>& matrix, int target)
{
    int result = 0;
    vector<vector<int>> sum(matrix.size(), vector<int>(matrix[0].size()));

    for (size_t i = 0; i < matrix.size(); i++)
    {
        for (size_t j = 0; j < matrix[0].size(); j++)
        {
            if (j == 0) sum[i][j] = matrix[i][j];
            else sum[i][j] = sum[i][j - 1] + matrix[i][j];
        }
    }

    for (size_t c1 = 0; c1 < matrix[0].size(); c1++)
    {
        for (size_t c2 = c1; c2 < matrix[0].size(); c2++)
        {
            unordered_map<int, int> num_map;
            int sum_num = 0;
            num_map[sum_num]++;
            for (size_t r = 0; r < matrix.size(); r++)
            {
                int num = 0;
                if (c1 == 0) num = sum[r][c2];
                else num = sum[r][c2] - sum[r][c1 - 1];
                sum_num += num;
                if (num_map.count(sum_num - target) > 0)
                {
                    result += num_map[sum_num - target];
                }
                num_map[sum_num]++;
            }
        }
    }
    return result;
}



/// <summary>
/// Leet code #1089. Duplicate Zeros
/// 
/// Given a fixed length array arr of integers, duplicate each occurrence 
/// of zero, shifting the remaining elements to the right.
///
/// Note that elements beyond the length of the original array are not 
/// written.
///
/// Do the above modifications to the input array in place, do not return 
/// anything from your function.
///  
/// Example 1:
/// Input: [1,0,2,3,0,4,5,0]
/// Output: null
/// Explanation: After calling your function, the input array is modified 
/// to: [1,0,0,2,3,0,0,4]
///
/// Example 2:
///
/// Input: [1,2,3]
/// Output: null
/// Explanation: After calling your function, the input array is modified 
/// to: [1,2,3]
///
/// Note:
/// 1. 1 <= arr.length <= 10000
/// 2. 0 <= arr[i] <= 9
/// </summary>
void LeetCodeArray::duplicateZeros(vector<int>& arr)
{
    int count = 0;
    int index = 0;
    while (index + count < (int)arr.size())
    {
        if (arr[index] == 0) count++;
        index++;
    }
    index--;
    for (int i = arr.size() - 1; i >= 0; i--)
    {
        arr[i] = arr[index];
        if (arr[index] == 0)
        {
            if (index + count < (int)arr.size())
            {
                i--;
                arr[i] = 0;
            }
            count--;
        }
        index--;
    }
}

/// <summary>
/// Leet code #1124. Longest Well-Performing Interval
/// 
/// We are given hours, a list of the number of hours worked per day for a 
/// given employee.
/// A day is considered to be a tiring day if and only if the number of hours 
/// worked is (strictly) greater than 8.
/// A well-performing interval is an interval of days for which the number of 
/// tiring days is strictly larger than the number of non-tiring days.
/// Return the length of the longest well-performing interval.
/// 
/// Example 1:
/// Input: hours = [9,9,6,0,6,6,9]
/// Output: 3
/// Explanation: The longest well-performing interval is [9,9,6].
/// 
/// Constraints:
/// 1. 1 <= hours.length <= 10000
/// 2. 0 <= hours[i] <= 16
/// </summary>
int LeetCodeArray::longestWPI(vector<int>& hours)
{
    int n = hours.size();
    vector<int> dp(n, -1);
    int sum = 0;
    int result = 0;
    for (int i = 0; i < (int)hours.size(); i++)
    {
        if (hours[i] <= 8)
        {
            sum--;
        }
        else
        {
            sum++;
        }

        if (sum > 0) result = i + 1;
        else if (sum == -n) continue;
        else
        {
            // for zero we do not need to store the position
            if (sum < 0) if (dp[sum + n] == -1) dp[sum + n] = i;
            if (dp[sum + n - 1] != -1)
            {
                result = max(result, i - dp[sum + n - 1]);
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #1121. Divide Array Into Increasing Sequences
/// 
/// Given a non-decreasing array of positive integers nums and an integer K, 
/// find out if this array can be divided into one or more disjoint 
/// increasing subsequences of length at least K.
/// 
/// Example 1:
/// Input: nums = [1,2,2,3,3,4,4], K = 3
/// Output: true
/// Explanation: 
/// The array can be divided into the two subsequences [1,2,3,4] and [2,3,4] 
/// with lengths at least 3 each.
///
/// Example 2:
/// Input: nums = [5,6,6,7,8], K = 3
/// Output: false
/// Explanation: 
/// There is no way to divide the array using the conditions required.
/// 
/// Note:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= K <= nums.length
/// 3. 1 <= nums[i] <= 10^5
/// </summary>
bool LeetCodeArray::canDivideIntoSubsequences(vector<int>& nums, int K)
{
    int max_dup = 0;
    int first = 0;
    for (int i = 0; i <= (int)nums.size(); i++)
    {
        if (i == nums.size())
        {
            max_dup = max(max_dup, i - first);
        }
        else if (i > 0 && nums[i] != nums[i - 1])
        {
            max_dup = max(max_dup, i - first);
            first = i;
        }
    }
    // the minimum length of the increasing sequence is determined by 
    // maxium duplication
    if ((int)nums.size() / max_dup >= K)
    {
        return true;
    }
    else
    {
        return false;
    }
}

/// <summary>
/// Leet code #1138. Alphabet Board Path
/// 
/// On an alphabet board, we start at position (0, 0), corresponding to 
/// character board[0][0].
///
/// Here, board = ["abcde", "fghij", "klmno", "pqrst", "uvwxy", "z"], 
/// as shown in the diagram below.
///
/// We may make the following moves:
///
/// 'U' moves our position up one row, if the position exists on the 
/// board;
/// 'D' moves our position down one row, if the position exists on the 
/// board;
/// 'L' moves our position left one column, if the position exists on the 
/// board;
/// 'R' moves our position right one column, if the position exists on the 
/// board;
/// '!' adds the character board[r][c] at our current position (r, c) to the 
/// answer.
/// (Here, the only positions that exist on the board are positions with 
///  letters on them.)
///
/// Return a sequence of moves that makes our answer equal to target in the 
/// minimum number of moves.  You may return any path that does so.
///
/// Example 1:
/// Input: target = "leet"
/// Output: "DDR!UURRR!!DDD!"
///
/// Example 2:
/// Input: target = "code"
/// Output: "RR!DDRR!UUL!R!"
///  
/// Constraints:
/// 1. 1 <= target.length <= 100
/// 2. target consists only of English lowercase letters.
/// </summary>
string LeetCodeArray::alphabetBoardPath(string target)
{
    string result;
    char curr = 'a';
    for (size_t i = 0; i < target.size(); i++)
    {
        char next = target[i];
        int row_curr = (curr - 'a') / 5;
        int col_curr = (curr - 'a') % 5;

        int row_next = (next - 'a') / 5;
        int col_next = (next - 'a') % 5;

        if (next == 'z')
        {
            if (col_curr > col_next) result.append(string(col_curr - col_next, 'L'));
            if (row_next > row_curr) result.append(string(row_next - row_curr, 'D'));
        }
        else if (curr == 'z')
        {
            if (row_curr > row_next) result.append(string(row_curr - row_next, 'U'));
            if (col_next - col_curr) result.append(string(col_next - col_curr, 'R'));
        }
        else
        {
            if (row_next > row_curr)
            {
                result.append(string(row_next - row_curr, 'D'));
            }
            else if (row_next < row_curr)
            {
                result.append(string(row_curr - row_next, 'U'));
            }
            if (col_next > col_curr)
            {
                result.append(string(col_next - col_curr, 'R'));
            }
            else if (col_next < col_curr)
            {
                result.append(string(col_curr - col_next, 'L'));
            }
        }
        result.push_back('!');
        curr = next;
    }
    return result;
}

/// <summary>
/// Leet code #1176. Diet Plan Performance
/// 
/// A dieter consumes calories[i] calories on the i-th day.  For every 
/// consecutive sequence of k days, they look at T, the total calories 
/// consumed during that sequence of k days:
/// If T < lower, they performed poorly on their diet and lose 1 point; 
/// If T > upper, they performed well on their diet and gain 1 point;
/// Otherwise, they performed normally and there is no change in points.
/// Return the total number of points the dieter has after all 
/// calories.length days.
///
/// Note that: The total points could be negative.
/// 
/// Example 1:
/// Input: calories = [1,2,3,4,5], k = 1, lower = 3, upper = 3
/// Output: 0
/// Explaination: calories[0], calories[1] < lower and 
/// calories[3], calories[4] > upper, total points = 0.
///
/// Example 2:
/// Input: calories = [3,2], k = 2, lower = 0, upper = 1
/// Output: 1
/// Explaination: calories[0] + calories[1] > upper, total points = 1.
///
/// Example 3:
/// Input: calories = [6,5,0,0], k = 2, lower = 1, upper = 5
/// Output: 0
/// Explaination: calories[0] + calories[1] > upper, 
/// calories[2] + calories[3] < lower, total points = 0.
/// 
/// Constraints:
/// 1. 1 <= k <= calories.length <= 10^5
/// 2. 0 <= calories[i] <= 20000
/// 3. 0 <= lower <= upper
/// </summary>
int LeetCodeArray::dietPlanPerformance(vector<int>& calories, int k, int lower, int upper)
{
    vector<int> sum(calories.size());
    for (size_t i = 0; i < calories.size(); i++)
    {
        sum[i] = calories[i];
        if (i > 0) sum[i] += sum[i - 1];
    }
    int result = 0;
    for (int i = k - 1; i < (int)sum.size(); i++)
    {
        int s = sum[i];
        if (i > k - 1)
        {
            s -= sum[i - k];
        }
        if (s > upper) result++;
        else if (s < lower) result--;
    }
    return result;
}

/// <summary>
/// Leet code #1183. Maximum Number of Ones
/// 
/// Consider a matrix M with dimensions width * height, such that every cell
/// has value 0 or 1, and any square sub-matrix of M of size 
/// sideLength * sideLength has at most maxOnes ones.
/// Return the maximum possible number of ones that the matrix M can have.
/// 
/// Example 1:
/// Input: width = 3, height = 3, sideLength = 2, maxOnes = 1
/// Output: 4
/// Explanation:
/// In a 3*3 matrix, no 2*2 sub-matrix can have more than 1 one.
/// The best solution that has 4 ones is:
/// [1,0,1]
/// [0,0,0]
/// [1,0,1]
///
/// Example 2:
/// Input: width = 3, height = 3, sideLength = 2, maxOnes = 2
/// Output: 6
/// Explanation:
/// [1,0,1]
/// [1,0,1]
/// [1,0,1]
/// 
/// Constraints:
/// 1. 1 <= width, height <= 100
/// 2. 1 <= sideLength <= width, height
/// 3. 0 <= maxOnes <= sideLength * sideLength
/// </summary>
int LeetCodeArray::maximumNumberOfOnes(int width, int height, int sideLength, int maxOnes)
{
    priority_queue<int> heap;
    for (int i = 0; i < sideLength; i++)
    {
        for (int j = 0; j < sideLength; j++)
        {
            int count = ((width + sideLength - 1 - j) / sideLength) *
                ((height + sideLength - 1 - i) / sideLength);
            heap.push(count);
        }
    }

    int result = 0;
    for (int i = 0; i < maxOnes; i++)
    {
        result += heap.top();
        heap.pop();
    }
    return result;
 }

/// <summary>
/// Leet code #1184. Distance Between Bus Stops
/// 
/// A bus has n stops numbered from 0 to n - 1 that form a circle. We know 
/// the distance between all pairs of neighboring stops where distance[i] 
/// is the distance between the stops number i and (i + 1) % n.
/// The bus goes along both directions i.e. clockwise and counterclockwise.
/// Return the shortest distance between the given start and destination 
/// stops.
/// 
/// Example 1:
///
/// Input: distance = [1,2,3,4], start = 0, destination = 1
/// Output: 1
/// Explanation: Distance between 0 and 1 is 1 or 9, minimum is 1.
/// 
/// Example 2:
///
/// Input: distance = [1,2,3,4], start = 0, destination = 2
/// Output: 3
/// Explanation: Distance between 0 and 2 is 3 or 7, minimum is 3.
///  
/// Example 3:
///
/// Input: distance = [1,2,3,4], start = 0, destination = 3
/// Output: 4
/// Explanation: Distance between 0 and 3 is 6 or 4, minimum is 4.
/// 
/// Constraints:
/// 1. 1 <= n <= 10^4
/// 2. distance.length == n
/// 3. 0 <= start, destination < n
/// 4. 0 <= distance[i] <= 10^4
/// </summary>
int LeetCodeArray::distanceBetweenBusStops(vector<int>& distance, int start, int destination)
{
    int distance1 = 0;
    for (int i = start; ; i++)
    {
        if (i == distance.size()) i = 0;
        if (i == destination) break;
        distance1 += distance[i];
    }

    int distance2 = 0;
    for (int i = destination; ; i++)
    {
        if (i == distance.size()) i = 0;
        if (i == start) break;
        distance2 += distance[i];
    }
    return min(distance1, distance2);
}

/// <summary>
/// Leet code #1186. Maximum Subarray Sum with One Deletion
/// 
/// Given an array of integers, return the maximum sum for a non-empty 
/// subarray (contiguous elements) with at most one element deletion. 
/// In other words, you want to choose a subarray and optionally delete 
/// one element from it so that there is still at least one element left 
/// and the sum of the remaining elements is maximum possible.
/// Note that the subarray needs to be non-empty after deleting one element.
/// 
/// Example 1:
/// Input: arr = [1,-2,0,3]
/// Output: 4
/// Explanation: Because we can choose [1, -2, 0, 3] and drop -2, thus the 
/// subarray [1, 0, 3] becomes the maximum value.
///
/// Example 2:
/// Input: arr = [1,-2,-2,3]
/// Output: 3
/// Explanation: We just choose [3] and it's the maximum sum.
///
/// Example 3:
/// Input: arr = [-1,-1,-1,-1]
/// Output: -1
/// Explanation: The final subarray needs to be non-empty. You can't 
/// choose [-1] and delete -1 from it, then get an empty subarray to make 
/// the sum equals to 0.
/// 
/// Constraints:
/// 1. 1 <= arr.length <= 10^5
/// 2. -10^4 <= arr[i] <= 10^4
/// </summary>
int LeetCodeArray::maximumSum(vector<int>& arr)
{
    vector<int> dp1(arr.size()), dp2(arr.size());
    for (size_t i = 0; i < arr.size(); i++)
    {
        dp1[i] = arr[i];
        if (i > 0) dp1[i] = max(dp1[i-1] + arr[i], dp1[i]);
    }
    for (int i = arr.size() - 1; i >=0; i--)
    {
        dp2[i] = arr[i];
        if (i < (int)arr.size() - 1) dp2[i] = max(dp2[i + 1] + arr[i], dp2[i]);
    }
    int result = INT_MIN;
    for (size_t i = 0; i < arr.size(); i++)
    {
        result = max(result, dp1[i]);
        if (i > 0 && i < arr.size() - 1)
        {
            result = max(result, dp1[i - 1] + dp2[i + 1]);
        }
    }
    return result;
}

/// <summary>
/// Leet code #1191. K-Concatenation Maximum Sum
/// 
/// Given an integer array arr and an integer k, modify the array by repeating 
/// it k times.
/// For example, if arr = [1, 2] and k = 3 then the modified array will 
/// be [1, 2, 1, 2, 1, 2].
/// Return the maximum sub-array sum in the modified array. Note that the 
/// length of the sub-array can be 0 and its sum in that case is 0.
///
/// As the answer can be very large, return the answer modulo 10^9 + 7.
/// 
/// Example 1:
/// Input: arr = [1,2], k = 3
/// Output: 9
///
/// Example 2:
/// Input: arr = [1,-2,1], k = 5
/// Output: 2
/// Example 3:
/// Input: arr = [-1,-2], k = 7
/// Output: 0
/// 
/// Constraints:
/// 1. 1 <= arr.length <= 10^5
/// 2. 1 <= k <= 10^5
/// 3. -10^4 <= arr[i] <= 10^4
/// </summary>
int LeetCodeArray::kConcatenationMaxSum(vector<int>& arr, int k)
{
    int M = 1000000007;
    // use 64 bits so we do not worry about overflow
    long long sum = 0;
    long long min_sum = 0;
    long long result = 0;
    int n = arr.size();
    for (size_t i = 0; i < min(k, 2) * arr.size(); i++)
    {
        sum += arr[i % n];
        result = max(result, sum - min_sum);
        min_sum = min(min_sum, sum);
    }
    if (sum > 0 && k > 2)
    {
        result += (sum / 2) * ((long long)k - 2);
    }
    result = result % M;
    return (int)result;
}

/// <summary>
/// Leet code #1200. Minimum Absolute Difference
/// 
/// Given an array of distinct integers arr, find all pairs of elements 
/// with the minimum absolute difference of any two elements. 
///
/// Return a list of pairs in ascending order(with respect to pairs), 
/// each pair [a, b] follows
///
/// a, b are from arr
/// a < b
/// b - a equals to the minimum absolute difference of any two elements in arr
/// 
///
/// Example 1:
///
/// Input: arr = [4,2,1,3]
/// Output: [[1,2],[2,3],[3,4]]
/// Explanation: The minimum absolute difference is 1. List all pairs with 
/// difference equal to 1 in ascending order.
///
/// Example 2:
///
/// Input: arr = [1,3,6,10,15]
/// Output: [[1,3]]
///
/// Example 3:
///
/// Input: arr = [3,8,-10,23,19,-4,-14,27]
/// Output: [[-14,-10],[19,23],[23,27]]
/// 
/// Constraints:
/// 1. 2 <= arr.length <= 10^5
/// 2. -10^6 <= arr[i] <= 10^6
/// </summary>
vector<vector<int>> LeetCodeArray::minimumAbsDifference(vector<int>& arr)
{
    int diff = INT_MAX;
    vector<int> nums = arr;
    sort(nums.begin(), nums.end());
    deque<vector<int>> min_deque;
    for (size_t i = 0; i < nums.size() -1; i++)
    {
        if (nums[i + 1] - nums[i] < diff)
        {
            min_deque.clear();
            diff = nums[i + 1] - nums[i];
        }
        if (nums[i + 1] - nums[i] == diff)
        {
            min_deque.push_back({ nums[i], nums[i + 1] });
        }
    }
    vector<vector<int>> result = vector<vector<int>>(min_deque.begin(), min_deque.end());
    return result;
}

/// <summary>
/// Leet code #1198. Find Smallest Common Element in All Rows
/// 
/// Given a matrix mat where every row is sorted in increasing order, return 
/// the smallest common element in all rows.
///
/// If there is no common element, return -1.
///
/// 
///
/// Example 1:
///
/// Input: mat = [[1,2,3,4,5],[2,4,5,8,10],[3,5,7,9,11],[1,3,5,7,9]]
/// Output: 5
/// 
///
/// Constraints:
///
/// 1. 1 <= mat.length, mat[i].length <= 500
/// 2. 1 <= mat[i][j] <= 10^4
/// 3. mat[i] is sorted in increasing order.
/// </summary>
int LeetCodeArray::smallestCommonElement(vector<vector<int>>& mat)
{
    priority_queue<pair<int, int>> common;
    int largest = 0;
    for (size_t i = 0; i < mat.size(); i++)
    {
        common.push(make_pair(-mat[i][0], i));
        largest = max(largest, mat[i][0]);
    }
    int result = -1;
    while (!common.empty())
    {
        pair<int, int> pos = common.top();
        common.pop();
        result = -pos.first;
        if (result == largest)
        {
            return result;
        }
        else
        {
            int index = lower_bound(mat[pos.second].begin(), mat[pos.second].end(), largest) 
                        - mat[pos.second].begin();
            if (index == mat[pos.second].size())
            {
                return -1;
            }
            else
            {
                largest = max(largest, mat[pos.second][index]);
                common.push(make_pair(0-mat[pos.second][index], pos.second));
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #1208. Get Equal Substrings Within Budget
///
/// You are given two strings s and t of the same length. You want to change
/// s to t. Changing the i-th character of s to i-th character of t costs 
/// |s[i] - t[i]| that is, the absolute difference between the ASCII values 
/// of the characters.
///
/// You are also given an integer maxCost.
///
/// Return the maximum length of a substring of s that can be changed to be 
/// the same as the corresponding substring of twith a cost less than or equal 
/// to maxCost.
///
/// If there is no substring from s that can be changed to its corresponding 
/// substring from t, return 0.
///
/// Example 1:
///
/// Input: s = "abcd", t = "bcdf", maxCost = 3
/// Output: 3
/// Explanation: "abc" of s can change to "bcd". That costs 3, so the maximum 
/// length is 3.
///
/// Example 2:
/// 
/// Input: s = "abcd", t = "cdef", maxCost = 3
/// Output: 1
/// Explanation: Each character in s costs 2 to change to charactor in t, so 
/// the maximum length is 1.
///
/// Example 3:
///
/// Input: s = "bacd", t = "cade", maxCost = 0
/// Output: 1
/// Explanation: You can't make any change, so the maximum length is 1.
/// 
/// Constraints:
/// 1. 1 <= s.length, t.length <= 10^5
/// 2. 0 <= maxCost <= 10^6
/// 3. s and t only contain lower case English letters.
/// </summary>
int LeetCodeArray::equalSubstring(string s, string t, int maxCost)
{
    int sum = 0;
    int result = 0;
    deque<int> sub_deq;
    for (size_t i = 0; i < s.size(); i++)
    {
        int cost = abs(s[i] - t[i]);
        sub_deq.push_back(cost);
        sum += cost;
        while ((!sub_deq.empty()) && (sum > maxCost))
        {
            sum -= sub_deq.front();
            sub_deq.pop_front();
        }
        if (sum <= maxCost)
        {
            result = max(result, (int)sub_deq.size());
        }
    }
    return result;
}

/// <summary>
/// Leet code #1221. Split a String in Balanced Strings
/// 
/// Balanced strings are those who have equal quantity of 'L' and 'R' 
/// characters.
///
/// Given a balanced string s split it in the maximum amount of balanced 
/// strings.
///
/// Return the maximum amount of splitted balanced strings.
///
/// Example 1:
///
/// Input: s = "RLRRLLRLRL"
/// Output: 4
/// Explanation: s can be split into "RL", "RRLL", "RL", "RL", each substring 
/// contains same number of 'L' and 'R'.
///
/// Example 2:
///
/// Input: s = "RLLLLRRRLR"
/// Output: 3
/// Explanation: s can be split into "RL", "LLLRRR", "LR", each substring 
/// contains same number of 'L' and 'R'.
///
/// Example 3:
///
/// Input: s = "LLLLRRRR"
/// Output: 1
/// Explanation: s can be split into "LLLLRRRR".
///  
/// Constraints:
/// 
/// 1. 1 <= s.length <= 1000
/// 2. s[i] = 'L' or 'R'
/// </summary>
int LeetCodeArray::balancedStringSplit(string s)
{
    int result = 0;
    int match = 0;

    for (size_t i = 0; i < s.size(); i++)
    {
        if (s[i] == 'L') match++;
        else match--;
        if (match == 0) result++;
    }
    return result;
}

/// <summary>
/// Leet code #1222. Queens That Can Attack the King
/// 
/// On an 8x8 chessboard, there can be multiple Black Queens and one 
/// White King.
///
/// Given an array of integer coordinates queens that represents the 
/// positions of the Black Queens, and a pair of coordinates king that 
/// represent the position of the White King, return the coordinates 
/// of all the queens (in any order) that can attack the King.
///
/// 
/// Example 1:
/// 
/// Input: queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0]
/// Output: [[0,1],[1,0],[3,3]]
/// Explanation:  
/// The queen at [0,1] can attack the king cause they're in the same row. 
/// The queen at [1,0] can attack the king cause they're in the same column. 
/// The queen at [3,3] can attack the king cause they're in the same diagnal.
/// The queen at [0,4] can't attack the king cause it's blocked by the 
/// queen at [0,1]. 
/// The queen at [4,0] can't attack the king cause it's blocked by the 
/// queen at [1,0]. 
/// The queen at [2,4] can't attack the king cause it's not in the same 
/// row/column/diagnal as the king.
///
/// Example 2:
/// Input: queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], king = [3,3]
/// Output: [[2,2],[3,4],[4,4]]
///
/// Example 3:
/// Input: queens = 
/// [[5,6],[7,7],[2,1],[0,7],[1,6],[5,1],[3,7],[0,3],[4,0],[1,2],[6,3],[5,0],
/// [0,4],[2,2],[1,1],[6,4],[5,4],[0,0],[2,6],[4,5],[5,2],[1,4],[7,5],[2,3],
/// [0,5],[4,2],[1,0],[2,7],[0,1],[4,6],[6,1],[0,6],[4,3],[1,7]], king = [3,4]
/// Output: [[2,3],[1,4],[1,6],[3,7],[4,3],[5,4],[4,5]]
/// 
/// Constraints:
/// 1. 1 <= queens.length <= 63
/// 2. queens[0].length == 2
/// 3. 0 <= queens[i][j] < 8
/// 4. king.length == 2
/// 5. 0 <= king[0], king[1] < 8
/// 6. At most one piece is allowed in a cell.
/// </summary>
vector<vector<int>> LeetCodeArray::queensAttacktheKing(vector<vector<int>>& queens, vector<int>& king)
{
    vector<vector<int>> result;
    vector<vector<int>> board(8, vector<int>(8));
    for (size_t i = 0; i < queens.size(); i++)
    {
        board[queens[i][0]][queens[i][1]] = 1;
    }

    for (size_t i = 0; i < 8; i++)
    {
        int r = king[0];
        int c = king[1];
        if (i == 0)
        {
            while (r >= 0 && c >= 0 && board[r][c] == 0)
            {
                r--;
                c--;
            }
        }
        else if (i == 1)
        {
            while (r >= 0 && c >= 0 && board[r][c] == 0)
            {
                r--;
            }
        }
        else if (i == 2)
        {
            while (r >= 0 && c >= 0 && board[r][c] == 0)
            {
                c--;
            }
        }
        else if (i == 3)
        {
            while (r >= 0 && c < 8 && board[r][c] == 0)
            {
                r--;
                c++;
            }
        }
        else if (i == 4)
        {
            while (r < 8 && c >= 0 && board[r][c] == 0)
            {
                r++;
                c--;
            }
        }
        else if (i == 5)
        {
            while (r < 8 && c < 8 && board[r][c] == 0)
            {
                r++;
            }
        }
        else if (i == 6)
        {
            while (r < 8 && c < 8 && board[r][c] == 0)
            {
                c++;
            }
        }
        else
        {
            while (r < 8 && c < 8 && board[r][c] == 0)
            {
                r++;
                c++;
            }
        }
        if (r >= 0 && c >= 0 && r < 8 && c < 8)
        {
            result.push_back({ r, c });
        }
    }
    return result;
}

/// <summary>
/// Leet code #1228. Missing Number In Arithmetic Progression
/// 
/// In some array arr, the values were in arithmetic progression: the 
/// values arr[i+1] - arr[i] are all equal for every 
/// 0 <= i < arr.length - 1.
///
/// Then, a value from arr was removed that was not the first or last 
/// value in the array.
///
/// Return the removed value.
///
/// Example 1:
///
/// Input: arr = [5,7,11,13]
/// Output: 9
/// Explanation: The previous array was [5,7,9,11,13].
///
/// Example 2:
/// Input: arr = [15,13,12]
/// Output: 14
/// Explanation: The previous array was [15,14,13,12].
///
/// Constraints:
/// 1. 3 <= arr.length <= 1000
/// 2. 0 <= arr[i] <= 10^5
/// </summary>
int LeetCodeArray::missingNumber(vector<int>& arr)
{
    int prev = 0;
    int prev_diff = 0;
    int result = 0;
    for (size_t i = 1; i < arr.size(); i++)
    {
        int diff = arr[i] - arr[i - 1];
        if ((i == 1) || (prev_diff == diff))
        {
            prev = arr[i - 1];
            prev_diff = arr[i] - arr[i - 1];
        }
        else
        {
            if (abs(prev_diff) < abs(diff))
            {
                result = arr[i - 1] + prev_diff;
            }
            else
            {
                result = prev + diff;
            }
            break;
        }
    }
    return result;
}

/// <summary>
/// Leet code #152. Maximum Product Subarray
/// 
/// Given an integer array nums, find the contiguous subarray within an array 
/// (containing at least one number) which has the largest product.
///
/// Example 1:
///
/// Input: [2,3,-2,4]
/// Output: 6
/// Explanation: [2,3] has the largest product 6.
///
/// Example 2:
///
/// Input: [-2,0,-1]
/// Output: 0
/// Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
/// </summary>
int LeetCodeArray::maxProduct(vector<int>& nums)
{
    int result = INT_MIN;
    int min_product = 1;
    int max_product = 1;
    for (size_t i = 0; i < nums.size(); i++)
    {
        int curr_min = min(min(nums[i] * min_product, nums[i] * max_product), nums[i]);
        int curr_max = max(max(nums[i] * min_product, nums[i] * max_product), nums[i]);
        min_product = curr_min;
        max_product = curr_max;
        result = max(result, max_product);
    }
    return result;
}

/// <summary>
/// Leet code #325. Maximum Size Subarray Sum Equals k
/// 
/// Given an array nums and a target value k, find the maximum length of a 
/// subarray that sums to k. 
/// If there isn't one, return 0 instead. 
/// Note:
/// The sum of the entire nums array is guaranteed to fit within the 32-bit 
/// signed integer range. 
///
/// Example 1:
/// Given nums = [1, -1, 5, -2, 3], k = 3,
/// return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest) 
///
/// Example 2:
/// Given nums = [-2, -1, 2, 1], k = 1,
/// return 2. (because the subarray [-1, 2] sums to 1 and is the longest) 
///
/// Follow Up:
/// Can you do it in O(n) time? 
/// </summary>
int LeetCodeArray::maxSubArrayLen(vector<int>& nums, int k)
{
    unordered_map<int, int> sum_map;
    int sum = 0;
    int max_length = 0;

    sum_map[0] = -1;
    for (int i = 0; i < (int)nums.size(); i++)
    {
        sum += nums[i];
        if (sum_map.find(sum - k) != sum_map.end())
        {
            max_length = max(max_length, i - sum_map[sum - k]);
        }
        if (sum_map.find(sum) == sum_map.end())
        {
            sum_map[sum] = i;
        }
    }
    return max_length;
}

/// <summary>
/// Leet code #422. Valid Word Square    
/// 
/// Given a sequence of words, check whether it forms a valid word square. 
/// A sequence of words forms a valid word square if the kth row and column 
/// read the exact same string, where 0 ≤ k < max(numRows, numColumns).
/// Note:
/// 1.The number of words given is at least 1 and does not exceed 500.
/// 2.Word length will be at least 1 and does not exceed 500.
/// 3.Each word contains only lowercase English alphabet a-z.
/// Example 1: 
/// Input:
/// [
///  "abcd",
///  "bnrt",
///  "crmy",
///  "dtye"
/// ]
/// Output:
/// true
/// Explanation:
/// The first row and first column both read "abcd".
/// The second row and second column both read "bnrt".
/// The third row and third column both read "crmy".
/// The fourth row and fourth column both read "dtye".
/// Therefore, it is a valid word square.
///
/// Example 2: 
/// Input:
/// [
///  "abcd",
///  "bnrt",
///  "crm",
///  "dt"
/// ]
/// Output:
/// true
///
/// Explanation:
/// The first row and first column both read "abcd".
/// The second row and second column both read "bnrt".
/// The third row and third column both read "crm".
/// The fourth row and fourth column both read "dt".
/// Therefore, it is a valid word square.
/// Example 3: 
/// Input:
/// [
///  "ball",
///  "area",
///  "read",
///  "lady"
/// ]
///
/// Output:
/// false
/// Explanation:
/// The third row reads "read" while the third column reads "lead".
/// Therefore, it is NOT a valid word square.
/// </summary>
bool LeetCodeArray::validWordSquare(vector<string>& words)
{
    for (size_t i = 0; i < words.size(); i++)
    {
        for (size_t j = 0; j < words[i].size(); j++)
        {
            if (j >= words.size() || i >= words[j].size())
            {
                return false;
            }
            if (words[i][j] != words[j][i])
            {
                return false;
            }
        }
    }
    return true;
}

/// <summary>
/// Leet code #523. Continuous Subarray Sum   
/// 
/// Given a list of non-negative numbers and a target integer k, write a 
/// function to check if the array has a continuous subarray of size at 
/// least 2 that sums up to the multiple of k, that is, sums up to n*k 
/// where n is also an integer.
///
/// Example 1:
/// Input: [23, 2, 4, 6, 7],  k=6
/// Output: True
/// Explanation: Because [2, 4] is a continuous subarray of size 2 and 
/// sums up to 6.
/// Example 2:
/// Input: [23, 2, 6, 4, 7],  k=42
/// Output: True
/// Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of 
/// size 5 and sums up to 42.
/// Note:
/// The length of the array won't exceed 10,000.
/// You may assume the sum of all the numbers is in the range of a 
/// signed 32-bit integer.
/// </summary>
bool LeetCodeArray::checkSubarraySum(vector<int>& nums, int k)
{
    unordered_map<int, int> num_map;
    int sum = 0;
    num_map[sum] = -1;
    for (size_t i = 0; i < nums.size(); i++)
    {
        sum += nums[i];
        if (k == 0)
        {
            if ((num_map.count(-sum) > 0) && (num_map[-sum] + 1 < (int)i))
            {
                return true;
            }
            if (num_map.count(sum) == 0) num_map[sum] = i;
        }
        else
        {
            if ((num_map.count(sum % k) > 0) && (num_map[sum % k] + 1 < (int)i))
            {
                return true;
            }
            if (num_map.count(sum % k) == 0) num_map[sum % k] = i;
        }
    }
    return false;
}

/// <summary>
/// Leet code #525. Contiguous Array    
/// 
/// Given a binary array, find the maximum length of a contiguous subarray 
/// with equal number of 0 and 1. 
/// Example 1:
/// Input: [0,1]
/// Output: 2
/// Explanation: [0, 1] is the longest contiguous subarray with equal 
/// number of 0 and 1.
///
/// Example 2:
/// Input: [0,1,0]
/// Output: 2
/// Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with 
/// equal number of 0 and 1.
/// Note: The length of the given binary array will not exceed 50,000. 
/// </summary>
int LeetCodeArray::findMaxLength(vector<int>& nums)
{
    unordered_map<int, int> pos_map;

    // set the initial equal point before the array
    pos_map[0] = -1;
    vector<int> num_count(nums.size());
    int max_length = 0;

    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] == 0)
        {
            num_count[i] = -1;
        }
        else
        {
            num_count[i] = 1;
        }
        if (i > 0) num_count[i] += num_count[i - 1];
        if (pos_map.count(num_count[i]) == 0)
        {
            pos_map[num_count[i]] = i;
        }
        else
        {
            max_length = max(max_length, (int)(i - pos_map[num_count[i]]));
        }
    }
    return max_length;
}

/// <summary>
/// Leet code #891. Sum of Subsequence Widths
/// 
/// Given an array of integers A, consider all non-empty subsequences of A.
///
/// For any sequence S, let the width of S be the difference between the 
/// maximum and minimum element of S.
///
/// Return the sum of the widths of all subsequences of A. 
///
/// As the answer may be very large, return the answer modulo 10^9 + 7.
///
/// Example 1:
///
/// Input: [2,1,3]
/// Output: 6
/// Explanation:
/// Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].
/// The corresponding widths are 0, 0, 0, 1, 1, 2, 2.
/// The sum of these widths is 6.
///
/// Note:
///
/// 1 <= A.length <= 20000
/// 1 <= A[i] <= 20000
/// </summary>
int LeetCodeArray::sumSubseqWidths(vector<int>& A)
{
    int M = 1000000007;
    vector<int> nums = A;
    int result = 0;
    vector<int> factor(A.size());
    for (size_t i = 0; i < A.size(); i++)
    {
        if (i == 0) factor[i] = 1;
        else  factor[i] = (factor[i - 1] << 1) % M;
    }
    sort(nums.begin(), nums.end());
    for (size_t i = 0; i < nums.size(); i++)
    {
        result = (result + ((long long)factor[i] - (long long)1) * nums[i]) % M;
        result = (result - ((long long)factor[A.size() - (long long)1 - (long long)i] - 1) * nums[i]) % M;
        result = (result + M) % M;
    }
    return result;
}

/// <summary>
/// Leet code #560. Subarray Sum Equals K
///
/// Given an array of integers and an integer k, you need to find the 
/// total number of continuous subarrays whose sum equals to k.
/// Example 1:
/// Input:nums = [1,1,1], k = 2 
/// Output: 2
///
/// Note:
/// The length of the array is in range [1, 20,000].
/// The range of numbers in the array is [-1000, 1000] and the range of 
/// the integer k is [-1e7, 1e7].
/// </summary>
int LeetCodeArray::subarraySum(vector<int>& nums, int k)
{
    unordered_map<int, int> sum_map;
    int sum = 0;
    int count = 0;
    sum_map[0] = 1;
    for (size_t i = 0; i < nums.size(); i++)
    {
        sum += nums[i];
        if (sum_map.count(sum - k) > 0)
        {
            count += sum_map[sum - k];
        }
        sum_map[sum]++;
    }
    return count;
}

/// <summary>
/// Leet code #930. Binary Subarrays With Sum
/// 
/// In an array A of 0s and 1s, how many non-empty subarrays have sum S?
/// 
/// Example 1:
/// Input: A = [1,0,1,0,1], S = 2
/// Output: 4
/// Explanation: 
/// The 4 subarrays are bolded below:
/// [1,0,1,x,x]
/// [1,0,1,0,x]
/// [x,0,1,0,1]
/// [x,x,1,0,1]
/// 
/// Note:
/// 
/// 1. A.length <= 30000
/// 2. 0 <= S <= A.length
/// 3. A[i] is either 0 or 1.
/// </summary>
int LeetCodeArray::numSubarraysWithSum(vector<int>& A, int S)
{
    int result = 0;

    vector<int> dp;
    dp.push_back(0);

    for (size_t i = 0; i < A.size(); i++)
    {
        if (A[i] == 1) dp.push_back(0);
        else dp[dp.size() - 1]++;
        if (dp.size() < (size_t)(S + 1)) continue;
        if (S == 0)
        {
            result += dp[dp.size() - 1];
        }
        else
        {
            result += dp[dp.size() - 1 - S] + 1;
        }
    }
    return result;
}

/// <summary>
/// Leet code #974. Subarray Sums Divisible by K
/// 
/// Given an array A of integers, return the number of (contiguous, non-empty) 
/// subarrays that have a sum divisible by K.
///
/// Example 1:
///
/// Input: A = [4,5,0,-2,-3,1], K = 5
/// Output: 7
/// Explanation: There are 7 subarrays with a sum divisible by K = 5:
/// [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], 
/// [-2, -3]
/// 
/// Note:
///
/// 1. 1 <= A.length <= 30000
/// 2. -10000 <= A[i] <= 10000
/// 3. 2 <= K <= 10000
/// </summary>
int LeetCodeArray::subarraysDivByK(vector<int>& A, int K)
{
    vector<int> remainder(K);
    remainder[0]++;
    int sum = 0;
    int result = 0;
    for (size_t i = 0; i < A.size(); i++)
    {
        sum += A[i];
        int mod = (sum % K + K) % K;
        result += remainder[mod];
        remainder[mod]++;
    }
    return result;
}

/// <summary>
/// Leet code #1243. Array Transformation
///  
/// Given an initial array arr, every day you produce a new array using the 
/// array of the previous day.
///
/// On the i-th day, you do the following operations on the array of day 
/// i-1 to produce the array of day i:
///
/// If an element is smaller than both its left neighbor and its right 
/// neighbor, then this element is incremented.
/// If an element is bigger than both its left neighbor and its right 
/// neighbor, then this element is decremented.
/// The first and last elements never change.
/// After some days, the array does not change. Return that final array.
/// 
/// Example 1:
/// Input: arr = [6,2,3,4]
/// Output: [6,3,3,4]
/// Explanation: 
/// On the first day, the array is changed from [6,2,3,4] to [6,3,3,4].
/// No more operations can be done to this array.
///
/// Example 2:
/// Input: arr = [1,6,3,4,3,5]
/// Output: [1,4,4,4,4,5]
/// Explanation: 
/// On the first day, the array is changed from [1,6,3,4,3,5] 
/// to [1,5,4,3,4,5].
/// On the second day, the array is changed from [1,5,4,3,4,5] 
/// to [1,4,4,4,4,5].
/// No more operations can be done to this array.
/// 
/// Constraints:
/// 1. 1 <= arr.length <= 100
/// 2. 1 <= arr[i] <= 100
/// </summary>
vector<int> LeetCodeArray::transformArray(vector<int>& arr)
{
    vector<int> result = arr;
    bool is_final = false;
    while (!is_final)
    {
        is_final = true;
        int left = result[0];
        for (size_t i = 1; i < result.size() - 1; i++)
        {
            int right = result[i + 1];
            int new_val = result[i];
            if (result[i] < left && result[i] < right)
            {
                is_final = false;
                new_val++;
            }
            else if (result[i] > left&& result[i] > right)
            {
                is_final = false;
                new_val--;
            }
            left = result[i];
            result[i] = new_val;
        }
    }
    return result;
}

/// <summary>
/// Leet code #1248. Count Number of Nice Subarrays
///  
/// Given an array of integers nums and an integer k. A subarray is called 
/// nice if there are k odd numbers on it.
///
/// Return the number of nice sub-arrays.
///
/// Example 1:
///
/// Input: nums = [1,1,2,1,1], k = 3
/// Output: 2
/// Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] 
/// and [1,2,1,1].
///
/// Example 2:
///
/// Input: nums = [2,4,6], k = 1
/// Output: 0
/// Explanation: There is no odd numbers in the array.
///
/// Example 3:
///
/// Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2
/// Output: 16
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 50000
/// 2. 1 <= nums[i] <= 10^5
/// 3. 1 <= k <= nums.length
/// </summary>
int LeetCodeArray::numberOfSubarrays(vector<int>& nums, int k)
{
    deque<int> window;
    int count = 1;
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] % 2 == 1)
        {
            window.push_back(count);
            count = 1;
        }
        else
        {
            count++;
        }
        if (window.size() == k)
        {
            result += window.front();
        }
        else if (window.size() == k + 1)
        {
            window.pop_front();
            result += window.front();
        }
    }
    return result;
}

/// <summary>
/// Leet code #1252. Cells with Odd Values in a Matrix
/// 
/// Given n and m which are the dimensions of a matrix initialized by zeros 
/// and given an array indices where indices[i] = [ri, ci]. For each pair 
/// of [ri, ci] you have to increment all cells in row ri and column ci by 1.
///
/// Return the number of cells with odd values in the matrix after applying 
/// the increment to all indices.
/// 
/// Example 1:
/// 
/// Input: n = 2, m = 3, indices = [[0,1],[1,1]]
/// Output: 6
/// Explanation: Initial matrix = [[0,0,0],[0,0,0]].
/// After applying first increment it becomes [[1,2,1],[0,1,0]].
/// The final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.
///
/// Example 2:
/// 
/// Input: n = 2, m = 2, indices = [[1,1],[0,0]]
/// Output: 0
/// Explanation: Final matrix = [[2,2],[2,2]]. There is no odd number in the 
/// final matrix.
/// 
/// Constraints:
///
/// 1. 1 <= n <= 50
/// 2. 1 <= m <= 50
/// 3. 1 <= indices.length <= 100
/// 4. 0 <= indices[i][0] < n
/// 5. 0 <= indices[i][1] < m
/// </summary>
int LeetCodeArray::oddCells(int n, int m, vector<vector<int>>& indices)
{
    vector<int> row(n), col(m);
    for (size_t i = 0; i < indices.size(); i++)
    {
        row[indices[i][0]]++;
        col[indices[i][1]]++;
    }
    int result = 0;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if ((row[i] + col[j]) % 2 == 1) result++;
        }
    }
    return result;
}

/// <summary>
/// Leet code #1253. Reconstruct a 2-Row Binary Matrix
/// 
/// Given the following details of a matrix with n columns and 2 rows :
///
/// The matrix is a binary matrix, which means each element in the matrix 
/// can be 0 or 1.
/// The sum of elements of the 0-th(upper) row is given as upper.
/// The sum of elements of the 1-st(lower) row is given as lower.
/// The sum of elements in the i-th column(0-indexed) is colsum[i], where 
/// colsum is given as an integer array with length n.
/// Your task is to reconstruct the matrix with upper, lower and colsum.
///
/// Return it as a 2-D integer array.
/// 
/// If there are more than one valid solution, any of them will be accepted.
///
/// If no valid solution exists, return an empty 2-D array.
///
/// 
/// Example 1:
///
/// Input: upper = 2, lower = 1, colsum = [1,1,1]
/// Output: [[1,1,0],[0,0,1]]
/// Explanation: [[1,0,1],[0,1,0]], and [[0,1,1],[1,0,0]] are also correct 
/// answers.
///
/// Example 2:
///
/// Input: upper = 2, lower = 3, colsum = [2,2,1,1]
/// Output: []
///
/// Example 3:
///
/// Input: upper = 5, lower = 5, colsum = [2,1,2,0,1,0,1,2,0,1]
/// Output: [[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]]
///
/// Constraints:
/// 1. 1 <= colsum.length <= 10^5
/// 2. 0 <= upper, lower <= colsum.length
/// 3. 0 <= colsum[i] <= 2
/// </summary>
vector<vector<int>> LeetCodeArray::reconstructMatrix(int upper, int lower, vector<int>& colsum)
{
    vector<vector<int>> result(2);

    for (size_t i = 0; i < colsum.size(); i++)
    {
        if (colsum[i] == 0)
        {
            result[0].push_back(0);
            result[1].push_back(0);
        }
        else if (colsum[i] == 2)
        {
            result[0].push_back(1);
            result[1].push_back(1);
            upper--;
            lower--;
        }
        else 
        {
            if (upper >= lower)
            {
                result[0].push_back(1);
                result[1].push_back(0);
                upper--;
            }
            else
            {
                result[0].push_back(0);
                result[1].push_back(1);
                lower--;
            }
        }
        if (upper < 0 || lower < 0)
        {
            result.clear();
            break;
        }
    }
    if (upper != 0 || lower != 0)
    {
        result.clear();
    }
    return result;
}

/// <summary>
/// Leet code #1260. Shift 2D Grid
/// 
/// Given a 2D grid of size n * m and an integer k. You need to shift 
/// the grid k times.
///
/// In one shift operation:
///
/// Element at grid[i][j] becomes at grid[i][j + 1].
/// Element at grid[i][m - 1] becomes at grid[i + 1][0].
/// Element at grid[n - 1][m - 1] becomes at grid[0][0].
/// Return the 2D grid after applying shift operation k times.
/// 
/// Example 1:
///
/// Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1
/// Output: [[9,1,2],[3,4,5],[6,7,8]]
///
/// Example 2:
///
/// Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4
/// Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]
///
/// Example 3:
///
/// Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9
/// Output: [[1,2,3],[4,5,6],[7,8,9]]
/// 
/// Constraints:
///
/// 1. 1 <= grid.length <= 50
/// 2. 1 <= grid[i].length <= 50
/// 3. -1000 <= grid[i][j] <= 1000
/// 4. 0 <= k <= 100
/// </summary>
vector<vector<int>> LeetCodeArray::shiftGrid(vector<vector<int>>& grid, int k)
{
    vector<vector<int>> result = grid;

    for (size_t i = 0; i < grid.size(); i++)
    {
        for (size_t j = 0; j < grid[i].size(); j++)
        {
            int col = j + k;
            int row = i;
            row = row + (col / grid[i].size());
            row = row % grid.size();
            col = col % grid[i].size();
            result[row][col] = grid[i][j];
        }
    }
    return result;
}

/// <summary>
/// Leet code #1267. Count Servers that Communicate
/// 
/// You are given a map of a server center, represented as a m * n integer 
/// matrix grid, where 1 means that on that cell there is a server and 0 
/// means that it is no server. Two servers are said to communicate if 
/// they are on the same row or on the same column.
///
/// Return the number of servers that communicate with any other server.
///
/// Example 1:
///
/// Input: grid = [[1,0],[0,1]]
/// Output: 0
/// Explanation: No servers can communicate with others.
///
/// Example 2:
///
/// Input: grid = [[1,0],[1,1]]
/// Output: 3
/// Explanation: All three servers can communicate with at least one other 
/// server.
///
/// Example 3:
///
/// Input: grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]
/// Output: 4
/// Explanation: The two servers in the first row can communicate with each 
/// other. The two servers in the third column can communicate with each 
/// other. The server at right bottom corner can't communicate with any 
/// other server.
/// 
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 1 <= m <= 250
/// 4. 1 <= n <= 250
/// 5. grid[i][j] == 0 or 1
/// </summary>
int LeetCodeArray::countServers(vector<vector<int>>& grid)
{
    int m = grid.size();
    int n = grid[0].size();
    vector<int> row(m), col(n);

    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (grid[i][j] == 1)
            {
                row[i] ++;
                col[j] ++;
            }
        }
    }
    int result = 0;
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (grid[i][j] == 1)
            {
                if (row[i] > 1 || col[j] > 1)
                {
                    result++;
                }
            }
        }
    }
    return result;
}

/// <summary>
/// Leetcode #1275. Find Winner on a Tic Tac Toe Game
/// 
/// Tic-tac-toe is played by two players A and B on a 3 x 3 grid.
///
/// Here are the rules of Tic-Tac-Toe:
///
/// Players take turns placing characters into empty squares (" ").
/// The first player A always places "X" characters, while the second 
/// player B always places "O" characters.
/// "X" and "O" characters are always placed into empty squares, never 
/// on filled ones.
/// The game ends when there are 3 of the same (non-empty) character 
/// filling any row, column, or diagonal.
/// The game also ends if all squares are non-empty.
/// No more moves can be played if the game is over.
/// Given an array moves where each element is another array of size 2 
/// corresponding to the row and column of the grid where they mark 
/// their respective character in the order in which A and B play.
///
/// Return the winner of the game if it exists (A or B), in case the 
/// game ends in a draw return "Draw", if there are still movements 
/// to play return "Pending".
///
/// You can assume that moves is valid (It follows the rules of 
/// Tic-Tac-Toe), the grid is initially empty and A will play first.
///
/// Example 1:
///
/// Input: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]
/// Output: "A"
/// Explanation: "A" wins, he always plays first.
/// "X  "    "X  "    "X  "    "X  "    "X  "
/// "   " -> "   " -> " X " -> " X " -> " X "
/// "   "    "O  "    "O  "    "OO "    "OOX"
///
/// Example 2:
///
/// Input: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]
/// Output: "B"
/// Explanation: "B" wins.
/// "X  "    "X  "    "XX "    "XXO"    "XXO"    "XXO"
/// "   " -> " O " -> " O " -> " O " -> "XO " -> "XO " 
/// "   "    "   "    "   "    "   "    "   "    "O  "
///
/// Example 3:
///
/// Input: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]
/// Output: "Draw"
/// Explanation: The game ends in a draw since there are no moves to make.
/// "XXO"
/// "OOX"
/// "XOX"
///
/// Example 4:
///
/// Input: moves = [[0,0],[1,1]]
/// Output: "Pending"
/// Explanation: The game has not finished yet.
/// "X  "
/// " O "
/// "   "
/// 
/// Constraints:
/// 1. 1 <= moves.length <= 9
/// 2. moves[i].length == 2
/// 3. 0 <= moves[i][j] <= 2
/// 4. There are no repeated elements on moves.
/// 5. moves follow the rules of tic tac toe.
/// </summary>
string LeetCodeArray::tictactoe(vector<vector<int>>& moves)
{
    vector<int> row(3), col(3), diag_s(6), diag_r(6);

    for (size_t i = 0; i < moves.size(); i++)
    {
        if (i % 2 == 0)
        {
            row[moves[i][0]]++;
            col[moves[i][1]]++;
            diag_s[moves[i][0] + moves[i][1]]++;
            diag_r[moves[i][0] + 3 - moves[i][1]]++;
            if (row[moves[i][0]] == 3 || 
                col[moves[i][1]] == 3 ||
                diag_s[moves[i][0] + moves[i][1]] == 3 ||
                diag_r[moves[i][0] + 3 - moves[i][1]] == 3)
            {
                return "A";
            }
        }
        else
        {
            row[moves[i][0]]--;
            col[moves[i][1]]--;
            diag_s[moves[i][0] + moves[i][1]]--;
            diag_r[moves[i][0] + 3 - moves[i][1]]--;
            if (row[moves[i][0]] == -3 || 
                col[moves[i][1]] == -3 ||
                diag_s[moves[i][0] + moves[i][1]] == -3 ||
                diag_r[moves[i][0] + 3 - moves[i][1]] == -3)
            {
                return "B";
            }
        }
    }
    if (moves.size() == 9) return "Draw";
    else return "Pending";
}

/// <summary>
/// Leet code #1282. Group the People Given the Group Size They Belong To
///
/// Medium
///
/// There are n people whose IDs go from 0 to n - 1 and each person 
/// belongs exactly to one group. Given the array groupSizes of 
/// length n telling the group size each person belongs to, return the 
/// groups there are and the people's IDs each group includes.
///
/// You can return any solution in any order and the same applies for 
/// IDs. Also, it is guaranteed that there exists at least one solution. 
///
/// Example 1:
///
/// Input: groupSizes = [3,3,3,3,3,1,3]
/// Output: [[5],[0,1,2],[3,4,6]]
/// Explanation: 
/// Other possible solutions are [[2,1,6],[5],[0,4,3]] 
/// and [[5],[0,6,2],[4,3,1]].
///
/// Example 2:
///
/// Input: groupSizes = [2,1,3,3,3,2]
/// Output: [[1],[0,5],[2,3,4]]
/// 
/// Constraints:
/// 1. groupSizes.length == n
/// 2. 1 <= n <= 500
/// 3. 1 <= groupSizes[i] <= n
/// </summary>
vector<vector<int>> LeetCodeArray::groupThePeople(vector<int>& groupSizes)
{
    vector<vector<int>> result;
    vector<pair<int, int>> people;
    for (size_t i = 0; i < groupSizes.size(); i++)
    {
        people.push_back({ groupSizes[i], i });
    }
    sort(people.begin(), people.end());
    vector<int> bag;
    for (size_t i = 0; i < people.size(); i++)
    {
        bag.push_back(people[i].second);
        if (bag.size() == people[i].first )
        {
            result.push_back(bag);
            bag.clear();
        }
    }
    return result;
}

/// <summary>
/// Leet code #1287. Element Appearing More Than 25% In Sorted Array
/// 
/// Easy
///
/// Given an integer array sorted in non-decreasing order, there is 
/// exactly one integer in the array that occurs more than 25% of the time.
///
/// Return that integer.
///
/// Example 1:
///
/// Input: arr = [1,2,2,6,6,6,6,7,10]
///
/// Output: 6
///
/// Constraints:
/// 1. 1 <= arr.length <= 10^4
/// 2. 0 <= arr[i] <= 10^5
/// </summary>
int LeetCodeArray::findSpecialInteger(vector<int>& arr)
{
    int result = 0;
    auto itr = arr.begin();
    while (itr != arr.end())
    {
        auto next = upper_bound(itr, arr.end(), *itr);
        int distance = next - itr;
        if (distance > (int)arr.size() / 4)
        {
            result = *itr;
            break;
        }
        itr = next;
    }
    return result;
}

/// <summary>
/// Leet code #1292. Maximum Side Length of a Square with Sum Less than 
/// or Equal to Threshold
///
/// Medium
///
/// Given a m x n matrix mat and an integer threshold. Return the maximum 
/// side-length of a square with a sum less than or equal to threshold or 
/// return 0 if there is no such square.
/// 
/// Example 1: 
/// Input: mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], 
/// threshold = 4
/// Output: 2
/// Explanation: The maximum side length of square with sum less than 4 
/// is 2 as shown.
///
/// Example 2:
/// Input: mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],
/// [2,2,2,2,2]], threshold = 1
/// Output: 0
///
/// Example 3:
/// Input: mat = [[1,1,1,1],[1,0,0,0],[1,0,0,0],[1,0,0,0]], threshold = 6
/// Output: 3
///
/// Example 4:
/// Input: mat = [[18,70],[61,1],[25,85],[14,40],[11,96],[97,96],[63,45]], 
/// threshold = 40184
/// Output: 2
///
/// Constraints:
/// 1. 1 <= m, n <= 300
/// 2. m == mat.length
/// 3. n == mat[i].length
/// 4. 0 <= mat[i][j] <= 10000
/// 5. 0 <= threshold <= 10^5
/// </summary>
int LeetCodeArray::maxSideLength(vector<vector<int>>& mat, int threshold)
{
    int result = 0;
    vector<vector<int>> sum(mat.size(), vector<int>(mat[0].size()));
    vector<int> row(mat.size());
    vector<int> col(mat[0].size());

    for (int i = 0; i < (int)mat.size(); i++)
    {
        for (int j = 0; j < (int)mat[0].size(); j++)
        {
            sum[i][j] = mat[i][j];
            sum[i][j] += row[i];
            sum[i][j] += col[j];
            if (i > 0 && j > 0) sum[i][j] += sum[i - 1][j - 1];            
            row[i] += mat[i][j];
            col[j] += mat[i][j];

            for (int k = result; k < min(i, j) + 1; k++)
            {
                int s = sum[i][j];
                if (i >= (k + 1)) s -= sum[i - (k + 1)][j];
                if (j >= (k + 1)) s -= sum[i][j - (k + 1)];
                if (i >= (k + 1) && j >= (k + 1)) s += sum[i - (k + 1)][j - (k + 1)];
                if (s <= threshold)
                {
                    result = k + 1;
                }
                else
                {
                    break;
                }
            }
        }
    }
    return result;
}

/// <summary>
/// Leetcode #1296. Divide Array in Sets of K Consecutive Numbers
/// 
/// Given an array of integers nums and a positive integer k, find 
/// whether it's possible to divide this array into sets of k 
/// consecutive numbers
/// Return True if its possible otherwise return False.
///
/// Example 1:
///
/// Input: nums = [1,2,3,3,4,4,5,6], k = 4
/// Output: true
/// Explanation: Array can be divided into [1,2,3,4] and [3,4,5,6].
///
/// Example 2:
///
/// Input: nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3
/// Output: true
/// Explanation: Array can be divided into [1,2,3] , [2,3,4] , [3,4,5] 
/// and [9,10,11].
///
/// Example 3:
///
/// Input: nums = [3,3,2,2,1,1], k = 3
/// Output: true
///
/// Example 4:
///
/// Input: nums = [1,2,3,4], k = 3
/// Output: false
/// Explanation: Each array should be divided in subarrays of size 3.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^9
/// 3. 1 <= k <= nums.length
/// </summary>
bool LeetCodeArray::isPossibleDivide(vector<int>& nums, int k)
{
    map<int, int> sorted_num;
    for (size_t i = 0; i < nums.size(); i++)
    {
        sorted_num[nums[i]]++;
    }
    while (!sorted_num.empty())
    {
        int first = sorted_num.begin()->first;
        int second = sorted_num.begin()->second;
        for (int i = 0; i < k; i++)
        {
            if (sorted_num[first + i] < second) return false;
            sorted_num[first + i] -= second;
            if (sorted_num[first + i] == 0)
            {
                sorted_num.erase(first + i);
            }
        }
    }
    return true;
}

/// <summary>
/// Leetcode #1299. Replace Elements with Greatest Element on Right Side
///
/// Easy	
///
/// Given an array arr, replace every element in that array with the 
/// greatest element among the elements to its right, and replace the 
/// last element with -1.
///
/// After doing so, return the array.
/// 
/// Example 1:
/// Input: arr = [17,18,5,4,6,1]
/// Output: [18,6,6,6,1,-1]
///
/// Constraints:
/// 1. 1 <= arr.length <= 10^4
/// 2. 1 <= arr[i] <= 10^5
/// </summary>
vector<int> LeetCodeArray::replaceElements(vector<int>& arr)
{
    int right = -1;
    vector<int> result(arr.size());
    for (int i = arr.size() - 1; i >= 0; i--)
    {
        result[i] = right;
        right = max(arr[i], right);
    }
    return result;
}

/// <summary>
/// Leetcode #1306. Jump Game III
///
/// Medium
///
/// Given an array of non-negative integers arr, you are initially 
/// positioned at start index of the array. When you are at index i, 
/// you can jump to i + arr[i] or i - arr[i], check if you can reach 
/// to any index with value 0.
///
/// Notice that you can not jump outside of the array at any time.
/// 
/// Example 1:
/// Input: arr = [4,2,3,0,3,1,2], start = 5
/// Output: true
/// Explanation: 
/// All possible ways to reach at index 3 with value 0 are: 
/// index 5 -> index 4 -> index 1 -> index 3 
/// index 5 -> index 6 -> index 4 -> index 1 -> index 3 
///
/// Example 2:
/// Input: arr = [4,2,3,0,3,1,2], start = 0
/// Output: true 
/// Explanation: 
/// One possible way to reach at index 3 with value 0 is: 
/// index 0 -> index 4 -> index 1 -> index 3
///
/// Example 3:
/// Input: arr = [3,0,2,1,2], start = 2
/// Output: false
/// Explanation: There is no way to reach at index 1 with value 0.
///
/// Constraints:
/// 1. 1 <= arr.length <= 5 * 10^4
/// 2. 0 <= arr[i] < arr.length
/// 3. 0 <= start < arr.length
/// </summary>
bool LeetCodeArray::canReach(vector<int>& arr, int start)
{
    queue<int> search;
    search.push(start);
    vector<int> visited(arr.size());
    visited[start] = 1;

    while (!search.empty())
    {
        int index = search.front();
        search.pop();
        if (arr[index] == 0) return true;
        int next = index + arr[index];
        if (next < (int)arr.size() && visited[next] == 0)
        {
            search.push(next);
            visited[next] = 1;
        }
        next = index - arr[index];
        if (next >= 0 && visited[next] == 0)
        {
            search.push(next);
            visited[next] = 1;
        }
    }
    return false;
}

/// <summary>
/// Leet code #36. Valid Sudoku
///
/// Medium
///
/// Determine if a 9x9 Sudoku board is valid. Only the filled cells need 
/// to be validated according to the following rules:
///
/// Each row must contain the digits 1-9 without repetition.
/// Each column must contain the digits 1-9 without repetition.
/// Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 
/// without repetition.
/// 
/// A partially filled sudoku which is valid.
///  
/// The Sudoku board could be partially filled, where empty cells are 
/// filled with the character '.'.
///
/// Example 1:
///
/// Input:
/// [
///  ["5","3",".",".","7",".",".",".","."],
///  ["6",".",".","1","9","5",".",".","."],
///  [".","9","8",".",".",".",".","6","."],
///  ["8",".",".",".","6",".",".",".","3"],
///  ["4",".",".","8",".","3",".",".","1"],
///  ["7",".",".",".","2",".",".",".","6"],
///  [".","6",".",".",".",".","2","8","."],
///  [".",".",".","4","1","9",".",".","5"],
///  [".",".",".",".","8",".",".","7","9"]
/// ]
/// Output: true
/// Example 2:
///
/// Input:
/// [
///  ["8","3",".",".","7",".",".",".","."],
///  ["6",".",".","1","9","5",".",".","."],
///  [".","9","8",".",".",".",".","6","."],
///  ["8",".",".",".","6",".",".",".","3"],
///  ["4",".",".","8",".","3",".",".","1"],
///  ["7",".",".",".","2",".",".",".","6"],
///  [".","6",".",".",".",".","2","8","."],
///  [".",".",".","4","1","9",".",".","5"],
///  [".",".",".",".","8",".",".","7","9"]
/// ]
/// Output: false
/// Explanation: Same as Example 1, except with the 5 in the top left 
/// corner being modified to 8. Since there are two 8's in the top 
/// left 3x3 sub-box, it is invalid.
/// Note:
///
/// A Sudoku board (partially filled) could be valid but is not 
/// necessarily solvable.
/// Only the filled cells need to be validated according to the mentioned 
/// rules.
/// The given board contain only digits 1-9 and the character '.'.
/// The given board size is always 9x9.
/// </summary>
bool LeetCodeArray::isValidSudoku(vector<vector<char>>& board)
{
    size_t size = board.size();
    size_t square_size = (size_t)sqrt((double)size);
    vector<unordered_set<int>> row_map = vector<unordered_set<int>>(size);
    vector<unordered_set<int>> col_map = vector<unordered_set<int>>(size);
    vector<unordered_set<int>> square_map = vector<unordered_set<int>>(size);
    // first scan, set up the flag in the memory map, which will help us to immediately identify 
    // the bad candidate in the cell.
    for (size_t i = 0; i < size; i++)
    {
        for (size_t j = 0; j < size; j++)
        {
            size_t pos = i * size + j;
            char value = board[i][j];
            if (board[i][j] != '.')
            {
                int s = (i / square_size) * square_size + (j / square_size);
                if (row_map[i].find(value) == row_map[i].end())
                {
                    row_map[i].insert(value);
                }
                else
                {
                    return false;
                }
                if (col_map[j].find(value) == col_map[j].end())
                {
                    col_map[j].insert(value);
                }
                else
                {
                    return false;
                }
                if (square_map[s].find(value) == square_map[s].end())
                {
                    square_map[s].insert(value);
                }
                else
                {
                    return false;
                }
            }
        }
    }
    return true;
}


/// <summary>
/// Leet code #1310. XOR Queries of a Subarray
/// 
/// Medium
///
/// Given the array arr of positive integers and the array queries where 
/// queries[i] = [Li, Ri], for each query i compute the XOR of elements 
/// from Li to Ri (that is, arr[Li] xor arr[Li+1] xor ... xor arr[Ri] ). 
/// Return an array containing the result for the given queries. 
/// 
/// Example 1:
/// Input: arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]
/// Output: [2,7,14,8] 
/// Explanation: 
/// The binary representation of the elements in the array are:
/// 1 = 0001 
/// 3 = 0011 
/// 4 = 0100 
/// 8 = 1000 
/// The XOR values for queries are:
/// [0,1] = 1 xor 3 = 2 
/// [1,2] = 3 xor 4 = 7 
/// [0,3] = 1 xor 3 xor 4 xor 8 = 14 
/// [3,3] = 8
///
/// Example 2:
/// Input: arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]
/// Output: [8,0,4,4]
///
/// Constraints:
/// 1. 1 <= arr.length <= 3 * 10^4
/// 2. 1 <= arr[i] <= 10^9
/// 3. 1 <= queries.length <= 3 * 10^4
/// 4. queries[i].length == 2
/// 5. 0 <= queries[i][0] <= queries[i][1] < arr.length
/// </summary>
vector<int> LeetCodeArray::xorQueries(vector<int>& arr, vector<vector<int>>& queries)
{
    vector<int> sum(arr.size());

    for (size_t i = 0; i < arr.size(); i++)
    {
        if (i == 0) sum[i] = arr[i];
        else sum[i] = sum[i - 1] ^ arr[i];
    }

    vector<int> result(queries.size());
    for (size_t i = 0; i < queries.size(); i++)
    {
        if (queries[i][0] == 0) result[i] = sum[queries[i][1]];
        else result[i] = sum[queries[i][1]] ^ sum[queries[i][0]-1];
    }
    return result;
}

/// <summary>
/// Leet code #1313. Decompress Run-Length Encoded List
///
/// Easy
///
/// We are given a list nums of integers representing a list compressed with 
/// run-length encoding.
///
/// Consider each adjacent pair of elements [a, b] = [nums[2*i], nums[2*i+1]] 
/// (with i >= 0).  For each such pair, there are a elements with value b in 
/// the decompressed list.
///
/// Return the decompressed list.
///
/// Example 1:
///
/// Input: nums = [1,2,3,4]
/// Output: [2,4,4,4]
/// 
/// Constraints:
/// 1. 2 <= nums.length <= 100
/// 2. nums.length % 2 == 0
/// 3. 1 <= nums[i] <= 100
/// </summary>
vector<int> LeetCodeArray::decompressRLElist(vector<int>& nums)
{
    vector<int> result;

    for (size_t i = 0; i < nums.size(); i += 2)
    {
        for (int j = 0; j < nums[i]; j++)
        {
            result.push_back(nums[i + 1]);
        }
    }
    return result;
}

/// <summary>
/// Leet code #1314. Matrix Block Sum
///
/// Medium
///
/// Given a m * n matrix mat and an integer K, return a matrix answer where 
/// each answer[i][j] is the sum of all elements mat[r][c] for 
/// i - K <= r <= i + K, j - K <= c <= j + K, and (r, c) is a valid position 
/// in the matrix. 
/// 
/// Example 1:
/// Input: mat = [[1,2,3],[4,5,6],[7,8,9]], K = 1
/// Output: [[12,21,16],[27,45,33],[24,39,28]]
///
/// Example 2:
/// Input: mat = [[1,2,3],[4,5,6],[7,8,9]], K = 2
/// Output: [[45,45,45],[45,45,45],[45,45,45]]
/// 
/// Constraints:
/// 1. m == mat.length
/// 2. n == mat[i].length
/// 3. 1 <= m, n, K <= 100
/// 4. 1 <= mat[i][j] <= 100
/// </summary>
vector<vector<int>> LeetCodeArray::matrixBlockSum(vector<vector<int>>& mat, int K)
{
    int m = mat.size();
    int n = mat[0].size();
    vector<vector<pair<int, int>>> sum(m, vector<pair<int, int>>(n));

    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            sum[i][j].first = mat[i][j];
            if (j > 0) sum[i][j].first += sum[i][j - 1].first;
            sum[i][j].second = sum[i][j].first;
            if (i > 0) sum[i][j].second += sum[i - 1][j].second;
        }
    }

    vector<vector<int>> result(m, vector<int>(n));
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            int y0 = max(0, i - K);
            int x0 = max(0, j - K);
            int y1 = min(i + K, m - 1);
            int x1 = min(j + K, n - 1);

            result[i][j] = sum[y1][x1].second;
            if (y0 > 0) result[i][j] -= sum[y0 - 1][x1].second;
            if (x0 > 0) result[i][j] -= sum[y1][x0-1].second;
            if (y0 > 0 && x0 > 0)result[i][j] += sum[y0-1][x0 - 1].second;
        }
    }
    return result;
}

/// <summary>
/// Leet code #413. Arithmetic Slices
///
/// A sequence of number is called arithmetic if it consists of at least 
/// three elements and if the difference between 
/// any two consecutive elements is the same
/// For example, these are arithmetic sequence:
/// 1, 3, 5, 7, 9
/// 7, 7, 7, 7
/// 3, -1, -5, -9
/// The following sequence is not arithmetic.
/// 1, 1, 2, 5, 7
/// A zero-indexed array A consisting of N numbers is given. A 
/// slice of that array is any pair of integers (P, Q) such that 
/// 0 <= P < Q < N.
/// A slice (P, Q) of array A is called arithmetic if the sequence:
/// A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, 
/// this means that P + 1 < Q.
/// The function should return the number of arithmetic slices in the 
/// array A. 
/// Example: 
/// A = [1, 2, 3, 4]
/// return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] 
/// and [1, 2, 3, 4] itself.
/// </summary>
int LeetCodeArray::numberOfArithmeticSlices(vector<int>& A)
{
    vector<int> sum_count(A.size());
    int count = 0;
    int diff;
    for (size_t i = 0; i < A.size(); i++)
    {
        if (i == 0) continue;
        else if (i == 1)
        {
            diff = A[i] - A[i - 1];
        }
        else if (A[i] - A[i - 1] == diff)
        {
            count++;
        }
        else
        {
            count = 0;
            diff = A[i] - A[i - 1];
        }
        sum_count[i] = count;
    }
    int sum = 0;
    for (size_t i = 0; i < sum_count.size(); i++)
    {
        sum += sum_count[i];
    }
    return sum;
}


/// <summary>
/// Leet code #485. Max Consecutive Ones  
/// 
/// Given a binary array, find the maximum number of consecutive 1s in this array. 
/// Example 1:
/// Input: [1,1,0,1,1,1]
/// Output: 3
/// Explanation: The first two digits or the last three digits are consecutive 1s.
/// The maximum number of consecutive 1s is 3.
/// Note: 
/// The input array will only contain 0 and 1.
/// The length of input array is a positive integer and will not exceed 10,000 
/// </summary>
int LeetCodeArray::findMaxConsecutiveOnes(vector<int>& nums)
{
    int max_ones = 0;
    int count_ones = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] == 0) count_ones = 0;
        else
        {
            count_ones++;
            max_ones = max(max_ones, count_ones);
        }
    }
    return max_ones;
}

/// <summary>
/// Leet code #446. Arithmetic Slices II - Subsequence    
/// 
/// A sequence of numbers is called arithmetic if it consists of at 
/// least three elements and if the difference between any two 
/// consecutive elements is the same.
///
/// For example, these are arithmetic sequences:
/// 1, 3, 5, 7, 9
/// 7, 7, 7, 7
/// 3, -1, -5, -9
///
/// The following sequence is not arithmetic.
/// 1, 1, 2, 5, 7
/// A zero-indexed array A consisting of N numbers is given. A 
/// subsequence slice of that array is any sequence of integers 
/// (P0, P1, ..., Pk) such that 0 ≤ P0 < P1 < ... < Pk < N.
///
/// A subsequence slice (P0, P1, ..., Pk) of array A is called 
/// arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1], A[Pk] 
/// is arithmetic. In particular, this means that k ≥ 2.
/// 
/// The function should return the number of arithmetic subsequence 
/// slices in the array A. 
///
/// The input contains N integers. Every integer is in the range of -2^31 
/// and 2^31-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than 
/// 2^31-1.
///
/// Example: 
/// Input: [2, 4, 6, 8, 10]
/// Output: 7
///
/// Explanation:
/// All arithmetic subsequence slices are:
/// [2,4,6]
/// [4,6,8]
/// [6,8,10]
/// [2,4,6,8]
/// [4,6,8,10]
/// [2,4,6,8,10]
/// [2,6,10]
/// </summary>
int LeetCodeArray::numberOfArithmeticSlicesII(vector<int>& A)
{
    int result = 0;
    vector<unordered_map<long long, int>> dp(A.size());
    for (int i = 0; i < (int)A.size(); i++)
    {
        for (int j = 0; j < i; j++)
        {
            long long diff = (long long)A[i] - (long long)A[j];
            if (dp[j].count(diff) > 0)
            {
                dp[i][diff] += dp[j][diff];
                result += dp[j][diff];
            }
            dp[i][diff]++;
        }
    }
    return result;
}

/// <summary>
/// Leet code #368. Largest Divisible Subset 
/// 
/// Given a set of distinct positive integers, find the largest 
/// subset such that every pair (Si, Sj) of elements in this subset 
/// satisfies: Si % Sj = 0 or Sj % Si = 0. 
///
/// If there are multiple solutions, return any subset is fine. 
///
/// Example 1: 
/// nums: [1,2,3]
/// Result: [1,2] (of course, [1,3] will also be ok)
///
/// Example 2: 
/// nums: [1,2,4,8]
/// Result: [1,2,4,8]
/// </summary>
vector<int> LeetCodeArray::largestDivisibleSubset(vector<int>& nums)
{
    vector<int> result;
    vector<vector<int>> set_map(nums.size());
    sort(nums.begin(), nums.end());
    for (size_t i = 0; i < nums.size(); i++)
    {
        for (size_t j = 0; j < i; j++)
        {
            if ((nums[i] % nums[j]) == 0)
            {
                if (set_map[i].size() < set_map[j].size())
                {
                    set_map[i] = set_map[j];
                }
            }
        }
        set_map[i].push_back(nums[i]);
        if (set_map[i].size() > result.size()) result = set_map[i];
    }
    return result;
}


/// <summary>
/// Leet code #1330. Reverse Subarray To Maximize Array Value 
/// 
/// Hard
///
/// You are given an integer array nums. The value of this array is 
/// defined as the sum of |nums[i]-nums[i+1]| for 
/// all 0 <= i < nums.length-1.
///
/// You are allowed to select any subarray of the given array and 
/// reverse it. You can perform this operation only once.
///
/// Find maximum possible value of the final array.
/// 
/// Example 1:
/// Input: nums = [2,3,1,5,4]
/// Output: 10
/// Explanation: By reversing the subarray [3,1,5] the array 
/// becomes [2,5,1,3,4] whose value is 10.
///
/// Example 2:
/// Input: nums = [2,4,9,24,2,1,10]
/// Output: 68
///
/// Constraints:
/// 1. 1 <= nums.length <= 3*10^4
/// 2. -10^5 <= nums[i] <= 10^5
/// </summary>
int LeetCodeArray::maxValueAfterReverse(vector<int>& nums)
{
    int sum = 0;
    int min_max = INT_MAX;
    int max_min = INT_MIN;
    int gap_begin = 0;
    int gap_end = 0;

    for (size_t i = 1; i < nums.size(); i++)
    {
        sum += abs(nums[i - 1] - nums[i]);
        min_max = min(min_max, max(nums[i - 1], nums[i]));
        max_min = max(max_min, min(nums[i - 1], nums[i]));
        
        gap_begin = max(gap_begin, std::abs(nums[0] - nums[i]) - std::abs(nums[i - 1] - nums[i]));
        gap_end = max(gap_end, std::abs(nums[i-1] - nums[nums.size() - 1]) - std::abs(nums[i - 1] - nums[i]));
    }
    int result = sum + 2 * (max_min - min_max);
    result = max(result, sum + gap_begin);
    result = max(result, sum + gap_end);

    return result;
}

/// <summary>
/// Leet code #1329. Sort the Matrix Diagonally 
/// 
/// Medium
///
/// Given a m * n matrix mat of integers, sort it diagonally in ascending 
/// order from the top-left to the bottom-right then return the sorted 
/// array.
/// 
/// Example 1:
/// Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
/// Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]]
/// 
/// Constraints:
/// 1. m == mat.length
/// 2. n == mat[i].length
/// 3. 1 <= m, n <= 100
/// 4. 1 <= mat[i][j] <= 100
/// </summary>
vector<vector<int>> LeetCodeArray::diagonalSort(vector<vector<int>>& mat)
{
    vector<vector<int>> result(mat.size(), vector<int>(mat[0].size()));
    int m = mat.size();
    int n = mat[0].size();

    for (int i = 0; i < m; i++)
    {
        if (i == 0)
        {
            for (int j = 0; j < n; j++)
            {
                int r = i;
                int c = j;
                vector<int> temp;
                while (r < m && c < n)
                {
                    temp.push_back(mat[r][c]);
                    r++;
                    c++;
                }
                sort(temp.begin(), temp.end());
                r = i;
                c = j;
                int index = 0;
                while (r < m && c < n)
                {
                    result[r][c] = temp[index];
                    r++;
                    c++;
                    index++;
                }
            }
        }
        else
        {
            int r = i;
            int c = 0;
            vector<int> temp;
            while (r < m && c < n)
            {
                temp.push_back(mat[r][c]);
                r++;
                c++;
            }
            sort(temp.begin(), temp.end());
            r = i;
            c = 0;
            int index = 0;
            while (r < m && c < n)
            {
                result[r][c] = temp[index];
                r++;
                c++;
                index++;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #1333. Filter Restaurants by Vegan-Friendly, Price and Distance
/// 
/// Medium
///
/// Given the array restaurants where  restaurants[i] = [idi, ratingi, 
/// veganFriendlyi, pricei, distancei]. You have to filter the restaurants 
/// using three filters.
///
/// The veganFriendly filter will be either true (meaning you should only 
/// include restaurants with veganFriendlyi set to true) or false (meaning 
/// you can include any restaurant). In addition, you have the filters 
/// maxPrice and maxDistance which are the maximum value for price and 
/// distance of restaurants you should consider respectively.
///
/// Return the array of restaurant IDs after filtering, ordered by rating 
/// from highest to lowest. For restaurants with the same rating, order 
/// them by id from highest to lowest. For simplicity veganFriendlyi and 
/// veganFriendly take value 1 when it is true, and 0 when it is false.
///
/// Example 1:
/// Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],
/// [4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, 
/// maxDistance = 10
/// Output: [3,1,5] 
/// Explanation: 
/// The restaurants are:
/// Restaurant 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]
/// Restaurant 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]
/// Restaurant 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]
/// Restaurant 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]
/// Restaurant 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] 
/// After filter restaurants with veganFriendly = 1, maxPrice = 50 and 
/// maxDistance = 10 we have restaurant 3, restaurant 1 and restaurant 5 
/// (ordered by rating from highest to lowest).
///	
/// Example 2:
/// Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],
/// [4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, 
/// maxDistance = 10
/// Output: [4,3,2,1,5]
/// Explanation: The restaurants are the same as in example 1, but in 
/// this case the filter veganFriendly = 0, therefore all restaurants are
/// considered.
///
/// Example 3:
/// Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],
/// [4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, 
/// maxDistance = 3
/// Output: [4,5]
///
/// Constraints:
/// 1. 1 <= restaurants.length <= 10^4
/// 2. restaurants[i].length == 5
/// 3. 1 <= id[i], ratingi, pricei, distancei <= 10^5
/// 4. 1 <= maxPrice, maxDistance <= 10^5
/// 5. veganFriendlyi and veganFriendly are 0 or 1.
/// 6. All id[i] are distinct.
/// </summary>
vector<int> LeetCodeArray::filterRestaurants(vector<vector<int>>& restaurants,
    int veganFriendly, int maxPrice, int maxDistance)
{
    priority_queue<pair<int, int>> pq;
    for (size_t i = 0; i < restaurants.size(); i++)
    {
        if (restaurants[i][3] > maxPrice) continue;
        if (restaurants[i][4] > maxDistance) continue;
        if (restaurants[i][2] == 0 && veganFriendly  == 1) continue;
        pq.push({ restaurants[i][1], restaurants[i][0] });
    }
    vector<int> result;
    while (!pq.empty())
    {
        pair<int, int> r = pq.top();
        pq.pop();
        result.push_back(r.second);
    }
    return result;
}

/// <summary>
/// Leet code #1337. The K Weakest Rows in a Matrix 
/// 
/// Easy
///
/// Given a m * n matrix mat of ones (representing soldiers) and zeros 
/// (representing civilians), return the indexes of the k weakest rows 
/// in the matrix ordered from the weakest to the strongest.
/// 
/// A row i is weaker than row j, if the number of soldiers in row i is 
/// less than the number of soldiers in row j, or they have the same 
/// number of soldiers but i is less than j. Soldiers are always stand 
/// in the frontier of a row, that is, always ones may appear first and 
/// then zeros.
/// 
/// Example 1:
///
/// Input: mat = 
/// [[1,1,0,0,0],
///  [1,1,1,1,0],
///  [1,0,0,0,0],
///  [1,1,0,0,0],
///  [1,1,1,1,1]], 
/// k = 3
/// Output: [2,0,3]
/// Explanation: 
/// The number of soldiers for each row is: 
/// row 0 -> 2 
/// row 1 -> 4 
/// row 2 -> 1 
/// row 3 -> 2 
/// row 4 -> 5 
/// Rows ordered from the weakest to the strongest are [2,0,3,1,4]
/// 
/// Example 2:
///
/// Input: mat = 
/// [[1,0,0,0],
///  [1,1,1,1],
///  [1,0,0,0],
///  [1,0,0,0]], 
/// k = 2
/// Output: [0,2]
/// Explanation: 
/// The number of soldiers for each row is: 
/// row 0 -> 1 
/// row 1 -> 4 
/// row 2 -> 1 
/// row 3 -> 1 
/// Rows ordered from the weakest to the strongest are [0,2,3,1]
/// 
/// Constraints:
/// 1. m == mat.length
/// 2. n == mat[i].length
/// 3. 2 <= n, m <= 100
/// 4. 1 <= k <= m
/// 5. matrix[i][j] is either 0 or 1.
/// </summary>
vector<int> LeetCodeArray::kWeakestRows(vector<vector<int>>& mat, int k)
{
    set<pair<int, int>> pq;
    int m = mat.size();
    int n = mat[0].size();
    for (int i = 0; i < m; i++)
    {
        int count = 0;
        for (int j = 0; j < n; j++)
        {
            if (mat[i][j] == 0) break;
            count++;
        }
        pq.insert(make_pair(count, i));
    }
    vector<int> result;
    for (int i = 0; i < k; i++)
    {
        result.push_back(pq.begin()->second);
        pq.erase(pq.begin());
    }
    return result;
}

/// <summary>
/// Leet code #1338. Reduce Array Size to The Half 
/// 
/// Medium
///
/// Given an array arr.  You can choose a set of integers and remove all 
/// the occurrences of these integers in the array.
///
/// Return the minimum size of the set so that at least half of the 
/// integers of the array are removed.
///  
/// Example 1:
///
/// Input: arr = [3,3,3,3,5,5,5,2,2,7]
/// Output: 2
/// Explanation: Choosing {3,7} will make the new array [5,5,5,2,2] which 
/// has size 5 (i.e equal to half of the size of the old array).
/// Possible sets of size 2 are {3,5},{3,2},{5,2}.
/// Choosing set {2,7} is not possible as it will make the new 
/// array [3,3,3,3,5,5,5] which has size greater than half of the size of 
/// the old array.
///
/// Example 2:
///
/// Input: arr = [7,7,7,7,7,7]
/// Output: 1
/// Explanation: The only possible set you can choose is {7}. This will make 
/// the new array empty.
///
/// Example 3:
///
/// Input: arr = [1,9]
/// Output: 1
///
/// Example 4:
///
/// Input: arr = [1000,1000,3,7]
/// Output: 1
///
/// Example 5:
///
/// Input: arr = [1,2,3,4,5,6,7,8,9,10]
/// Output: 5
/// 
/// Constraints:
/// 1. 1 <= arr.length <= 10^5
/// 2. arr.length is even.
/// 3. 1 <= arr[i] <= 10^5
/// </summary>
int LeetCodeArray::minSetSize(vector<int>& arr)
{
    unordered_map<int, int> num_count;
    for (size_t i = 0; i < arr.size(); i++)
    {
        num_count[arr[i]]++;
    }

    priority_queue<int> pq;
    for (auto itr = num_count.begin(); itr != num_count.end(); ++itr)
    {
        pq.push(itr->second);
    }
    int result = 0;
    int sum = 0;
    while (!pq.empty())
    {
        int num = pq.top();
        pq.pop();
        sum += num;
        result++;
        if (sum >= ((int)arr.size() / 2))
        {
            break;
        }
    }
    return result;
}

/// <summary>
/// Leet code #1343. Number of Sub-arrays of Size K and Average Greater 
/// than or Equal to Threshold
///
/// Medium
///
/// Given an array of integers arr and two integers k and threshold.
///
/// Return the number of sub-arrays of size k and average greater than 
/// or equal to threshold.
///
/// Example 1:
/// Input: arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4
/// Output: 3
/// Explanation: Sub-arrays [2,5,5],[5,5,5] and [5,5,8] have 
/// averages 4, 5 and 6 respectively. All other sub-arrays of size 3 
/// have averages less than 4 (the threshold).
///
/// Example 2:
/// Input: arr = [1,1,1,1,1], k = 1, threshold = 0
/// Output: 5
///
/// Example 3:
/// Input: arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5
/// Output: 6
/// Explanation: The first 6 sub-arrays of size 3 have averages greater 
/// than 5. Note that averages are not integers.
///
/// Example 4:
/// Input: arr = [7,7,7,7,7,7,7], k = 7, threshold = 7
/// Output: 1
///
/// Example 5:
/// Input: arr = [4,4,4,4], k = 4, threshold = 1
/// Output: 1
///
/// Constraints:
/// 1. 1 <= arr.length <= 10^5
/// 2. 1 <= arr[i] <= 10^4
/// 3. 1 <= k <= arr.length
/// 4. 0 <= threshold <= 10^4
/// </summary>
int LeetCodeArray::numOfSubarrays(vector<int>& arr, int k, int threshold)
{
    deque<int> sum;
    sum.push_back(0);
    int result = 0;
    for (size_t i = 0; i < arr.size(); i++)
    {
        sum.push_back(sum.back() + arr[i]);
        if (sum.size() == k + 1)
        {
            if ((sum.back() - sum.front()) >= k * threshold)
            {
                result++;
            }
            sum.pop_front();
        }
    }
    return result;
}

/// <summary>
/// Leet code #1346. Check If N and Its Double Exist
///
/// Easy
///
/// Given an array arr of integers, check if there exists two integers 
/// N and M such that N is the double of M ( i.e. N = 2 * M).
///
/// More formally check if there exists two indices i and j such that :
///  
/// i != j
/// 0 <= i, j < arr.length
/// arr[i] == 2 * arr[j]
/// 
/// Example 1:
/// Input: arr = [10,2,5,3]
/// Output: true
/// Explanation: N = 10 is the double of M = 5,that is, 10 = 2 * 5.
///
/// Example 2:
/// Input: arr = [7,1,14,11]
/// Output: true
/// Explanation: N = 14 is the double of M = 7,that is, 14 = 2 * 7.
///
/// Example 3:
/// Input: arr = [3,1,7,11]
/// Output: false
/// Explanation: In this case does not exist N and M, such that N = 2 * M.
///
/// Constraints:
/// 1. 2 <= arr.length <= 500
/// 2. -10^3 <= arr[i] <= 10^3
/// </summary>
bool LeetCodeArray::checkIfExist(vector<int>& arr)
{
    unordered_set<int> num_set;
    for (size_t i = 0; i < arr.size(); i++)
    {
        if (((num_set.count(arr[i] / 2) > 0) && (arr[i] % 2 == 0)) || (num_set.count(arr[i] * 2) > 0))
        {
            return true;
        }
        num_set.insert(arr[i]);
    }
    return false;
}

/// <summary>
/// Leet code #1151. Minimum Swaps to Group All 1's Together
/// 
/// Given a binary array data, return the minimum number of swaps required 
/// to group all 1’s present in the array together in any place in the array.
/// 
/// Example 1:
/// Input: [1,0,1,0,1]
/// Output: 1
/// Explanation: 
/// There are 3 ways to group all 1's together:
/// [1,1,1,0,0] using 1 swap.
/// [0,1,1,1,0] using 2 swaps.
/// [0,0,1,1,1] using 1 swap.
/// The minimum is 1.
///
/// Example 2:
/// Input: [0,0,0,1,0]
/// Output: 0
/// Explanation: 
/// Since there is only one 1 in the array, no swaps needed.
///
/// Example 3:
/// Input: [1,0,1,0,1,0,0,1,1,0,1]
/// Output: 3
/// Explanation: 
/// One possible solution that uses 3 swaps is [0,0,0,0,0,1,1,1,1,1,1].
/// 
/// Note:
/// 1. 1 <= data.length <= 10^5
/// 2. 0 <= data[i] <= 1
/// </summary>
int LeetCodeArray::minSwaps(vector<int>& data)
{
    vector<int> sum(data.size());
    for (size_t i = 0; i < data.size(); i++)
    {
        if (i == 0) sum[0] = data[0];
        else (sum[i] = sum[i - 1] + data[i]);
    }
    int length = sum[sum.size() - 1];
    int result = 0;
    for (size_t i = length - 1; i < sum.size(); i++)
    {
        int count = 0;
        if (i == length - 1) count = sum[i];
        else count = sum[i] - sum[i - length];
        result = max(result, count);
    }
    return length - result;
}

/// <summary>
/// Leet code #1351. Count Negative Numbers in a Sorted Matrix
///
/// Easy
///
/// Given a m * n matrix grid which is sorted in non-increasing order 
/// both row-wise and column-wise. 
///
/// Return the number of negative numbers in grid.
///
/// Example 1:
/// Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
/// Output: 8
/// Explanation: There are 8 negatives number in the matrix.
///
/// Example 2:
/// Input: grid = [[3,2],[1,0]]
/// Output: 0
///
/// Example 3:
/// Input: grid = [[1,-1],[-1,-1]]
/// Output: 3
///
/// Example 4:
/// Input: grid = [[-1]]
/// Output: 1
/// 
///
/// Constraints:
///
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 1 <= m, n <= 100
/// 4. -100 <= grid[i][j] <= 100
/// </summary>
int LeetCodeArray::countNegatives(vector<vector<int>>& grid)
{
    int row = 0;
    int col = grid[0].size() - 1;
    int result = 0;
    while (row < (int)grid.size() && col >= 0)
    {
        if (grid[row][col] < 0)
        {
            result += grid.size() - row;
            col--;
        }
        else
        {
            row++;
        }
    }
    return result;
}

/// <summary>
/// Leet code #1380. Lucky Numbers in a Matrix
///
/// Easy
///
/// Given a m * n matrix of distinct numbers, return all lucky numbers 
/// in the matrix in any order.
/// A lucky number is an element of the matrix such that it is the 
/// minimum element in its row and maximum in its column.
///
/// Example 1:
/// Input: matrix = [[3,7,8],[9,11,13],[15,16,17]]
/// Output: [15]
/// Explanation: 15 is the only lucky number since it is the minimum 
/// in its row and the maximum in its column
///
/// Example 2:
/// Input: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]
/// Output: [12]
/// Explanation: 12 is the only lucky number since it is the minimum in 
/// its row and the maximum in its column.
///
/// Example 3:
/// Input: matrix = [[7,8],[1,2]]
/// Output: [7]
///
/// Constraints:
/// 1. m == mat.length
/// 2. n == mat[i].length
/// 3. 1 <= n, m <= 50
/// 4. 1 <= matrix[i][j] <= 10^5.
/// 5. All elements in the matrix are distinct.
/// </summary>
vector<int> LeetCodeArray::luckyNumbers(vector<vector<int>>& matrix)
{
    int m = matrix.size();
    int n = matrix[0].size();
    vector<int> row(m, INT_MAX), col(n, INT_MIN);
    for (size_t i = 0; i < matrix.size(); i++)
    {
        for (size_t j = 0; j < matrix[i].size(); j++)
        {
            row[i] = min(row[i], matrix[i][j]);
            col[j] = max(col[j], matrix[i][j]);
        }
    }
    vector<int> result;
    for (size_t i = 0; i < matrix.size(); i++)
    {
        for (size_t j = 0; j < matrix[i].size(); j++)
        {
            if (matrix[i][j] == row[i] && matrix[i][j] == col[j])
            result.push_back(matrix[i][j]);
        }
    }
    return result;
}

/// <summary>
/// Leet code #1389. Create Target Array in the Given Order
/// 
/// Easy
///
/// Given two arrays of integers nums and index. Your task is to create 
/// target array under the following rules:
///
/// Initially target array is empty.
/// From left to right read nums[i] and index[i], insert at index index[i] 
/// the value nums[i] in target array.
/// Repeat the previous step until there are no elements to read in nums 
/// and index.
/// Return the target array.
///
/// It is guaranteed that the insertion operations will be valid.
///
/// Example 1:
/// Input: nums = [0,1,2,3,4], index = [0,1,2,2,1]
/// Output: [0,4,1,3,2]
/// Explanation:
/// nums       index     target
/// 0            0        [0]
/// 1            1        [0,1]
/// 2            2        [0,1,2] 
/// 3            2        [0,1,3,2]
/// 4            1        [0,4,1,3,2]
///
/// Example 2:
/// Input: nums = [1,2,3,4,0], index = [0,1,2,3,0]
/// Output: [0,1,2,3,4]
/// Explanation:
/// nums       index     target
/// 1            0        [1]
/// 2            1        [1,2]
/// 3            2        [1,2,3]
/// 4            3        [1,2,3,4]
/// 0            0        [0,1,2,3,4]
///
/// Example 3:
/// Input: nums = [1], index = [0]
/// Output: [1]
/// 
/// Constraints:
/// 1. 1 <= nums.length, index.length <= 100
/// 2. nums.length == index.length
/// 3. 0 <= nums[i] <= 100
/// 4. 0 <= index[i] <= i
/// </summary>
vector<int> LeetCodeArray::createTargetArray(vector<int>& nums, vector<int>& index)
{
    int n = nums.size();
    vector<int> result(nums.size(), -1);
    for (int i = 0; i < n; i++)
    {
        int j = 0;
        for (j = index[i]; j < n; j++)
        {
            if (result[j] == -1) break;
        }
        for (int k = j; k > index[i]; k--) result[k] = result[k - 1];
        result[index[i]] = nums[i];
    }
    return result;
}

/// <summary>
/// Leet code #1395. Count Number of Teams
/// 
/// Medium
///
/// There are n soldiers standing in a line. Each soldier is assigned a 
/// unique rating value.
///
/// You have to form a team of 3 soldiers amongst them under the following
/// rules:
///
/// Choose 3 soldiers with index (i, j, k) with rating (rating[i], 
/// rating[j], rating[k]).
/// A team is valid if:  (rating[i] < rating[j] < rating[k]) or 
/// (rating[i] > rating[j] > rating[k]) where (0 <= i < j < k < n).
/// Return the number of teams you can form given the conditions. 
/// (soldiers can be part of multiple teams).
/// 
/// Example 1:
/// Input: rating = [2,5,3,4,1]
/// Output: 3
/// Explanation: We can form three teams given the conditions. 
/// (2,3,4), (5,4,1), (5,3,1). 
///
/// Example 2:
/// Input: rating = [2,1,3]
/// Output: 0
/// Explanation: We can't form any team given the conditions.
///
/// Example 3:
/// Input: rating = [1,2,3,4]
/// Output: 4
///
/// Constraints:
/// 1. n == rating.length
/// 2. 1 <= n <= 200
/// 3. 1 <= rating[i] <= 10^5
/// </summary>
int LeetCodeArray::numTeams(vector<int>& rating)
{
    vector<int> low(rating.size());
    vector<int> high(rating.size());
    int result = 0;
    for (size_t i = 0; i < rating.size(); i++)
    {
        for (size_t j = 0; j < i; j++)
        {
            if (rating[j] < rating[i])
            {
                low[i]++;
                result += low[j];
            }
            else  if (rating[j] > rating[i])
            {
                high[i]++;
                result += high[j];
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #1409. Queries on a Permutation With Key 
/// 
/// Medium
///
/// Given the array queries of positive integers between 1 and m, 
/// you have to process all queries[i] (from i=0 to 
/// i=queries.length-1) according to the following rules:
///
/// In the beginning, you have the permutation P=[1,2,3,...,m].
/// For the current i, find the position of queries[i] in the 
/// permutation P (indexing from 0) and then move this at the 
/// beginning of the permutation P. Notice that the position of 
/// queries[i] in P is the result for queries[i].
/// Return an array containing the result for the given queries.
/// 
/// Example 1:
/// Input: queries = [3,1,2,1], m = 5
/// Output: [2,1,2,1] 
/// Explanation: The queries are processed as follow: 
/// For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, 
/// then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. 
/// For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, 
/// then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. 
/// For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, 
/// then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. 
/// For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, 
/// then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. 
/// Therefore, the array containing the result is [2,1,2,1].  
///
/// Example 2:
/// Input: queries = [4,1,2,2], m = 4
/// Output: [3,1,2,0]
///
/// Example 3:
/// Input: queries = [7,5,5,8,3], m = 8
/// Output: [6,5,0,7,5]
///
/// Constraints:
/// 1. 1 <= m <= 10^3
/// 2. 1 <= queries.length <= m
/// 3. 1 <= queries[i] <= m
/// </summary>
vector<int> LeetCodeArray::processQueries(vector<int>& queries, int m)
{
    vector<int> permutation(m);
    vector<int> position(m);
    vector<int> result;
    for (int i = 0; i < m; i++)
    {
        permutation[i] = i + 1;
        position[i] = i;
    }

    for (size_t i = 0; i < queries.size(); i++)
    {
        int pos = position[queries[i] - 1];

        for (int j = pos - 1; j >= 0; j--)
        {
            permutation[j + 1] = permutation[j];
            position[permutation[j] - 1]++;
        }
        permutation[0] = queries[i];
        position[queries[i] - 1] = 0;
        result.push_back(pos);
    }
    return result;
}

/// <summary>
/// Leet code #1413. Minimum Value to Get Positive Step by Step Sum 
/// 
/// Easy
///
/// Given an array of integers nums, you start with an initial positive 
/// value startValue.
///
/// In each iteration, you calculate the step by step sum of startValue 
/// plus elements in nums (from left to right).
///
/// Return the minimum positive value of startValue such that the step by 
/// step sum is never less than 1.
///
/// Example 1:
/// Input: nums = [-3,2,-3,4,2]
/// Output: 5
/// Explanation: If you choose startValue = 4, in the third iteration your 
/// step by step sum is less than 1.
///            step by step sum
///            startValue = 4 | startValue = 5 | nums
///              (4 -3 ) = 1  | (5 -3 ) = 2    |  -3
///              (1 +2 ) = 3  | (2 +2 ) = 4    |   2
///              (3 -3 ) = 0  | (4 -3 ) = 1    |  -3
///              (0 +4 ) = 4  | (1 +4 ) = 5    |   4
///              (4 +2 ) = 6  | (5 +2 ) = 7    |   2
/// Example 2:
/// Input: nums = [1,2]
/// Output: 1
/// Explanation: Minimum start value should be positive. 
///
/// Example 3:
/// Input: nums = [1,-2,-3]
/// Output: 5
///
/// Constraints:
/// 1. 1 <= nums.length <= 100
/// 2. -100 <= nums[i] <= 100
/// </summary>
int LeetCodeArray::minStartValue(vector<int>& nums)
{
    int sum = 0;
    int result = 1;
    for (size_t i = 0; i < nums.size(); i++)
    {
        sum += nums[i];
        result = max(result, 1 - sum);
    }
    return result;
}

/// <summary>
/// Leet code #1423. Maximum Points You Can Obtain from Cards
/// 
/// Medium
///
/// There are several cards arranged in a row, and each card has an 
/// associated number of points The points are given in the integer 
/// array cardPoints.
///
/// In one step, you can take one card from the beginning or from the 
/// end of the row. You have to take exactly k cards.
///
/// Your score is the sum of the points of the cards you have taken.
///
/// Given the integer array cardPoints and the integer k, return 
/// the maximum score you can obtain.
///
/// Example 1:
/// Input: cardPoints = [1,2,3,4,5,6,1], k = 3
/// Output: 12
/// Explanation: After the first step, your score will 
/// always be 1. However, choosing the rightmost card first 
/// will maximize your total score. The optimal strategy is 
/// to take the three cards on the right, giving a final 
/// score of 1 + 6 + 5 = 12.
///
/// Example 2:
/// Input: cardPoints = [2,2,2], k = 2
/// Output: 4
/// Explanation: Regardless of which two cards you take, your score will 
/// always be 4.
///
/// Example 3:
/// Input: cardPoints = [9,7,7,9,7,7,9], k = 7
/// Output: 55
/// Explanation: You have to take all the cards. Your score is the sum of 
/// points of all cards.
///
/// Example 4:
/// Input: cardPoints = [1,1000,1], k = 1
/// Output: 1
/// Explanation: You cannot take the card in the middle. Your best score 
/// is 1. 
///
/// Example 5:
/// Input: cardPoints = [1,79,80,1,1,1,200,1], k = 3
/// Output: 202
///
/// Constraints:
/// 1. 1 <= cardPoints.length <= 10^5
/// 2. 1 <= cardPoints[i] <= 10^4
/// 3. 1 <= k <= cardPoints.length
/// </summary>
int LeetCodeArray::maxScore(vector<int>& cardPoints, int k)
{
    int sum = 0;
    int result = 0;
    for (int i = 0; i < 2 * k; i++)
    {
        int index = (cardPoints.size() - k + i) % cardPoints.size();
        sum += cardPoints[index];
        if (i >= k) sum -= cardPoints[cardPoints.size() - k + i - k];
        if (i >= k-1) result = max(result, sum);
    }
    return result;
}

/// <summary>
/// Leet code #1424. Diagonal Traverse II
/// 
/// Medium
///
/// Given a list of lists of integers, nums, return all elements of nums 
/// in diagonal order as shown in the below images.
/// 
/// Example 1:
/// Input: nums = [[1,2,3],[4,5,6],[7,8,9]]
/// Output: [1,4,2,7,5,3,8,6,9]
///
/// Example 2:
/// Input: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]
/// Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]
///
/// Example 3:
/// Input: nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]]
/// Output: [1,4,2,5,3,8,6,9,7,10,11]
///
/// Example 4:
/// Input: nums = [[1,2,3,4,5,6]]
/// Output: [1,2,3,4,5,6]
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i].length <= 10^5
/// 3. 1 <= nums[i][j] <= 10^9
/// 4. There at most 10^5 elements in nums.
/// </summary>
vector<int> LeetCodeArray::findDiagonalOrderII(vector<vector<int>>& nums)
{
    vector<vector<int>> arr;
    for (size_t r = 0; r < nums.size(); r++)
    {
        for (size_t c = 0; c < nums[r].size(); c++)
        {
            if (r + c >= arr.size()) arr.push_back(vector<int>());
            arr[r + c].push_back(nums[r][c]);
        }
    }
    vector<int> result;
    for (size_t i = 0; i < arr.size(); i++)
    {
        for (int j = (int)arr[i].size() - 1; j >= 0; j--)
        {
            result.push_back(arr[i][j]);
        }
    }
    return result;
}

/// <summary>
/// Leet code #1431. Kids With the Greatest Number of Candies
/// 
/// Easy
///
/// Given the array candies and the integer extraCandies, where candies[i] 
/// represents the number of candies that the ith kid has.
///
/// For each kid check if there is a way to distribute extraCandies among 
/// the kids such that he or she can have the greatest number of candies 
/// among them. Notice that multiple kids can have the greatest number of 
/// candies.
///
/// Example 1:
/// Input: candies = [2,3,5,1,3], extraCandies = 3
/// Output: [true,true,true,false,true] 
/// Explanation: 
/// Kid 1 has 2 candies and if he or she receives all extra candies (3) 
/// will have 5 candies --- the greatest number of candies among the kids. 
/// Kid 2 has 3 candies and if he or she receives at least 2 extra candies 
/// will have the greatest number of candies among the kids. 
/// Kid 3 has 5 candies and this is already the greatest number of candies 
/// among the kids. 
/// Kid 4 has 1 candy and even if he or she receives all extra candies will
/// only have 4 candies. 
/// Kid 5 has 3 candies and if he or she receives at least 2 extra candies 
/// will have the greatest number of candies among the kids. 
///
/// Example 2:
/// Input: candies = [4,2,1,1,2], extraCandies = 1
/// Output: [true,false,false,false,false] 
/// Explanation: There is only 1 extra candy, therefore only kid 1 will 
/// have the greatest number of candies among the kids regardless of who 
/// takes the extra candy.
///
/// Example 3:
/// Input: candies = [12,1,12], extraCandies = 10
/// Output: [true,false,true]
/// Constraints:
/// 1. 2 <= candies.length <= 100
/// 2. 1 <= candies[i] <= 100
/// 3. 1 <= extraCandies <= 50
/// </summary>
vector<bool> LeetCodeArray::kidsWithCandies(vector<int>& candies, int extraCandies)
{
    int max_candy = 0;
    vector<bool> result(candies.size());
    for (auto candy : candies) max_candy = max(max_candy, candy);

    for (size_t i = 0; i < candies.size(); i++)
    {
        if (candies[i] + extraCandies >= max_candy)  result[i] = true;
        else result[i] = false;
    }
    return result;
}

/// <summary>
/// Leet code #1437. Check If All 1's Are at Least Length K Places Away
/// 
/// Medium
///
/// Given an array nums of 0s and 1s and an integer k, return True if 
/// all 1's are at least k places away from each other, otherwise return 
/// False.
///
/// Example 1:
/// Input: nums = [1,0,0,0,1,0,0,1], k = 2
/// Output: true
/// Explanation: Each of the 1s are at least 2 places away from each 
/// other.
///
/// Example 2:
/// Input: nums = [1,0,0,1,0,1], k = 2
/// Output: false
/// Explanation: The second 1 and third 1 are only one apart from each 
/// other.
///
/// Example 3:
/// Input: nums = [1,1,1,1,1], k = 0
/// Output: true
///
/// Example 4:
/// Input: nums = [0,1,0,1], k = 1
/// Output: true
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 0 <= k <= nums.length
/// 3. nums[i] is 0 or 1
/// </summary>
bool LeetCodeArray::kLengthApart(vector<int>& nums, int k)
{
    int last = -1;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] == 1)
        {
            if (last != -1 && (int)i - last <= k) return false;
            last = i;
        }
    }
    return true;
}


/// <summary>
/// Leet code #1441. Build an Array With Stack Operations
///
/// Easy
///
/// Given an array target and an integer n. In each iteration, you will read 
/// a number from  list = {1,2,3..., n}.
///
/// Build the target array using the following operations:
///
/// Push: Read a new element from the beginning list, and push it in the array.
/// Pop: delete the last element of the array.
/// If the target array is already built, stop reading more elements.
/// You are guaranteed that the target array is strictly increasing, only 
/// containing numbers between 1 to n inclusive.
///
/// Return the operations to build the target array.
///
/// You are guaranteed that the answer is unique.
/// 
/// Example 1:
///
/// Input: target = [1,3], n = 3
/// Output: ["Push","Push","Pop","Push"]
/// Explanation: 
/// Read number 1 and automatically push in the array -> [1]
/// Read number 2 and automatically push in the array then Pop it -> [1]
/// Read number 3 and automatically push in the array -> [1,3]
///
/// Example 2:
/// Input: target = [1,2,3], n = 3
/// Output: ["Push","Push","Push"]
///
/// Example 3:
/// Input: target = [1,2], n = 4
/// Output: ["Push","Push"]
/// Explanation: You only need to read the first 2 numbers and stop.
///
/// Example 4:
/// Input: target = [2,3,4], n = 4
/// Output: ["Push","Pop","Push","Push","Push"]
/// 
/// Constraints:
/// 1. 1 <= target.length <= 100
/// 2. 1 <= target[i] <= 100
/// 3. 1 <= n <= 100
/// 4. target is strictly increasing.
/// </summary>
vector<string> LeetCodeArray::buildArray(vector<int>& target, int n)
{
    vector<string> result;
    int index = 0;
    for (int i = 1; i <= n; i++)
    {
        if (index >= (int)target.size()) break;
        result.push_back("Push");
        if (target[index] > i)
        {
            result.push_back("Pop");
        }
        else
        {
            index++;
        }
    }
    return result;
}

/// <summary>
/// Leet code #1442. Count Triplets That Can Form Two Arrays of Equal XOR
///
/// Medium
///
/// Given an array of integers arr.
///
/// We want to select three indices i, j and k where 
/// (0 <= i < j <= k < arr.length).
///
/// Let's define a and b as follows:
///
/// a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
/// b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
/// Note that ^ denotes the bitwise-xor operation.
///
/// Return the number of triplets (i, j and k) Where a == b.
/// 
/// Example 1:
/// Input: arr = [2,3,1,6,7]
/// Output: 4
/// Explanation: The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)
///
/// Example 2:
/// Input: arr = [1,1,1,1,1]
/// Output: 10
///
/// Example 3:
/// Input: arr = [2,3]
/// Output: 0
///
/// Example 4:
/// Input: arr = [1,3,5,7,9]
/// Output: 3
///
/// Example 5:
/// Input: arr = [7,11,12,9,5,2,7,17,22]
/// Output: 8
///
/// Constraints:
/// 1. 1 <= arr.length <= 300
/// 2. 1 <= arr[i] <= 10^8
/// </summary>
int LeetCodeArray::countTriplets(vector<int>& arr)
{
    int result = 0;
    map<int, pair<int, int>> xor_map;
    int sum_xor = 0;
    xor_map[0] = { 0, 1 };
    for (size_t i = 0; i < arr.size(); i++)
    {
        sum_xor = sum_xor ^ arr[i];
        if (xor_map.count(sum_xor) > 0)
        {
            result += (i * xor_map[sum_xor].second - xor_map[sum_xor].first);
        }
        xor_map[sum_xor].first += i + 1;
        xor_map[sum_xor].second ++;
    }
    return result;
}

/// <summary>
/// Leet code #1450. Number of Students Doing Homework at a Given Time
/// 
/// Easy
///
/// Given two integer arrays startTime and endTime and given an integer 
/// queryTime.
/// 
/// The ith student started doing their homework at the time startTime[i] 
/// and finished it at time endTime[i].
///
/// Return the number of students doing their homework at time queryTime. 
/// More formally, return the number of students where queryTime lays in 
/// the interval [startTime[i], endTime[i]] inclusive.
/// 
/// Example 1:
/// Input: startTime = [1,2,3], endTime = [3,2,7], queryTime = 4
/// Output: 1
/// Explanation: We have 3 students where:
/// The first student started doing homework at time 1 and finished at 
/// time 3 and wasn't doing anything at time 4.
/// The second student started doing homework at time 2 and finished at 
/// time 2 and also wasn't doing anything at time 4.
/// The third student started doing homework at time 3 and finished at 
/// time 7 and was the only student doing homework at time 4.
///
/// Example 2:
/// Input: startTime = [4], endTime = [4], queryTime = 4
/// Output: 1
/// Explanation: The only student was doing their homework at the 
/// queryTime.
///
/// Example 3:
/// Input: startTime = [4], endTime = [4], queryTime = 5
/// Output: 0
///
/// Example 4:
/// Input: startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7
/// Output: 0
///
/// Example 5:
/// Input: startTime = [9,8,7,6,5,4,3,2,1], 
/// endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5
/// Output: 5
///
/// Constraints:
/// 1. startTime.length == endTime.length
/// 2. 1 <= startTime.length <= 100
/// 3. 1 <= startTime[i] <= endTime[i] <= 1000
/// 4. 1 <= queryTime <= 1000
/// </summary>
int LeetCodeArray::busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime)
{
    int result = 0;
    for (size_t i = 0; i < startTime.size(); i++)
    {
        if (startTime[i] <= queryTime && endTime[i] >= queryTime)
        {
            result++;
        }
    }
    return result;
}

/// <summary>
/// Leet code #1063. Number of Valid Subarrays
/// 
/// Given an array A of integers, return the number of non-empty continuous 
/// subarrays that satisfy the following condition:
///
/// The leftmost element of the subarray is not larger than other elements 
/// in the subarray.
///
/// Example 1:
///
/// Input: [1,4,2,5,3]
/// Output: 11
/// Explanation: There are 11 valid subarrays: [1],[4],[2],[5],[3],[1,4],
/// [2,5],[1,4,2],[2,5,3],[1,4,2,5],[1,4,2,5,3].
///
/// Example 2:
///
/// Input: [3,2,1]
/// Output: 3
/// Explanation: The 3 valid subarrays are: [3],[2],[1].
///
/// Example 3:
///
/// Input: [2,2,2]
/// Output: 6
/// Explanation: There are 6 valid subarrays: [2],[2],[2],[2,2],[2,2],[2,2,2].
/// 
///
/// Note:
///
/// 1. 1 <= A.length <= 50000
/// 2. 0 <= A[i] <= 100000
/// </summary>
int LeetCodeArray::validSubarrays(vector<int>& nums)
{
    int result = 0;
    stack<int> dp;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (dp.empty())
        {
            dp.push(nums[i]);
        }
        else
        {
            while (!dp.empty())
            {
                if (dp.top() > nums[i])
                {
                    dp.pop();
                }
                else
                {
                    break;
                }
            }
            dp.push(nums[i]);
        }
        result += dp.size();
    }
    return result;
}

/// <summary>
/// Leet code #1460. Make Two Arrays Equal by Reversing Sub-arrays
/// 
/// Easy
///
/// Given two integer arrays of equal length target and arr.
///
/// In one step, you can select any non-empty sub-array of arr and 
/// reverse it. You are allowed to make any number of steps.
///
/// Return True if you can make arr equal to target, or False otherwise.
/// 
/// Example 1:
///
/// Input: target = [1,2,3,4], arr = [2,4,1,3]
/// Output: true
/// Explanation: You can follow the next steps to convert arr to target:
/// 1- Reverse sub-array [2,4,1], arr becomes [1,4,2,3]
/// 2- Reverse sub-array [4,2], arr becomes [1,2,4,3]
/// 3- Reverse sub-array [4,3], arr becomes [1,2,3,4]
/// There are multiple ways to convert arr to target, this is not the 
/// only way to do so.
///
/// Example 2:
/// Input: target = [7], arr = [7]
/// Output: true
/// Explanation: arr is equal to target without any reverses.
///
/// Example 3:
/// Input: target = [1,12], arr = [12,1]
/// Output: true
///
/// Example 4:
/// Input: target = [3,7,9], arr = [3,7,11]
/// Output: false
/// Explanation: arr doesn't have value 9 and it can never be converted 
/// to target.
///
/// Example 5:
/// Input: target = [1,1,1,1,1], arr = [1,1,1,1,1]
/// Output: true
///
/// Constraints:
/// 1. target.length == arr.length
/// 2. 1 <= target.length <= 1000
/// 3. 1 <= target[i] <= 1000
/// 4. 1 <= arr[i] <= 1000
/// </summary>
bool LeetCodeArray::canBeEqual(vector<int>& target, vector<int>& arr)
{
    unordered_map<int, int> src_map;
    unordered_map<int, int> dest_map;
    for (size_t i = 0; i < arr.size(); i++)
    {
        src_map[arr[i]]++;
        dest_map[target[i]]++;
    }

    for (auto &itr : src_map)
    {
        if (dest_map[itr.first] != itr.second) return false;
    }
    return true;
}

/// <summary>
/// Leet code #1470. Shuffle the Array
/// 
/// Easy
/// 
/// Given the array nums consisting of 2n elements in the form 
/// [x1,x2,...,xn,y1,y2,...,yn].
///
/// Return the array in the form [x1,y1,x2,y2,...,xn,yn].
/// 
/// Example 1:
/// Input: nums = [2,5,1,3,4,7], n = 3
/// Output: [2,3,5,4,1,7] 
/// Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the 
/// answer is [2,3,5,4,1,7].
///
/// Example 2:
/// Input: nums = [1,2,3,4,4,3,2,1], n = 4
/// Output: [1,4,2,3,3,2,4,1]
///
/// Example 3:
/// Input: nums = [1,1,2,2], n = 2
/// Output: [1,2,1,2]
///
/// Constraints:
/// 1. 1 <= n <= 500
/// 2. nums.length == 2n
/// 3. 1 <= nums[i] <= 10^3
/// </summary>	
vector<int> LeetCodeArray::shuffle(vector<int>& nums, int n)
{
    vector<int> result(nums.size());
    for (int i = 0; i < n; i++)
    {
        result[2*i] = nums[i];
        result[2*i + 1] = nums[i + n];
    }
    return result;
}

/// <summary>
/// Leet code #1471. The k Strongest Values in an Array
///                
/// Medium
/// 
/// Given an array of integers arr and an integer k.
/// A value arr[i] is said to be stronger than a value arr[j] 
/// if |arr[i] - m| > |arr[j] - m| where m is the median of the array.
/// If |arr[i] - m| == |arr[j] - m|, then arr[i] is said to be stronger 
/// than arr[j] if arr[i] > arr[j].
///
/// Return a list of the strongest k values in the array. return the 
/// answer in any arbitrary order.
///
/// Median is the middle value in an ordered integer list. More formally, 
/// if the length of the list is n, the median is the element in 
/// position ((n - 1) / 2) in the sorted list (0-indexed).
///
/// For arr = [6, -3, 7, 2, 11], n = 5 and the median is obtained by 
/// sorting the array arr = [-3, 2, 6, 7, 11] and the median is arr[m] 
/// where m = ((5 - 1) / 2) = 2. The median is 6.
/// For arr = [-7, 22, 17, 3], n = 4 and the median is obtained by 
/// sorting the array arr = [-7, 3, 17, 22] and the median is arr[m] 
/// where m = ((4 - 1) / 2) = 1. The median is 3.
///
/// Example 1:
/// Input: arr = [1,2,3,4,5], k = 2
/// Output: [5,1]
/// Explanation: Median is 3, the elements of the array sorted by the 
/// strongest are [5,1,4,2,3]. The strongest 2 elements are [5, 1]. 
/// [1, 5] is also accepted answer.
/// Please note that although |5 - 3| == |1 - 3| but 5 is stronger than 1 
/// because 5 > 1.
///
/// Example 2:
/// Input: arr = [1,1,3,5,5], k = 2
/// Output: [5,5]
/// Explanation: Median is 3, the elements of the array sorted by the 
/// strongest are [5,5,1,1,3]. The strongest 2 elements are [5, 5].
///
/// Example 3:
/// Input: arr = [6,7,11,7,6,8], k = 5
/// Output: [11,8,6,6,7]
/// Explanation: Median is 7, the elements of the array sorted by the 
/// strongest are [11,8,6,6,7,7].
/// Any permutation of [11,8,6,6,7] is accepted.
///
/// Example 4:
/// Input: arr = [6,-3,7,2,11], k = 3
/// Output: [-3,11,2]
///
/// Example 5:
/// Input: arr = [-7,22,17,3], k = 2
/// Output: [22,17]
///
/// Constraints:
/// 1. 1 <= arr.length <= 10^5
/// 2. -10^5 <= arr[i] <= 10^5
/// 3. 1 <= k <= arr.length
/// </summary>	
vector<int> LeetCodeArray::getStrongest(vector<int>& arr, int k)
{
    vector<int> result;
    sort(arr.begin(), arr.end());
    int median = arr[(arr.size() - 1) / 2];
    int first = 0;
    int last = arr.size() - 1;
    for (int i = 0; i < k; i++)
    {
        if (abs(arr[last] - median) > abs(arr[first] - median))
        {
            result.push_back(arr[last]);
            last--;
        }
        else if (abs(arr[last] - median) < abs(arr[first] - median))
        {
            result.push_back(arr[first]);
            first++;
        }
        else
        {
            result.push_back(arr[last]);
            last--;
        }
    }
    return result;
}

/// <summary>
/// Leet code #1477. Find Two Non-overlapping Sub-arrays Each With 
///                  Target Sum
///
/// Medium
///
/// Given an array of integers arr and an integer target.
///
/// You have to find two non-overlapping sub-arrays of arr each with 
/// sum equal target. There can be multiple answers so you have to 
/// find an answer where the sum of the lengths of the two sub-arrays 
/// is minimum.
///
/// Return the minimum sum of the lengths of the two required 
/// sub-arrays, or return -1 if you cannot find such two sub-arrays.
///
/// Example 1:
/// Input: arr = [3,2,2,4,3], target = 3
/// Output: 2
/// Explanation: Only two sub-arrays have sum = 3 ([3] and [3]). The 
/// sum of their lengths is 2.
///
/// Example 2:
/// Input: arr = [7,3,4,7], target = 7
/// Output: 2
/// Explanation: Although we have three non-overlapping sub-arrays 
/// of sum = 7 ([7], [3,4] and [7]), but we will choose the first 
/// and third sub-arrays as the sum of their lengths is 2.
///
/// Example 3:
/// Input: arr = [4,3,2,6,2,3,4], target = 6
/// Output: -1
/// Explanation: We have only one sub-array of sum = 6.
///
/// Example 4:
/// Input: arr = [5,5,4,4,5], target = 3
/// Output: -1
/// Explanation: We cannot find a sub-array of sum = 3.
///
/// Example 5:
/// Input: arr = [3,1,1,1,5,1,2,1], target = 3
/// Output: 3
/// Explanation: Note that sub-arrays [1,2] and [2,1] cannot be an 
/// answer because they overlap.
///
/// Constraints:
/// 1. 1 <= arr.length <= 10^5
/// 2. 1 <= arr[i] <= 1000
/// 3. 1 <= target <= 10^8
/// </summary> 
int LeetCodeArray::minSumOfLengths(vector<int>& arr, int target)
{
    unordered_map<int, int> sum_map;
    sum_map[0] = -1;
    int sum = 0;
    vector<int> dp(arr.size(), INT_MAX);
    int result = INT_MAX;
    for (int i = 0; i < (int)arr.size(); i++)
    {
        sum += arr[i];
        if (sum_map.count(sum - target) > 0)
        {
            int gap = i - sum_map[sum - target];
            int pos = i - gap;
            if (pos >= 0 && dp[pos] !=  INT_MAX)
            {
                result = min(result, gap + dp[pos]);
            }
            dp[i] = gap;
        }
        if (i > 0) dp[i] = min(dp[i], dp[i - 1]);
        sum_map[sum] = i;
    }
    return result == INT_MAX ? -1 : result;
}

/// <summary>
/// Leet code #1480. Running Sum of 1d Array
///
/// Easy
///
/// Given an array nums. We define a running sum of an array as 
/// runningSum[i] = sum(nums[0]…nums[i]).
///
/// Return the running sum of nums.
/// 
/// Example 1:
/// Input: nums = [1,2,3,4]
/// Output: [1,3,6,10]
/// Explanation: Running sum is obtained as follows: 
/// [1, 1+2, 1+2+3, 1+2+3+4].
///
/// Example 2:
/// Input: nums = [1,1,1,1,1]
/// Output: [1,2,3,4,5]
/// Explanation: Running sum is obtained as follows: [1, 1+1, 
/// 1+1+1, 1+1+1+1, 1+1+1+1+1].
///
/// Example 3:
/// Input: nums = [3,1,2,10,1]
/// Output: [3,4,6,16,17]
///
/// Constraints:
/// 1. 1 <= nums.length <= 1000
/// 2. -10^6 <= nums[i] <= 10^6
/// </summary> 
vector<int> LeetCodeArray::runningSum(vector<int>& nums)
{
    vector<int> result(nums.size());
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (i == 0) result[i] = nums[i];
        else result[i] = result[i - 1] + nums[i];
    }
    return result;
}

/// <summary>
/// Leet code #1488. Avoid Flood in The City
/// 
/// Medium
///
/// Your country has an infinite number of lakes. Initially, all the 
/// lakes are empty, but when it rains over the nth lake, the nth lake 
/// becomes full of water. If it rains over a lake which is full of 
/// water, there will be a flood. Your goal is to avoid the flood in 
/// any lake.
///
/// Given an integer array rains where:
/// rains[i] > 0 means there will be rains over the rains[i] lake.
/// rains[i] == 0 means there are no rains this day and you can choose 
/// one lake this day and dry it.
/// Return an array ans where:
/// ans.length == rains.length
/// ans[i] == -1 if rains[i] > 0.
/// ans[i] is the lake you choose to dry in the ith day if rains[i] == 0.
/// If there are multiple valid answers return any of them. If it is 
/// impossible to avoid flood return an empty array.
///
/// Notice that if you chose to dry a full lake, it becomes empty, but 
/// if you chose to dry an empty lake, nothing changes. (see example 4)
///
/// Example 1:
/// Input: rains = [1,2,3,4]
/// Output: [-1,-1,-1,-1]
/// Explanation: After the first day full lakes are [1]
/// After the second day full lakes are [1,2]
/// After the third day full lakes are [1,2,3]
/// After the fourth day full lakes are [1,2,3,4]
/// There's no day to dry any lake and there is no flood in any lake.
///
/// Example 2:
/// Input: rains = [1,2,0,0,2,1]
/// Output: [-1,-1,2,1,-1,-1]
/// Explanation: After the first day full lakes are [1]
/// After the second day full lakes are [1,2]
/// After the third day, we dry lake 2. Full lakes are [1]
/// After the fourth day, we dry lake 1. There is no full lakes.
/// After the fifth day, full lakes are [2].
/// After the sixth day, full lakes are [1,2].
/// It is easy that this scenario is flood-free. [-1,-1,1,2,-1,-1] is 
/// another acceptable scenario.
///
/// Example 3:
/// 1. Input: rains = [1,2,0,1,2]
/// 2. Output: []
/// Explanation: After the second day, full lakes are  [1,2]. We have 
/// to dry one lake in the third day.
/// After that, it will rain over lakes [1,2]. It's easy to prove that 
/// no matter which lake you choose to dry in the 3rd day, the other one 
/// will flood.
///
/// Example 4:
/// 1. Input: rains = [69,0,0,0,69]
/// 2. Output: [-1,69,1,1,-1]
/// 3. Explanation: Any solution on one of the forms [-1,69,x,y,-1], 
/// 4. [-1,x,69,y,-1] or [-1,x,y,69,-1] is acceptable 
///    where 1 <= x,y <= 10^9
///
/// Example 5:
/// Input: rains = [10,20,20]
/// Output: []
/// Explanation: It will rain over lake 20 two consecutive days. 
/// There is no chance to dry any lake.
///
/// Constraints:
/// 1. 1 <= rains.length <= 10^5
/// 2. 0 <= rains[i] <= 10^9
/// </summary>
vector<int> LeetCodeArray::avoidFlood(vector<int>& rains)
{
    unordered_map<int, int> lakes;
    set<int> drys;
    vector<int> result(rains.size(), 1);
    for (size_t i = 0; i < rains.size(); i++)
    {
        int lake = rains[i];
        if (lake == 0)
        {
            drys.insert(i);
        }
        else
        {
            result[i] = -1;
            if (lakes.count(lake) > 0)
            {
                auto itr = drys.upper_bound(lakes[lake]);
                if (itr == drys.end())
                {
                    result.clear();
                    break;
                }
                else
                {
                    result[*itr] = lake;
                    drys.erase(itr);
                }
            }
            lakes[lake] = i;
        }
    }
    return result;
}

/// <summary>
/// Leet code #1491. Average Salary Excluding the Minimum and Maximum Salary
/// 
/// Easy
///
/// Given an array of unique integers salary where salary[i] is the salary 
/// of the employee i.
///
/// Return the average salary of employees excluding the minimum and maximum 
/// salary.
///  
/// Example 1:
/// Input: salary = [4000,3000,1000,2000]
/// Output: 2500.00000
/// Explanation: Minimum salary and maximum salary are 1000 and 4000 
/// respectively.
/// Average salary excluding minimum and maximum salary is 
/// (2000+3000)/2= 2500
///
/// Example 2:
/// Input: salary = [1000,2000,3000]
/// Output: 2000.00000
/// Explanation: Minimum salary and maximum salary are 1000 and 3000 
/// respectively.
/// Average salary excluding minimum and maximum salary is (2000)/1= 2000
///
/// Example 3:
/// Input: salary = [6000,5000,4000,3000,2000,1000]
/// Output: 3500.00000
/// Example 4:
/// Input: salary = [8000,9000,2000,3000,6000,1000]
/// Output: 4750.00000
/// Constraints:
/// 1. 3 <= salary.length <= 100
/// 2. 10^3 <= salary[i] <= 10^6
/// 3. salary[i] is unique.
/// 4. Answers within 10^-5 of the actual value will be accepted as correct.
/// </summary>
double LeetCodeArray::average(vector<int>& salary)
{
    int min_val = INT_MAX;
    int max_val = INT_MIN;
    double sum = 0;
    for (size_t i = 0; i < salary.size(); i++)
    {
        sum += (double)salary[i];
        min_val = min(min_val, salary[i]);
        max_val = max(max_val, salary[i]);
    }

    if (salary.size() > 2)
    {
        return (sum - (double)min_val - (double)max_val) / (double)(salary.size() - 2);
    }
    else
    {
        return (double)0.0;
    }
}

/// <summary>
/// Leet code #1493. Longest Subarray of 1's After Deleting One Element
/// 
/// Medium
///
/// Given a binary array nums, you should delete one element from it.
///
/// Return the size of the longest non-empty subarray containing only 1's 
/// in the resulting array.
/// Return 0 if there is no such subarray.
/// Example 1:
/// Input: nums = [1,1,0,1]
/// Output: 3
/// Explanation: After deleting the number in position 2, [1,1,1] 
/// contains 3 numbers with value of 1's.
///
/// Example 2:
/// Input: nums = [0,1,1,1,0,1,1,0,1]
/// Output: 5
/// Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] 
/// longest subarray with value of 1's is [1,1,1,1,1].
///
/// Example 3:
/// Input: nums = [1,1,1]
/// Output: 2
/// Explanation: You must delete one element.
/// Example 4:
/// Input: nums = [1,1,0,0,1,1,1,0,1]
/// Output: 4
///
/// Example 5:
/// Input: nums = [0,0,0]
/// Output: 0
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. nums[i] is either 0 or 1.
/// </summary>
int LeetCodeArray::longestSubarray(vector<int>& nums)
{
    deque<int> zeros;
    int result = 0;
    for (int i = 0; i < (int)nums.size(); i++)
    {
        if (nums[i] == 0)
        {
            zeros.push_back(i);
            if (zeros.size() > 2) zeros.pop_front();
        }
        if (zeros.size() < 2) result = max(result, i);
        else result = max(result, i - zeros.front() - 1);
    }
    return result;
}

/// <summary>
/// Leet code #1497. Check If Array Pairs Are Divisible by k
/// 
/// Medium
///
/// Given an array of integers arr of even length n and an integer k.
/// We want to divide the array into exactly n / 2 pairs such that the 
/// sum of each pair is divisible by k.
/// Return True If you can find a way to do that or False otherwise.
/// 
/// Example 1:
/// Input: arr = [1,2,3,4,5,10,6,7,8,9], k = 5
/// Output: true
/// Explanation: Pairs are (1,9),(2,8),(3,7),(4,6) and (5,10).
///
/// Example 2:
/// Input: arr = [1,2,3,4,5,6], k = 7
/// Output: true
/// Explanation: Pairs are (1,6),(2,5) and(3,4).
///
/// Example 3:
/// Input: arr = [1,2,3,4,5,6], k = 10
/// Output: false
/// Explanation: You can try all possible pairs to see that there is no 
/// way to divide arr into 3 pairs each with sum divisible by 10.
///
/// Example 4:
/// Input: arr = [-10,10], k = 2
/// Output: true
///
/// Example 5:
/// Input: arr = [-1,1,-2,2,-3,3,-4,4], k = 3
/// Output: true
///
/// Constraints:
/// 1. arr.length == n
/// 2. 1 <= n <= 10^5
/// 3. n is even.
/// 4. -10^9 <= arr[i] <= 10^9
/// 5. 1 <= k <= 10^5
/// </summary>
bool LeetCodeArray::canArrange(vector<int>& arr, int k)
{
    vector<int> result(k);
    for (size_t i = 0; i < arr.size(); i++)
    {
        int re = arr[i] % k;
        if (re < 0) result[abs(re)]--;
        else result[abs(re)]++;
    }
    if (result[0] % 2 != 0) return false;
    for (int i = 1; i <= k / 2; i++)
    {
        if (result[i] != result[k - i]) return false;
    }
    return true;
}

/// <summary>
/// Leet code #1498. Number of Subsequences That Satisfy the Given Sum 
///                  Condition
/// 
/// Medium
///
/// Given an array of integers nums and an integer target.
/// Return the number of non-empty subsequences of nums such that the 
/// sum of the minimum and maximum element on it is less or equal than 
/// target.
///
/// Since the answer may be too large, return it modulo 10^9 + 7.
/// 
/// Example 1:
/// Input: nums = [3,5,6,7], target = 9
/// Output: 4
/// Explanation: There are 4 subsequences that satisfy the condition.
/// [3] -> Min value + max value <= target (3 + 3 <= 9)
/// [3,5] -> (3 + 5 <= 9)
/// [3,5,6] -> (3 + 6 <= 9)
/// [3,6] -> (3 + 6 <= 9)
///
/// Example 2:
/// Input: nums = [3,3,6,8], target = 10
/// Output: 6
/// Explanation: There are 6 subsequences that satisfy the condition. 
/// (nums can have repeated numbers).
/// [3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]
///
/// Example 3:
/// Input: nums = [2,3,3,4,6,7], target = 12
/// Output: 61
/// Explanation: There are 63 non-empty subsequences, two of them don't 
/// satisfy the condition ([6,7], [7]).
/// Number of valid subsequences (63 - 2 = 61).
///
/// Example 4:
/// Input: nums = [5,2,4,1,7,6,8], target = 16
/// Output: 127
/// Explanation: All non-empty subset satisfy the condition (2^7 - 1) = 127
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^6
/// 3. 1 <= target <= 10^6
/// </summary>
int LeetCodeArray::numSubseq(vector<int>& nums, int target)
{
    int M = 1000000007;
    sort(nums.begin(), nums.end());
    vector<int> factors(nums.size());
    int result = 0;
    int first = 0;
    int last = nums.size() - 1;
    while (first <= last)
    {
        if (nums[first] + nums[last] > target) last--;
        else
        {
            int gap = last - first;
            if (factors[gap] == 0)
            {
                factors[0] = 1;
                for (int j = 1; j <= gap; j++)
                {
                    factors[j] = (factors[j - 1] * 2) % M;
                }
            }
            result = (result + factors[gap]) % M;
            first++;
        }
    }
    return result;
}

/// <summary>
/// Leet code #1502. Can Make Arithmetic Progression From Sequence
/// 
/// Easy
///
/// Given an array of numbers arr. A sequence of numbers is called an 
/// arithmetic progression if the difference between any two consecutive 
/// elements is the same.
///
/// Return true if the array can be rearranged to form an arithmetic 
/// progression, otherwise, return false.
/// 
/// Example 1:
/// Input: arr = [3,5,1]
/// Output: true
/// Explanation: We can reorder the elements as [1,3,5] or [5,3,1] with 
/// differences 2 and -2 respectively, between each consecutive elements.
///
/// Example 2:
/// Input: arr = [1,2,4]
/// Output: false
/// Explanation: There is no way to reorder the elements to obtain an 
/// arithmetic progression.
///
/// Constraints:
/// 1. 2 <= arr.length <= 1000
/// 2. -10^6 <= arr[i] <= 10^6
/// </summary>
bool LeetCodeArray::canMakeArithmeticProgression(vector<int>& arr)
{
    sort(arr.begin(), arr.end());
    for (int i = 0; i < (int)arr.size() - 2; i++)
    {
        if (arr[i + 1] - arr[i] != arr[i + 2] - arr[i + 1])
        {
            return false;
        }
    }
    return true;
}

/// <summary>
/// Leet code #1504. Count Submatrices With All Ones
/// 
/// Medium
///
/// Given a rows * columns matrix mat of ones and zeros, return how many 
/// submatrices have all ones.
/// 
/// Example 1:
/// Input: mat = [[1,0,1],
///               [1,1,0],
///               [1,1,0]]
/// Output: 13
/// Explanation:
/// There are 6 rectangles of side 1x1.
/// There are 2 rectangles of side 1x2.
/// There are 3 rectangles of side 2x1.
/// There is 1 rectangle of side 2x2. 
/// There is 1 rectangle of side 3x1.
/// Total number of rectangles = 6 + 2 + 3 + 1 + 1 = 13.
///
/// Example 2:
///
/// Input: mat = [[0,1,1,0],
///               [0,1,1,1],
///               [1,1,1,0]]
/// Output: 24
/// Explanation:
/// There are 8 rectangles of side 1x1.
/// There are 5 rectangles of side 1x2.
/// There are 2 rectangles of side 1x3. 
/// There are 4 rectangles of side 2x1.
/// There are 2 rectangles of side 2x2. 
/// There are 2 rectangles of side 3x1. 
/// There is 1 rectangle of side 3x2. 
/// Total number of rectangles = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24.
///
/// Example 3:
/// Input: mat = [[1,1,1,1,1,1]]
/// Output: 21
///
/// Example 4:
/// Input: mat = [[1,0,1],[0,1,0],[1,0,1]]
/// Output: 5
/// 
/// Constraints:
/// 1. 1 <= rows <= 150
/// 2. 1 <= columns <= 150
/// 3. 0 <= mat[i][j] <= 1
/// </summary>
int LeetCodeArray::numSubmat(vector<vector<int>>& mat)
{
    int rows = mat.size();
    int cols = mat[0].size();
    int result = 0;
    vector<vector<vector<int>>> dp(rows, vector<vector<int>>(cols, vector<int>(cols)));
    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < cols; j++)
        {
            for (int k = j; k >= 0; k--)
            {
                if (mat[i][k] == 0) break;
                int g = j - k;
                dp[i][j][g]++;
                if (i > 0) dp[i][j][g] += dp[i - 1][j][g];
                result += dp[i][j][g];
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #1508. Range Sum of Sorted Subarray Sums
///
/// Medium
///	
/// Given the array nums consisting of n positive integers. You computed 
/// the sum of all non-empty continous subarrays from the array and then 
/// sort them in non-decreasing order, creating a new array of 
/// n * (n + 1) / 2 numbers.
/// Return the sum of the numbers from index left to index right 
/// (indexed from 1), inclusive, in the new array. Since the answer 
/// can be a huge number return it modulo 10^9 + 7.
///
/// Example 1:
/// Input: nums = [1,2,3,4], n = 4, left = 1, right = 5
/// Output: 13 
/// Explanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. 
/// After sorting them in non-decreasing order we have the new array 
/// [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index 
/// le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. 
///
/// Example 2:
/// Input: nums = [1,2,3,4], n = 4, left = 3, right = 4
/// Output: 6
/// Explanation: The given array is the same as example 1. We have 
/// the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the 
/// numbers from index le = 3 to ri = 4 is 3 + 3 = 6.
///
/// Example 3:
/// Input: nums = [1,2,3,4], n = 4, left = 1, right = 10
/// Output: 50
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^3
/// 2. nums.length == n
/// 3. 1 <= nums[i] <= 100
/// 4. 1 <= left <= right <= n * (n + 1) / 2
/// </summary>
int LeetCodeArray::rangeSum(vector<int>& nums, int n, int left, int right)
{
    int M = 1000000007;
    vector<int> dp(n);
    vector<int> sum;
    for (int i = 0; i < n; i++)
    {
        if (i == 0) dp[i] = nums[i];
        else dp[i] = dp[i - 1] + nums[i];

        for (int j = -1; j < i; j++)
        {
            if (j == -1) sum.push_back(dp[i]);
            else sum.push_back(dp[i] - dp[j]);
        }
    }
    sort(sum.begin(), sum.end());
    int result = 0;
    for (int i = left - 1; i < right; i++)
    {
        result = result + sum[i];
    }
    return result;
}

/// <summary>
/// Leet code #1513. Number of Substrings With Only 1s
///
/// Medium
///	
/// Given a binary string s (a string consisting only of '0' and '1's).
///
/// Return the number of substrings with all characters 1's.
/// Since the answer may be too large, return it modulo 10^9 + 7.
/// 
/// Example 1:
/// Input: s = "0110111"
/// Output: 9
/// Explanation: There are 9 substring in total with only 1's characters.
/// "1" -> 5 times.
/// "11" -> 3 times.
/// "111" -> 1 time.
///
/// Example 2:
/// Input: s = "101"
/// Output: 2
/// Explanation: Substring "1" is shown 2 times in s.
///
/// Example 3:
/// Input: s = "111111"
/// Output: 21
/// Explanation: Each substring contains only 1's characters.
///
/// Example 4:
/// Input: s = "000"
/// Output: 0
/// 
/// Constraints:
/// 1. s[i] == '0' or s[i] == '1'
/// 2. 1 <= s.length <= 10^5
/// </summary>
int LeetCodeArray::numSub(string s)
{
    int result = 0;
    int count = 0;
    int M = 1000000007;
    for (size_t i = 0; i < s.size(); i++)
    {
        if (s[i] == '0') count = 0;
        else
        {
            count++;
            result = (result + count) % M;
        }
    }
    return result;
}

/// <summary>
/// Leet code #1524. Number of Sub-arrays With Odd Sum
/// 
/// Medium
///
/// Given an array of integers arr. Return the number of sub-arrays with 
/// odd sum.
///
/// As the answer may grow large, the answer must be computed 
/// modulo 10^9 + 7.
/// 
/// Example 1:
/// Input: arr = [1,3,5]
/// Output: 4
/// Explanation: All sub-arrays are [[1],[1,3],[1,3,5],[3],[3,5],[5]]
/// All sub-arrays sum are [1,4,9,3,8,5].
/// Odd sums are [1,9,3,5] so the answer is 4.
///
/// Example 2:
/// Input: arr = [2,4,6]
/// Output: 0
/// Explanation: All sub-arrays are [[2],[2,4],[2,4,6],[4],[4,6],[6]]
/// All sub-arrays sum are [2,6,12,4,10,6].
/// All sub-arrays have even sum and the answer is 0.
///
/// Example 3:
/// Input: arr = [1,2,3,4,5,6,7]
/// Output: 16
///
/// Example 4:
/// Input: arr = [100,100,99,99]
/// Output: 4
///
/// Example 5:
/// Input: arr = [7]
/// Output: 1
/// 
/// Constraints:
/// 1. 1 <= arr.length <= 10^5
/// 2. 1 <= arr[i] <= 100
/// </summary>
int LeetCodeArray::numOfSubarrays(vector<int>& arr)
{
    vector<int> count(2);
    count[0] = 1;
    int M = 1000000007;
    int result = 0;
    int sum = 0;
    for (size_t i = 0; i < arr.size(); i++)
    {
        sum += arr[i];
        result = (result + count[1 - (sum % 2)]) % M;
        count[sum % 2]++;
    }
    return result;
}

/// <summary>
/// Leet code #1526. Minimum Number of Increments on Subarrays to Form a 
///                  Target Array
/// 
/// Hard
///
/// Given an array of positive integers target and an array initial of 
/// same size with all zeros.
///
/// Return the minimum number of operations to form a target array from 
/// initial if you are allowed to do the following operation:
///
/// Choose any subarray from initial and increment each value by one.
/// The answer is guaranteed to fit within the range of a 32-bit signed 
/// integer.
///
///
/// Example 1:
///
/// Input: target = [1,2,3,2,1]
/// Output: 3
/// Explanation: We need at least 3 operations to form the target array 
/// from the initial array.
/// [0,0,0,0,0] increment 1 from index 0 to 4 (inclusive).
/// [1,1,1,1,1] increment 1 from index 1 to 3 (inclusive).
/// [1,2,2,2,1] increment 1 at index 2.
/// [1,2,3,2,1] target array is formed.
///
/// Example 2:
/// Input: target = [3,1,1,2]
/// Output: 4
/// Explanation: (initial)[0,0,0,0] -> [1,1,1,1] -> [1,1,1,2] -> 
/// [2,1,1,2] -> [3,1,1,2] (target).
///
/// Example 3:
/// Input: target = [3,1,5,4,2]
/// Output: 7
/// Explanation: (initial)[0,0,0,0,0] -> [1,1,1,1,1] -> [2,1,1,1,1] 
/// -> [3,1,1,1,1] -> [3,1,2,2,2] -> [3,1,3,3,2] -> [3,1,4,4,2] 
/// -> [3,1,5,4,2] (target).
///
/// Example 4:
/// Input: target = [1,1,1,1]
/// Output: 1
///
/// Constraints:
/// 1. 1 <= target.length <= 10^5
/// 2. 1 <= target[i] <= 10^5
/// </summary>
int LeetCodeArray::minNumberOperations(vector<int>& target)
{
    int result = 0;
    int prev = 0;
    for (size_t i = 0; i < target.size(); i++)
    {
        if (target[i] > prev)
        {
            result += target[i] - prev;
        }
        prev = target[i];
    }
    return result;
}


/// <summary>
/// Leet code #1534. Count Good Triplets
/// 
/// Easy
///
/// Given an array of integers arr, and three integers a, b and c. You need 
/// to find the number of good triplets.
///
/// A triplet (arr[i], arr[j], arr[k]) is good if the following conditions 
/// are true:
///
/// 0 <= i < j < k < arr.length
/// |arr[i] - arr[j]| <= a
/// |arr[j] - arr[k]| <= b
/// |arr[i] - arr[k]| <= c
/// Where |x| denotes the absolute value of x.
///
/// Return the number of good triplets.
/// 
/// Example 1:
/// Input: arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3
/// Output: 4
/// Explanation: There are 4 good triplets: 
/// [(3,0,1), (3,0,1), (3,1,1), (0,1,1)]
///
/// Example 2:
/// Input: arr = [1,1,2,2,3], a = 0, b = 0, c = 1
/// Output: 0
/// Explanation: No triplet satisfies all conditions.
///
/// Constraints:
/// 1. 3 <= arr.length <= 100
/// 2. 0 <= arr[i] <= 1000
/// 3. 0 <= a, b, c <= 1000
/// </summary>
int LeetCodeArray::countGoodTriplets(vector<int>& arr, int a, int b, int c)
{
    int result = 0;
    for (size_t i = 0; i < arr.size(); i++)
    {
        for (size_t j = i + 1; j < arr.size(); j++)
        {
            for (size_t k = j + 1; k < arr.size(); k++)
            {
                if ((abs(arr[i] - arr[j]) <= a) &&
                    (abs(arr[j] - arr[k]) <= b) &&
                    (abs(arr[i] - arr[k]) <= c))
                {
                    result++;
                }
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #1537. Get the Maximum Score
/// 
/// Hard
///
/// You are given two sorted arrays of distinct integers nums1 and nums2.
///
/// A valid path is defined as follows:
///
/// Choose array nums1 or nums2 to traverse (from index-0).
/// Traverse the current array from left to right.
/// If you are reading any value that is present in nums1 and nums2 you are 
/// allowed to change your path to the other array. (Only one repeated value 
/// is considered in the valid path).
/// Score is defined as the sum of uniques values in a valid path.
///
/// Return the maximum score you can obtain of all possible valid paths.
///
/// Since the answer may be too large, return it modulo 10^9 + 7.
///
/// Example 1:
/// Input: nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]
/// Output: 30
/// Explanation: Valid paths:
/// [2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],  
/// (starting from nums1)
/// [4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]    (starting from nums2)
/// The maximum is obtained with the path in green [2,4,6,8,10].
///
/// Example 2:
/// Input: nums1 = [1,3,5,7,9], nums2 = [3,5,100]
/// Output: 109
/// Explanation: Maximum sum is obtained with the path [1,3,5,100].
///
/// Example 3:
/// Input: nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]
/// Output: 40
/// Explanation: There are no common elements between nums1 and nums2.
/// Maximum sum is obtained with the path [6,7,8,9,10].
///
/// Example 4:
/// Input: nums1 = [1,4,5,8,9,11,19], nums2 = [2,3,4,11,12]
/// Output: 61
///  
/// Constraints:
/// 1. 1 <= nums1.length <= 10^5
/// 2. 1 <= nums2.length <= 10^5
/// 3. 1 <= nums1[i], nums2[i] <= 10^7
/// 4. nums1 and nums2 are strictly increasing.
/// </summary>
int LeetCodeArray::maxSum(vector<int>& nums1, vector<int>& nums2)
{
    int M = 1000000007;

    long long sum1 = 0, sum2 = 0;
    int index1 = nums1.size() - 1, index2 = nums2.size() - 1;
    while (index1 >= 0 || index2 >= 0)
    {
        if (index1 < 0 || (index2 >= 0 && nums1[index1] < nums2[index2]))
        {
            sum2 += nums2[index2];
            index2--;
        }
        else if (index2 < 0 || (index1 >= 0 && nums2[index2] < nums1[index1]))
        {
            sum1 += nums1[index1];
            index1--;
        }
        else
        {
            sum1 = max(sum1, sum2);
            sum2 = sum1;
            sum1 += nums1[index1];
            sum2 += nums2[index2];
            index1--;
            index2--;
        }
    }
    int result = (int)(max(sum1, sum2) % M);
    return result;
}

/// <summary>
/// Leet code #1539. Kth Missing Positive Number
/// 
/// Easy
///
/// Given an array arr of positive integers sorted in a strictly increasing
/// order, and an integer k.
///
/// Find the kth positive integer that is missing from this array.
///
/// Example 1:
/// Input: arr = [2,3,4,7,11], k = 5
/// Output: 9
/// Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. 
/// The 5th missing positive integer is 9.
///
/// Example 2:
///
/// Input: arr = [1,2,3,4], k = 2
/// Output: 6
/// Explanation: The missing positive integers are [5,6,7,...]. 
/// The 2nd missing positive integer is 6.
/// Constraints:
/// 1. 1 <= arr.length <= 1000
/// 2. 1 <= arr[i] <= 1000
/// 3. 1 <= k <= 1000
/// 4. arr[i] < arr[j] for 1 <= i < j <= arr.lengthYou are given two sorted 
///    arrays of distinct integers nums1 and nums2.
/// </summary>
int LeetCodeArray::findKthPositive(vector<int>& arr, int k)
{
    int prev = 0;
    int result = 0;
    for (size_t i = 0; i < arr.size(); i++)
    {
        if (arr[i] - prev > 1)
        {
            if (k <= arr[i] - prev - 1)
            {
                result = prev + k;
                break;
            }
            k -= arr[i] - prev - 1;
        }
        prev = arr[i];
    }
    result = prev + k;
    return result;
}

/// <summary>
/// Leet code #1550. Three Consecutive Odds
/// 
/// Easy
///
/// Given an integer array arr, return true if there are three consecutive 
/// odd numbers in the array. Otherwise, return false.
///
/// Example 1:
/// Input: arr = [2,6,4,1]
/// Output: false
/// Explanation: There are no three consecutive odds.
///
/// Example 2:
/// Input: arr = [1,2,34,3,4,5,7,23,12]
/// Output: true
/// Explanation: [5,7,23] are three consecutive odds.
/// 
/// Constraints:
/// 1. 1 <= arr.length <= 1000
/// 2. 1 <= arr[i] <= 1000
/// </summary>
bool LeetCodeArray::threeConsecutiveOdds(vector<int>& arr)
{
    int count = 0;
    for (size_t i = 0; i < arr.size(); i++)
    {
        if (arr[i] % 2 == 0)
        {
            count = 0;
        }
        else
        {
            count++;
            if (count == 3) return true;
        }
    }
    return false;
}

/// <summary>
/// Leet code #1538. Guess the Majority in a Hidden Array
/// 
/// Medium
///
/// We have an integer array nums, where all the integers in nums are 0 
/// or 1. You will not be given direct access to the array, instead, you 
/// will have an API ArrayReader which have the following functions:
/// 
/// int query(int a, int b, int c, int d): where 0 <= a < b < c < d < 
/// ArrayReader.length(). The function returns the distribution of the 
/// value of the 4 elements and returns:
/// 4 : if the values of the 4 elements are the same (0 or 1).
/// 2 : if three elements have a value equal to 0 and one element has 
/// value equal to 1 or vice versa.
/// 0 : if two element have a value equal to 0 and two elements have a 
/// value equal to 1.
/// int length(): Returns the size of the array.
/// You are allowed to call query() 2 * n times at most where n is equal 
/// to ArrayReader.length().
///
/// Return any index of the most frequent value in nums, in case of tie, 
/// return -1.
/// 
/// Follow up: What is the minimum number of calls needed to find the 
/// majority element?
///
/// Example 1:
/// Input: nums = [0,0,1,0,1,1,1,1]
/// Output: 5
/// Explanation: The following calls to the API
/// reader.length() // returns 8 because there are 8 elements in the hidden
///                 // array.
/// reader.query(0,1,2,3) // returns 2 this is a query that compares the 
///                       // elements nums[0], nums[1], nums[2], nums[3]
///                       // Three elements have a value equal to 0 and one 
///                       // element has value equal to 1 or viceversa.
/// reader.query(4,5,6,7) // returns 4 because nums[4], nums[5], nums[6], 
///                       // nums[7] have the same value.
///                       // we can infer that the most frequent value is 
///                       // found in the last 4 elements.
///                       // Index 2, 4, 6, 7 is also a correct answer.
///
/// Example 2:
/// Input: nums = [0,0,1,1,0]
/// Output: 0
///
/// Example 3:
/// Input: nums = [1,0,1,0,1,0,1,0]
/// Output: -1
/// Constraints:
/// 1. 5 <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 1
/// </summary>
int LeetCodeArray::guessMajority(ArrayReader& reader)
{
    vector<int> dp(5);
    dp[0] = reader.query(0, 1, 2, 3);
    dp[1] = reader.query(0, 1, 2, 4);
    dp[2] = reader.query(0, 2, 3, 4);
    dp[3] = reader.query(1, 2, 3, 4);
    dp[4] = reader.query(0, 1, 3, 4);
    int length = reader.length();

    int vote = 1;
    int diff = -1;
    for (int i = 5; i < length; i++)
    {
        int value = reader.query(0, 1, 2, i);
        if (value == dp[0]) vote++;
        else
        {
            vote--;
            diff = i;
        }
    }
    if (dp[0] == dp[1])
    {
        vote++;
    }
    else
    {
        vote--;
        diff = 4;
    }
    if (dp[1] == dp[2])
    {
        vote++;
    }
    else
    {
        vote--;
        diff = 1;
    }
    if (dp[2] == dp[3])
    {
        if (diff != 1) vote++;
        else vote--;
    }
    else
    {
        if (diff != 1) vote--;
        else vote++;
    }
    if (dp[1] == dp[4])
    {
        vote++;
    }
    else
    {
        vote--;
        diff = 2;
    }
    if (vote == 0) return -1;
    else if (vote > 0) return 3;
    else return diff;
}

/// <summary>
/// Leet code #1533. Find the Index of the Large Integer
/// 
/// Medium
///
/// We have an integer array arr, where all the integers in arr are equal 
/// except for one integer which is larger than the rest of the integers. 
/// You will not be given direct access to the array, instead, you will 
/// have an API ArrayReader which have the following functions:
/// int compareSub(int l, int r, int x, int y): where 0 <= l, r, x, y < 
/// ArrayReader.length(), l <= r and x <= y. The function compares the 
/// sum of sub-array arr[l..r] with the sum of the sub-array arr[x..y] 
/// and returns:
/// 1 if arr[l]+arr[l+1]+...+arr[r] > arr[x]+arr[x+1]+...+arr[y].
/// 0 if arr[l]+arr[l+1]+...+arr[r] == arr[x]+arr[x+1]+...+arr[y].
/// -1 if arr[l]+arr[l+1]+...+arr[r] < arr[x]+arr[x+1]+...+arr[y].
/// int length(): Returns the size of the array.
/// You are allowed to call compareSub() 20 times at most. You can 
/// assume both functions work in O(1) time.
///
/// Return the index of the array arr which has the largest integer.
/// Follow-up:
/// What if there are two numbers in arr that are bigger than all other 
/// numbers?
/// What if there is one number that is bigger than other numbers and 
/// one number that is smaller than other numbers?
/// 
/// Example 1: 
/// Input: arr = [7,7,7,7,10,7,7,7]
/// Output: 4
/// Explanation: The following calls to the API
/// reader.compareSub(0, 0, 1, 1) // returns 0 this is a query comparing 
/// the sub-array (0, 0) with the sub array (1, 1), (i.e. compares arr[0] 
/// with arr[1]).
/// Thus we know that arr[0] and arr[1] doesn't contain the largest 
/// element.
/// reader.compareSub(2, 2, 3, 3) // returns 0.
/// reader.compareSub(4, 4, 5, 5) // returns 1.
/// Notice that we made only 3 calls, so the answer is valid.
///
/// Example 2:
/// Input: nums = [6,6,12]
/// Output: 2
/// 
/// Constraints:
/// 1. 2 <= arr.length <= 5 * 10^5
/// 2. 1 <= arr[i] <= 100
/// 3. All elements of arr are equal except for one element which is 
/// larger than all other elements.
/// </summary>
int LeetCodeArray::getIndex(ArrayReader& reader)
{
    int first = 0;
    int last = reader.length() - 1;
    while (first < last)
    {
        int length = (last - first + 1) / 2;
        int middle = first + length;
        int result = reader.compareSub(first, middle - 1, middle, middle + length - 1);
        if (result == -1)
        {
            first = middle;
            last = middle + length - 1;
        }
        else if (result == 1)
        {
            last = middle - 1;
        }
        else
        {
            break;
        }
    }
    return last;
}

/// <summary>
/// Leet code #1566. Detect Pattern of Length M Repeated K or More Times
/// 
/// Easy
///
/// Given an array of positive integers arr,  find a pattern of length m 
/// that is repeated k or more times.
///
/// A pattern is a subarray (consecutive sub-sequence) that consists of 
/// one or more values, repeated multiple times consecutively without 
/// overlapping. A pattern is defined by its length and the number of 
/// repetitions.
///
/// Return true if there exists a pattern of length m that is repeated 
/// k or more times, otherwise return false.
/// 
/// Example 1:
/// Input: arr = [1,2,4,4,4,4], m = 1, k = 3
/// Output: true
/// Explanation: The pattern (4) of length 1 is repeated 4 consecutive 
/// times. Notice that pattern can be repeated k or more times but not 
/// less.
///
/// Example 2:
/// Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2
/// Output: true
/// Explanation: The pattern (1,2) of length 2 is repeated 2 consecutive 
/// times. Another valid pattern (2,1) is also repeated 2 times.
///
/// Example 3:
/// Input: arr = [1,2,1,2,1,3], m = 2, k = 3
/// Output: false
/// Explanation: The pattern (1,2) is of length 2 but is repeated only 2 
/// times. There is no pattern of length 2 that is repeated 3 or more 
/// times.
///
/// Example 4:
/// Input: arr = [1,2,3,1,2], m = 2, k = 2
/// Output: false
/// Explanation: Notice that the pattern (1,2) exists twice but not 
/// consecutively, so it doesn't count.
///
/// Example 5:
/// Input: arr = [2,2,2,2], m = 2, k = 3
/// Output: false
/// Explanation: The only pattern of length 2 is (2,2) however it's 
/// repeated only twice. Notice that we do not count overlapping 
/// repetitions.
/// 
/// Constraints:
/// 1. 2 <= arr.length <= 100
/// 2. 1 <= arr[i] <= 100
/// 3. 1 <= m <= 100
/// 4. 2 <= k <= 100
/// </summary>
bool LeetCodeArray::containsPattern(vector<int>& arr, int m, int k)
{
    vector<int> dp(arr.size());
    for (int i = 0; i < (int)arr.size(); i++)
    {
        if (i < m) continue;
        if (i + m > (int)arr.size()) continue;
        bool match = true;
        for (int j = 0; j < m; j++)
        {
            if (arr[i - (m - j)] != arr[i + j])
            {
                match = false;
                break;
            }
        }
        if (match == true)
        {
            dp[i] = dp[i - m] + 1;
            if (dp[i] == k-1) return true;
        }
    }
    return false;
}


/// <summary>
/// Leet code #1567. Maximum Length of Subarray With Positive Product
/// 
/// Medium
///
/// Given an array of integers nums, find the maximum length of a subarray 
/// where the product of all its elements is positive.
///
/// A subarray of an array is a consecutive sequence of zero or more 
/// values taken out of that array.
///
/// Return the maximum length of a subarray with positive product.
///
/// Example 1:
/// Input: nums = [1,-2,-3,4]
/// Output: 4
/// Explanation: The array nums already has a positive product of 24.
///
/// Example 2:
/// Input: nums = [0,1,-2,-3,-4]
/// Output: 3
/// Explanation: The longest subarray with positive product is [1,-2,-3] 
/// which has a product of 6.
/// Notice that we cannot include 0 in the subarray since that'll make 
/// the product 0 which is not positive.
///
/// Example 3:
/// Input: nums = [-1,-2,-3,0,1]
/// Output: 2
/// Explanation: The longest subarray with positive product is [-1,-2] 
/// or [-2,-3].
///
/// Example 4:
/// Input: nums = [-1,2]
/// Output: 1
///
/// Example 5:
/// Input: nums = [1,2,3,5,-6,4,0,10]
/// Output: 4
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. -10^9 <= nums[i] <= 10^9
/// </summary>
int LeetCodeArray::getMaxLen(vector<int>& nums)
{
    vector<int> map(2, INT_MAX);
    map[0] = -1;
    int count = 0;
    int result = 0;
    for (int i = 0; i < (int)nums.size(); i++)
    {
        if (nums[i] == 0)
        {
            map[1] = INT_MAX;
            map[0] = i;
            count = 0;
        }
        else if (nums[i] < 0)
        {
            count = 1 - count;
            if (map[count]  != INT_MAX)
            {
                result = max(result, i - map[count]);
            }
            else
            {
                map[count] = i;
            }
        }
        else
        {
            result = max(result, i - map[count]);
        }
    }
    return result;
}

/// <summary>
/// Leet code #1572. Matrix Diagonal Sum
/// 
/// Easy
///
/// Given a square matrix mat, return the sum of the matrix diagonals. 
/// Only include the sum of all the elements on the primary diagonal and 
/// all the elements on the secondary diagonal that are not part of the 
/// primary diagonal.
///
/// Example 1:
/// Input: mat = [[1,2,3],
///          [4,5,6],
///          [7,8,9]]
/// Output: 25
/// Explanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25
/// Notice that element mat[1][1] = 5 is counted only once.
///
/// Example 2:
/// Input: mat = [[1,1,1,1],
///          [1,1,1,1],
///          [1,1,1,1],
///          [1,1,1,1]]
/// Output: 8
///
/// Example 3:
/// Input: mat = [[5]]
/// Output: 5
///
/// Constraints:
/// 1. n == mat.length == mat[i].length
/// 2. 1 <= n <= 100
/// 3. 1 <= mat[i][j] <= 100
/// </summary>
int LeetCodeArray::diagonalSum(vector<vector<int>>& mat)
{
    int result = 0;

    int row = 0; 
    int col = 0;
    while (row < (int)mat.size())
    {
        result += mat[row][col];
        row++;
        col++;
    }
    row = 0;
    col = mat.size() - 1;
    while (row < (int)mat.size())
    {
        if (row != col) result += mat[row][col];
        row++;
        col--;
    }
    
    return result;
}

/// <summary>
/// Leet code #1574. Shortest Subarray to be Removed to Make Array Sorted 
/// 
/// Medium
///
/// Given an integer array arr, remove a subarray (can be empty) from arr 
/// such that the remaining elements in arr are non-decreasing.
///
/// A subarray is a contiguous subsequence of the array.
/// Return the length of the shortest subarray to remove.
///
/// Example 1:
/// Input: arr = [1,2,3,10,4,2,3,5]
/// Output: 3
/// Explanation: The shortest subarray we can remove is [10,4,2] of 
/// length 3. The remaining elements after that will be [1,2,3,3,5] which 
/// are sorted.
/// Another correct solution is to remove the subarray [3,10,4].
///
/// Example 2:
/// Input: arr = [5,4,3,2,1]
/// Output: 4
/// Explanation: Since the array is strictly decreasing, we can only keep 
/// a single element. Therefore we need to remove a subarray of length 4, 
/// either [5,4,3,2] or [4,3,2,1].
///
/// Example 3:
/// Input: arr = [1,2,3]
/// Output: 0
/// Explanation: The array is already non-decreasing. We do not need to 
/// remove any elements.
///
/// Example 4:
/// Input: arr = [1]
/// Output: 0
///
/// Constraints:
/// 1. 1 <= arr.length <= 10^5
/// 2. 0 <= arr[i] <= 10^9
/// </summary>
int LeetCodeArray::findLengthOfShortestSubarray(vector<int>& arr)
{
    int left = 0;
    while (left < (int)arr.size() - 1 && arr[left] <= arr[left + 1]) left++;
    if (left == arr.size() - 1) return 0;
    int right = arr.size() - 1;
    while (right > 0 && arr[right - 1] <= arr[right]) right--;
    int result = left + 1;
    result = max(result, (int)arr.size() - right);
    int last = arr.size() - 1;
    while (left >= 0 && last >= right)
    {
        if (arr[last] >= arr[left])
        {
            result = max(result, left + 1 + (int)arr.size() - last);
            last--;
        }
        else
        {
            left--;
        }
    }
    return arr.size() - result;
}

/// <summary>
/// Leet code #1582. Special Positions in a Binary Matrix 
/// 
/// Easy
///
/// Given a rows x cols matrix mat, where mat[i][j] is either 0 or 1, 
/// return the number of special positions in mat.
///
/// A position (i,j) is called special if mat[i][j] == 1 and all other 
/// elements in row i and column j are 0 (rows and columns are 0-indexed).
///
/// Example 1:
/// Input: mat = [[1,0,0],
///          [0,0,1],
///          [1,0,0]]
/// Output: 1
/// Explanation: (1,2) is a special position because mat[1][2] == 1 and 
/// all other elements in row 1 and column 2 are 0.
///
/// Example 2:
/// Input: mat = [[1,0,0],
///          [0,1,0],
///          [0,0,1]]
/// Output: 3
/// Explanation: (0,0), (1,1) and (2,2) are special positions. 
///
/// Example 3:
/// Input: mat = [[0,0,0,1],
///          [1,0,0,0],
///          [0,1,1,0],
///          [0,0,0,0]]
/// Output: 2
///
/// Example 4:
/// Input: mat = [[0,0,0,0,0],
///          [1,0,0,0,0],
///          [0,1,0,0,0],
///          [0,0,1,0,0],
///          [0,0,0,1,1]]
/// Output: 3
/// Constraints:
/// 1. rows == mat.length
/// 2. cols == mat[i].length
/// 3. 1 <= rows, cols <= 100
/// 4. mat[i][j] is 0 or 1.
/// </summary>
int LeetCodeArray::numSpecial(vector<vector<int>>& mat)
{
    vector<int> row(mat.size()), col(mat[0].size());
    int result = 0;
    for (size_t i = 0; i < mat.size(); i++)
    {
        for (size_t j = 0; j < mat[i].size(); j++)
        {
            if (mat[i][j] == 1)
            {
                row[i]++;
                col[j]++;
            }
        }
    }
    for (size_t i = 0; i < mat.size(); i++)
    {
        for (size_t j = 0; j < mat[i].size(); j++)
        {
            if (mat[i][j] == 1)
            {
                if (row[i] == 1 && col[j] == 1)
                {
                    result++;
                }
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #1583. Count Unhappy Friends
/// 
/// Medium
///
/// You are given a list of preferences for n friends, where n is always 
/// even.
///
/// For each person i, preferences[i] contains a list of friends sorted 
/// in the order of preference. In other words, a friend earlier in the 
/// list is more preferred than a friend later in the list. Friends in 
/// each list are denoted by integers from 0 to n-1.
///
/// All the friends are divided into pairs. The pairings are given in a 
/// list pairs, where pairs[i] = [xi, yi] denotes xi is paired with yi 
/// and yi is paired with xi.
///
/// However, this pairing may cause some of the friends to be unhappy. 
/// A friend x is unhappy if x is paired with y and there exists a 
/// friend u who is paired with v but:
///
/// x prefers u over y, and
/// u prefers x over v.
/// Return the number of unhappy friends.
/// 
/// Example 1:
/// Input: n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], 
/// [1, 2, 0]], pairs = [[0, 1], [2, 3]]
/// Output: 2
/// Explanation:
/// Friend 1 is unhappy because:
/// - 1 is paired with 0 but prefers 3 over 0, and
/// - 3 prefers 1 over 2.
/// Friend 3 is unhappy because:
/// - 3 is paired with 2 but prefers 1 over 2, and
/// - 1 prefers 3 over 0.
/// Friends 0 and 2 are happy.
///
/// Example 2:
/// Input: n = 2, preferences = [[1], [0]], pairs = [[1, 0]]
/// Output: 0
/// Explanation: Both friends 0 and 1 are happy.
///
/// Example 3:
/// Input: n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], 
/// [0, 2, 1]], pairs = [[1, 3], [0, 2]]
/// Output: 4
/// 
/// Constraints:
/// 1. 2 <= n <= 500
/// 2. n is even.
/// 3. preferences.length == n
/// 4. preferences[i].length == n - 1
/// 5. 0 <= preferences[i][j] <= n - 1
/// 6. preferences[i] does not contain i.
/// 7. All values in preferences[i] are unique.
/// 8. pairs.length == n/2
/// 9. pairs[i].length == 2
/// 10. xi != yi
/// 11. 0 <= xi, yi <= n - 1
/// 12. Each person is contained in exactly one pair.
/// </summary>
int LeetCodeArray::unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs)
{
    vector<vector<int>> rank(n, vector<int>(n));
    for (size_t i = 0; i < preferences.size(); i++)
    {
        for (size_t j = 0; j < preferences[i].size(); j++)
        {
            rank[i][preferences[i][j]] = j+1;
        }
    }
    vector<int> friend_pair(n);
    for (size_t i = 0; i < pairs.size(); i++)
    {
        friend_pair[pairs[i][0]] = pairs[i][1];
        friend_pair[pairs[i][1]] = pairs[i][0];
    }
    int result = 0;
    for (int i = 0; i < n; i++)
    {
        for (size_t j = 0; j < preferences[i].size(); j++)
        {
            int other = preferences[i][j];
            if (other == friend_pair[i]) break;
            if (rank[other][i] < rank[other][friend_pair[other]])
            {
                result++;
                break;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #1588. Sum of All Odd Length Subarrays 
/// 
/// Easy
///
/// Given an array of positive integers arr, calculate the sum of all 
/// possible odd-length subarrays.
///
/// A subarray is a contiguous subsequence of the array.
/// Return the sum of all odd-length subarrays of arr.
///
/// Example 1:
/// Input: arr = [1,4,2,5,3]
/// Output: 58
/// Explanation: The odd-length subarrays of arr and their sums are:
/// [1] = 1
/// [4] = 4
/// [2] = 2
/// [5] = 5
/// [3] = 3
/// [1,4,2] = 7
/// [4,2,5] = 11
/// [2,5,3] = 10
/// [1,4,2,5,3] = 15
/// If we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 
/// 10 + 15 = 58
/// 
/// Example 2:
/// Input: arr = [1,2]
/// Output: 3
/// Explanation: There are only 2 subarrays of odd length, [1] 
/// and [2]. Their sum is 3.
///
/// Example 3:
/// Input: arr = [10,11,12]
/// Output: 66
/// Constraints:
/// 1. 1 <= arr.length <= 100
/// 2. 1 <= arr[i] <= 1000
/// </summary>
int LeetCodeArray::sumOddLengthSubarrays(vector<int>& arr)
{
    // counting for ending at current position.
    pair<int, int> odd = { 0, 0 }, even = { 0, 0 };
    int result = 0;
    for (size_t i = 0; i < arr.size(); i++)
    {
        pair<int, int> next_odd, next_even;
        next_odd.first = even.first + 1;
        next_odd.second = even.second + (even.first + 1) * arr[i];
        next_even.first = odd.first;
        next_even.second = odd.second + odd.first * arr[i];
        odd = next_odd;
        even = next_even;

        result = result + odd.second;
    }
    return result;
}

/// <summary>
/// Leet code #1590. Make Sum Divisible by P
/// 
/// Medium
///
/// Given an array of positive integers nums, remove the smallest subarray 
/// (possibly empty) such that the sum of the remaining elements is 
/// divisible by p. It is not allowed to remove the whole array.
///
/// Return the length of the smallest subarray that you need to remove, 
/// or -1 if it's impossible.
///
/// A subarray is defined as a contiguous block of elements in the array.
/// 
/// Example 1:
/// Input: nums = [3,1,4,2], p = 6
/// Output: 1
/// Explanation: The sum of the elements in nums is 10, which is not 
/// divisible by 6. We can remove the subarray [4], and the sum of the 
/// remaining elements is 6, which is divisible by 6.
///
/// Example 2:
/// Input: nums = [6,3,5,2], p = 9
/// Output: 2
/// Explanation: We cannot remove a single element to get a sum divisible 
/// by 9. The best way is to remove the subarray [5,2], leaving us with 
/// [6,3] with sum 9.
///
/// Example 3:
/// Input: nums = [1,2,3], p = 3
/// Output: 0
/// Explanation: Here the sum is 6. which is already divisible by 3. Thus 
/// we do not need to remove anything.
///
/// Example 4:
/// Input: nums = [1,2,3], p = 7
/// Output: -1
/// Explanation: There is no way to remove a subarray in order to get a 
/// sum divisible by 7.
///
/// Example 5:
/// Input: nums = [1000000000,1000000000,1000000000], p = 3
/// Output: 0
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^9
/// 3. 1 <= p <= 10^9
/// </summary>
int LeetCodeArray::minSubarray(vector<int>& nums, int p)
{
    unordered_map<int, int> positions;
    int sum = 0;
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        sum = (sum + nums[i]) % p;
    }
    if (sum == 0) return result;
    result = INT_MAX;
    int curr = 0;
    positions[0] = -1;
    for (int i = 0; i < (int)nums.size(); i++)
    {
        curr = (curr + nums[i]) % p;
        int target = (curr + p - sum) % p;
        if (positions.count(target) > 0)
        {
            result = min(result, i - positions[target]);
        }
        positions[curr] = i;
    }
    return (result < (int) nums.size()) ? result : -1;
}

/// <summary>
/// Leet code #1599. Maximum Profit of Operating a Centennial Wheel
/// 
/// Medium
///
/// You are the operator of a Centennial Wheel that has four gondolas, 
/// and each gondola has room for up to four people. You have the ability 
/// to rotate the gondolas counterclockwise, which costs you runningCost 
/// dollars.
///
/// You are given an array customers of length n where customers[i] is 
/// the number of new customers arriving just before the ith rotation 
/// (0-indexed). This means you must rotate the wheel i times before 
/// customers[i] arrive. Each customer pays boardingCost dollars when 
/// they board on the gondola closest to the ground and will exit once 
/// that gondola reaches the ground again.
///
/// You can stop the wheel at any time, including before serving all 
/// customers. If you decide to stop serving customers, all subsequent 
/// rotations are free in order to get all the customers down safely. 
/// Note that if there are currently more than four customers waiting at 
/// the wheel, only four will board the gondola, and the rest will wait 
/// for the next rotation.
/// 
/// Return the minimum number of rotations you need to perform to maximize 
/// your profit. If there is no scenario where the profit is positive, 
/// return -1.
///
/// Example 1:
/// 
/// Input: customers = [8,3], boardingCost = 5, runningCost = 6
/// Output: 3
/// Explanation: The numbers written on the gondolas are the number of 
/// people currently there.
/// 1. 8 customers arrive, 4 board and 4 wait for the next gondola, the 
///    wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14.
/// 2. 3 customers arrive, the 4 waiting board the wheel and the other 3 
///    wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28.
/// 3. The final 3 customers board the gondola, the wheel rotates. Current 
///    profit is 11 * $5 - 3 * $6 = $37.
/// 4. The highest profit was $37 after rotating the wheel 3 times.
///
/// Example 2:
/// Input: customers = [10,9,6], boardingCost = 6, runningCost = 4
/// Output: 7
/// Explanation:
/// 1. 10 customers arrive, 4 board and 6 wait for the next gondola, the 
///    wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.
/// 2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 
///    newly waiting), the wheel rotates. Current profit is 
///    8 * $6 - 2 * $4 = $40.
/// 3. The final 6 customers arrive, 4 board and 13 wait, the wheel 
///    rotates. Current profit is 12 * $6 - 3 * $4 = $60.
/// 4. 4 board and 9 wait, the wheel rotates. Current profit is 
///    16 * $6 - 4 * $4 = $80.
/// 5. 4 board and 5 wait, the wheel rotates. Current profit is 
///    20 * $6 - 5 * $4 = $100.
/// 6. 4 board and 1 waits, the wheel rotates. Current profit is 
///    24 * $6 - 6 * $4 = $120.
/// 7. 1 boards, the wheel rotates. Current profit is 
///    25 * $6 - 7 * $4 = $122.
/// 8. The highest profit was $122 after rotating the wheel 7 times.
///
/// Example 3:
/// Input: customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92
/// Output: -1
/// Explanation:
/// 1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current 
///    profit is 3 * $1 - 1 * $92 = -$89.
/// 2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current 
///    profit is 7 * $1 - 2 * $92 = -$177.
/// 3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current 
///    profit is 7 * $1 - 3 * $92 = -$269.
/// 4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current 
///    profit is 12 * $1 - 4 * $92 = -$356.
/// 5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current 
///    profit is 13 * $1 - 5 * $92 = -$447.
/// 6. The profit was never positive, so return -1.
///
/// Example 4:
/// Input: customers = [10,10,6,4,7], boardingCost = 3, runningCost = 8
/// Output: 9
/// Explanation:
/// 1. 10 customers arrive, 4 board and 6 wait, the wheel rotates. Current 
///    profit is 4 * $3 - 1 * $8 = $4.
/// 2. 10 customers arrive, 4 board and 12 wait, the wheel rotates. Current 
///    profit is 8 * $3 - 2 * $8 = $8.
/// 3. 6 customers arrive, 4 board and 14 wait, the wheel rotates. Current 
///    profit is 12 * $3 - 3 * $8 = $12.
/// 4. 4 customers arrive, 4 board and 14 wait, the wheel rotates. Current 
///    profit is 16 * $3 - 4 * $8 = $16.
/// 5. 7 customers arrive, 4 board and 17 wait, the wheel rotates. Current 
///    profit is 20 * $3 - 5 * $8 = $20.
/// 6. 4 board and 13 wait, the wheel rotates. Current profit 
///    is 24 * $3 - 6 * $8 = $24.
/// 7. 4 board and 9 wait, the wheel rotates. Current profit is 
///    28 * $3 - 7 * $8 = $28.
/// 8. 4 board and 5 wait, the wheel rotates. Current profit is 
///    32 * $3 - 8 * $8 = $32.
/// 9. 4 board and 1 waits, the wheel rotates. Current profit is 
///    36 * $3 - 9 * $8 = $36.
/// 10. 1 board and 0 wait, the wheel rotates. Current profit is 
///    37 * $3 - 10 * $8 = $31.
/// 11. The highest profit was $36 after rotating the wheel 9 times.
///
/// Constraints:
/// 1. n == customers.length
/// 2. 1 <= n <= 10^5
/// 3. 0 <= customers[i] <= 50
/// 4. 1 <= boardingCost, runningCost <= 100
/// </summary>
int LeetCodeArray::minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost)
{
    int result = -1;
    int max_profit = 0;
    int waiting = 0;
    int profit = 0;
    int index = 0;
    while (waiting > 0 || index < (int)customers.size())
    {
        if (index < (int)customers.size())
        {
            waiting += customers[index];
        }
        index++;
        if (waiting > 4)
        {
            profit += boardingCost * 4;
            waiting -= 4;
        }
        else
        {
            profit += boardingCost * waiting;
            waiting = 0;
        }
        profit -= runningCost;
        if (profit > max_profit)
        {
            max_profit = profit;
            result = index;
        }
    }
    return result;
}

/// <summary>
/// Leet code #1605. Find Valid Matrix Given Row and Column Sums
/// 
/// Medium
///
/// You are given two arrays rowSum and colSum of non-negative integers 
/// where rowSum[i] is the sum of the elements in the ith row and colSum[j] 
/// is the sum of the elements of the jth column of a 2D matrix. In other 
/// words, you do not know the elements of the matrix, but you do know the 
/// sums of each row and column.
///
/// Find any matrix of non-negative integers of size rowSum.length x 
/// colSum.length that satisfies the rowSum and colSum requirements.
///
/// Return a 2D array representing any matrix that fulfills the 
/// requirements. It's guaranteed that at least one matrix that fulfills 
/// the requirements exists.
///
/// Example 1:
/// Input: rowSum = [3,8], colSum = [4,7]
/// Output: [[3,0],
///          [1,7]]
/// Explanation:
/// 0th row: 3 + 0 = 0 == rowSum[0]
/// 1st row: 1 + 7 = 8 == rowSum[1]
/// 0th column: 3 + 1 = 4 == colSum[0]
/// 1st column: 0 + 7 = 7 == colSum[1]
/// The row and column sums match, and all matrix elements are 
/// non-negative.
/// Another possible matrix is: [[1,2],
///                              [3,5]]
/// Example 2:
/// Input: rowSum = [5,7,10], colSum = [8,6,8]
/// Output: [[0,5,0],
///          [6,1,0],
///         [2,0,8]]
///
/// Example 3:
/// Input: rowSum = [14,9], colSum = [6,9,8]
/// Output: [[0,9,5],
///          [6,0,3]]
///
/// Example 4:
/// Input: rowSum = [1,0], colSum = [1]
/// Output: [[1],
///          [0]]
///
/// Example 5:
/// Input: rowSum = [0], colSum = [0]
/// Output: [[0]]
///
/// Constraints:
/// 1. 1 <= rowSum.length, colSum.length <= 500
/// 2. 0 <= rowSum[i], colSum[i] <= 108
/// 3. sum(rows) == sum(columns)
/// </summary>
vector<vector<int>> LeetCodeArray::restoreMatrix(vector<int> rowSum, vector<int> colSum)
{
    vector<vector<int>> result(rowSum.size(), vector<int>(colSum.size()));
    int row = 0;
    int col = 0;
    while (row < (int)rowSum.size() && col < (int)colSum.size())
    {
        if (rowSum[row] < colSum[col])
        {
            result[row][col] = rowSum[row];
            colSum[col] -= result[row][col];
            row++;
        }
        else
        {
            result[row][col] = colSum[col];
            rowSum[row] -= result[row][col];
            col++;
        }
    }
    return result;
}

/// <summary>
/// Leet code #1629. Slowest Key
/// 
/// Easy
///
/// A newly designed keypad was tested, where a tester pressed a sequence 
/// of n keys, one at a time.
///
/// You are given a string keysPressed of length n, where keysPressed[i] 
/// was the ith key pressed in the testing sequence, and a sorted list 
/// releaseTimes, where releaseTimes[i] was the time the ith key was 
/// released. Both arrays are 0-indexed. The 0th key was pressed at the 
/// time 0, and every subsequent key was pressed at the exact time the 
/// previous key was released.
///
/// The tester wants to know the key of the keypress that had the longest 
/// duration. The ith keypress had a duration of releaseTimes[i] - 
/// releaseTimes[i - 1], and the 0th keypress had a duration of 
/// releaseTimes[0].
///
/// Note that the same key could have been pressed multiple times during 
/// the test, and these multiple presses of the same key may not have had 
/// the same duration.
///
/// Return the key of the keypress that had the longest duration. If there 
/// are multiple such keypresses, return the lexicographically largest key 
/// of the keypresses.
///
/// Example 1:
/// Input: releaseTimes = [9,29,49,50], keysPressed = "cbcd"
/// Output: "c"
/// Explanation: The keypresses were as follows:
/// Keypress for 'c' had a duration of 9 (pressed at time 0 and released 
/// at time 9).
/// Keypress for 'b' had a duration of 29 - 9 = 20 (pressed at time 9 
/// right after the release of the previous character and released at 
/// time 29).
/// Keypress for 'c' had a duration of 49 - 29 = 20 (pressed at time 29 
/// right after the release of the previous character and released at 
/// time 49).
/// Keypress for 'd' had a duration of 50 - 49 = 1 (pressed at time 49 
/// right after the release of the previous character and released at 
/// time 50).
/// The longest of these was the keypress for 'b' and the second keypress 
/// for 'c', both with duration 20.
/// 'c' is lexicographically larger than 'b', so the answer is 'c'.
///
/// Example 2:
/// Input: releaseTimes = [12,23,36,46,62], keysPressed = "spuda"
/// Output: "a"
/// Explanation: The keypresses were as follows:
/// Keypress for 's' had a duration of 12.
/// Keypress for 'p' had a duration of 23 - 12 = 11.
/// Keypress for 'u' had a duration of 36 - 23 = 13.
/// Keypress for 'd' had a duration of 46 - 36 = 10.
/// Keypress for 'a' had a duration of 62 - 46 = 16.
/// The longest of these was the keypress for 'a' with duration 16.
///
/// Constraints:
/// 1. releaseTimes.length == n
/// 2. keysPressed.length == n
/// 3. 2 <= n <= 1000
/// 4. 1 <= releaseTimes[i] <= 10^9 
/// 5. releaseTimes[i] < releaseTimes[i+1]
/// 6. keysPressed contains only lowercase English letters.
/// </summary>
char LeetCodeArray::slowestKey(vector<int>& releaseTimes, string keysPressed)
{
    int prev_rel = 0;
    char max_key = '#';
    int max_dur = 0;
    for (size_t i = 0; i < releaseTimes.size(); i++)
    {
        int duration = releaseTimes[i] - prev_rel;
        if ((duration > max_dur) || (duration == max_dur && keysPressed[i] > max_key))
        {
            max_key = keysPressed[i];
            max_dur = duration;
        }
        prev_rel = releaseTimes[i];
    }
    return max_key;
}

/// <summary>
/// Leet code #1630. Arithmetic Subarrays
/// 
/// Medium
///
/// A sequence of numbers is called arithmetic if it consists of at least 
/// two elements, and the difference between every two consecutive 
/// elements is the same. More formally, a sequence s is arithmetic if and 
/// only if s[i+1] - s[i] == s[1] - s[0] for all valid i.
/// 
/// For example, these are arithmetic sequences:
/// 1, 3, 5, 7, 9
/// 7, 7, 7, 7
/// 3, -1, -5, -9
/// The following sequence is not arithmetic:
/// 
/// 1, 1, 2, 5, 7
/// You are given an array of n integers, nums, and two arrays of m 
/// integers each, l and r, representing the m range queries, where the 
/// ith query is the range [l[i], r[i]]. All the arrays are 0-indexed.
///
/// Return a list of boolean elements answer, where answer[i] is true if 
/// the subarray nums[l[i]], nums[l[i]+1], ... , nums[r[i]] can be 
/// rearranged to form an arithmetic sequence, and false otherwise.
/// 
/// Example 1:
/// Input: nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5]
/// Output: [true,false,true]
/// Explanation:
/// In the 0th query, the subarray is [4,6,5]. This can be rearranged 
/// as [6,5,4], which is an arithmetic sequence.
/// In the 1st query, the subarray is [4,6,5,9]. This cannot be rearranged 
/// as an arithmetic sequence.
/// In the 2nd query, the subarray is [5,9,3,7]. This can be rearranged 
/// as [3,5,7,9], which is an arithmetic sequence.
///
/// Example 2:
/// Input: nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], 
/// l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]
/// Output: [false,true,false,false,true,true]
/// 
/// Constraints:
///
/// 1. n == nums.length
/// 2. m == l.length
/// 3. m == r.length
/// 4. 2 <= n <= 500
/// 5. 1 <= m <= 500
/// 6. 0 <= l[i] < r[i] < n
/// 7. -10^5 <= nums[i] <= 10^5
/// </summary>
vector<bool> LeetCodeArray::checkArithmeticSubarrays(vector<int>& nums, vector<int>& l, vector<int>& r)
{
    vector<bool> result(l.size());
    for (size_t i = 0; i < l.size(); i++)
    {
        int min_val = INT_MAX;
        int max_val = INT_MIN;
        for (int j = l[i]; j <= r[i]; j++)
        {
            min_val = min(min_val, nums[j]);
            max_val = max(max_val, nums[j]);
        }
        int delta = (max_val - min_val) / (r[i] - l[i]);
        if (delta * (r[i] - l[i]) != (max_val - min_val))
        {
            result[i] = false;
            continue;
        }
        result[i] = true;
        if (delta == 0) continue;
        vector<int> visited(r[i] - l[i] + 1);
        for (int j = l[i]; j <= r[i]; j++)
        {
            int pos = (nums[j] - min_val) / delta;
            if (pos * delta != (nums[j] - min_val))
            {
                result[i] = false;
                break;
            }
            if (visited[pos] == 1)
            {
                result[i] = false;
                break;
            }
            visited[pos] = 1;
        }
    }
    return result;
}

/// <summary>
/// Leet code #1636. Sort Array by Increasing Frequency
/// 
/// Easy
///
/// Given an array of integers nums, sort the array in increasing order 
/// based on the frequency of the values. If multiple values have the 
/// same frequency, sort them in decreasing order.
///
/// Return the sorted array.
///
/// Example 1:
/// Input: nums = [1,1,2,2,2,3]
/// Output: [3,1,1,2,2,2]
/// Explanation: '3' has a frequency of 1, '1' has a frequency of 2, 
/// and '2' has a frequency of 3.
///
/// Example 2:
/// Input: nums = [2,3,1,3,2]
/// Output: [1,3,3,2,2]
/// Explanation: '2' and '3' both have a frequency of 2, so they are 
/// sorted in decreasing order.
///
/// Example 3:
/// Input: nums = [-1,1,-6,4,5,-6,1,4,1]
/// Output: [5,-1,4,4,-6,-6,1,1,1]
///
/// Constraints:
/// 1. 1 <= nums.length <= 100
/// 2. -100 <= nums[i] <= 100
/// </summary>
vector<int> LeetCodeArray::frequencySort(vector<int>& nums)
{
    unordered_map<int, int> num_map;
    for (size_t i = 0; i < nums.size(); i++)
    {
        num_map[nums[i]]++;
    }
    priority_queue<pair<int, int>> pq;
    for (auto &itr : num_map)
    {
        pq.push(make_pair(-itr.second, itr.first));
    }
    vector<int> result;
    while (!pq.empty())
    {
        pair<int, int> pair = pq.top();
        pq.pop();
        for (int i = 0; i < 0-pair.first; i++)
        {
            result.push_back(pair.second);
        }
    }
    return result;
}

/// <summary>
/// Leet code #1640. Check Array Formation Through Concatenation
/// 
/// Easy
///
/// You are given an array of distinct integers arr and an array of 
/// integer arrays pieces, where the integers in pieces are distinct. 
/// Your goal is to form arr by concatenating the arrays in pieces in 
/// any order. However, you are not allowed to reorder the integers 
/// in each array pieces[i].
/// 
/// Return true if it is possible to form the array arr from pieces. 
/// Otherwise, return false.
///
/// Example 1:
/// Input: arr = [85], pieces = [[85]]
/// Output: true
///
/// Example 2:
/// Input: arr = [15,88], pieces = [[88],[15]]
/// Output: true
/// Explanation: Concatenate [15] then [88]
///
/// Example 3:
/// Input: arr = [49,18,16], pieces = [[16,18,49]]
/// Output: false
/// Explanation: Even though the numbers match, we cannot reorder pieces[0].
///
/// Example 4:
/// Input: arr = [91,4,64,78], pieces = [[78],[4,64],[91]]
/// Output: true
/// Explanation: Concatenate [91] then [4,64] then [78]
///
/// Example 5:
/// Input: arr = [1,3,5,7], pieces = [[2,4,6,8]]
/// Output: false
///
/// Constraints:
/// 1. 1 <= pieces.length <= arr.length <= 100
/// 2. sum(pieces[i].length) == arr.length
/// 3. 1 <= pieces[i].length <= arr.length
/// 4. 1 <= arr[i], pieces[i][j] <= 100
/// 5. The integers in arr are distinct. 
/// 6. The integers in pieces are distinct (i.e., If we flatten pieces in a 1D 
///    array, all the integers in this array are distinct).
/// </summary>
bool LeetCodeArray::canFormArray(vector<int>& arr, vector<vector<int>>& pieces)
{
    unordered_map<int, int> num_map;
    for (size_t i = 0; i < pieces.size(); i++)
    {
        num_map[pieces[i][0]] = i;
    }
    int j = -1;
    int k = 0;
    for (size_t i = 0; i < arr.size(); i++)
    {
        if (j == -1)
        {
            if (num_map.count(arr[i]) == 0)
            {
                return false;
            }
            j = num_map[arr[i]];
            num_map.erase(arr[i]);
            k = 0;
        }
        if (arr[i] != pieces[j][k]) return false;
        k++;
        if (k == pieces[j].size()) j = -1;
    }
    return true;
}

/// <summary>
/// Leet code #1637. Widest Vertical Area Between Two Points Containing 
///                  No Points
/// 
/// Medium
///
/// Given n points on a 2D plane where points[i] = [x[i], y[i]], Return 
/// the widest vertical area between two points such that no points are 
/// inside the area.
///
/// A vertical area is an area of fixed-width extending infinitely along 
/// the y-axis (i.e., infinite height). The widest vertical area is the 
/// one with the maximum width.
///
/// Note that points on the edge of a vertical area are not considered 
/// included in the area.
///
/// Example 1:
/// Input: points = [[8,7],[9,9],[7,4],[9,7]]
/// Output: 1
/// Explanation: Both the red and the blue area are optimal.
///
/// Example 2:
/// Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]
/// Output: 3
/// Constraints:
/// 1. n == points.length
/// 2. 2 <= n <= 10^5
/// 3. points[i].length == 2
/// 4. 0 <= x[i], y[i] <= 10^9
/// </summary>
int LeetCodeArray::maxWidthOfVerticalArea(vector<vector<int>>& points)
{
    int result = 0;
    sort(points.begin(), points.end());
    for (size_t i = 1; i < points.size(); i++)
    {
        result = max(result, points[i][0] - points[i - 1][0]);
    }
    return result;
}

/// <summary>
/// Leet code #1646. Get Maximum in Generated Array
/// 
/// Easy
///
/// You are given an integer n. An array nums of length n + 1 is 
/// generated in the following way:
///
/// nums[0] = 0
/// nums[1] = 1
/// nums[2 * i] = nums[i] when 2 <= 2 * i <= n
/// nums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n
/// Return the maximum integer in the array nums​​​.
///
/// Example 1:
/// Input: n = 7
/// Output: 3
/// Explanation: According to the given rules:
/// nums[0] = 0
/// nums[1] = 1
/// nums[(1 * 2) = 2] = nums[1] = 1
/// nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2
/// nums[(2 * 2) = 4] = nums[2] = 1
/// nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3
/// nums[(3 * 2) = 6] = nums[3] = 2
/// nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3
/// Hence, nums = [0,1,1,2,1,3,2,3], and the maximum is 3.
///
/// Example 2:
/// Input: n = 2
/// Output: 1
/// Explanation: According to the given rules, the maximum between 
/// nums[0], nums[1], and nums[2] is 1.
///
/// Example 3:
/// Input: n = 3
/// Output: 2
/// Explanation: According to the given rules, the maximum between 
/// nums[0], nums[1], nums[2], and nums[3] is 2.
///
/// Constraints:
/// 1. 0 <= n <= 100
/// </summary>
int LeetCodeArray::getMaximumGenerated(int n)
{
    vector<int> nums(n + 1);
    int result = 0;
    for (int i = 0; i <= n; i++)
    {
        if (i == 0) nums[i] = 0;
        else if (i == 1) nums[i] = 1;
        else if (i % 2 == 0) nums[i] = nums[i / 2];
        else nums[i] = nums[i / 2] + nums[i / 2 + 1];
        result = max(result, nums[i]);
    }
    return result;
}


/// <summary>
/// Leet code #1652. Defuse the Bomb
/// 
/// Easy
///
/// You have a bomb to defuse, and your time is running out! Your informer 
/// will provide you with a circular array code of length of n and a key k.
///
/// To decrypt the code, you must replace every number. All the numbers are 
/// replaced simultaneously.
/// 
/// If k > 0, replace the ith number with the sum of the next k numbers.
/// If k < 0, replace the ith number with the sum of the previous k numbers.
/// If k == 0, replace the ith number with 0.
/// As code is circular, the next element of code[n-1] is code[0], and the 
/// previous element of code[0] is code[n-1].
///
/// Given the circular array code and an integer key k, return the 
/// decrypted code to defuse the bomb!
/// 
/// Example 1:
/// Input: code = [5,7,1,4], k = 3
/// Output: [12,10,16,13]
/// Explanation: Each number is replaced by the sum of the next 3 numbers. 
/// The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the 
/// numbers wrap around.
///
/// Example 2:
/// Input: code = [1,2,3,4], k = 0
/// Output: [0,0,0,0]
/// Explanation: When k is zero, the numbers are replaced by 0. 
///
/// Example 3:
/// 1. Input: code = [2,4,9,3], k = -2
/// 2. Output: [12,5,6,13]
/// Explanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that 
/// the numbers wrap around again. If k is negative, the sum is of the 
/// previous numbers.
/// Constraints:
/// 1. n == code.length
/// 2. 1 <= n <= 100
/// 3. 1 <= code[i] <= 100
/// 4. -(n - 1) <= k <= n - 1
/// </summary>
vector<int> LeetCodeArray::decrypt(vector<int>& code, int k)
{
    int n = code.size();
    vector<int> sum(2 * n);
    for (int i = 0; i < 2 * n; i++)
    {
        if (i == 0) sum[i] = code[i];
        else sum[i] = sum[i - 1] + code[i % n];
    }
    vector<int> result(n);
    for (int i = 0; i < n; i++)
    {
        if (k == 0) result[i] = 0;
        if (k > 0) result[i] = sum[i + k] - sum[i];
        else result[i] = sum[i + n - 1] - sum[i + n + k - 1];
    }
    return result;
}

/// <summary>
/// Leet code #1656. Design an Ordered Stream
/// 
/// Easy
///
/// Given two string arrays word1 and word2, return true if the two arrays 
/// represent the same string, and false otherwise.
///
/// A string is represented by an array if the array elements concatenated 
/// in order forms the string.
///
/// Example 1:
/// Input: word1 = ["ab", "c"], word2 = ["a", "bc"]
/// Output: true
/// Explanation:
/// word1 represents string "ab" + "c" -> "abc"
/// word2 represents string "a" + "bc" -> "abc"
/// The strings are the same, so return true.
///
/// Example 2:
/// Input: word1 = ["a", "cb"], word2 = ["ab", "c"]
/// Output: false
///
/// Example 3:
/// Input: word1  = ["abc", "d", "defg"], word2 = ["abcddefg"]
/// Output: true
///
/// Constraints:
/// 1. 1 <= word1.length, word2.length <= 10^3
/// 2. 1 <= word1[i].length, word2[i].length <= 10^3
/// 3. 1 <= sum(word1[i].length), sum(word2[i].length) <= 10^3
/// 4. word1[i] and word2[i] consist of lowercase letters.
/// </summary>
bool LeetCodeArray::arrayStringsAreEqual(vector<string>& word1, vector<string>& word2)
{
    size_t r_i = 0, c_i = 0;
    size_t r_j = 0, c_j = 0;

    while (r_i < word1.size() && r_j < word2.size())
    {
        if (word1[r_i][c_i] != word2[r_j][c_j])
        {
            return false;
        }
        c_i++;
        c_j++;
        if (c_i == word1[r_i].size())
        {
            r_i++;
            c_i = 0;
        }
        if (c_j == word2[r_j].size())
        {
            r_j++;
            c_j = 0;
        }
    }
    if (r_i < word1.size() || r_j < word2.size())
    {
        return false;
    }
    else
    {
        return true;
    }
}

/// <summary>
/// Leet code #1658. Minimum Operations to Reduce X to Zero
/// 
/// Medium
///
/// You are given an integer array nums and an integer x. In one operation, 
/// you can either remove the leftmost or the rightmost element from the 
/// array nums and subtract its value from x. Note that this modifies the 
/// array for future operations.
///
/// Return the minimum number of operations to reduce x to exactly 0 if 
/// it's possible, otherwise, return -1.
///
/// Example 1:
/// Input: nums = [1,1,4,2,3], x = 5
/// Output: 2
/// Explanation: The optimal solution is to remove the last two elements to 
/// reduce x to zero.
///
/// Example 2:
/// Input: nums = [5,6,7,8,9], x = 4
/// Output: -1
///
/// Example 3:
/// Input: nums = [3,2,20,1,1,3], x = 10
/// Output: 5
/// Explanation: The optimal solution is to remove the last three elements 
/// and the first two elements (5 operations in total) to reduce x to zero.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^4
/// 3. 1 <= x <= 10^9
/// </summary>
int LeetCodeArray::minOperations(vector<int>& nums, int x)
{
    int result = INT_MAX;
    int sum = 0;
    int left = 0;
    for (left = 0; left < (int)nums.size(); left++)
    {
        sum += nums[left];
        if (sum == x) result = min(result, left + 1);
        if (sum >= x) break;
    }
    if (sum < x) return -1;

    int right = nums.size();
    while (left >= 0 || sum <= x)
    {
        if (left >= 0 && sum > x)
        {
            sum -= nums[left];
            left--;
        }
        else if (right > 0 && sum < x)
        {
            right--;
            sum += nums[right];
        }
        else
        {
            result = min(result, left + 1 + (int)nums.size() - right);
            if (left < 0) break;
            sum -= nums[left];
            left--;
        }
    }
    if (result == INT_MAX) result = -1;
    return result;
}

/// <summary>
/// Leet code #1664. Ways to Make a Fair Array
/// 
/// Medium
///
/// You are given an integer array nums. You can choose exactly one index 
/// (0-indexed) and remove the element. Notice that the index of the 
/// elements may change after the removal.
///
/// For example, if nums = [6,1,7,4,1]:
///
/// Choosing to remove index 1 results in nums = [6,7,4,1].
/// Choosing to remove index 2 results in nums = [6,1,4,1].
/// Choosing to remove index 4 results in nums = [6,1,7,4].
/// An array is fair if the sum of the odd-indexed values equals the sum 
/// of the even-indexed values.
///
/// Return the number of indices that you could choose such that after 
/// the removal, nums is fair.
///
/// Example 1:
/// Input: nums = [2,1,6,4]
/// Output: 1
/// Explanation:
/// Remove index 0: [1,6,4] -> Even sum: 1 + 4 = 5. Odd sum: 6. Not fair.
/// Remove index 1: [2,6,4] -> Even sum: 2 + 4 = 6. Odd sum: 6. Fair.
/// Remove index 2: [2,1,4] -> Even sum: 2 + 4 = 6. Odd sum: 1. Not fair.
/// Remove index 3: [2,1,6] -> Even sum: 2 + 6 = 8. Odd sum: 1. Not fair.
/// There is 1 index that you can remove to make nums fair.
///
/// Example 2:
/// Input: nums = [1,1,1]
/// Output: 3
/// Explanation: You can remove any index and the remaining array is fair.
///
/// Example 3:
/// Input: nums = [1,2,3]
/// Output: 0
/// Explanation: You cannot make a fair array after removing any index.
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^4
/// </summary>
int LeetCodeArray::waysToMakeFair(vector<int>& nums)
{
    int even = 0;
    int odd = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (i % 2 == 0) even += nums[i];
        else odd += nums[i];
    }
    int result = 0;
    int e = 0;
    int o = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (i % 2 == 0)
        {
            if (odd - o + e == even - e + o - nums[i]) result++;
            e += nums[i];
        }
        else
        {
            if (odd - o + e - nums[i] == even - e + o) result++;
            o += nums[i];
        }
    }
    return result;
}

/// <summary>
/// Leet code #1672. Richest Customer Wealth
/// 
/// Easy
/// 
/// You are given an m x n integer grid accounts where accounts[i][j] 
/// is the amount of money the ith customer has in the jth bank. Return 
/// the wealth that the richest customer has.
///
/// A customer's wealth is the amount of money they have in all their 
/// bank accounts. The richest customer is the customer that has the 
/// maximum wealth.
/// 
/// Example 1:
///
/// Input: accounts = [[1,2,3],[3,2,1]]
/// Output: 6
/// Explanation:
/// 1st customer has wealth = 1 + 2 + 3 = 6
/// 2nd customer has wealth = 3 + 2 + 1 = 6
/// Both customers are considered the richest with a wealth of 6 each, 
/// so return 6.
///
/// Example 2:
/// Input: accounts = [[1,5],[7,3],[3,5]]
/// Output: 10
/// Explanation: 
/// 1st customer has wealth = 6
/// 2nd customer has wealth = 10 
/// 3rd customer has wealth = 8
/// The 2nd customer is the richest with a wealth of 10.
///
/// Example 3:
/// Input: accounts = [[2,8,7],[7,1,3],[1,9,5]]
/// Output: 17
/// Constraints:
/// 1. m == accounts.length
/// 2. n == accounts[i].length
/// 3. 1 <= m, n <= 50
/// 4. 1 <= accounts[i][j] <= 100
/// </summary>
int LeetCodeArray::maximumWealth(vector<vector<int>>& accounts)
{
    int result = 0;
    for (size_t i = 0; i < accounts.size(); i++)
    {
        int sum = 0;
        for (size_t j = 0; j < accounts[i].size(); j++)
        {
            sum += accounts[i][j];
        }
        result = max(result, sum);
    }
    return result;
}

/// <summary>
/// Leet code #1673. Find the Most Competitive Subsequence
/// 
/// Medium
/// 
/// Given an integer array nums and a positive integer k, return the most 
/// competitive subsequence of nums of size k.
///
/// An array's subsequence is a resulting sequence obtained by erasing some 
/// (possibly zero) elements from the array.
///
/// We define that a subsequence a is more competitive than a subsequence b 
/// (of the same length) if in the first position where a and b differ, 
/// subsequence a has a number less than the corresponding number in b. For 
/// example, [1,3,4] is more competitive than [1,3,5] because the first 
/// position they differ is at the final number, and 4 is less than 5.
///
/// Example 1:
/// Input: nums = [3,5,2,6], k = 2
/// Output: [2,6]
/// Explanation: Among the set of every possible subsequence: {[3,5], 
/// [3,2], [3,6], [5,2], [5,6], [2,6]}, [2,6] is the most competitive.
///
/// Example 2:
/// Input: nums = [2,4,3,3,5,4,9,6], k = 4
/// Output: [2,3,3,4]
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 10^9
/// 3. 1 <= k <= nums.length
/// </summary>
vector<int> LeetCodeArray::mostCompetitive(vector<int>& nums, int k)
{
    vector<int> result;
    for (size_t i = 0; i < nums.size(); i++)
    {
        while (!result.empty() && nums[i] < result.back() &&
              (int)(nums.size() - i +result.size()) > k)
        {
            result.pop_back();
        }
        if ((int)result.size() < k)
        {
            result.push_back(nums[i]);
        }
    }
    return result;
}

/// <summary>
/// Leet code #1671. Minimum Number of Removals to Make Mountain Array
/// 
/// Hard
/// 
/// You may recall that an array arr is a mountain array if and only if:
///
/// arr.length >= 3
/// There exists some index i (0-indexed) with 0 < i < arr.length - 1 such 
/// that:
/// arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
/// arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
/// Given an integer array nums, return the minimum number of elements to 
/// remove to make nums a mountain array.
/// 
/// Example 1: 
/// Input: nums = [1,3,1]
/// Output: 0
/// Explanation: The array itself is a mountain array so we do not need to 
/// remove any elements.
///
/// Example 2:
/// Input: nums = [2,1,1,5,6,2,3,1]
/// Output: 3
/// Explanation: One solution is to remove the elements at indices 0, 1, 
/// and 5, making the array nums = [1,5,6,3,1].
/// Example 3:
/// Input: nums = [4,3,2,1,1,2,3,1]
/// Output: 4
///
/// Example 4:
/// Input: nums = [1,2,3,4,4,3,2,1]
/// Output: 1
/// Constraints:
/// 1. 3 <= nums.length <= 1000
/// 2. 1 <= nums[i] <= 10^9
/// 3. It is guaranteed that you can make a mountain array out of nums.
/// </summary>
int LeetCodeArray::minimumMountainRemovals(vector<int>& nums)
{
    vector<int> left(nums.size());
    vector<int> right(nums.size());
    int prev_max = 0;
    vector<int> dp;
    for (size_t i = 0; i < nums.size(); i++)
    {
        int index = lower_bound(dp.begin(), dp.end(), nums[i]) - dp.begin();
        if (index == dp.size()) dp.push_back(nums[i]);
        else dp[index] = nums[i];
        left[i] = index;
    }
    dp.clear();
    for (int i = nums.size() - 1; i >= 0; i--)
    {
        int index = lower_bound(dp.begin(), dp.end(), nums[i]) - dp.begin();
        if (index == dp.size()) dp.push_back(nums[i]);
        else dp[index] = nums[i];
        right[i] = index;
    }
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (left[i] > 0 && right[i] > 0)
        {
            result = max(result, left[i] + right[i] + 1);
        }
    }
    return nums.size() - result;
}

/// <summary>
/// Leet code #1691. Maximum Height by Stacking Cuboids
/// 
/// Hard
/// 
/// Given n cuboids where the dimensions of the ith cuboid is cuboids[i] = 
/// [widthi, lengthi, heighti] (0-indexed). Choose a subset of cuboids and 
/// place them on each other.
///
/// You can place cuboid i on cuboid j if widthi <= widthj and lengthi <= 
/// lengthj and heighti <= heightj. You can rearrange any cuboid's dimensions 
/// by rotating it to put it on another cuboid.
///
/// Return the maximum height of the stacked cuboids.
/// 
/// Example 1:
/// Input: cuboids = [[50,45,20],[95,37,53],[45,23,12]]
/// Output: 190
/// Explanation:
/// Cuboid 1 is placed on the bottom with the 53x37 side facing down with 
/// height 95.
/// Cuboid 0 is placed next with the 45x20 side facing down with height 50.
/// Cuboid 2 is placed next with the 23x12 side facing down with height 45.
/// The total height is 95 + 50 + 45 = 190.
///
/// Example 2:
/// Input: cuboids = [[38,25,45],[76,35,3]]
/// Output: 76
/// Explanation:
/// You can't place any of the cuboids on the other.
/// We choose cuboid 1 and rotate it so that the 35x3 side is facing down 
/// and its height is 76.
///
/// Example 3:
/// Input: cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],
/// [17,7,11],[17,11,7]]
/// Output: 102
/// Explanation:
/// After rearranging the cuboids, you can see that all cuboids have the 
/// same dimension.
/// You can place the 11x7 side down on all cuboids so their heights are 17.
/// The maximum height of stacked cuboids is 6 * 17 = 102.
///
/// Constraints:
/// 1. n == cuboids.length
/// 2. 1 <= n <= 100
/// 3. 1 <= widthi, lengthi, heighti <= 100
/// </summary>
int LeetCodeArray::maxHeight(vector<vector<int>>& cuboids)
{
    for (size_t i = 0; i < cuboids.size(); i++)
    {
        sort(cuboids[i].begin(), cuboids[i].end());
    }
    sort(cuboids.begin(), cuboids.end());
    vector<int> dp(cuboids.size());
    int result = 0;
    for (size_t i = 0; i < cuboids.size(); i++)
    {
        for (size_t j = 0; j < i; j++)
        {
            if (cuboids[i][0] >= cuboids[j][0] &&
                cuboids[i][1] >= cuboids[j][1] &&
                cuboids[i][2] >= cuboids[j][2])
            {
                dp[i] = max(dp[i], dp[j]);
            }
        }
        dp[i] += cuboids[i][2];
        result = max(result, dp[i]);
    }
    return result;
}

/// <summary>
/// Leet code #1685. Sum of Absolute Differences in a Sorted Array
/// 
/// Medium
/// 
/// You are given an integer array nums sorted in non-decreasing order.
///
/// Build and return an integer array result with the same length as nums 
/// such that result[i] is equal to the summation of absolute differences 
/// between nums[i] and all the other elements in the array.
///
/// In other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 
/// 0 <= j < nums.length and j != i (0-indexed).
/// 
/// Example 1:
///
/// Input: nums = [2,3,5]
/// Output: [4,3,5]
/// Explanation: Assuming the arrays are 0-indexed, then
/// result[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4,
/// result[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3,
/// result[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5.
///
/// Example 2:
/// Input: nums = [1,4,6,8,10]
/// Output: [24,15,13,15,21]
/// Constraints:
/// 1. 2 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= nums[i + 1] <= 10^4
/// </summary>
vector<int> LeetCodeArray::getSumAbsoluteDifferences(vector<int>& nums)
{
    vector<int> result(nums.size());
    int left_count = 0;
    int right_count = 0;
    int left_sum = 0;
    int right_sum = 0;
    for (size_t i = 1; i < nums.size(); i++)
    {
        left_count++;
        left_sum += left_count * (nums[i] - nums[i - 1]);
    }
    result[nums.size() - 1] = left_sum + right_sum;

    for (int i = (int)nums.size() - 2; i >= 0; i--)
    {
        left_sum -= left_count * (nums[i + 1] - nums[i]);
        left_count--;
        right_count++;
        right_sum += right_count * (nums[i + 1] - nums[i]);
        result[i] = left_sum + right_sum;
    }
    return result;
}

/// <summary>
/// Leet code #1695. Maximum Erasure Value
/// 
/// Medium
/// 
/// You are given an array of positive integers nums and want to erase a 
/// subarray containing unique elements. The score you get by erasing 
/// the subarray is equal to the sum of its elements.
///
/// Return the maximum score you can get by erasing exactly one subarray.
///
/// An array b is called to be a subarray of a if it forms a contiguous 
/// subsequence of a, that is, if it is equal to a[l],a[l+1],...,a[r] 
/// for some (l,r).
/// 
/// Example 1:
/// Input: nums = [4,2,4,5,6]
/// Output: 17
/// Explanation: The optimal subarray here is [2,4,5,6].
///
/// Example 2:
/// Input: nums = [5,2,1,2,5,2,1,2,5]
/// Output: 8
/// Explanation: The optimal subarray here is [5,2,1] or [1,2,5].
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^4
/// </summary>
int LeetCodeArray::maximumUniqueSubarray(vector<int>& nums)
{
    vector<int> num_map(10001);
    int prev = -1;
    int sum = 0;
    int result = INT_MIN;
    for (size_t i = 0; i < nums.size(); i++)
    {
        num_map[nums[i]]++;
        sum += nums[i];
        while (num_map[nums[i]] == 2)           
        {
            prev++;
            sum -= nums[prev];
            num_map[nums[prev]]--;
        }
        result = max(result, sum);
    }
    return result;
}

/// <summary>
/// Leet code #1700. Number of Students Unable to Eat Lunch
/// 
/// Easy
/// 
/// The school cafeteria offers circular and square sandwiches at lunch 
/// break, referred to by numbers 0 and 1 respectively. All students 
/// stand in a queue. Each student either prefers square or circular 
/// sandwiches.
///
/// The number of sandwiches in the cafeteria is equal to the number of 
/// students. The sandwiches are placed in a stack. At each step:
///
/// If the student at the front of the queue prefers the sandwich on the 
/// top of the stack, they will take it and leave the queue. 
/// Otherwise, they will leave it and go to the queue's end.
/// This continues until none of the queue students want to take the top 
/// sandwich and are thus unable to eat. 
///
/// You are given two integer arrays students and sandwiches where 
/// sandwiches[i] is the type of the ith sandwich in the stack (i = 0 is 
/// the top of the stack) and students[j] is the preference of the jth 
/// student in the initial queue (j = 0 is the front of the queue). 
/// Return the number of students that are unable to eat.
///
/// Example 1:
/// Input: students = [1,1,0,0], sandwiches = [0,1,0,1]
/// Output: 0 
/// Explanation:
/// - Front student leaves the top sandwich and returns to the end of the 
///   line making students = [1,0,0,1].
/// - Front student leaves the top sandwich and returns to the end of the 
///   line making students = [0,0,1,1].
/// - Front student takes the top sandwich and leaves the line making 
///   students = [0,1,1] and sandwiches = [1,0,1].
/// - Front student leaves the top sandwich and returns to the end of 
///   the line making students = [1,1,0].
/// - Front student takes the top sandwich and leaves the line making 
///   students = [1,0] and sandwiches = [0,1].
/// - Front student leaves the top sandwich and returns to the end of the 
///   line making students = [0,1].
/// - Front student takes the top sandwich and leaves the line making 
///   students = [1] and sandwiches = [1].
/// - Front student takes the top sandwich and leaves the line making 
///   students = [] and sandwiches = [].
/// Hence all students are able to eat.
///
/// Example 2:
/// Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
/// Output: 3
///
/// Constraints:
/// 1. 1 <= students.length, sandwiches.length <= 100
/// 2. students.length == sandwiches.length
/// 3. sandwiches[i] is 0 or 1.
/// 4. students[i] is 0 or 1.
/// </summary>
int LeetCodeArray::countStudents(vector<int>& students, vector<int>& sandwiches)
{
    int one = 0;
    int zero = 0;
    for (size_t i = 0; i < students.size(); i++)
    {
        if (students[i] == 1) one++;
        else zero++;
    }
    int result = students.size();
    for (size_t i = 0; i < sandwiches.size(); i++)
    {
        if (sandwiches[i] == 1) one--;
        else zero--;
        if (one < 0 || zero < 0)
        {
            break;
        }
        result--;
    }
    return result;
}

/// <summary>
/// Leet code #1701. Average Waiting Time
/// 
/// Medium
/// 
/// There is a restaurant with a single chef. You are given an array 
/// customers, where customers[i] = [arrivali, timei]:
///
/// arrivali is the arrival time of the ith customer. The arrival times 
/// are sorted in non-decreasing order.
/// timei is the time needed to prepare the order of the ith customer.
/// When a customer arrives, he gives the chef his order, and the chef 
/// starts preparing it once he is idle. The customer waits till the chef 
/// finishes preparing his order. The chef does not prepare food for more 
/// than one customer at a time. The chef prepares food for customers in 
/// the order they were given in the input.
///
/// Return the average waiting time of all customers. Solutions within 
/// 10-5 from the actual answer are considered accepted.
///
/// Example 1:
/// Input: customers = [[1,2],[2,5],[4,3]]
/// Output: 5.00000
/// Explanation:
/// 1) The first customer arrives at time 1, the chef takes his order and 
///   starts preparing it immediately at time 1, and finishes at time 3, 
///   so the waiting time of the first customer is 3 - 1 = 2.
/// 2) The second customer arrives at time 2, the chef takes his order and 
///    starts preparing it at time 3, and finishes at time 8, so the 
///    waiting time of the second customer is 8 - 2 = 6.
/// 3) The third customer arrives at time 4, the chef takes his order and 
///    starts preparing it at time 8, and finishes at time 11, so the 
///    waiting time of the third customer is 11 - 4 = 7.
/// So the average waiting time = (2 + 6 + 7) / 3 = 5.
///
/// Example 2:
/// Input: customers = [[5,2],[5,4],[10,3],[20,1]]
/// Output: 3.25000
/// Explanation:
/// 1) The first customer arrives at time 5, the chef takes his order and 
///    starts preparing it immediately at time 5, and finishes at time 7, 
///    so the waiting time of the first customer is 7 - 5 = 2.
/// 2) The second customer arrives at time 5, the chef takes his order and 
///    starts preparing it at time 7, and finishes at time 11, so the 
///    waiting time of the second customer is 11 - 5 = 6.
/// 3) The third customer arrives at time 10, the chef takes his order and 
///    starts preparing it at time 11, and finishes at time 14, so the 
///    waiting time of the third customer is 14 - 10 = 4.
/// 4) The fourth customer arrives at time 20, the chef takes his order 
///    and starts preparing it immediately at time 20, and finishes at 
///    time 21, so the waiting time of the fourth customer is 21 - 20 = 1.
/// So the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25.
/// 
/// Constraints:
/// 1. 1 <= customers.length <= 105
/// 2. 1 <= arrivali, timei <= 104
/// 3. arrivali <= arrivali+1
/// </summary>
double LeetCodeArray::averageWaitingTime(vector<vector<int>>& customers)
{
    double accumulate = 0;
    int wait_time = 0;
    for (size_t i = 0; i < customers.size(); i++)
    {
        if (i > 0)
        {
            wait_time -= customers[i][0] - customers[i - 1][0];
            if (wait_time < 0) wait_time = 0;
        }
        wait_time += customers[i][1];
        accumulate += wait_time;
    }
    return accumulate / (double)customers.size();
}

/// <summary>
/// Leet code #1703. Minimum Adjacent Swaps for K Consecutive Ones
/// 
/// Hard
/// 
/// You are given an integer array, nums, and an integer k. nums comprises 
/// of only 0's and 1's. In one move, you can choose two adjacent indices 
/// and swap their values.
///
/// Return the minimum number of moves required so that nums has k 
/// consecutive 1's.
///
/// Example 1:
/// Input: nums = [1,0,0,1,0,1], k = 2
/// Output: 1
/// Explanation: In 1 move, nums could be [1,0,0,0,1,1] and have 
/// 2 consecutive 1's.
///
/// Example 2:
/// Input: nums = [1,0,0,0,0,0,1,1], k = 3
/// Output: 5
/// Explanation: In 5 moves, the leftmost 1 can be shifted right until 
/// nums = [0,0,0,0,0,1,1,1].
///
/// Example 3:
/// Input: nums = [1,1,0,1], k = 2
/// Output: 0
/// Explanation: nums already has 2 consecutive 1's.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. nums[i] is 0 or 1.
/// 3. 1 <= k <= sum(nums)
/// </summary>
int LeetCodeArray::minMoves(vector<int>& nums, int k)
{
    long long sum = 0;
    long long last_sum = 0;
    int result = INT_MAX;
    deque<long long> dp;
    for (size_t i = 0; i < nums.size(); i++)
    {
        // skip all 0
        if (nums[i] == 0) continue;
        // accumulate position sum
        last_sum += i;
        dp.push_back(last_sum);
        if ((int)dp.size() > k)
        {
            sum = dp.front();
            dp.pop_front();
        }
        if (dp.size() == k)
        {
            int median = k / 2;
            long long move = 0;
            if (median > 0)
            {
                long long curr = dp[median] - dp[median - 1];
                long long post_move = dp.back() - dp[median] - ((long long)k - 1 - (long long)median) * curr;
                long long prev_move = median * curr - (dp[median - 1] - sum);
                move = post_move + prev_move;
                int adjust = (1 + median) * median;
                if (k % 2 == 0)
                {
                    adjust -= median;
                }
                move -= adjust;
            }
            result = min(result, (int)move);
        }
    }
    return result;
}

/// <summary>
/// Leet code #1706. Where Will the Ball Fall
/// 
/// Medium
/// 
/// You have a 2-D grid of size m x n representing a box, and you have n 
/// balls. The box is open on the top and bottom sides.
///
/// Each cell in the box has a diagonal board spanning two corners of the 
/// cell that can redirect a ball to the right or to the left.
///
/// A board that redirects the ball to the right spans the top-left corner 
/// to the bottom-right corner and is represented in the grid as 1.
/// A board that redirects the ball to the left spans the top-right corner 
/// to the bottom-left corner and is represented in the grid as -1.
/// We drop one ball at the top of each column of the box. Each ball can 
/// get stuck in the box or fall out of the bottom. A ball gets stuck if 
/// it hits a "V" shaped pattern between two boards or if a board redirects 
/// the ball into either wall of the box.
///
/// Return an array answer of size n where answer[i] is the column that the 
/// ball falls out of at the bottom after dropping the ball from the ith 
/// column at the top, or -1 if the ball gets stuck in the box.
///
/// Example 1:
/// Input: grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],
/// [-1,-1,-1,-1,-1]]
/// Output: [1,-1,-1,-1,-1]
/// Explanation: This example is shown in the photo.
/// Ball b0 is dropped at column 0 and falls out of the box at column 1.
/// Ball b1 is dropped at column 1 and will get stuck in the box between 
/// column 2 and 3 and row 1.
/// Ball b2 is dropped at column 2 and will get stuck on the box between 
/// column 2 and 3 and row 0.
/// Ball b3 is dropped at column 3 and will get stuck on the box between 
/// column 2 and 3 and row 0.
/// Ball b4 is dropped at column 4 and will get stuck on the box between 
/// column 2 and 3 and row 1.
///
/// Example 2:
/// Input: grid = [[-1]]
/// Output: [-1]
/// Explanation: The ball gets stuck against the left wall.
///
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 1 <= m, n <= 100
/// 4. grid[i][j] is 1 or -1.
/// </summary>
vector<int> LeetCodeArray::findBall(vector<vector<int>>& grid)
{
    int m = grid.size();
    int n = grid[0].size();
    vector<int> result(n);
    for (int i = 0; i < n; i++) result[i] = i;
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (result[j] == -1) continue;
            int pos = result[j];
            if (pos > 0 && grid[i][pos - 1] == 1 && grid[i][pos] == -1) result[j] = -1;
            else if (pos < n - 1 && grid[i][pos] == 1 && grid[i][pos + 1] == -1) result[j] = -1;
            else if (pos == 0 && grid[i][pos] == -1) result[j] = -1;
            else if (pos == n - 1 && grid[i][pos] == 1) result[j] = -1;
            else
            {
                result[j] += grid[i][pos];
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code #1712. Ways to Split Array Into Three Subarrays
/// 
/// Medium
/// 
/// A split of an integer array is good if:
/// The array is split into three non-empty contiguous subarrays - named 
/// left, mid, right respectively from left to right.
/// The sum of the elements in left is less than or equal to the sum of 
/// the elements in mid, and the sum of the elements in mid is less than 
/// or equal to the sum of the elements in right.
/// Given nums, an array of non-negative integers, return the number of 
/// good ways to split nums. As the number may be too large, return it 
/// modulo 10^9 + 7.
///
/// Example 1:
/// Input: nums = [1,1,1]
/// Output: 1
/// Explanation: The only good way to split nums is [1] [1] [1].
///
/// Example 2:
/// Input: nums = [1,2,2,2,5,0]
/// Output: 3
/// Explanation: There are three good ways of splitting nums:
/// [1] [2] [2,2,5,0]
/// [1] [2,2] [2,5,0]
/// [1,2] [2,2] [5,0]
///
/// Example 3:
/// Input: nums = [3,2,1]
/// Output: 0
/// Explanation: There is no good way to split nums.
/// Constraints:
/// 1. 3 <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 10^4
/// </summary>
int LeetCodeArray::waysToSplit(vector<int>& nums)
{
    int M = 1000000007;
    int result = 0;
    int n = nums.size();
    vector<int> sums(n);
    int s = 0;
    for (int i = 0; i < n; i++)
    {
        s += nums[i];
        sums[i] = s;
    }
    int first = 0;
    int last = 0;
    for (int i = 0; i < n - 2; i++)
    {
        while ((first < n - 1) && (first <= i || sums[first] - sums[i] < sums[i]))
        {
            first++;
        }
        while ((last < n-1) && (last < first || sums[n - 1] - sums[last] >= sums[last] - sums[i]))
        {
            last++;
        }
        if (last > first) result = (result + last - first) % M;
    }
    return result;
}

/// <summary>
/// Leet code 1720. Decode XORed Array
/// 
/// Easy
/// 
/// There is a hidden integer array arr that consists of n non-negative 
/// integers.
///
/// It was encoded into another integer array encoded of length n - 1, 
/// such that encoded[i] = arr[i] XOR arr[i + 1]. For example, if 
/// arr = [1,0,2,1], then encoded = [1,2,3].
///
/// You are given the encoded array. You are also given an integer first, 
/// that is the first element of arr, i.e. arr[0].
/// 
/// Return the original array arr. It can be proved that the answer exists 
/// and is unique.
///
/// Example 1:
/// Input: encoded = [1,2,3], first = 1
/// Output: [1,0,2,1]
/// Explanation: If arr = [1,0,2,1], then first = 1 and encoded = 
/// [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]
///
/// Example 2:
/// Input: encoded = [6,2,7,3], first = 4
/// Output: [4,2,0,7,4]
///
/// Constraints:
/// 1. 2 <= n <= 10^4
/// 2. encoded.length == n - 1
/// 3. 0 <= encoded[i] <= 10^5
/// 4. 0 <= first <= 10^5
/// </summary>
vector<int> LeetCodeArray::decode(vector<int>& encoded, int first)
{
    vector<int> result(encoded.size() + 1);
    result[0] = first;

    for (size_t i = 0; i < encoded.size(); i++)
    {
        result[i + 1] = result[i] ^ encoded[i];
    }
    return result;
}

/// <summary>
/// Leet code 1713. Minimum Operations to Make a Subsequence
/// 
/// Hard
/// 
/// You are given an array target that consists of distinct integers and 
/// another integer array arr that can have duplicates.
///
/// In one operation, you can insert any integer at any position in arr. 
/// For example, if arr = [1,4,1,2], you can add 3 in the middle and make 
/// it [1,4,3,1,2]. Note that you can insert the integer at the very 
/// beginning or end of the array.
///
/// Return the minimum number of operations needed to make target a 
/// subsequence of arr.
/// 
/// A subsequence of an array is a new array generated from the original 
/// array by deleting some elements (possibly none) without changing the 
/// remaining elements' relative order. For example, [2,7,4] is a 
//// subsequence of [4,2,3,7,2,1,4] (the underlined elements), while 
/// [2,4,2] is not.
///
/// Example 1:
/// Input: target = [5,1,3], arr = [9,4,2,3,4]
/// Output: 2
/// Explanation: You can add 5 and 1 in such a way that makes 
/// arr = [5,9,4,1,2,3,4], then target will be a subsequence of arr.
///
/// Example 2:
/// Input: target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]
/// Output: 3
/// 
/// Constraints:
/// 1. 1 <= target.length, arr.length <= 10^5
/// 2. 1 <= target[i], arr[i] <= 10^9
/// 3. target contains no duplicates.
/// </summary>
int LeetCodeArray::minOperations(vector<int>& target, vector<int>& arr)
{
    unordered_map<int, vector<int>> pos_map;
    for (size_t i = 0; i < arr.size(); i++)
    {
        pos_map[arr[i]].push_back(i);
    }
    set<int> seq;
    for (size_t i = 0; i < target.size(); i++)
    {
        map<int, int> new_map;
        for (size_t j = 0; j < pos_map[target[i]].size(); j++)
        {
            auto itr = seq.lower_bound(pos_map[target[i]][j]);
            int key = 0;
            if (itr == seq.end()) key = INT_MAX;
            else key = *itr;
            if (new_map.count(key) == 0) new_map[key] = pos_map[target[i]][j];
        }
        for (auto& itr : new_map)
        {
            if (itr.first == INT_MAX) seq.insert(itr.second);
            else
            {
                seq.erase(itr.first);
                seq.insert(itr.second);
            }
        }
    }
    return target.size() - seq.size();
}

/// <summary>
/// Leet code 1725. Number Of Rectangles That Can Form The Largest Square
/// 
/// Easy
/// 
/// You are given an array rectangles where rectangles[i] = [li, wi] 
/// represents the ith rectangle of length li and width wi.
///
/// You can cut the ith rectangle to form a square with a side length 
/// of k if both k <= li and k <= wi. For example, if you have a 
/// rectangle [4,6], you can cut it to get a square with a side length 
/// of at most 4.
///
/// Let maxLen be the side length of the largest square you can obtain 
/// from any of the given rectangles.
///
/// Return the number of rectangles that can make a square with a side 
/// length of maxLen.
///
/// Example 1:
/// Input: rectangles = [[5,8],[3,9],[5,12],[16,5]]
/// Output: 3
/// Explanation: The largest squares you can get from each rectangle 
/// are of lengths [5,3,5,5].
/// The largest possible square is of length 5, and you can get it 
/// out of 3 rectangles.
///
/// Example 2:
/// Input: rectangles = [[2,3],[3,7],[4,3],[3,7]]
/// Output: 3
///
/// Constraints:
/// 1. 1 <= rectangles.length <= 1000
/// 2. rectangles[i].length == 2
/// 3. 1 <= li, wi <= 109
/// 4. li != wi
/// </summary>
int LeetCodeArray::countGoodRectangles(vector<vector<int>>& rectangles)
{
    int result = 0;
    int max_length = 0;
    for (size_t i = 0; i < rectangles.size(); i++)
    {
        int length = min(rectangles[i][0], rectangles[i][1]);
        if (length > max_length)
        {
            max_length = length;
            result = 1;
        }
        else if (length == max_length)
        {
            result++;
        }
    }
    return result;
}

/// <summary>
/// Leet code 1726. Tuple with Same Product
/// 
/// Medium
/// 
/// Given an array nums of distinct positive integers, return the number 
/// of tuples (a, b, c, d) such that a * b = c * d where a, b, c, and d 
/// are elements of nums, and a != b != c != d.
/// Example 1:
/// Input: nums = [2,3,4,6]
/// Output: 8
/// Explanation: There are 8 valid tuples:
/// (2,6,3,4) , (2,6,4,3) , (6,2,3,4) , (6,2,4,3)
/// (3,4,2,6) , (4,3,2,6) , (3,4,6,2) , (4,3,6,2)
///
/// Example 2:
/// Input: nums = [1,2,4,5,10]
/// Output: 16
/// Explanation: There are 16 valids tuples:
/// (1,10,2,5) , (1,10,5,2) , (10,1,2,5) , (10,1,5,2)
/// (2,5,1,10) , (2,5,10,1) , (5,2,1,10) , (5,2,10,1)
/// (2,10,4,5) , (2,10,5,4) , (10,2,4,5) , (10,2,4,5)
/// (4,5,2,10) , (4,5,10,2) , (5,4,2,10) , (5,4,10,2)
///
/// Example 3:
/// Input: nums = [2,3,4,6,8,12]
/// Output: 40
///
/// Example 4:
/// Input: nums = [2,3,5,7]
/// Output: 0
///
/// Constraints:
/// 1. 1 <= nums.length <= 1000
/// 2. 1 <= nums[i] <= 10^4
/// 3. All elements in nums are distinct.
/// </summary>
int LeetCodeArray::tupleSameProduct(vector<int>& nums)
{
    unordered_map<int, int> products;
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        for (size_t j = i + 1; j < nums.size(); j++)
        {
            int product = nums[i] * nums[j];

            if (products.count(product) > 0)
            {
                result += products[product];
            }
            products[product]++;
        }
    }
    return result * 8;
}

/// <summary>
/// Leet code 1727. Largest Submatrix With Rearrangements
/// 
/// Medium
/// 
/// You are given a binary matrix matrix of size m x n, and you are 
/// allowed to rearrange the columns of the matrix in any order.
///
/// Return the area of the largest submatrix within matrix where every 
/// element of the submatrix is 1 after reordering the columns optimally.
///
/// Example 1:
/// Input: matrix = [[0,0,1],[1,1,1],[1,0,1]]
/// Output: 4
/// Explanation: You can rearrange the columns as shown above.
/// The largest submatrix of 1s, in bold, has an area of 4.
///
/// Example 2:
/// Input: matrix = [[1,0,1,0,1]]
/// Output: 3
/// Explanation: You can rearrange the columns as shown above.
/// The largest submatrix of 1s, in bold, has an area of 3.
///
/// Example 3:
/// Input: matrix = [[1,1,0],[1,0,1]]
/// Output: 2
/// Explanation: Notice that you must rearrange entire columns, and there 
/// is no way to make a submatrix of 1s larger than an area of 2.
///
/// Example 4:
/// Input: matrix = [[0,0],[0,0]]
/// Output: 0
/// Explanation: As there are no 1s, no submatrix of 1s can be formed 
/// and the area is 0.
/// 
/// Constraints:
/// 1. m == matrix.length
/// 2. n == matrix[i].length
/// 3. 1 <= m * n <= 10^5
/// 4. matrix[i][j] is 0 or 1.
/// </summary>
int LeetCodeArray::largestSubmatrix(vector<vector<int>>& matrix)
{
    vector<int> row(matrix[0].size());
    int result = 0;
    for (size_t i = 0; i < matrix.size(); i++)
    {
        for (size_t j = 0; j < matrix[i].size(); j++)
        {
            if (matrix[i][j] == 1) row[j]++;
            else row[j] = 0;
        }
        vector<int> sorted_row = row;
        sort(sorted_row.begin(), sorted_row.end(), greater<int>());
        for (size_t j = 0; j < sorted_row.size(); j++)
        {
            result = max(result, sorted_row[j] * ((int)j + 1));
        }
    }
    return result;
}

/// <summary>
/// Leet code 1708. Largest Subarray Length K
/// 
/// Easy
/// 
/// An array A is larger than some array B if for the first index i 
/// where A[i] != B[i], A[i] > B[i].
///
/// For example, consider 0-indexing:
///
/// [1,3,2,4] > [1,2,2,4], since at index 1, 3 > 2.
/// [1,4,4,4] < [2,1,1,1], since at index 0, 1 < 2.
/// A subarray is a contiguous subsequence of the array.
///
/// Given an integer array nums of distinct integers, return the largest 
/// subarray of nums of length k.
/// 
/// Example 1:
/// Input: nums = [1,4,5,2,3], k = 3
/// Output: [5,2,3]
/// Explanation: The subarrays of size 3 are: [1,4,5], [4,5,2], 
/// and [5,2,3].
/// Of these, [5,2,3] is the largest.
///
/// Example 2: 
/// Input: nums = [1,4,5,2,3], k = 4
/// Output: [4,5,2,3]
/// Explanation: The subarrays of size 4 are: [1,4,5,2], and [4,5,2,3].
/// Of these, [4,5,2,3] is the largest.
///
/// Example 3:
/// Input: nums = [1,4,5,2,3], k = 1
/// Output: [5]
/// Constraints:
/// 1. 1 <= k <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^9
/// 3. All the integers of nums are unique.
/// Follow up: What if the integers in nums are not distinct?
/// </summary>
vector<int> LeetCodeArray::largestSubarray(vector<int>& nums, int k)
{
    vector<int> result(k);
    int n = nums.size();
    int s = 0; 
    for (int t = 1; t < n - (k - 1); t++)
    {
        if (nums[s] < nums[t])
        {
            s = t;
        }
    }
    for (int i = 0; i < k; i++)
    {
        result[i] = nums[s + i];
    }
    return result;
}

/// <summary>
/// Leet code 1732. Find the Highest Altitude
/// 
/// Easy
/// 
/// There is a biker going on a road trip. The road trip consists of 
/// n + 1 points at different altitudes. The biker starts his trip on 
/// point 0 with altitude equal 0.
///
/// You are given an integer array gain of length n where gain[i] is 
/// the net gain in altitude between points i and i + 1 for all 
/// (0 <= i < n). Return the highest altitude of a point.
/// 
/// Example 1:
/// Input: gain = [-5,1,5,0,-7]
/// Output: 1
/// Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.
///
/// Example 2:
/// Input: gain = [-4,-3,-2,-1,4,3,2]
/// Output: 0
/// Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. 
/// The highest is 0.
/// 
/// Constraints:
/// 1. n == gain.length
/// 2. 1 <= n <= 100
/// 3. -100 <= gain[i] <= 100
/// </summary>
int LeetCodeArray::largestAltitude(vector<int>& gain)
{
    int altitude = 0;
    int result = 0;
    for (size_t i = 0; i < gain.size(); i++)
    {
        altitude += gain[i];
        result = max(result, altitude);
    }
    return result;
}

/// <summary>
/// Leet code 1738. Find Kth Largest XOR Coordinate Value 
/// 
/// Medium
/// 
/// You are given a 2D matrix of size m x n, consisting of non-negative 
/// integers. You are also given an integer k.
///
/// The value of coordinate (a, b) of the matrix is the XOR of all 
/// matrix[i][j] where 0 <= i <= a < m and 0 <= j <= b < n (0-indexed).
///
/// Find the kth largest value (1-indexed) of all the coordinates of 
/// matrix.
/// 
/// Example 1:
/// Input: matrix = [[5,2],[1,6]], k = 1
/// Output: 7
/// Explanation: The value of coordinate (0,1) is 5 XOR 2 = 7, which is 
/// the largest value.
///
/// Example 2:
/// Input: matrix = [[5,2],[1,6]], k = 2
/// Output: 5
/// Explanation: The value of coordinate (0,0) is 5 = 5, which is the 2nd 
/// largest value.
///
/// Example 3:
/// Input: matrix = [[5,2],[1,6]], k = 3
/// Output: 4
/// Explanation: The value of coordinate (1,0) is 5 XOR 1 = 4, which is 
/// the 3rd largest value.
///
/// Example 4:
/// Input: matrix = [[5,2],[1,6]], k = 4
/// Output: 0
/// Explanation: The value of coordinate (1,1) is 5 XOR 2 XOR 1 XOR 6 = 0, 
/// which is the 4th largest value.
/// 
/// Constraints:
/// 1. m == matrix.length
/// 2. n == matrix[i].length
/// 3. 1 <= m, n <= 1000
/// 4. 0 <= matrix[i][j] <= 10^6
/// 5. 1 <= k <= m * n
/// </summary>
int LeetCodeArray::kthLargestValue(vector<vector<int>>& matrix, int k)
{
    vector<int> row(matrix[0].size());
    vector<int> sum(matrix[0].size());

    priority_queue<int> heap;
    for (size_t i = 0; i < matrix.size(); i++)
    {
        for (size_t j = 0; j < matrix[i].size(); j++)
        {
            row[j] = row[j] ^ matrix[i][j];
            if (j == 0)
            {
                sum[j] = row[j];
            }
            else
            {
                sum[j] = sum[j-1] ^ row[j];
            }
            heap.push(sum[j]);
        }
    }
    int result = 0;
    for (int i = 0; i < k; i++)
    {
        result = heap.top();
        heap.pop();
    }
    return result;
}

/// <summary>
/// Leet code 1744. Can You Eat Your Favorite Candy on Your Favorite Day?
/// 
/// Medium
/// 
/// You are given a (0-indexed) array of positive integers candiesCount 
/// where candiesCount[i] represents the number of candies of the ith type 
/// you have. You are also given a 2D array queries where queries[i] = 
/// [favoriteTypei, favoriteDayi, dailyCapi].
///
/// You play a game with the following rules:
///
/// You start eating candies on day 0.
/// You cannot eat any candy of type i unless you have eaten all candies 
/// of type i - 1.
/// You must eat at least one candy per day until you have eaten all the 
/// candies.
/// Construct a boolean array answer such that answer.length == 
/// queries.length and answer[i] is true if you can eat a candy of type 
/// favoriteTypei on day favoriteDayi without eating more than dailyCapi 
/// candies on any day, and false otherwise. Note that you can eat 
/// different types of candy on the same day, provided that you follow 
/// rule 2.
///
/// Return the constructed array answer.
///
/// Example 1:
/// Input: candiesCount = [7,4,5,3,8], 
/// queries = [[0,2,2],[4,2,4],[2,13,1000000000]]
/// Output: [true,false,true]
/// Explanation:
/// 1- If you eat 2 candies (type 0) on day 0 and 2 candies (type 0) on 
///    day 1, you will eat a candy of type 0 on day 2.
/// 2- You can eat at most 4 candies each day.
/// If you eat 4 candies every day, you will eat 4 candies (type 0) on 
/// day 0 and 4 candies (type 0 and type 1) on day 1.
/// On day 2, you can only eat 4 candies (type 1 and type 2), so you 
///  cannot eat a candy of type 4 on day 2.
/// 3- If you eat 1 candy each day, you will eat a candy of type 2 on 
/// day 13.
///
/// Example 2:
/// Input: candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],
/// [3,10,100],[4,100,30],[1,3,1]]
/// Output: [false,true,true,false,false]
/// 
/// Constraints:
/// 1. 1 <= candiesCount.length <= 10^5
/// 2. 1 <= candiesCount[i] <= 105
/// 3. 1 <= queries.length <= 105
/// 4. queries[i].length == 3
/// 5. 0 <= favoriteTypei < candiesCount.length
/// 6. 0 <= favoriteDayi <= 10^9
/// 7. 1 <= dailyCapi <= 10^9
/// </summary>
vector<bool> LeetCodeArray::canEat(vector<int>& candiesCount, vector<vector<int>>& queries)
{
    vector<long long> sum(candiesCount.size() + 1);
    for (size_t i = 0; i < candiesCount.size(); i++)
    {
        sum[i + 1] = sum[i] + candiesCount[i];
    }
    vector<bool> result;
    for (size_t i = 0; i < queries.size(); i++)
    {
        int type = queries[i][0];
        int day = queries[i][1];
        int cap = queries[i][2];
        if ((long long)day + 1 > sum[type + 1]) result.push_back(false);
        else if ((long long)cap * (long long)day + 1 <= sum[type]) result.push_back(false);
        else result.push_back(true);
    }
    return result;
}

/// <summary>
/// Leet code 1749. Maximum Absolute Sum of Any Subarray
/// 
/// Medium
/// 
/// You are given an integer array nums. The absolute sum of a subarray 
/// [numsl, numsl+1, ..., numsr-1, numsr] is abs(numsl + numsl+1 + ... + 
/// numsr-1 + numsr).
///
/// Return the maximum absolute sum of any (possibly empty) subarray of 
/// nums.
///
/// Note that abs(x) is defined as follows:
///
/// If x is a negative integer, then abs(x) = -x.
/// If x is a non-negative integer, then abs(x) = x.
///
/// Example 1:
/// Input: nums = [1,-3,2,3,-4]
/// Output: 5
/// Explanation: The subarray [2,3] has absolute sum = abs(2+3) = 
/// abs(5) = 5.
///
/// Example 2:
/// Input: nums = [2,-5,1,-4,3,-2]
/// Output: 8
/// Explanation: The subarray [-5,1,-4] has absolute sum = 
/// abs(-5+1-4) = abs(-8) = 8.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. -10^4 <= nums[i] <= 10^4
/// </summary>
int LeetCodeArray::maxAbsoluteSum(vector<int>& nums)
{
    int result = INT_MIN;
    int min_val = 0;
    int max_val = 0;
    set<int> pre_sum;
    pre_sum.insert(0);
    int sum = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        sum += nums[i];
        result = max(result, abs(sum - min_val));
        result = max(result, abs(sum - max_val));
        min_val = min(min_val, sum);
        max_val = max(max_val, sum);
    }
    return result;
}

/// <summary>
/// Leet code 1769. Minimum Number of Operations to Move All Balls to 
///                 Each Box
/// 
/// Medium
/// 
/// You have n boxes. You are given a binary string boxes of length n, 
/// where boxes[i] is '0' if the ith box is empty, and '1' if it contains 
/// one ball.
///
/// In one operation, you can move one ball from a box to an adjacent box. 
/// Box i is adjacent to box j if abs(i - j) == 1. Note that after doing 
/// so, there may be more than one ball in some boxes.
///
/// Return an array answer of size n, where answer[i] is the minimum number 
/// of operations needed to move all the balls to the ith box.
///
/// Each answer[i] is calculated considering the initial state of the boxes.
/// 
/// Example 1:
///
/// Input: boxes = "110"
/// Output: [1,1,3]
/// Explanation: The answer for each box is as follows:
/// 1) First box: you will have to move one ball from the second box to 
///    the first box in one operation.
/// 2) Second box: you will have to move one ball from the first box to 
///    the second box in one operation.
/// 3) Third box: you will have to move one ball from the first box to the 
///    third box in two operations, and move one ball from the second box 
///    to the third box in one operation.
///
/// Example 2:
/// Input: boxes = "001011"
/// Output: [11,8,5,4,3,4]
/// Constraints:
/// 1. n == boxes.length
/// 2. 1 <= n <= 2000
/// 3. boxes[i] is either '0' or '1'.
/// </summary>
vector<int> LeetCodeArray::minOperations(string boxes)
{
    int n = boxes.size();
    vector<int> sum(n);
    vector<int> dp(n);
    vector<int> result;
    for (int i = 1; i < n; i++)
    {
        if (boxes[i - 1] == '1') dp[i] = 1;
        dp[i] += dp[i - 1];
        sum[i] = sum[i - 1] + dp[i];
    }
    result = sum;
    sum = vector<int>(n);
    dp = vector<int>(n);
    for (int i = n-2; i >= 0; i--)
    {
        if (boxes[i + 1] == '1') dp[i] = 1;
        dp[i] += dp[i + 1];
        sum[i] = sum[i + 1] + dp[i];
        result[i] += sum[i];
    }
    return result;
}

/// <summary>
/// Leet code 1759. Count Number of Homogenous Substrings
/// 
/// Medium
/// 
/// Given a string s, return the number of homogenous substrings of s. 
/// Since the answer may be too large, return it modulo 10^9 + 7.
///
/// A string is homogenous if all the characters of the string are the 
/// same.
///
/// A substring is a contiguous sequence of characters within a string.
/// 
/// Example 1:
/// Input: s = "abbcccaa"
/// Output: 13
/// Explanation: The homogenous substrings are listed as below:
/// "a"   appears 3 times.
/// "aa"  appears 1 time.
/// "b"   appears 2 times.
/// "bb"  appears 1 time.
/// "c"   appears 3 times.
/// "cc"  appears 2 times.
/// "ccc" appears 1 time.
/// 3 + 1 + 2 + 1 + 3 + 2 + 1 = 13.
///
/// Example 2:
/// Input: s = "xy"
/// Output: 2
/// Explanation: The homogenous substrings are "x" and "y".
/// Example 3:
/// Input: s = "zzzzz"
/// Output: 15
///
/// Constraints:
/// 1. 1 <= s.length <= 105
/// 2. s consists of lowercase letters.
/// </summary>
int LeetCodeArray::countHomogenous(string s)
{
    int M = 1000000007;
    int result = 0, sum = 0;
    for (size_t i = 0; i < s.size(); i++)
    {
        if (i == 0) sum = 1;
        else if (s[i] == s[i - 1]) sum++;
        else sum = 1;
        result = (result + sum) % M;
    }
    return result;
}

/// <summary>
/// Leet code 1764. Form Array by Concatenating Subarrays of Another Array
/// 
/// Medium
/// 
/// You are given a 2D integer array groups of length n. You are also 
/// given an integer array nums.
///
/// You are asked if you can choose n disjoint subarrays from the array 
/// nums such that the ith subarray is equal to groups[i] (0-indexed), 
/// and if i > 0, the (i-1)th subarray appears before the ith subarray 
/// in nums (i.e. the subarrays must be in the same order as groups).
///
/// Return true if you can do this task, and false otherwise.
/// Note that the subarrays are disjoint if and only if there is no 
/// index k such that nums[k] belongs to more than one subarray. A 
/// subarray is a contiguous sequence of elements within an array.
///
/// Example 1:
/// Input: groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0]
/// Output: true
/// Explanation: You can choose the 0th subarray 
/// as [1,-1,0,1,-1,-1,3,-2,0] and the 1st one as [1,-1,0,1,-1,-1,3,-2,0].
/// These subarrays are disjoint as they share no common nums[k] element.
///
/// Example 2:
/// Input: groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2]
/// Output: false
/// Explanation: Note that choosing the subarrays [1,2,3,4,10,-2] 
/// and [1,2,3,4,10,-2] is incorrect because they are not in the same 
/// order as in groups.
/// [10,-2] must come before [1,2,3,4].
///
/// Example 3:
/// Input: groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7]
/// Output: false
/// Explanation: Note that choosing the subarrays [7,7,1,2,3,4,7,7] 
/// and [7,7,1,2,3,4,7,7] is invalid because they are not disjoint.
/// They share a common elements nums[4] (0-indexed).
///
/// Constraints:
/// 1. groups.length == n
/// 2. 1 <= n <= 10^3
/// 3. 1 <= groups[i].length, sum(groups[i].length) <= 10^3
/// 4. 1 <= nums.length <= 10^3
/// 5. -10^7 <= groups[i][j], nums[k] <= 10^7
/// </summary>
bool LeetCodeArray::canChoose(vector<vector<int>>& groups, vector<int>& nums)
{
    int group_id = 0;
    int item_id = 0;
    int index = 0;
    while (group_id < (int)groups.size() && index < (int)nums.size())
    {
        if (groups[group_id][item_id] == nums[index])
        {
            item_id++;
            index++;
            if (item_id == groups[group_id].size())
            {
                group_id++;
                item_id = 0;
            }
        }
        else
        {
            if (item_id != 0) index -= item_id - 1;
            else index++;
            item_id = 0;
        }
    }
    if (group_id == groups.size()) return true;
    else return false;
}

/// <summary>
/// Leet code 1779. Find Nearest Point That Has the Same X or Y Coordinate
/// 
/// Easy
/// 
/// You are given two integers, x and y, which represent your current 
/// location on a Cartesian grid: (x, y). You are also given an array 
/// points where each points[i] = [ai, bi] represents that a point exists 
/// at (ai, bi). A point is valid if it shares the same x-coordinate or 
/// the same y-coordinate as your location.
///
/// Return the index (0-indexed) of the valid point with the smallest 
/// Manhattan distance from your current location. If there are multiple, 
/// return the valid point with the smallest index. If there are no valid 
/// points, return -1.
///
/// The Manhattan distance between two points (x1, y1) and (x2, y2) is 
/// abs(x1 - x2) + abs(y1 - y2).
///
/// Example 1:
/// Input: x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]]
/// Output: 2
/// Explanation: Of all the points, only [3,1], [2,4] and [4,4] are valid. 
/// Of the valid points, [2,4] and [4,4] have the smallest Manhattan 
/// distance from your current location, with a distance of 1. [2,4] has 
/// the smallest index, so return 2.
///
/// Example 2:
/// Input: x = 3, y = 4, points = [[3,4]]
/// Output: 0
/// Explanation: The answer is allowed to be on the same location as your current location.
///
/// Example 3:
/// Input: x = 3, y = 4, points = [[2,3]]
/// Output: -1
/// Explanation: There are no valid points.
///
/// Constraints:
/// 1. 1 <= points.length <= 10^4
/// 2. points[i].length == 2
/// 3. 1 <= x, y, ai, bi <= 10^4
/// </summary>
int LeetCodeArray::nearestValidPoint(int x, int y, vector<vector<int>>& points)
{
    int min_distance = INT_MAX;
    int result = -1;
    for (size_t i = 0; i < points.size(); i++)
    {
        if (points[i][0] != x && points[i][1] != y) continue;
        int distance = abs(points[i][0] - x) + abs(points[i][1] - y);
        if (distance < min_distance)
        {
            min_distance = distance;
            result = i;
        }
    }
    return result;
}

/// <summary>
/// Leet code 1793. Maximum Score of a Good Subarray
/// 
/// Hard
/// 
/// You are given an array of integers nums (0-indexed) and an integer k.
/// 
/// The score of a subarray (i, j) is defined as min(nums[i], 
/// nums[i+1], ..., nums[j]) * (j - i + 1). A good subarray is a subarray 
/// where i <= k <= j.
///
/// Return the maximum possible score of a good subarray.
///
/// Example 1:
/// Input: nums = [1,4,3,7,4,5], k = 3
/// Output: 15
/// Explanation: The optimal subarray is (1, 5) with a score of 
/// min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15. 
///
/// Example 2:
/// Input: nums = [5,5,4,5,4,1,1,1], k = 0
/// Output: 20
/// Explanation: The optimal subarray is (0, 4) with a score of 
/// min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 2 * 10^4
/// 3. 0 <= k < nums.length
/// </summary>
int LeetCodeArray::maximumScore(vector<int>& nums, int k)
{
    int n = nums.size();
    priority_queue<pair<int, int>> pq;
    int result = nums[k];
    int min_num = nums[k];
    int count = 1;
    if (k > 0) pq.push(make_pair(nums[k - 1], k - 1));
    if (k < n-1) pq.push(make_pair(nums[k + 1], k + 1));
    while (!pq.empty())
    {
        pair<int, int> pos = pq.top();
        pq.pop();
        if (pos.second < k && pos.second > 0)
        {
            pq.push(make_pair(nums[pos.second - 1], pos.second - 1));
        }
        else if (pos.second > k && pos.second < n - 1)
        {
            pq.push(make_pair(nums[pos.second + 1], pos.second + 1));
        }
        min_num = min(min_num, pos.first);
        count++;
        result = max(min_num * count, result);
    }
    return result;
}

/// <summary>
/// Leet code 1800. Maximum Ascending Subarray Sum
/// 
/// Easy
/// 
/// Given an array of positive integers nums, return the maximum possible 
/// sum of an ascending subarray in nums.
///
/// A subarray is defined as a contiguous sequence of numbers in an array.
///
/// A subarray [numsl, numsl+1, ..., numsr-1, numsr] is ascending if for 
/// all i where l <= i < r, numsi < numsi+1. Note that a subarray of 
/// size 1 is ascending.
///
/// Example 1:
/// Input: nums = [10,20,30,5,10,50]
/// Output: 65
/// Explanation: [5,10,50] is the ascending subarray with the maximum 
/// sum of 65.
///
/// Example 2:
/// Input: nums = [10,20,30,40,50]
/// Output: 150
/// Explanation: [10,20,30,40,50] is the ascending subarray with the 
/// maximum sum of 150.
///
/// Example 3:
/// Input: nums = [12,17,15,13,10,11,12]
/// Output: 33
/// Explanation: [10,11,12] is the ascending subarray with the maximum 
/// sum of 33.
///
/// Example 4:
/// Input: nums = [100,10,1]
/// Output: 100
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 100
/// 2. 1 <= nums[i] <= 100
/// </summary>
int LeetCodeArray::maxAscendingSum(vector<int>& nums)
{
    int result = 0, sum = 0, last = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] > last) sum += nums[i];
        else sum = nums[i];
        last = nums[i];
        result = max(result, sum);
    }
    return result;
}

/// <summary>
/// Leet code 1806. Minimum Number of Operations to Reinitialize a 
///                 Permutation
/// 
/// Medium
/// 
/// You are given an even integer n. You initially have a permutation 
/// perm of size n where perm[i] == i (0-indexed).
/// In one operation, you will create a new array arr, and for each i:
/// If i % 2 == 0, then arr[i] = perm[i / 2].
/// If i % 2 == 1, then arr[i] = perm[n / 2 + (i - 1) / 2].
/// You will then assign arr to perm.
///
/// Return the minimum non-zero number of operations you need to perform 
/// on perm to return the permutation to its initial value.
///
/// Example 1:
/// Input: n = 2
/// Output: 1
/// Explanation: perm = [0,1] initially.
/// After the 1st operation, perm = [0,1]
/// So it takes only 1 operation.
///
/// Example 2:
/// Input: n = 4
/// Output: 2
/// Explanation: perm = [0,1,2,3] initially.
/// After the 1st operation, perm = [0,2,1,3]
/// After the 2nd operation, perm = [0,1,2,3]
/// So it takes only 2 operations.
///
/// Example 3:
/// Input: n = 6
/// Output: 4
///
/// Constraints:
/// 1. 2 <= n <= 1000
/// 2. n is even.
/// </summary>
int LeetCodeArray::reinitializePermutation(int n)
{
    vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        if (i % 2 == 0) nums[i] = i / 2;
        else nums[i] = n / 2 + (i - 1) / 2;
    }
    int result = 0;
    for (int i = 0; i < n; i++)
    {
        if (nums[i] == -1) continue;
        queue<int> queue;
        queue.push(nums[i]);
        nums[i] = -1;
        int count = 0;
        while (!queue.empty())
        {
            int index = queue.front();
            queue.pop();
            count++;
            if (index == i) break;
            queue.push(nums[index]);
            nums[index] = -1;
        }
        result = max(result, count);
    }
    return result;
}

/// <summary>
/// Leet code 1818. Minimum Absolute Sum Difference
/// 
/// Medium
/// 
/// You are given two positive integer arrays nums1 and nums2, both of 
/// length n.
///
/// The absolute sum difference of arrays nums1 and nums2 is defined as 
/// the sum of |nums1[i] - nums2[i]| for each 0 <= i < n (0-indexed).
///
/// You can replace at most one element of nums1 with any other element 
/// in nums1 to minimize the absolute sum difference.
///
/// Return the minimum absolute sum difference after replacing at most 
/// one element in the array nums1. Since the answer may be large, return 
/// it modulo 10^9 + 7.
///
/// |x| is defined as:
///
/// x if x >= 0, or
/// -x if x < 0.
/// 
/// Example 1:
/// Input: nums1 = [1,7,5], nums2 = [2,3,5]
/// Output: 3
/// Explanation: There are two possible optimal solutions:
/// - Replace the second element with the first: [1,7,5] => [1,1,5], or
/// - Replace the second element with the third: [1,7,5] => [1,5,5].
/// Both will yield an absolute sum difference of 
/// |1-2| + (|1-3| or |5-3|) + |5-5| = 3.
///
/// Example 2:
/// Input: nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]
/// Output: 0
/// Explanation: nums1 is equal to nums2 so no replacement is needed. 
/// This will result in an 
/// absolute sum difference of 0.
///
/// Example 3:
/// Input: nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]
/// Output: 20
/// Explanation: Replace the first element with the second: 
/// [1,10,4,4,2,7] => [10,10,4,4,2,7].
/// This yields an absolute sum difference of 
/// |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20
///
/// Constraints:
/// 1. n == nums1.length
/// 2. n == nums2.length
/// 3. 1 <= n <= 10^5
/// 4. 1 <= nums1[i], nums2[i] <= 10^5
/// </summary>
int LeetCodeArray::minAbsoluteSumDiff(vector<int>& nums1, vector<int>& nums2)
{
    set<int> set1(nums1.begin(), nums1.end());
    int delta = 0;
    int M = 1000000007;
    int result = 0;

    for (size_t i = 0; i < nums1.size(); i++)
    {
        int diff = abs(nums1[i] - nums2[i]);
        result = (result + diff) % M;

        auto itr = set1.lower_bound(nums2[i]);
        if (itr != set1.end())
        {
            delta = max(delta, diff - abs(*itr - nums2[i]));
        }
        if (itr != set1.begin())
        {
            delta = max(delta, diff - abs(*prev(itr) - nums2[i]));
        }
    }
    result = (result - delta + M) % M;
    return result;
}

/// <summary>
/// Leet code 1822. Sign of the Product of an Array
/// 
/// Easy
/// 
/// There is a function signFunc(x) that returns:
///
/// 1 if x is positive.
/// -1 if x is negative.
/// 0 if x is equal to 0.
/// You are given an integer array nums. Let product be the product of 
/// all values in the array nums.
///
/// Return signFunc(product).
/// 
/// Example 1:
/// Input: nums = [-1,-2,-3,-4,3,2,1]
/// Output: 1
/// Explanation: The product of all values in the array is 144, and 
/// signFunc(144) = 1
///
/// Example 2:
/// Input: nums = [1,5,0,2,-3]
/// Output: 0
/// Explanation: The product of all values in the array is 0, and 
/// signFunc(0) = 0
///
/// Example 3:
/// Input: nums = [-1,1,-1,1,-1]
/// Output: -1
/// Explanation: The product of all values in the array is -1, and 
/// signFunc(-1) = -1
///
/// Constraints:
/// 1. 1 <= nums.length <= 1000
/// 2. -100 <= nums[i] <= 100
/// </summary>
int LeetCodeArray::arraySign(vector<int>& nums)
{
    int result = 1;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] > 0) result = result * 1;
        else if (nums[i] < 0) result = result * -1;
        else
        {
            result = 0;
            break;
        }
    }
    return result;
}

/// <summary>
/// Leet code 1823. Find the Winner of the Circular Game
/// 
/// Medium
/// 
/// There are n friends that are playing a game. The friends are sitting 
/// in a circle and are numbered from 1 to n in clockwise order. More 
/// formally, moving clockwise from the ith friend brings you to the 
/// (i+1)th friend for 1 <= i < n, and moving clockwise from the nth 
/// friend brings you to the 1st friend.
///
/// The rules of the game are as follows:
/// 
/// Start at the 1st friend.
/// Count the next k friends in the clockwise direction including the 
/// friend you started at. The counting wraps around the circle and may 
/// count some friends more than once.
/// The last friend you counted leaves the circle and loses the game.
/// If there is still more than one friend in the circle, go back to 
/// step 2 starting from the friend immediately clockwise of the friend 
/// who just lost and repeat.
/// Else, the last friend in the circle wins the game.
/// Given the number of friends, n, and an integer k, return the winner 
/// of the game.
/// 
/// Example 1:
/// Input: n = 5, k = 2
/// Output: 3
/// Explanation: Here are the steps of the game:
/// 1) Start at friend 1.
/// 2) Count 2 friends clockwise, which are friends 1 and 2.
/// 3) Friend 2 leaves the circle. Next start is friend 3.
/// 4) Count 2 friends clockwise, which are friends 3 and 4.
/// 5) Friend 4 leaves the circle. Next start is friend 5.
/// 6) Count 2 friends clockwise, which are friends 5 and 1.
/// 7) Friend 1 leaves the circle. Next start is friend 3.
/// 8) Count 2 friends clockwise, which are friends 3 and 5.
/// 9) Friend 5 leaves the circle. Only friend 3 is left, so they are the 
///    winner.
///
/// Example 2:
/// Input: n = 6, k = 5
/// Output: 1
/// Explanation: The friends leave in this order: 5, 4, 6, 2, 3. 
/// The winner is friend 1.
///
/// Constraints:
/// 1. 1 <= k <= n <= 500
/// </summary>
int LeetCodeArray::findTheWinner(int n, int k)
{
    list<int> people;
    for (int i = 0; i < n; i++)
    {
        people.push_back(i + 1);
    }  
    auto itr = people.begin();
    auto prev = itr;
    while (people.size() > 1)
    {
        for (int i = 0; i < k; i++)
        {
            prev = itr;
            itr++;
            if (itr == people.end()) itr = people.begin();
        }
        people.erase(prev);
    }
    return *itr;
}

/// <summary>
/// Leet code 1827. Minimum Operations to Make the Array Increasing
/// 
/// Easy
/// 
/// You are given an integer array nums (0-indexed). In one operation, 
/// you can choose an element of the array and increment it by 1.
///
/// For example, if nums = [1,2,3], you can choose to increment nums[1] 
/// to make nums = [1,3,3].
/// Return the minimum number of operations needed to make nums 
/// strictly increasing.
///
/// An array nums is strictly increasing if nums[i] < nums[i+1] for 
/// all 0 <= i < nums.length - 1. An array of length 1 is trivially 
/// strictly increasing.
/// Example 1:
///
/// Input: nums = [1,1,1]
/// Output: 3
/// Explanation: You can do the following operations:
/// 1) Increment nums[2], so nums becomes [1,1,2].
/// 2) Increment nums[1], so nums becomes [1,2,2].
/// 3) Increment nums[2], so nums becomes [1,2,3].
///
/// Example 2:
/// Input: nums = [1,5,2,4,1]
/// Output: 14
///
/// Example 3:
/// Input: nums = [8]
/// Output: 0
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 5000
/// 2. 1 <= nums[i] <= 10^4
/// </summary>
int LeetCodeArray::minOperations(vector<int>& nums)
{
    int last = 0;
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (last >= nums[i]) result += last + 1 - nums[i];
        last = max(last + 1, nums[i]);
    }
    return result;
}

/// <summary>
/// Leet code 1762. Buildings With an Ocean View
/// 
/// Medium
/// 
/// There are n buildings in a line. You are given an integer array 
/// heights of size n that represents the heights of the buildings in the 
/// line.
///
/// The ocean is to the right of the buildings. A building has an ocean 
/// view if the building can see the ocean without obstructions. Formally, 
/// a building has an ocean view if all the buildings to its right have a 
/// smaller height.
///
/// Return a list of indices (0-indexed) of buildings that have an ocean 
/// view, sorted in increasing order.
/// 
/// Example 1:
/// Input: heights = [4,2,3,1]
/// Output: [0,2,3]
/// Explanation: Building 1 (0-indexed) does not have an ocean view 
/// because building 2 is taller.
///
/// Example 2:
/// Input: heights = [4,3,2,1]
/// Output: [0,1,2,3]
/// Explanation: All the buildings have an ocean view.
///
/// Example 3:
/// Input: heights = [1,3,2,4]
/// Output: [3]
/// Explanation: Only building 3 has an ocean view.
///
/// Example 4:
/// Input: heights = [2,2,2,2]
/// Output: [3]
/// Explanation: Buildings cannot see the ocean if there are 
/// buildings of the same height to its right.
/// 
/// Constraints:
/// 1. 1 <= heights.length <= 10^5
/// 2. 1 <= heights[i] <= 10^9
/// </summary>
vector<int> LeetCodeArray::findBuildings(vector<int>& heights)
{
    reverse(heights.begin(), heights.end());
    vector<int> result;
    for (size_t i = 0; i < heights.size(); i++)
    {
        if (i == 0)
        {
            result.push_back(0);
        }
        else
        {
            if (heights[i] > heights[result.back()])
            {
                result.push_back(i);
            }
        }
    }
    reverse(heights.begin(), heights.end());
    reverse(result.begin(), result.end());
    for (size_t i = 0; i < result.size(); i++)
    {
        result[i] = heights.size() - 1 - result[i];
    }
    return result;
}


/// <summary>
/// Leet code 1826. Faulty Sensor
/// 
/// Easy
/// 
/// An experiment is being conducted in a lab. To ensure accuracy, there 
/// are two sensors collecting data simultaneously. You are given 2 arrays 
/// sensor1 and sensor2, where sensor1[i] and sensor2[i] are the ith data 
/// points collected by the two sensors.
///
/// However, this type of sensor has a chance of being defective, which 
/// causes exactly one data point to be dropped. After the data is dropped, 
/// all the data points to the right of the dropped data are shifted one 
/// place to the left, and the last data point is replaced with some 
/// random value. It is guaranteed that this random value will not be equal 
/// to the dropped value.
///
/// For example, if the correct data is [1,2,3,4,5] and 3 is dropped, the 
/// sensor could return [1,2,4,5,7] (the last position can be any value, 
/// not just 7).
/// We know that there is a defect in at most one of the sensors. Return 
/// the sensor number (1 or 2) with the defect. If there is no defect in 
/// either sensor or if it is impossible to determine the defective sensor,
/// return -1.
///
/// Example 1:
/// Input: sensor1 = [2,3,4,5], sensor2 = [2,1,3,4]
/// Output: 1
/// Explanation: Sensor 2 has the correct values.
/// The second data point from sensor 2 is dropped, and the last value of 
/// sensor 1 is replaced by a 5.
///
/// Example 2:
/// Input: sensor1 = [2,2,2,2,2], sensor2 = [2,2,2,2,5]
/// Output: -1
/// Explanation: It is impossible to determine which sensor has a defect.
/// Dropping the last value for either sensor could produce the output 
/// for the other sensor.
///
/// Example 3:
/// Input: sensor1 = [2,3,2,2,3,2], sensor2 = [2,3,2,3,2,7]
/// Output: 2
/// Explanation: Sensor 1 has the correct values.
/// The fourth data point from sensor 1 is dropped, and the last value 
/// of sensor 1 is replaced by a 7.
/// 
/// Constraints:
/// 1. sensor1.length == sensor2.length
/// 2. 1 <= sensor1.length <= 100
/// 3. 1 <= sensor1[i], sensor2[i] <= 100
/// </summary>
int LeetCodeArray::badSensor(vector<int>& sensor1, vector<int>& sensor2)
{
    bool broken = false;
    for (size_t i = 0; i < sensor1.size(); i++)
    {
        if (!broken)
        {
            if (sensor1[i] == sensor2[i]) continue;
            else broken = true;
        }
        if (broken)
        {
            if (i == sensor1.size() - 1) return -1;
            if (sensor1[i] == sensor2[i + 1] && sensor1[i + 1] != sensor2[i])
            {
                return 1;
            }
            else if (sensor2[i] == sensor1[i + 1] && sensor2[i + 1] != sensor1[i])
            {
                return 2;
            }
        }
    }
    return -1;
}

/// <summary>
/// Leet code 1838. Frequency of the Most Frequent Element
/// 
/// Medium
/// 
/// The frequency of an element is the number of times it occurs in an 
/// array.
///  
/// You are given an integer array nums and an integer k. In one 
/// operation, you can choose an index of nums and increment the 
/// element at that index by 1.
///
/// Return the maximum possible frequency of an element after performing 
/// at most k operations.
/// 
/// Example 1:
/// Input: nums = [1,2,4], k = 5
/// Output: 3
/// Explanation: Increment the first element three times and the second 
/// element two times to make nums = [4,4,4].
/// 4 has a frequency of 3.
///
/// Example 2: 
/// Input: nums = [1,4,8,13], k = 5
/// Output: 2
/// Explanation: There are multiple optimal solutions:
/// - Increment the first element three times to make nums = [4,4,8,13]. 
///   4 has a frequency of 2.
/// - Increment the second element four times to make nums = [1,8,8,13]. 
///   8 has a frequency of 2.
/// - Increment the third element five times to make nums = [1,4,13,13]. 
///   13 has a frequency of 2.
///
/// Example 3:
/// Input: nums = [3,9,6], k = 2
/// Output: 1
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^5
/// 3. 1 <= k <= 10^5
/// </summary>
int LeetCodeArray::maxFrequency(vector<int>& nums, int k)
{
    sort(nums.begin(), nums.end(), greater<int>());
    int sum = 0;
    queue<int> queue;
    size_t index = 0;
    int result = 0;
    while (index <= nums.size())
    {
        if (queue.empty())
        {
            queue.push(nums[index]);
            index++;
        }
        
        if (sum > k)
        {
            int first = queue.front();
            queue.pop();
            sum = sum - (first - queue.front()) * queue.size();
        }
        else
        {
            result = max(result, (int)queue.size());
            if (index < (int)nums.size())
            {
                queue.push(nums[index]);
                sum = sum + queue.front() - nums[index];
            }
            index++;
        }
    }
    return result;
}

/// <summary>
/// Leet code 1840. Maximum Building Height
/// 
/// Hard
/// 
/// You want to build n new buildings in a city. The new buildings will 
/// be built in a line and are labeled from 1 to n.
///
/// However, there are city restrictions on the heights of the new 
/// buildings:
///
/// The height of each building must be a non-negative integer.
/// The height of the first building must be 0.
/// The height difference between any two adjacent buildings cannot 
/// exceed 1.
/// Additionally, there are city restrictions on the maximum height of 
/// specific buildings. These restrictions are given as a 2D integer 
/// array restrictions where restrictions[i] = [idi, maxHeighti] indicates 
/// that building idi must have a height less than or equal to maxHeighti.
///
/// It is guaranteed that each building will appear at most once in 
/// restrictions, and building 1 will not be in restrictions.
///
/// Return the maximum possible height of the tallest building.
/// 
/// Example 1:
/// Input: n = 5, restrictions = [[2,1],[4,1]]
/// Output: 2
/// Explanation: The green area in the image indicates the maximum 
/// allowed height for each building.
/// We can build the buildings with heights [0,1,2,1,2], and the tallest 
/// building has a height of 2.
///
/// Example 2:
/// Input: n = 6, restrictions = []
/// Output: 5
/// Explanation: The green area in the image indicates the maximum 
/// allowed height for each building.
/// We can build the buildings with heights [0,1,2,3,4,5], and the tallest 
/// building has a height of 5.
///
/// Example 3:
/// Input: n = 10, restrictions = [[5,3],[2,5],[7,4],[10,3]]
/// Output: 5
/// Explanation: The green area in the image indicates the maximum allowed 
/// height for each building.
/// We can build the buildings with heights [0,1,2,3,3,4,4,5,4,3], and the 
/// tallest building has a height of 5.
///
/// Constraints:
/// 1. 2 <= n <= 10^9
/// 2. 0 <= restrictions.length <= min(n - 1, 10^5)
/// 3. 2 <= idi <= n
/// 4. idi is unique.
/// 5. 0 <= maxHeighti <= 10^9
/// </summary>
int LeetCodeArray::maxBuilding(int n, vector<vector<int>>& restrictions)
{
    vector<vector<int>> heights = restrictions;
    sort(heights.begin(), heights.end());

    vector<int> prev = { 1, 0 };
    for (size_t i = 0; i < heights.size(); i++)
    {
        heights[i][1] = min(heights[i][1], prev[1] + heights[i][0] - prev[0]);
        prev = heights[i];
    }
    if (heights.size() > 1)
    {
        prev = heights[heights.size() - 1];
        for (int i = heights.size() - 2; i >= 0; i--)
        {
            heights[i][1] = min(heights[i][1], prev[1] + prev[0] - heights[i][0]);
            prev = heights[i];
        }
    }

    prev = { 1, 0 };
    int result = 0;
    for (size_t i = 0; i < heights.size(); i++)
    {
        int h = ((heights[i][0] - prev[0]) + abs(heights[i][1] - prev[1])) / 2 +
            (min(heights[i][1], prev[1]));
        prev = heights[i];
        result = max(result, h);
    }
    result = max(result, prev[1] + n - prev[0]);
    return result;
}

/// <summary>
/// Leet code 1848. Minimum Distance to the Target Element
/// 
/// Easy
/// 
/// Given an integer array nums (0-indexed) and two integers target and 
/// start, find an index i such that nums[i] == target and abs(i - start) 
/// is minimized. Note that abs(x) is the absolute value of x.
/// Return abs(i - start).
/// It is guaranteed that target exists in nums.
///
/// Example 1:
/// Input: nums = [1,2,3,4,5], target = 5, start = 3
/// Output: 1
/// Explanation: nums[4] = 5 is the only value equal to target, so the 
/// answer is abs(4 - 3) = 1.
///
/// Example 2:
/// Input: nums = [1], target = 1, start = 0
/// Output: 0
/// Explanation: nums[0] = 1 is the only value equal to target, so the 
/// answer is abs(0 - 0) = 1.
///
/// Example 3:
/// Input: nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0
/// Output: 0
/// Explanation: Every value of nums is 1, but nums[0] minimizes 
/// abs(i - start), which is abs(0 - 0) = 0.
///
/// Constraints:
/// 1. 1 <= nums.length <= 1000
/// 2. 1 <= nums[i] <= 104
/// 3. 0 <= start < nums.length
/// 4. target is in nums.
/// </summary>
int LeetCodeArray::getMinDistance(vector<int>& nums, int target, int start)
{
    unordered_map<int, set<int>> num_map;
    for (size_t i = 0; i < nums.size(); i++)
    {
        num_map[nums[i]].insert(i);
    }
    int result = INT_MAX;
    auto itr = num_map[target].lower_bound(start);
    if (itr != num_map[target].end())
    {
        result = min(result, abs(start - *itr));
    }
    if (itr != num_map[target].begin())
    {
        itr = prev(itr);
        result = min(result, abs(start - *itr));
    }
    return result;
}


/// <summary>
/// Leet code 1855. Maximum Distance Between a Pair of Values
/// 
/// Medium
/// 
/// You are given two non-increasing 0-indexed integer arrays nums1
/// and nums2.
///
/// A pair of indices (i, j), where 0 <= i < nums1.length and 
/// 0 <= j < nums2.length, is valid if both i <= j and 
/// nums1[i] <= nums2[j]. The distance of the pair is j - i.
///
/// Return the maximum distance of any valid pair (i, j). If there are 
/// no valid pairs, return 0.
///
/// An array arr is non-increasing if arr[i-1] >= arr[i] for 
/// every 1 <= i < arr.length.
///
/// Example 1:
/// Input: nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]
/// Output: 2
/// Explanation: The valid pairs are (0,0), (2,2), (2,3), (2,4), 
/// (3,3), (3,4), and (4,4).
/// The maximum distance is 2 with pair (2,4).
///
/// Example 2:
/// Input: nums1 = [2,2,2], nums2 = [10,10,1]
/// Output: 1
/// Explanation: The valid pairs are (0,0), (0,1), and (1,1).
/// The maximum distance is 1 with pair (0,1).
///
/// Example 3:
/// Input: nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]
/// Output: 2
/// Explanation: The valid pairs are (2,2), (2,3), (2,4), (3,3), and (3,4).
/// The maximum distance is 2 with pair (2,4).
///
/// Example 4:
/// Input: nums1 = [5,4], nums2 = [3,2]
/// Output: 0
/// Explanation: There are no valid pairs, so return 0.
/// 
/// Constraints:
/// 1. 1 <= nums1.length <= 10^5
/// 2. 1 <= nums2.length <= 10^5
/// 3. 1 <= nums1[i], nums2[j] <= 10^5
/// 4. Both nums1 and nums2 are non-increasing.
/// </summary>
int LeetCodeArray::maxDistance(vector<int>& nums1, vector<int>& nums2)
{
    int i = 0; 
    int j = 0;
    int result = 0;
    while (i < (int)nums1.size() && j < (int)nums2.size())
    {
        if (nums1[i] <= nums2[j])
        {
            result = max(result, j - i);
            j++;
        }
        else
        {
            i++;
        }
    }
    return result;
}

/// <summary>
/// Leet code 1886. Determine Whether Matrix Can Be Obtained By Rotation
/// 
/// Easy
/// 
/// Given two n x n binary matrices mat and target, return true if it is 
/// possible to make mat equal to target by rotating mat in 90-degree 
/// increments, or false otherwise.
/// 
/// Example 1:
/// Input: mat = [[0,1],[1,0]], target = [[1,0],[0,1]]
/// Output: true
/// Explanation: We can rotate mat 90 degrees clockwise to make mat 
/// equal target.
///
/// Example 2:
/// Input: mat = [[0,1],[1,1]], target = [[1,0],[0,1]]
/// Output: false
/// Explanation: It is impossible to make mat equal to target by rotating 
/// mat.
///
/// Example 3:
/// Input: mat = [[0,0,0],[0,1,0],[1,1,1]], 
/// target = [[1,1,1],[0,1,0],[0,0,0]]
/// Output: true
/// Explanation: We can rotate mat 90 degrees clockwise two times to 
/// make mat equal target.
///
/// Constraints:
/// 1. n == mat.length == target.length
/// 2. n == mat[i].length == target[i].length
/// 2. 1 <= n <= 10
/// 3. mat[i][j] and target[i][j] are either 0 or 1.
/// </summary>
bool LeetCodeArray::findRotation(vector<vector<int>>& mat, vector<vector<int>>& target)
{
    bool b_match1 = true, b_match2 = true, b_match3 = true, b_match4 = true;
    int n = mat.size() - 1;
    for (int i = 0; i <= n; i++)
    {
        for (int j = 0; j <= n; j++)
        {
            if (mat[i][j] != target[j][n - i])  b_match1 = false;
            if (mat[i][j] != target[n - i][n - j])  b_match2 = false;
            if (mat[i][j] != target[n - j][i])  b_match3 = false;
            if (mat[i][j] != target[i][j])  b_match4 = false;
            if (b_match1 == false && b_match2 == false &&
                b_match3 == false && b_match4 == false)
            {
                return false;
            }
        }
    }
    return true;
}

/// <summary>
/// Leet code 1861. Rotating the Box
/// 
/// Medium
/// 
/// You are given an m x n matrix of characters box representing a 
/// side-view of a box. Each cell of the box is one of the following:
///  
/// A stone '#'
/// A stationary obstacle '*'
/// Empty '.'
/// The box is rotated 90 degrees clockwise, causing some of the stones 
/// to fall due to gravity. Each stone falls down until it lands on an 
/// obstacle, another stone, or the bottom of the box. Gravity does not 
/// affect the obstacles' positions, and the inertia from the box's 
/// rotation does not affect the stones' horizontal positions.
///
/// It is guaranteed that each stone in box rests on an obstacle, another 
/// stone, or the bottom of the box.
///
/// Example 1:
/// Input: box = [["#",".","#"]]
/// Output: [["."],
///         ["#"],
///         ["#"]]
///
/// Example 2:
/// Input: box = [["#",".","*","."],
///          ["#","#","*","."]]
/// Output: [["#","."],
///          ["#","#"],
///          ["*","*"],
///          [".","."]]
///
/// Example 3:
/// Input: box = [["#","#","*",".","*","."],
///           ["#","#","#","*",".","."],
///          ["#","#","#",".","#","."]]
/// Output: [[".","#","#"],
///          [".","#","#"],
///          ["#","#","*"],
///          ["#","*","."],
///          ["#",".","*"],
///         ["#",".","."]]
///
/// Constraints:
/// 1. m == box.length
/// 2. n == box[i].length
/// 3. 1 <= m, n <= 500
/// 4. box[i][j] is either '#', '*', or '.'.
/// </summary>
vector<vector<char>> LeetCodeArray::rotateTheBox(vector<vector<char>>& box)
{
    int m = box[0].size();
    int n = box.size();
    vector<int> prev(n, m - 1);
    vector<vector<char>> result(m, vector<char>(n));
    for (int j = m - 1; j >= 0; j--)
    {
        for (int i = n - 1; i >= 0; i--)
        {
            result[j][n - 1- i] = '.';
            if (box[i][j] == '*')
            {
                result[j][n-1-i] = '*';
                prev[i] = j - 1;
            }
            else if (box[i][j] == '#')
            {
                result[prev[i]][n - 1 - i] = '#';
                prev[i]--;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code 1914. Cyclically Rotating a Grid
/// 
/// Medium
/// 
/// You are given an m x n integer matrix grid where m and n are both 
/// even integers, and an integer k.
///
/// The matrix is composed of several layers, which is shown in the 
/// below image, where each color is its own layer:
/// 
/// A cyclic rotation of the matrix is done by cyclically rotating each 
/// layer in the matrix. To cyclically rotate a layer once, each element 
/// in the layer will take the place of the adjacent element in the 
/// counter-clockwise direction. An example rotation is shown below:
///
/// Return the matrix after applying k cyclic rotations to it.
///
/// Example 1:
/// Input: grid = [[40,10],[30,20]], k = 1
/// Output: [[10,20],[40,30]]
/// Explanation: The figures above represent the grid at every state.
///
/// Example 2:
/// Input: grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2
/// Output: [[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]]
/// Explanation: The figures above represent the grid at every state.
///
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 2 <= m, n <= 50
/// 4. Both m and n are even integers.
/// 5. 1 <= grid[i][j] <= 5000
/// 6. 1 <= k <= 10^9
/// </summary>
vector<vector<int>> LeetCodeArray::rotateGrid(vector<vector<int>>& grid, int k)
{
    int m = grid.size();
    int n = grid[0].size();
    int t = min(m, n) / 2;
    vector<list<int>> arr(t);
    vector<vector<int>> result(m, vector<int>(n));
    for (int i = 0; i < t; i++)
    {
        int r = i;
        for (int c = i; c < n - i; c++)
        {
            arr[i].push_back(grid[r][c]);
        }
        int c = n - 1 - i;
        for (int r = i+1; r < m - 1 - i; r++)
        {
            arr[i].push_back(grid[r][c]);
        }
        r = m - 1 - i;
        for (int c = n - 1 - i; c >= i; c--)
        {
            arr[i].push_back(grid[r][c]);
        }
        c = i;
        for (int r = m - 2 - i; r > i; r--)
        {
            arr[i].push_back(grid[r][c]);
        }
    }
    for (int i = 0; i < t; i++)
    {
        int w = k % arr[i].size();
        for (int j = 0; j < w; j++)
        {
            arr[i].push_back(arr[i].front());
            arr[i].pop_front();
        }
    }
    for (int i = 0; i < t; i++)
    {
        int r = i;
        for (int c = i; c < n - i; c++)
        {
            result[r][c] = arr[i].front();
            arr[i].pop_front();
        }
        int c = n - 1 - i;
        for (int r = i + 1; r < m - 1 - i; r++)
        {
            result[r][c] = arr[i].front();
            arr[i].pop_front();
        }
        r = m - 1 - i;
        for (int c = n - 1 - i; c >= i; c--)
        {
            result[r][c] = arr[i].front();
            arr[i].pop_front();
        }
        c = i;
        for (int r = m - 2 - i; r > i; r--)
        {
            result[r][c] = arr[i].front();
            arr[i].pop_front();
        }
    }
    return result;
}

/// <summary>
/// Leet code 1920. Build Array from Permutation
/// 
/// Easy
/// 
/// Given a zero-based permutation nums (0-indexed), build an array ans 
/// of the same length where ans[i] = nums[nums[i]] for each 
/// 0 <= i < nums.length and return it.
///
/// A zero-based permutation nums is an array of distinct integers from 0 
/// to nums.length - 1 (inclusive).
/// 
/// Example 1:
/// Input: nums = [0,2,1,5,3,4]
/// Output: [0,1,2,4,5,3]
/// Explanation: The array ans is built as follows: 
/// ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], 
/// nums[nums[4]], nums[nums[5]]]
/// = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]
/// = [0,1,2,4,5,3]
///
/// Example 2:
/// Input: nums = [5,0,1,2,3,4]
/// Output: [4,5,0,1,2,3]
/// Explanation: The array ans is built as follows:
/// ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], 
/// nums[nums[4]], nums[nums[5]]]
/// = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]
/// = [4,5,0,1,2,3]
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 1000
/// 2. 0 <= nums[i] < nums.length
/// 3. The elements in nums are distinct.
/// 
/// Follow-up: Can you solve it without using an extra space (i.e., O(1) memory)?
/// </summary>
vector<int> LeetCodeArray::buildArray(vector<int>& nums)
{
    vector<int> result(nums.size());
    for (size_t i = 0; i < nums.size(); i++)
    {
        result[i] = nums[nums[i]];
    }
    return result;
}

/// <summary>
/// Leet code 1864. Minimum Number of Swaps to Make the Binary String 
///                 Alternating
/// 
/// Medium
/// 
/// Given a binary string s, return the minimum number of character swaps 
/// to make it alternating, or -1 if it is impossible.
///
/// The string is called alternating if no two adjacent characters are 
/// equal. For example, the strings "010" and "1010" are alternating, 
/// while the string "0100" is not.
///
/// Any two characters may be swapped, even if they are not adjacent.
/// 
/// Example 1:
/// Input: s = "111000"
/// Output: 1
/// Explanation: Swap positions 1 and 4: "111000" -> "101010"
/// The string is now alternating.
///
/// Example 2:
/// Input: s = "010"
/// Output: 0
/// Explanation: The string is already alternating, no swaps are needed.
///
/// Example 3:
/// Input: s = "1110"
/// Output: -1
///
/// Constraints:
/// 1. 1 <= s.length <= 1000
/// 2. s[i] is either '0' or '1'.
/// </summary>
int LeetCodeArray::minSwaps(string s)
{
    vector<vector<int>> count(2, vector<int>(2));
    for (size_t i = 0; i < s.size(); i++)
    {
        count[i % 2][s[i] - '0']++;
    }
    int result = INT_MAX;
    for (int i = 0; i < 2; i++)
    {
        if (count[0][i] == count[1][1 - i])
        {
            result = min(result, count[0][i]);
        }
    }
    if (result == INT_MAX) result = -1;
    return result;
}

/// <summary>
/// Leet code 1878. Get Biggest Three Rhombus Sums in a Grid
///                  
/// Medium
/// 
/// You are given an m x n integer matrix grid. 
/// A rhombus sum is the sum of the elements that form the border of a 
/// regular rhombus shape in grid???. The rhombus must have the shape 
/// of a square rotated 45 degrees with each of the corners centered 
/// in a grid cell. Below is an image of four valid rhombus shapes 
/// with the corresponding colored cells that should be included in each 
/// rhombus sum:
/// 
/// Note that the rhombus can have an area of 0, which is depicted by 
/// the purple rhombus in the bottom right corner.
///
/// Return the biggest three distinct rhombus sums in the grid in 
/// descending order. If there are less than three distinct values, return 
/// all of them.
/// 
/// Example 1:
/// Input: grid = [[3,4,5,1,3],[3,3,4,2,3],[20,30,200,40,10],
///                [1,5,5,4,1],[4,3,2,2,5]]
/// Output: [228,216,211]
/// Explanation: The rhombus shapes for the three biggest distinct rhombus 
/// sums are depicted above.
/// - Blue: 20 + 3 + 200 + 5 = 228
/// - Red: 200 + 2 + 10 + 4 = 216
/// - Green: 5 + 200 + 4 + 2 = 211
///
/// Example 2:
/// Input: grid = [[1,2,3],[4,5,6],[7,8,9]]
/// Output: [20,9,8]
/// Explanation: The rhombus shapes for the three biggest distinct 
/// rhombus sums are depicted above.
/// - Blue: 4 + 2 + 6 + 8 = 20
/// - Red: 9 (area 0 rhombus in the bottom right corner)
/// - Green: 8 (area 0 rhombus in the bottom middle)
///
/// Example 3:
/// Input: grid = [[7,7,7]]
/// Output: [7]
/// Explanation: All three possible rhombus sums are the same, so 
/// return [7].
/// 
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 1 <= m, n <= 50
/// 4. 1 <= grid[i][j] <= 10^5
/// </summary>
vector<int> LeetCodeArray::getBiggestThree(vector<vector<int>>& grid)
{
    set<int> result;
    int n = grid.size();
    int m = grid[0].size();
    vector<vector<vector<int>>> sum0(n, vector<vector<int>>(m, vector<int>(n)));
    vector<vector<vector<int>>> sum1(n, vector<vector<int>>(m, vector<int>(n)));
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            int sum_f = grid[i][j];
            int sum_r = grid[i][j];
            for (int k = 0; i - k >= 0 && i + k < n; k++)
            {
                if (k > 0)
                {
                    int y0 = i - k;
                    int y1 = i + k;
                    int x0 = j - k;
                    int x1 = j + k;
                    if (x0 >= 0) sum_r += grid[y0][x0] + grid[y1][x0];
                    if (x1 < m) sum_f += grid[y0][x1] + grid[y1][x1];
                }
                sum0[i][j][k] = sum_r;
                sum1[i][j][k] = sum_f;
            }
        }
    }

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            for (int k = 0; i - k >= 0 && i + k < n && j + 2 * k < m; k++)
            {          
                int sum = sum1[i][j][k];
                if (k > 0) sum += sum0[i][j + 2 * k][k - 1];
                result.insert(sum);
                if (result.size() > 3) result.erase(result.begin());
            }
        }
    }
    return vector<int>(result.rbegin(), result.rend());
}

/// <summary>
/// Leet code 1895. Largest Magic Square
///                  
/// Medium
/// 
/// A k x k magic square is a k x k grid filled with integers such that 
/// every row sum, every column sum, and both diagonal sums are all equal. 
/// The integers in the magic square do not have to be distinct. Every 
/// 1 x 1 grid is trivially a magic square.
///
/// Given an m x n integer grid, return the size (i.e., the side length k) 
/// of the largest magic square that can be found within this grid.
///
/// Example 1:
/// Input: grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]]
/// Output: 3
/// Explanation: The largest magic square has a size of 3.
/// Every row sum, column sum, and diagonal sum of this magic square is 
/// equal to 12.
/// - Row sums: 5+1+6 = 5+4+3 = 2+7+3 = 12
/// - Column sums: 5+5+2 = 1+4+7 = 6+3+3 = 12
/// - Diagonal sums: 5+4+3 = 6+4+2 = 12
///
/// Example 2:
/// Input: grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]]
/// Output: 2
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 1 <= m, n <= 50
/// 4. 1 <= grid[i][j] <= 10^6
/// </summary>
int LeetCodeArray::largestMagicSquare(vector<vector<int>>& grid)
{
    int n = grid.size();
    int m = grid[0].size();
    vector<vector<int>> row(n+1, vector<int>(m+1));
    vector<vector<int>> col(n+1, vector<int>(m+1));
    vector<vector<int>> diag1(n+1, vector<int>(m+1));
    vector<vector<int>> diag2(n+1, vector<int>(m+2));
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            row[i][j] = grid[i-1][j-1] + row[i][j - 1];
            col[i][j] = grid[i-1][j-1] + col[i - 1][j];
            diag1[i][j] = grid[i-1][j-1] + diag1[i-1][j-1];
            diag2[i][j] = grid[i - 1][j - 1] + diag2[i - 1][j + 1];
        }
    }
    int result = 0;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            int k = min(i, j);
            while (k > result)
            {
                bool match = false;
                int sum = diag1[i][j] - diag1[i - k][j - k];
                match = (sum == (diag2[i][j - k + 1] - diag2[i - k][j + 1]));
                if (match == true)
                {
                    for (int l = 0; l < k; l++)
                    {
                        match = (sum == (row[i - l][j] - row[i - l][j - k]));
                        if (match == false) break;
                        match = (sum == (col[i][j-l] - col[i - k][j - l]));
                        if (match == false) break;
                    }
                }
                if (match == true)
                {
                    result = max(result, k);
                    break;
                }
                k--;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet code 1888. Minimum Number of Flips to Make the Binary String 
///                 Alternating
///                  
/// Medium
/// 
/// You are given a binary string s. You are allowed to perform two types 
/// of operations on the string in any sequence:
///
/// Type-1: Remove the character at the start of the string s and append 
/// it to the end of the string.
/// Type-2: Pick any character in s and flip its value, i.e., if its value 
/// is '0' it becomes '1' and vice-versa.
/// Return the minimum number of type-2 operations you need to perform 
/// such that s becomes alternating.
///
/// The string is called alternating if no two adjacent characters are 
/// equal.
///
/// For example, the strings "010" and "1010" are alternating, while the 
/// string "0100" is not.
/// Example 1:
///
/// Input: s = "111000"
/// Output: 2
/// Explanation: Use the first operation two times to make s = "100011".
/// Then, use the second operation on the third and sixth elements to 
/// make s = "101010".
///
/// Example 2:
/// Input: s = "010"
/// Output: 0
/// Explanation: The string is already alternating.
///
/// Example 3:
/// Input: s = "1110"
/// Output: 1
/// Explanation: Use the second operation on the second element to 
/// make s = "1010".
///
/// Constraints:
/// 1. 1 <= s.length <= 10^5
/// 2. s[i] is either '0' or '1'.
/// </summary>
int LeetCodeArray::minFlips(string s)
{
    vector<vector<int>>count(2, vector<int>(2));
    int n = s.size();
    for (int i = 0; i < n; i++)
    {
        count[i % 2][s[i] - '0']++;
    }
    int result = count[0][0] + count[1][1];
    result = min(result, count[0][1] + count[1][0]);
    for (int i = 0; i < n; i++)
    {
        count[i % 2][s[i] - '0']--;
        count[(n + i) % 2][s[i] - '0']++;
        result = min(result, count[0][0] + count[1][1]);
        result = min(result, count[0][1] + count[1][0]);
    }
    return result;
}

/// <summary>
/// Leet code 1894. Find the Student that Will Replace the Chalk
///                                  
/// Medium
/// 
/// There are n students in a class numbered from 0 to n - 1. The teacher 
/// will give each student a problem starting with the student number 0, 
/// then the student number 1, and so on until the teacher reaches the 
/// student number n - 1. After that, the teacher will restart the process,
/// starting with the student number 0 again.
/// You are given a 0-indexed integer array chalk and an integer k. There 
/// are initially k pieces of chalk. When the student number i is given a 
/// problem to solve, they will use chalk[i] pieces of chalk to solve that 
/// problem. However, if the current number of chalk pieces is strictly 
/// less than chalk[i], then the student number i will be asked to replace 
/// the chalk.
///
/// Return the index of the student that will replace the chalk.
/// Example 1:
/// Input: chalk = [5,1,5], k = 22
/// Output: 0
/// Explanation: The students go in turns as follows:
/// - Student number 0 uses 5 chalk, so k = 17.
/// - Student number 1 uses 1 chalk, so k = 16.
/// - Student number 2 uses 5 chalk, so k = 11.
/// - Student number 0 uses 5 chalk, so k = 6.
/// - Student number 1 uses 1 chalk, so k = 5.
/// - Student number 2 uses 5 chalk, so k = 0.
/// Student number 0 does not have enough chalk, so they will have to 
/// replace it.
///
/// Example 2:
/// Input: chalk = [3,4,1,2], k = 25
/// Output: 1
/// Explanation: The students go in turns as follows:
/// - Student number 0 uses 3 chalk so k = 22.
/// - Student number 1 uses 4 chalk so k = 18.
/// - Student number 2 uses 1 chalk so k = 17.
/// - Student number 3 uses 2 chalk so k = 15.
/// - Student number 0 uses 3 chalk so k = 12.
/// - Student number 1 uses 4 chalk so k = 8.
/// - Student number 2 uses 1 chalk so k = 7.
/// - Student number 3 uses 2 chalk so k = 5.
/// - Student number 0 uses 3 chalk so k = 2.
/// Student number 1 does not have enough chalk, so they will have to 
/// replace it.
/// 
/// Constraints:
/// 1. chalk.length == n
/// 2. 1 <= n <= 10^5
/// 3. 1 <= chalk[i] <= 10^5
/// 4. 1 <= k <= 10^9
/// </summary>
int LeetCodeArray::chalkReplacer(vector<int>& chalk, int k)
{
    long long sum = 0;
    for (size_t i = 0; i < chalk.size(); i++)
    {
        sum += chalk[i];
    }
    k = k % sum;
    for (size_t i = 0; i < chalk.size(); i++)
    {
        if (k < chalk[i]) return i;
        k -= chalk[i];
    }
    return -1;
}

/// <summary>
/// Leet code 1929. Concatenation of Array
///                                                
/// Easy
/// 
/// Given an integer array nums of length n, you want to create an array 
/// ans of length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] 
/// for 0 <= i < n (0-indexed).
///
/// Specifically, ans is the concatenation of two nums arrays.
///
/// Return the array ans.
/// 
/// Example 1:
/// Input: nums = [1,2,1]
/// Output: [1,2,1,1,2,1]
/// Explanation: The array ans is formed as follows:
/// - ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]
/// - ans = [1,2,1,1,2,1]
///
/// Example 2:
/// Input: nums = [1,3,2,1]
/// Output: [1,3,2,1,1,3,2,1]
/// Explanation: The array ans is formed as follows:
/// - ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],
///          nums[3]]
/// - ans = [1,3,2,1,1,3,2,1]
/// 
/// Constraints:
/// 1. n == nums.length
/// 2. 1 <= n <= 1000
/// 3. 1 <= nums[i] <= 1000
/// </summary>
vector<int> LeetCodeArray::getConcatenation(vector<int>& nums)
{
    vector<int> result(nums.size() * 2);
    for (size_t i = 0; i < result.size(); i++)
    {
        result[i] = nums[i % nums.size()];
    }
    return result;
}

/// <summary>
/// Leet code 2006. Count Number of Pairs With Absolute Difference K
///                                                
/// Easy
/// 
/// Given an integer array nums and an integer k, return the number of 
/// pairs (i, j) where i < j such that |nums[i] - nums[j]| == k.
///
/// The value of |x| is defined as:
///
/// x if x >= 0.
/// -x if x < 0.
///
/// Example 1:
/// Input: nums = [1,2,2,1], k = 1
/// Output: 4
/// Explanation: The pairs with an absolute difference of 1 are:
/// - [1,2,2,1]
/// - [1,2,2,1]
/// - [1,2,2,1]
/// - [1,2,2,1]
///
/// Example 2:
/// Input: nums = [1,3], k = 3
/// Output: 0
/// Explanation: There are no pairs with an absolute difference of 3.
///
/// Example 3:
/// Input: nums = [3,2,1,5,4], k = 2
/// Output: 3
/// Explanation: The pairs with an absolute difference of 2 are:
/// - [3,2,1,5,4]
/// - [3,2,1,5,4]
/// - [3,2,1,5,4]
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 200
/// 2. 1 <= nums[i] <= 100
/// 3. 1 <= k <= 99
/// </summary>
int LeetCodeArray::countKDifference(vector<int>& nums, int k)
{
    vector<int> arr(101);
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] - k >= 1)
        {
            result += arr[nums[i] - k];
        }
        if (nums[i] + k <= 100)
        {
            result += arr[nums[i] + k];
        }
        arr[nums[i]]++;
    }
    return result;
}

/// <summary>
/// Leet code 2016. Maximum Difference Between Increasing Elements
///                                                
/// Easy
/// 
/// Given a 0-indexed integer array nums of size n, find the maximum 
/// difference between nums[i] and nums[j] (i.e., nums[j] - nums[i]), 
/// such that 0 <= i < j < n and nums[i] < nums[j].
/// Return the maximum difference. If no such i and j exists, return -1.
/// 
/// Example 1:
/// Input: nums = [7,1,5,4]
/// Output: 4
/// Explanation:
/// The maximum difference occurs with i = 1 and j = 2, 
/// nums[j] - nums[i] = 5 - 1 = 4.
/// Note that with i = 1 and j = 0, the difference nums[j] - nums[i] 
/// = 7 - 1 = 6, but i > j, so it is not valid.
///
/// Example 2:
/// Input: nums = [9,4,3,2]
/// Output: -1
/// Explanation:
/// There is no i and j such that i < j and nums[i] < nums[j].
///
/// Example 3:
/// Input: nums = [1,5,2,10]
/// Output: 9
/// Explanation:
/// The maximum difference occurs with i = 0 and j = 3, 
/// nums[j] - nums[i] = 10 - 1 = 9.
/// 
/// Constraints:
/// 1. n == nums.length
/// 2. 2 <= n <= 1000
/// 3. 1 <= nums[i] <= 10^9
/// </summary>
int LeetCodeArray::maximumDifference(vector<int>& nums)
{
    int min_val = INT_MAX;
    int result = -1;
    for (size_t i = 0; i < nums.size(); i++)
    {
        result = max(result, nums[i] - min_val);
        min_val = min(min_val, nums[i]);
    }
    return result == 0 ? -1 : result;
}

/// <summary>
/// Leet code 2022. Convert 1D Array Into 2D Array
///                                                
/// Easy
/// 
/// You are given a 0-indexed 1-dimensional (1D) integer array original, 
/// and two integers, m and n. You are tasked with creating a 
/// 2-dimensional (2D) array with m rows and n columns using all the 
/// elements from original.
///
/// The elements from indices 0 to n - 1 (inclusive) of original should 
/// form the first row of the constructed 2D array, the elements from 
/// indices n to 2 * n - 1 (inclusive) should form the second row of 
/// the constructed 2D array, and so on.
///
/// Return an m x n 2D array constructed according to the above 
/// procedure, or an empty 2D array if it is impossible.
/// 
/// Example 1:
/// Input: original = [1,2,3,4], m = 2, n = 2
/// Output: [[1,2],[3,4]]
/// Explanation:
/// The constructed 2D array should contain 2 rows and 2 columns.
/// The first group of n=2 elements in original, [1,2], becomes the first 
/// row in the constructed 2D array.
/// The second group of n=2 elements in original, [3,4], becomes the 
/// second row in the constructed 2D array.
///
/// Example 2:
/// Input: original = [1,2,3], m = 1, n = 3
/// Output: [[1,2,3]]
/// Explanation:
/// The constructed 2D array should contain 1 row and 3 columns.
/// Put all three elements in original into the first row of the 
/// constructed 2D array.
///
/// Example 3:
/// Input: original = [1,2], m = 1, n = 1
/// Output: []
/// Explanation:
/// There are 2 elements in original.
/// It is impossible to fit 2 elements in a 1x1 2D array, so return an 
/// empty 2D array.
///
/// Example 4:
/// Input: original = [3], m = 1, n = 2
/// Output: []
/// Explanation:
/// There is 1 element in original.
/// It is impossible to make 1 element fill all the spots in a 1x2 2D 
/// array, so return an empty 2D array.
/// 
/// Constraints:
/// 1. 1 <= original.length <= 5 * 10^4
/// 2. 1 <= original[i] <= 10^5
/// 3. 1 <= m, n <= 4 * 10^4
/// </summary>
vector<vector<int>> LeetCodeArray::construct2DArray(vector<int>& original, int m, int n)
{
    vector<vector<int>> result;
    if (m * n != original.size())
    {
        return result;
    }
    for (int i = 0; i < m; i++)
    {
        result.push_back(vector<int>());
        for (int j = 0; j < n; j++)
        {
            result[i].push_back(original[i * n + j]);
        }
    }
    return result;
}

/// <summary>
/// Leet code 2057. Smallest Index With Equal Value
///                                                
/// Easy
/// 
/// Given a 0-indexed integer array nums, return the smallest index i of 
/// nums such that i mod 10 == nums[i], or -1 if such index does not exist.
/// 
/// x mod y denotes the remainder when x is divided by y.
/// Example 1:
/// Input: nums = [0,1,2]
/// Output: 0
/// Explanation: 
/// i=0: 0 mod 10 = 0 == nums[0].
/// i=1: 1 mod 10 = 1 == nums[1].
/// i=2: 2 mod 10 = 2 == nums[2].
/// All indices have i mod 10 == nums[i], so we return the smallest 
/// index 0.
/// Example 2:
///
/// Input: nums = [4,3,2,1]
/// Output: 2
/// Explanation: 
/// i=0: 0 mod 10 = 0 != nums[0].
/// i=1: 1 mod 10 = 1 != nums[1].
/// i=2: 2 mod 10 = 2 == nums[2].
/// i=3: 3 mod 10 = 3 != nums[3].
/// 2 is the only index which has i mod 10 == nums[i].
///
/// Example 3:
/// Input: nums = [1,2,3,4,5,6,7,8,9,0]
/// Output: -1
/// Explanation: No index satisfies i mod 10 == nums[i].
///
/// Example 4:
/// Input: nums = [2,1,3,5,2]
/// Output: 1
/// Explanation: 1 is the only index with i mod 10 == nums[i].
///
/// Constraints:
/// 1. 1 <= nums.length <= 100
/// 2. 0 <= nums[i] <= 9
/// </summary>
int LeetCodeArray::smallestEqual(vector<int>& nums)
{
    int result = -1;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (result == -1 && i % 10 == nums[i])
        {
            result = i;
        }
    }
    return result;
}

/// <summary>
/// Leet code 1991. Find the Middle Index in Array
///                                                
/// Easy
/// 
/// Given a 0-indexed integer array nums, find the leftmost middleIndex 
/// (i.e., the smallest amongst all the possible ones).
///
/// A middleIndex is an index where nums[0] + nums[1] + ... + 
/// nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] 
/// + ... + nums[nums.length-1].
///
/// If middleIndex == 0, the left side sum is considered to be 0. 
/// Similarly, if middleIndex == nums.length - 1, the right side sum is 
/// considered to be 0.
///
/// Return the leftmost middleIndex that satisfies the condition, or -1 
/// if there is no such index.
/// 
/// Example 1:
/// Input: nums = [2,3,-1,8,4]
/// Output: 3
/// Explanation:
/// The sum of the numbers before index 3 is: 2 + 3 + -1 = 4
/// The sum of the numbers after index 3 is: 4 = 4
///
/// Example 2:
/// Input: nums = [1,-1,4]
/// Output: 2
/// Explanation:
/// The sum of the numbers before index 2 is: 1 + -1 = 0
/// The sum of the numbers after index 2 is: 0
///
/// Example 3:
/// Input: nums = [2,5]
/// Output: -1
/// Explanation:
/// There is no valid middleIndex.
///
/// Example 4:
/// Input: nums = [1]
/// Output: 0
/// Explantion:
/// The sum of the numbers before index 0 is: 0
/// The sum of the numbers after index 0 is: 0
/// Constraints:
/// 1. 1 <= nums.length <= 100
/// 2. -1000 <= nums[i] <= 1000
/// </summary>
int LeetCodeArray::findMiddleIndex(vector<int>& nums)
{
    vector<int> dp(nums.size());
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (i == 0) dp[i] = nums[0];
        else dp[i] = dp[i - 1] + nums[i];
    }
    int result = -1;
    for (size_t i = 0; i < dp.size(); i++)
    {
        int left = 0;
        int right = 0;
        if (i > 0) left = dp[i - 1];
        if (i < dp.size() - 1)
        {
            right = dp[dp.size() - 1] - dp[i];
        }
        if (left == right)
        {
            result = i;
            break;
        }
    }
    return result;
}

/// <summary>
/// Leet code 1930. Unique Length-3 Palindromic Subsequences
///                                                                 
/// Medium
/// 
/// Given a string s, return the number of unique palindromes of length 
/// three that are a subsequence of s.
///
/// Note that even if there are multiple ways to obtain the same 
/// subsequence, it is still only counted once.
///
/// A palindrome is a string that reads the same forwards and backwards.
///
/// A subsequence of a string is a new string generated from the original 
/// string with some characters (can be none) deleted without changing 
/// the relative order of the remaining characters.
///
/// For example, "ace" is a subsequence of "abcde".
/// Example 1:
/// Input: s = "aabca"
/// Output: 3
/// Explanation: The 3 palindromic subsequences of length 3 are:
/// - "aba" (subsequence of "aabca")
/// - "aaa" (subsequence of "aabca")
/// - "aca" (subsequence of "aabca")
///
/// Example 2:
/// Input: s = "adc"
/// Output: 0
/// Explanation: There are no palindromic subsequences of length 3 
/// in "adc".
///
/// Example 3:
/// Input: s = "bbcbaba"
/// Output: 4
/// Explanation: The 4 palindromic subsequences of length 3 are:
/// - "bbb" (subsequence of "bbcbaba")
/// - "bcb" (subsequence of "bbcbaba")
/// - "bab" (subsequence of "bbcbaba")
/// - "aba" (subsequence of "bbcbaba")
/// 
/// Constraints:
/// 1. 3 <= s.length <= 10^5
/// 2. s consists of only lowercase English letters.
/// </summary>
int LeetCodeArray::countPalindromicSubsequence(string s)
{
    vector<vector<int>> char_arr(26);
    vector<int> char_total(26);
    vector<int> char_count(26);

    for (size_t i = 0; i < s.size(); i++)
    {
        char_count[s[i] - 'a']++;
        if (char_arr[s[i] - 'a'].empty())
        {
            char_arr[s[i] - 'a'] = char_count;
            continue;
        }
        int count = 0;
        for (size_t j = 0; j < 26; j++)
        {
            if (char_count[j] > char_arr[s[i] - 'a'][j] && j != s[i] - 'a') count++;
            if (char_count[j] > char_arr[s[i] - 'a'][j] + 1 && j == s[i] - 'a') count++;
        }
        char_total[s[i] - 'a'] = max(char_total[s[i] - 'a'], count);
    }
    int result = 0;
    for (size_t i = 0; i < 26; i++)
    {
        result += char_total[i];
    }
    return result;
}


/// <summary>
/// Leet code 2009. Minimum Number of Operations to Make Array Continuous
///                                                                 
/// Hard
/// 
/// You are given an integer array nums. In one operation, you can replace 
/// any element in nums with any integer.
///
/// nums is considered continuous if both of the following conditions are 
/// fulfilled:
///
/// All elements in nums are unique.
/// The difference between the maximum element and the minimum element in 
/// nums equals nums.length - 1.
/// For example, nums = [4, 2, 5, 3] is continuous, but nums = [1, 2, 3, 
/// 5, 6] is not continuous.
///
/// Return the minimum number of operations to make nums continuous.
///
/// Example 1:
/// Input: nums = [4,2,5,3]
/// Output: 0
/// Explanation: nums is already continuous.
///
/// Example 2:
/// Input: nums = [1,2,3,5,6]
/// Output: 1
/// Explanation: One possible solution is to change the last element to 4.
/// The resulting array is [1,2,3,5,4], which is continuous.
///
/// Example 3:
/// Input: nums = [1,10,100,1000]
/// Output: 3
/// Explanation: One possible solution is to:
/// - Change the second element to 2.
/// - Change the third element to 3.
/// - Change the fourth element to 4.
///
/// The resulting array is [1,2,3,4], which is continuous.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^9
/// </summary>
int LeetCodeArray::minOperationsII(vector<int>& nums)
{
    int n = nums.size();
    vector<int> dp(n);
    int result = n;
    sort(nums.begin(), nums.end());
    for (int i = 1; i < n; i++)
    {
        dp[i] = dp[i - 1];
        if (nums[i] == nums[i - 1]) dp[i]++;
    }
    for (int i = 0; i < n; i++)
    {
        auto itr = lower_bound(nums.begin() + i, nums.end(), nums[i] + n);
        int count = (itr - (nums.begin() + i));
        count -= dp[i + count - 1] - dp[i];
        result = min(result, n - count);
    }
    return result;
}

/// <summary>
/// Leet code 1936. Add Minimum Number of Rungs
///                                                                 
/// Medium
/// 
/// You are given a strictly increasing integer array rungs that represents
/// the height of rungs on a ladder. You are currently on the floor at 
/// height 0, and you want to reach the last rung.
///
/// You are also given an integer dist. You can only climb to the next 
/// highest rung if the distance between where you are currently at (the 
/// floor or on a rung) and the next rung is at most dist. You are able to 
/// insert rungs at any positive integer height if a rung is not already 
/// there.
///
/// Return the minimum number of rungs that must be added to the ladder in 
/// order for you to climb to the last rung.
/// 
/// Example 1:
/// Input: rungs = [1,3,5,10], dist = 2
/// Output: 2
/// Explanation:
/// You currently cannot reach the last rung.
/// Add rungs at heights 7 and 8 to climb this ladder. 
/// The ladder will now have rungs at [1,3,5,7,8,10].
///
/// Example 2:
/// Input: rungs = [3,6,8,10], dist = 3
/// Output: 0
/// Explanation:
/// This ladder can be climbed without adding additional rungs.
///
/// Example 3:
/// Input: rungs = [3,4,6,7], dist = 2
/// Output: 1
/// Explanation:
/// You currently cannot reach the first rung from the ground.
/// Add a rung at height 1 to climb this ladder.
/// The ladder will now have rungs at [1,3,4,6,7].
///
/// Example 4:
/// Input: rungs = [5], dist = 10
/// Output: 0
/// Explanation:
/// This ladder can be climbed without adding additional rungs.
/// 
/// Constraints:
/// 1. 1 <= rungs.length <= 10^5
/// 2. 1 <= rungs[i] <= 10^9
/// 3. 1 <= dist <= 10^9
/// 4. rungs is strictly increasing.
/// </summary>
int LeetCodeArray::addRungs(vector<int>& rungs, int dist)
{
    int result = 0;
    int prev = 0;
    for (size_t i = 0; i < rungs.size(); i++)
    {
        result += (rungs[i] - prev + dist - 1) / dist - 1;
        prev = rungs[i];
    }
    return result;
}

/// <summary>
/// Leet code 2025. Maximum Number of Ways to Partition an Array
///                                                                 
/// Hard
/// 
/// You are given a 0-indexed integer array nums of length n. The number 
/// of ways to partition nums is the number of pivot indices that satisfy 
/// both conditions:
///
/// 1 <= pivot < n
/// nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + 
/// nums[pivot + 1] + ... + nums[n - 1]
/// You are also given an integer k. You can choose to change the value 
/// of one element of nums to k, or to leave the array unchanged.
///
/// Return the maximum possible number of ways to partition nums to 
/// satisfy both conditions after changing at most one element.
/// 
/// Example 1:
/// Input: nums = [2,-1,2], k = 3
/// Output: 1
/// Explanation: One optimal approach is to change nums[0] to k. 
/// The array becomes [3,-1,2].
/// There is one way to partition the array:
/// - For pivot = 2, we have the partition [3,-1 | 2]: 3 + -1 == 2.
///
/// Example 2:
/// 
/// Input: nums = [0,0,0], k = 1
/// Output: 2
/// Explanation: The optimal approach is to leave the array unchanged.
/// There are two ways to partition the array:
/// - For pivot = 1, we have the partition [0 | 0,0]: 0 == 0 + 0.
/// - For pivot = 2, we have the partition [0,0 | 0]: 0 + 0 == 0.
///
/// Example 3:
/// Input: nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33
/// Output: 4
/// Explanation: One optimal approach is to change nums[2] to k. The 
/// array becomes [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14].
/// There are four ways to partition the array.
/// 
/// Constraints:
/// 1. n == nums.length
/// 2. 2 <= n <= 10^5
/// 3. -10^5 <= k, nums[i] <= 10^5
/// </summary>
int LeetCodeArray::waysToPartition(vector<int>& nums, int k)
{
    vector<long long> sum(nums.size());
    unordered_map<long long, int> left, right, left_count, right_count;
    left[nums[0]]++;
    for (size_t i = 0; i < nums.size(); i++)
    {
        sum[i] = nums[i];
        if (i > 0)
        {
            sum[i] += sum[i - 1];
            right[nums[i]]++;
        }
    }
    int result = 0;
    int update = 0;
    for (size_t p = 1; p < nums.size(); p++)
    {
        long long left_sum = sum[p - 1];
        long long right_sum = sum[nums.size() - 1] - sum[p - 1];
        long long delta = right_sum - left_sum;
        if (left_sum == right_sum)
        {
            result++;
        }
        else if (left.count(k - delta) > 0)
        {
            left_count[k - delta]++;
            update = max(update, left_count[k - delta]);
        }
        else if (right.count(k + delta) > 0)
        {
            right_count[k + delta]++;
            update = max(update, right_count[k + delta]);
        }

        left[nums[p]]++;
        left_count[nums[p]] = max(left_count[nums[p]], right_count[nums[p]]);
        right[nums[p]]--;
        if (right[nums[p]] == 0)
        {
            right.erase(nums[p]);
            right_count.erase(nums[p]);
        }
    }
    result = max(result, update);
    return result;
}

/// <summary>
/// Leet 1937. Maximum Number of Points with Cost
///                                                                 
/// Medium
/// 
/// You are given an m x n integer matrix points (0-indexed). Starting 
/// with 0 points, you want to maximize the number of points you can get 
/// from the matrix.
///
/// To gain points, you must pick one cell in each row. Picking the cell 
/// at coordinates (r, c) will add points[r][c] to your score.
///
/// However, you will lose points if you pick a cell too far from the cell 
/// that you picked in the previous row. For every two adjacent rows r and 
/// r + 1 (where 0 <= r < m - 1), picking cells at coordinates (r, c1) and 
/// (r + 1, c2) will subtract abs(c1 - c2) from your score.
/// 
/// Return the maximum number of points you can achieve.
/// abs(x) is defined as:
/// x for x >= 0.
/// -x for x < 0.
///
/// Example 1:
/// Input: points = [[1,2,3],[1,5,1],[3,1,1]]
/// Output: 9
/// Explanation:
/// The blue cells denote the optimal cells to pick, which have 
/// coordinates (0, 2), (1, 1), and (2, 0).
/// You add 3 + 5 + 3 = 11 to your score.
/// However, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score.
/// Your final score is 11 - 2 = 9.
///
/// Example 2:
/// Input: points = [[1,5],[2,3],[4,2]]
/// Output: 11
/// Explanation:
/// The blue cells denote the optimal cells to pick, which have 
/// coordinates (0, 1), (1, 1), and (2, 0).
/// You add 5 + 3 + 4 = 12 to your score.
/// However, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score.
/// Your final score is 12 - 1 = 11.
/// 
/// Constraints:
/// 1. m == points.length
/// 2. n == points[r].length
/// 3. 1 <= m, n <= 10^5
/// 4. 1 <= m * n <= 10^5
/// 5. 0 <= points[r][c] <= 10^5
/// </summary>
long long LeetCodeArray::maxPoints(vector<vector<int>>& points)
{
    int n = points[0].size();
    vector<long long> sum(n);
    for (size_t i = 0; i < points.size(); i++)
    {
        for (int j = 0; j <n; j++)
        {
            sum[j] += (long long)points[i][j];
        }

        vector<long long> left(n);
        for (int j = 0; j < n; j++)
        {
            if (j == 0) left[j] = sum[j];
            else left[j] = max(sum[j], left[j - 1] - 1);
        }
        vector<long long> right(n);
        for (int j = n-1; j >= 0; j--)
        {
            if (j == n - 1) right[j] = sum[j];
            else right[j] = max(sum[j], right[j + 1] - 1);
        }
        for (int j = 0; j < n; j++)
        {
            sum[j] = max(left[j], right[j]);
        }
    }

    long long result = 0;
    for (int i = 0; i < n; i++)
    {
        result = max(result, sum[i]);
    }
    return result;
}

/// <summary>
/// Leet Code 1788. Maximize the Beauty of the Garden
///                                                                 
/// Hard
/// 
/// There is a garden of n flowers, and each flower has an integer beauty 
/// value. The flowers are arranged in a line. You are given an integer 
/// array flowers of size n and each flowers[i] represents the beauty of 
/// the ith flower.
///
/// A garden is valid if it meets these conditions:
/// 
/// The garden has at least two flowers.
/// The first and the last flower of the garden have the same beauty value.
/// As the appointed gardener, you have the ability to remove any (possibly 
/// none) flowers from the garden. You want to remove flowers in a way that 
/// makes the remaining garden valid. The beauty of the garden is the sum 
/// of the beauty of all the remaining flowers.
/// Return the maximum possible beauty of some valid garden after you have 
/// removed any (possibly none) flowers.
///
/// Example 1:
/// Input: flowers = [1,2,3,1,2]
/// Output: 8
/// Explanation: You can produce the valid garden [2,3,1,2] to have a 
/// total beauty of 2 + 3 + 1 + 2 = 8.
///
/// Example 2:
/// Input: flowers = [100,1,1,-3,1]
/// Output: 3
/// Explanation: You can produce the valid garden [1,1,1] to have a total 
/// beauty of 1 + 1 + 1 = 3.
///
/// Example 3:
/// Input: flowers = [-1,-2,0,-1]
/// Output: -2
/// Explanation: You can produce the valid garden [-1,-1] to have a total 
/// beauty of -1 + -1 = -2.
/// Constraints:
/// 1. 2 <= flowers.length <= 10^5
/// 2. -10^4 <= flowers[i] <= 10^4
/// 3. It is possible to create a valid garden by removing some (possibly 
///    none) flowers.
/// </summary>
int LeetCodeArray::maximumBeauty(vector<int>& flowers)
{
    unordered_map<int, int> flower_map;
    vector<int> dp(flowers.size());
    int result = INT_MIN;
    for (size_t i = 0; i < flowers.size(); i++)
    {
        if (i == 0) dp[i] = 0;
        else dp[i] = dp[i - 1];
        if (flowers[i] > 0)
        {
            dp[i] += flowers[i];
        }
        if (flower_map.count(flowers[i]) > 0)
        {
            int prev = flower_map[flowers[i]];
            int beauty = dp[i] - dp[prev] + flowers[i];
            if (flowers[i] < 0)
            {
                beauty += flowers[i];
            }
            result = max(result, beauty);
        }
        else
        {
            flower_map[flowers[i]] = i;
        }
    }
    return result;
}
/// <summary>
/// Leet Code 2088. Count Fertile Pyramids in a Land
///                                                                 
/// Hard
/// 
/// A farmer has a rectangular grid of land with m rows and n columns that
/// can be divided into unit cells. Each cell is either fertile 
/// (represented by a 1) or barren (represented by a 0). All cells outside 
/// the grid are considered barren.
///
/// A pyramidal plot of land can be defined as a set of cells with the 
/// following criteria:
///
/// The number of cells in the set has to be greater than 1 and all cells 
/// must be fertile.
/// The apex of a pyramid is the topmost cell of the pyramid. The height 
/// of a pyramid is the number of rows it covers. Let (r, c) be the apex 
/// of the pyramid, and its height be h. Then, the plot comprises of 
/// cells (i, j) where r <= i <= r + h - 1 and c - (i - r) <= j <= c + 
/// (i - r).
/// An inverse pyramidal plot of land can be defined as a set of cells 
/// with similar criteria:
///
/// The number of cells in the set has to be greater than 1 and all 
/// cells must be fertile.
/// The apex of an inverse pyramid is the bottommost cell of the 
/// inverse pyramid. The height of an inverse pyramid is the number of 
/// rows it covers. Let (r, c) be the apex of the pyramid, and its height 
/// be h. Then, the plot comprises of cells (i, j) where 
/// r - h + 1 <= i <= r and c - (r - i) <= j <= c + (r - i).
/// Some examples of valid and invalid pyramidal (and inverse pyramidal) 
/// plots are shown below. Black cells indicate fertile cells.
///
/// Given a 0-indexed m x n binary matrix grid representing the farmland, 
/// return the total number of pyramidal and inverse pyramidal plots that 
/// can be found in grid.
///
/// Example 1:
/// Input: grid = [[0,1,1,0],[1,1,1,1]]
/// Output: 2
/// Explanation:
/// The 2 possible pyramidal plots are shown in blue and red respectively.
/// There are no inverse pyramidal plots in this grid. 
/// Hence total number of pyramidal and inverse pyramidal plots 
/// is 2 + 0 = 2.
///
/// Example 2:
/// Input: grid = [[1,1,1],[1,1,1]]
/// Output: 2
/// Explanation:
/// The pyramidal plot is shown in blue, and the inverse pyramidal plot 
/// is shown in red. 
/// Hence the total number of plots is 1 + 1 = 2.
///
/// Example 3:
/// Input: grid = [[1,0,1],[0,0,0],[1,0,1]]
/// Output: 0
/// Explanation:
/// There are no pyramidal or inverse pyramidal plots in the grid.
///
/// Example 4:
/// Input: grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]
/// Output: 13
/// Explanation:
/// There are 7 pyramidal plots, 3 of which are shown in the 2nd 
/// and 3rd figures.
/// There are 6 inverse pyramidal plots, 2 of which are shown in the 
/// last figure.
/// The total number of plots is 7 + 6 = 13.
///
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 1 <= m, n <= 1000
/// 4. 1 <= m * n <= 10^5
/// 5. grid[i][j] is either 0 or 1.
/// </summary>
int LeetCodeArray::countPyramids(vector<vector<int>>& grid)
{
    int result = 0;
    vector<vector<int>> matrix = grid;
    for (int i = (int)matrix.size() - 2; i >= 0; i--)
    {
        for (int j = 1; j < (int)matrix[i].size() - 1; j++)
        {
            if (matrix[i][j] == 0) continue;
            int base = matrix[i + 1][j - 1];
            base = min(base, matrix[i + 1][j]);
            base = min(base, matrix[i + 1][j + 1]);
            matrix[i][j] += base;
            result += base;
        }
    }
    matrix = grid;
    for (int i = 1; i < (int)matrix.size(); i++)
    {
        for (int j = 1; j < (int)matrix[i].size() - 1; j++)
        {
            if (matrix[i][j] == 0) continue;
            int base = matrix[i - 1][j - 1];
            base = min(base, matrix[i - 1][j]);
            base = min(base, matrix[i - 1][j + 1]);
            matrix[i][j] += base;
            result += base;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2090. K Radius Subarray Averages
///                                                                 
/// Medium
/// 
/// You are given a 0-indexed array nums of n integers, and an integer k.
///
/// The k-radius average for a subarray of nums centered at some index i 
/// with the radius k is the average of all elements in nums between the 
/// indices i - k and i + k (inclusive). If there are less than k elements 
/// before or after the index i, then the k-radius average is -1.
///
/// Build and return an array avgs of length n where avgs[i] is the 
/// k-radius average for the subarray centered at index i.
///
/// The average of x elements is the sum of the x elements divided by x, 
/// using integer division. The integer division truncates toward zero, 
/// which means losing its fractional part.
///
/// For example, the average of four elements 2, 3, 1, and 5 is 
/// (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75, which truncates to 2.
///
/// Example 1:
/// Input: nums = [7,4,3,9,1,8,5,2,6], k = 3
/// Output: [-1,-1,-1,5,4,4,-1,-1,-1]
/// Explanation:
/// - avg[0], avg[1], and avg[2] are -1 because there are less than k 
///  elements before each index.
/// - The sum of the subarray centered at index 3 with radius 3 
/// is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37.
/// Using integer division, avg[3] = 37 / 7 = 5.
/// - For the subarray centered at index 4, avg[4] = 
///  (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4.
/// - For the subarray centered at index 5, avg[5] = 
///  (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4.
/// - avg[6], avg[7], and avg[8] are -1 because there are less than k 
///   elements after each index.
///
/// Example 2:
/// Input: nums = [100000], k = 0
/// Output: [100000]
/// Explanation:
/// - The sum of the subarray centered at index 0 with radius 0 
///   is: 100000.
/// avg[0] = 100000 / 1 = 100000.
///
/// Example 3:
/// Input: nums = [8], k = 100000
/// Output: [-1]
/// Explanation: 
/// - avg[0] is -1 because there are less than k elements before and 
///   after index 0.
/// 
/// Constraints:
/// 1. n == nums.length
/// 2. 1 <= n <= 10^5
/// 3. 0 <= nums[i], k <= 10^5
/// </summary>
vector<int> LeetCodeArray::getAverages(vector<int>& nums, int k)
{
    vector<int> result(nums.size(), -1);
    long long sum = 0;
    for (int i = 0; i < (int)nums.size(); i++)
    {
        sum += (long long)nums[i];
        if (i < 2 * k)
        {
            continue;
        }
        else if (i == 2 * k)
        {
            result[i - k] = (int)(sum / ((long long)2 * (long long)k + (long long)1));
        }
        else
        {
            sum -= nums[i - 2 * k - 1];
            result[i - k] = (int)(sum / ((long long)2 * (long long)k + (long long)1));
        }
    }
    return result;
}

/// <summary>
/// Leet Code 1874. Minimize Product Sum of Two Arrays
///                                                                 
/// Medium
/// 
/// The product sum of two equal-length arrays a and b is equal to the 
/// sum of a[i] * b[i] for all 0 <= i < a.length (0-indexed).
///
/// For example, if a = [1,2,3,4] and b = [5,2,3,1], the product sum would 
/// be 1*5 + 2*2 + 3*3 + 4*1 = 22.
/// Given two arrays nums1 and nums2 of length n, return the minimum 
/// product sum if you are allowed to rearrange the order of the elements 
/// in nums1. 
/// 
/// Example 1:
/// Input: nums1 = [5,3,4,2], nums2 = [4,2,2,5]
/// Output: 40
/// Explanation: We can rearrange nums1 to become [3,5,4,2]. The product 
/// sum of [3,5,4,2] and [4,2,2,5] is 3*4 + 5*2 + 4*2 + 2*5 = 40.
///
/// Example 2:
/// Input: nums1 = [2,1,4,5,7], nums2 = [3,2,4,8,6]
/// Output: 65
/// Explanation: We can rearrange nums1 to become [5,7,4,1,2]. The product 
/// sum of [5,7,4,1,2] and [3,2,4,8,6] is 5*3 + 7*2 + 4*4 + 1*8 + 2*6 = 65.
/// 
/// Constraints:
/// 1. n == nums1.length == nums2.length
/// 2. 1 <= n <= 10^5
/// 3. 1 <= nums1[i], nums2[i] <= 100
/// </summary>
int LeetCodeArray::minProductSum(vector<int>& nums1, vector<int>& nums2)
{
    int result = 0;
    sort(nums1.begin(), nums1.end());
    sort(nums2.begin(), nums2.end());
    for (size_t i = 0; i < nums1.size(); i++)
    {
        result += nums1[i] * nums2[nums2.size() - 1 - i];
    }
    return result;
}

/// <summary>
/// Leet Code 2079. Watering Plants 
///                                                                 
/// Medium
/// 
/// You want to water n plants in your garden with a watering can. The 
/// plants are arranged in a row and are labeled from 0 to n - 1 from 
/// left to right where the ith plant is located at x = i. There is a 
/// river at x = -1 that you can refill your watering can at.
///
/// Each plant needs a specific amount of water. You will water the 
/// plants in the following way:
/// 
/// Water the plants in order from left to right.
/// After watering the current plant, if you do not have enough water 
/// to completely water the next plant, return to the river to fully 
/// refill the watering can.
/// You cannot refill the watering can early.
/// You are initially at the river (i.e., x = -1). It takes one step 
/// to move one unit on the x-axis.
///  
/// Given a 0-indexed integer array plants of n integers, where plants[i] 
/// is the amount of water the ith plant needs, and an integer capacity 
/// representing the watering can capacity, return the number of steps 
/// needed to water all the plants.
/// 
/// Example 1:
/// 
/// Input: plants = [2,2,3,3], capacity = 5
/// Output: 14
/// Explanation: Start at the river with a full watering can:
/// - Walk to plant 0 (1 step) and water it. Watering can has 3 units of 
///   water.
/// - Walk to plant 1 (1 step) and water it. Watering can has 1 unit of 
///   water.
/// - Since you cannot completely water plant 2, walk back to the river 
///   to refill (2 steps).
/// - Walk to plant 2 (3 steps) and water it. Watering can has 2 units 
///   of water.
/// - Since you cannot completely water plant 3, walk back to the river 
///   to refill (3 steps).
/// - Walk to plant 3 (4 steps) and water it.
/// Steps needed = 1 + 1 + 2 + 3 + 3 + 4 = 14.
///
/// Example 2:
/// Input: plants = [1,1,1,4,2,3], capacity = 4
/// Output: 30
/// Explanation: Start at the river with a full watering can:
/// - Water plants 0, 1, and 2 (3 steps). Return to river (3 steps).
/// - Water plant 3 (4 steps). Return to river (4 steps).
/// - Water plant 4 (5 steps). Return to river (5 steps).
/// - Water plant 5 (6 steps).
/// Steps needed = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30.
///
/// Example 3:
/// Input: plants = [7,7,7,7,7,7,7], capacity = 8
/// Output: 49
/// Explanation: You have to refill before watering each plant.
/// Steps needed = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49.
/// 
/// Constraints:
/// 1. n == plants.length
/// 2. 1 <= n <= 1000
/// 3. 1 <= plants[i] <= 10^6
/// 4. max(plants[i]) <= capacity <= 10^9
/// </summary>
int LeetCodeArray::wateringPlants(vector<int>& plants, int capacity)
{
    int result = 0;
    int original_capacity = capacity;
    for (size_t i = 0; i < plants.size(); i++)
    {
        if (plants[i] > capacity)
        {
            result += 2 * i;
            capacity = original_capacity;
        }
        result++;
        capacity -= plants[i];
    }
    return result;
}

/// <summary>
/// Leet Code 2018. Check if Word Can Be Placed In Crossword 
///                                                                 
/// Medium
/// 
/// You are given an m x n matrix board, representing the current state 
/// of a crossword puzzle. The crossword contains lowercase English 
/// letters (from solved words), ' ' to represent any empty cells, 
/// and '#' to represent any blocked cells.
///
/// A word can be placed horizontally (left to right or right to left) or 
/// vertically (top to bottom or bottom to top) in the board if:
///
/// It does not occupy a cell containing the character '#'.
/// The cell each letter is placed in must either be ' ' (empty) or match 
/// the letter already on the board.
/// There must not be any empty cells ' ' or other lowercase letters 
/// directly left or right of the word if the word was placed horizontally.
/// There must not be any empty cells ' ' or other lowercase letters directly 
/// above or below the word if the word was placed vertically.
/// Given a string word, return true if word can be placed in board, or 
/// false otherwise.
/// 
/// Example 1:
/// Input: board = [["#", " ", "#"], [" ", " ", "#"], 
/// ["#", "c", " "]], word = "abc"
/// Output: true
/// Explanation: The word "abc" can be placed as shown above 
/// (top to bottom).
///
/// Example 2:
/// Input: board = [[" ", "#", "a"], [" ", "#", "c"], 
/// [" ", "#", "a"]], word = "ac"
/// Output: false
/// Explanation: It is impossible to place the word because there will 
/// always be a space/letter above or below it.
///
/// Example 3:
/// Input: board = [["#", " ", "#"], [" ", " ", "#"], ["#", " ", "c"]], 
/// word = "ca"
/// Output: true
/// Explanation: The word "ca" can be placed as shown above 
/// (right to left). 
///
/// Constraints:
/// 1. m == board.length
/// 2. n == board[i].length
/// 3. 1 <= m * n <= 2 * 10^5
/// 4. board[i][j] will be ' ', '#', or a lowercase English letter.
/// 5. 1 <= word.length <= max(m, n)
/// 6. word will contain only lowercase English letters.
/// </summary>
bool LeetCodeArray::placeWordInCrossword(vector<vector<char>>& board, string word)
{
    string rev_word = word;
    std::reverse(rev_word.begin(), rev_word.end());
    for (size_t i = 0; i < board.size(); i++)
    {
        int start = -1;
        bool ord = true;
        bool rev = true;
        for (size_t j = 0; j < board[i].size(); j++)
        {
            if (board[i][j] == '#')
            {
                if (start == word.size() - 1 && (ord == true || rev == true)) return true;
                start = -1;                
                ord = true;
                rev = true;
                continue;
            }
            else
            {
                start++;
                if (start >= (int)word.size())
                {
                    ord = false;
                    rev = false;
                }
                else
                {
                    if (board[i][j] != ' ')
                    {
                        if (board[i][j] != word[start])
                        {
                            ord = false;
                        }
                        if (board[i][j] != rev_word[start])
                        {
                            rev = false;
                        }
                    }                  
                }
            }
        }
        if (start == word.size() - 1 && (ord == true || rev == true)) return true;
    }

    for (size_t i = 0; i < board[0].size(); i++)
    {
        int start = -1;
        bool ord = true;
        bool rev = true;
        for (size_t j = 0; j < board.size(); j++)
        {
            if (board[j][i] == '#')
            {
                if (start == word.size() - 1 && (ord == true || rev == true)) return true;
                start = -1;
                ord = true;
                rev = true;
                continue;
            }
            else
            {
                start++;
                if (start >= (int)word.size())
                {
                    ord = false;
                    rev = false;
                }
                else
                {
                    if (board[j][i] != ' ')
                    {
                        if (board[j][i] != word[start])
                        {
                            ord = false;
                        }
                        if (board[j][i] != rev_word[start])
                        {
                            rev = false;
                        }
                    }
                }
            }
        }
        if (start == word.size() - 1 && (ord == true || rev == true)) return true;
    }
    return false;
}

/// <summary>
/// Leet Code 2078. Two Furthest Houses With Different Colors 
///                                                                 
/// Easy
/// 
/// There are n houses evenly lined up on the street, and each house is 
/// beautifully painted. You are given a 0-indexed integer array colors 
/// of length n, where colors[i] represents the color of the ith house.
///
/// Return the maximum distance between two houses with different colors.
///
/// The distance between the ith and jth houses is abs(i - j), where 
/// abs(x) is the absolute value of x.
///  
/// Example 1:
/// Input: colors = [1,1,1,6,1,1,1]
/// Output: 3
/// Explanation: In the above image, color 1 is blue, and color 6 is red.
/// The furthest two houses with different colors are house 0 and house 3.
/// House 0 has color 1, and house 3 has color 6. The distance between 
/// them is abs(0 - 3) = 3.
/// Note that houses 3 and 6 can also produce the optimal answer.
///
/// Example 2:
/// Input: colors = [1,8,3,8,3]
/// Output: 4
/// Explanation: In the above image, color 1 is blue, color 8 is yellow, 
/// and color 3 is green.
/// The furthest two houses with different colors are house 0 and house 4.
/// House 0 has color 1, and house 4 has color 3. The distance between 
/// them is abs(0 - 4) = 4.
///
/// Example 3:
/// Input: colors = [0,1]
/// Output: 1
/// Explanation: The furthest two houses with different colors are 
/// house 0 and house 1.
/// House 0 has color 0, and house 1 has color 1. The distance between 
/// them is abs(0 - 1) = 1.
/// 
/// Constraints:
/// 1. n == colors.length
/// 2. 2 <= n <= 100
/// 3. 0 <= colors[i] <= 100
/// 4. Test data are generated such that at least two houses have different 
///    colors.
/// </summary>
int LeetCodeArray::maxDistance(vector<int>& colors)
{
    int result = 0;
    int color1 = 0, pos1 = 0, color2 = 0, pos2 = 0;
    for (int i = 0; i < (int)colors.size(); i++)
    {
        if (i == 0)
        {
            color1 = colors[i];
        }
        else if (colors[i] != color1 && pos2 == 0)
        {
            color2 = colors[i];
            pos2 = i;

        }

        if (colors[i] != color1)
        {
            result = max(result, i - pos1);
        }
        else if (pos2 > 0)
        {
            result = max(result, i - pos2);
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2075. Decode the Slanted Ciphertext
///                                                                 
/// Medium
/// 
/// A string originalText is encoded using a slanted transposition cipher 
/// to a string encodedText with the help of a matrix having a fixed 
/// number of rows rows.
///
/// originalText is placed first in a top-left to bottom-right manner.
/// The blue cells are filled first, followed by the red cells, then the 
/// yellow cells, and so on, until we reach the end of originalText. The 
/// arrow indicates the order in which the cells are filled. All empty 
/// cells are filled with ' '. The number of columns is chosen such that 
/// the rightmost column will not be empty after filling in originalText.
///
/// encodedText is then formed by appending all characters of the matrix 
/// in a row-wise fashion.
/// 
/// The characters in the blue cells are appended first to encodedText, 
/// then the red cells, and so on, and finally the yellow cells. The 
/// arrow indicates the order in which the cells are accessed.
///
/// For example, if originalText = "cipher" and rows = 3, then we encode 
/// it in the following manner:
///
/// The blue arrows depict how originalText is placed in the matrix, and 
/// the red arrows denote the order in which encodedText is formed. In 
/// the above example, encodedText = "ch ie pr".
///
/// Given the encoded string encodedText and number of rows rows, return 
/// the original string originalText.
///
/// Note: originalText does not have any trailing spaces ' '. The test 
/// cases are generated such that there is only one possible 
/// originalText.
///
/// Example 1:
/// Input: encodedText = "ch   ie   pr", rows = 3
/// Output: "cipher"
/// Explanation: This is the same example described in the problem 
/// description.
///
/// Example 2:
/// Input: encodedText = "iveo    eed   l te   olc", rows = 4
/// Output: "i love leetcode"
/// Explanation: The figure above denotes the matrix that was used to 
/// encode originalText. 
/// The blue arrows show how we can find originalText from encodedText.
///
/// Example 3:
/// Input: encodedText = "coding", rows = 1
/// Output: "coding"
/// Explanation: Since there is only 1 row, both originalText and 
/// encodedText are the same.
///
/// Example 4:
/// Input: encodedText = " b  ac", rows = 2
/// Output: " abc"
/// Explanation: originalText cannot have trailing spaces, but it may be 
/// preceded by one or more spaces.
///
/// Constraints:
/// 1. 0 <= encodedText.length <= 10^6
/// 2. encodedText consists of lowercase English letters and ' ' only.
/// 3. encodedText is a valid encoding of some originalText that does not 
///    have trailing spaces.
/// 4. 1 <= rows <= 1000
/// 5. The testcases are generated such that there is only one possible 
///    originalText.
/// </summary>
string LeetCodeArray::decodeCiphertext(string encodedText, int rows)
{
    int width = encodedText.size() / rows;
    string result;
    for (int i = 0; i < width; i++)
    {
        for (int j = 0; j < rows; j++)
        {
            if (j + i >= width) break;
            result.push_back(encodedText[j * width + j + i]);
        }
    }
    while (isspace(result.back())) result.pop_back();
    return result;
}

/// <summary>
/// Leet Code 2086. Minimum Number of Buckets Required to Collect 
///                 Rainwater from Houses
///                                                                 
/// Medium
/// You are given a 0-indexed string street. Each character in street is 
/// either 'H' representing a house or '.' representing an empty space.
///
/// You can place buckets on the empty spaces to collect rainwater that 
/// falls from the adjacent houses. The rainwater from a house at index 
/// i is collected if a bucket is placed at index i - 1 and/or 
/// index i + 1. A single bucket, if placed adjacent to two houses, can 
/// collect the rainwater from both houses.
///
/// Return the minimum number of buckets needed so that for every house, 
/// there is at least one bucket collecting rainwater from it, or -1 if 
/// it is impossible.
/// 
/// Example 1:
/// Input: street = "H..H"
/// Output: 2
/// Explanation:
/// We can put buckets at index 1 and index 2.
/// "H..H" -> "HBBH" ('B' denotes where a bucket is placed).
/// The house at index 0 has a bucket to its right, and the house at 
/// index 3 has a bucket to its left.
/// Thus, for every house, there is at least one bucket collecting 
/// rainwater from it.
///
/// Example 2:
/// Input: street = ".H.H."
/// Output: 1
/// Explanation:
/// We can put a bucket at index 2.
/// ".H.H." -> ".HBH." ('B' denotes where a bucket is placed).
/// The house at index 1 has a bucket to its right, and the house at 
/// index 3 has a bucket to its left.
/// Thus, for every house, there is at least one bucket collecting 
/// rainwater from it.
///
/// Example 3:
/// Input: street = ".HHH."
/// Output: -1
/// Explanation:
/// There is no empty space to place a bucket to collect the rainwater 
/// from the house at index 2.
/// Thus, it is impossible to collect the rainwater from all the houses.
///
/// Example 4:
/// Input: street = "H"
/// Output: -1
/// Explanation:
/// There is no empty space to place a bucket.
/// Thus, it is impossible to collect the rainwater from the house.
///
/// Example 5:
/// Input: street = "."
/// Output: 0
/// Explanation:
/// There is no house to collect water from.
/// Thus, 0 buckets are needed.
///
/// Constraints:
/// 1. 1 <= street.length <= 10^5
/// 2. street[i] is either'H' or '.'.
/// </summary>
int LeetCodeArray::minimumBuckets(string street)
{
    int result = 0;
    for (int i = 0; i < (int)street.size(); i++)
    {
        if (street[i] == 'H')
        {
            if (i > 0 && street[i - 1] == '*')
            {
                continue;
            }
            else if (i < (int)street.size() - 1 && street[i+1] == '.')
            {
                street[i + 1] = '*';
                result++;
            }
            else if (i > 0 && street[i - 1] == '.')
            {
                street[i - 1] = '*';
                result++;
            }
            else
            {
                return -1;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2017. Grid Game
///                                                                 
/// Medium
///
/// You are given a 0-indexed 2D array grid of size 2 x n, where 
/// grid[r][c] represents the number of points at position (r, c) 
/// on the matrix. Two robots are playing a game on this matrix.
///
/// Both robots initially start at (0, 0) and want to reach (1, n-1). 
/// Each robot may only move to the right ((r, c) to (r, c + 1)) or 
/// down ((r, c) to (r + 1, c)).
///
/// At the start of the game, the first robot moves from (0, 0) to 
/// (1, n-1), collecting all the points from the cells on its path. 
/// For all cells (r, c) traversed on the path, grid[r][c] is set 
/// to 0. Then, the second robot moves from (0, 0) to (1, n-1), 
/// collecting the points on its path. Note that their paths may 
/// intersect with one another.
/// The first robot wants to minimize the number of points collected 
/// by the second robot. In contrast, the second robot wants to 
/// maximize the number of points it collects. If both robots play 
/// optimally, return the number of points collected by the second robot.
/// 
/// Example 1:
/// Input: grid = [[2,5,4],[1,5,1]]
/// Output: 4
/// Explanation: The optimal path taken by the first robot is shown in 
/// red, and the optimal path taken by the second robot is shown in blue.
/// The cells visited by the first robot are set to 0.
/// The second robot will collect 0 + 0 + 4 + 0 = 4 points.
///
/// Example 2:
/// Input: grid = [[3,3,1],[8,5,2]]
/// Output: 4
/// Explanation: The optimal path taken by the first robot is shown in red, 
/// and the optimal path taken by the second robot is shown in blue.
/// The cells visited by the first robot are set to 0.
/// The second robot will collect 0 + 3 + 1 + 0 = 4 points.
///
/// Example 3:
/// Input: grid = [[1,3,1,15],[1,3,3,1]]
/// Output: 7
/// Explanation: The optimal path taken by the first robot is shown in red, 
/// and the optimal path taken by the second robot is shown in blue.
/// The cells visited by the first robot are set to 0.
/// The second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points.
/// 
/// Constraints:
/// 1. grid.length == 2
/// 2. n == grid[r].length
/// 3. 1 <= n <= 5 * 10^4
/// 4. 1 <= grid[r][c] <= 10^5
/// </summary>
long long LeetCodeArray::gridGame(vector<vector<int>>& grid)
{
    long long sum1 = 0;
    long long sum2 = 0;
    for (size_t i = 0; i < grid[0].size(); i++) sum1 += grid[0][i];
    long long result = LONG_MAX;
    for (size_t i = 0; i < grid[0].size(); i++)
    {
        sum1 -= grid[0][i];
        if (i > 0) sum2 += (long long)grid[1][i-1];
        result = min(result, max(sum1, sum2));
    }
    return result;
}

/// <summary>
/// Leet Code 2073. Time Needed to Buy Tickets
///                                                                 
/// Easy
///
/// There are n people in a line queuing to buy tickets, where the 0th 
/// person is at the front of the line and the (n - 1)th person is at 
/// the back of the line.
///
/// You are given a 0-indexed integer array tickets of length n where 
/// the number of tickets that the ith person would like to buy is 
/// tickets[i].
///
/// Each person takes exactly 1 second to buy a ticket. A person can 
/// only buy 1 ticket at a time and has to go back to the end of the 
/// line (which happens instantaneously) in order to buy more tickets. 
/// If a person does not have any tickets left to buy, the person will 
/// leave the line.
///
/// Return the time taken for the person at position k (0-indexed) to 
/// finish buying tickets.
/// 
/// Example 1:
/// Input: tickets = [2,3,2], k = 2
/// Output: 6
/// Explanation: 
/// - In the first pass, everyone in the line buys a ticket and the line 
/// becomes [1, 2, 1].
/// - In the second pass, everyone in the line buys a ticket and the 
/// line becomes [0, 1, 0].
/// The person at position 2 has successfully bought 2 tickets and it 
/// took 3 + 3 = 6 seconds.
///
/// Example 2:
/// Input: tickets = [5,1,1,1], k = 0
/// Output: 8
/// Explanation:
/// - In the first pass, everyone in the line buys a ticket and the line 
///   becomes [4, 0, 0, 0].
/// - In the next 4 passes, only the person in position 0 is buying 
///   tickets.
/// The person at position 0 has successfully bought 5 tickets and it 
/// took 4 + 1 + 1 + 1 + 1 = 8 seconds.
///
/// Constraints:
/// 1. n == tickets.length
/// 2. 1 <= n <= 100
/// 3. 1 <= tickets[i] <= 100
/// 4. 0 <= k < n
/// </summary>
int LeetCodeArray::timeRequiredToBuy(vector<int>& tickets, int k)
{
    int result = 0;
    for (int i = 0; i < (int)tickets.size(); i++)
    {
        if (i <= k)
        {
            result += min(tickets[i], tickets[k]);
        }
        else
        {
            result += min(tickets[i], tickets[k] - 1);
        }
    }
    return result;
}

/// <summary>
/// Leet Code 1868. Product of Two Run-Length Encoded Arrays
///                                                                 
/// Medium
///
/// Run-length encoding is a compression algorithm that allows for an 
/// integer array nums with many segments of consecutive repeated 
/// numbers to be represented by a (generally smaller) 2D array 
/// encoded. Each encoded[i] = [vali, freqi] describes the ith 
/// segment of repeated numbers in nums where vali is the value that 
/// is repeated freqi times.
///
/// For example, nums = [1,1,1,2,2,2,2,2] is represented by the 
/// run-length encoded array encoded = [[1,3],[2,5]]. Another way to 
/// read this is "three 1's followed by five 2's".
/// The product of two run-length encoded arrays encoded1 and encoded2 
/// can be calculated using the following steps:
///
/// Expand both encoded1 and encoded2 into the full arrays nums1 and 
/// nums2 respectively.
/// Create a new array prodNums of length nums1.length and set 
/// prodNums[i] = nums1[i] * nums2[i].
/// Compress prodNums into a run-length encoded array and return it.
/// You are given two run-length encoded arrays encoded1 and encoded2 
/// representing full arrays nums1 and nums2 respectively. Both nums1 
/// and nums2 have the same length. Each encoded1[i] = [vali, freqi] 
/// describes the ith segment of nums1, and each encoded2[j] = 
/// [valj, freqj] describes the jth segment of nums2.
///
/// Return the product of encoded1 and encoded2.
///
/// Note: Compression should be done such that the run-length encoded 
/// array has the minimum possible length.
/// 
/// Example 1:
/// Input: encoded1 = [[1,3],[2,3]], encoded2 = [[6,3],[3,3]]
/// Output: [[6,6]]
/// Explanation: encoded1 expands to [1,1,1,2,2,2] and encoded2 
/// expands to [6,6,6,3,3,3].
/// prodNums = [6,6,6,6,6,6], which is compressed into the run-length 
/// encoded array [[6,6]].
///
/// Example 2:
/// Input: encoded1 = [[1,3],[2,1],[3,2]], encoded2 = [[2,3],[3,3]]
/// Output: [[2,3],[6,1],[9,2]]
/// Explanation: encoded1 expands to [1,1,1,2,3,3] and encoded2 expands 
/// to [2,2,2,3,3,3].
/// prodNums = [2,2,2,6,9,9], which is compressed into the run-length 
/// encoded array [[2,3],[6,1],[9,2]].
/// 
/// Constraints:
/// 1. 1 <= encoded1.length, encoded2.length <= 10^5
/// 2. encoded1[i].length == 2
/// 3. encoded2[j].length == 2
/// 4. 1 <= vali, freqi <= 10^4 for each encoded1[i].
/// 5. 1 <= valj, freqj <= 10^4 for each encoded2[j].
/// 6. The full arrays that encoded1 and encoded2 represent are the same 
///    length.
/// </summary>
vector<vector<int>> LeetCodeArray::findRLEArray(vector<vector<int>>& encoded1, vector<vector<int>>& encoded2)
{
    size_t first_index = 0, first_freq = 0, second_index = 0, second_freq = 0;
    first_freq = encoded1[0][1];
    second_freq = encoded2[0][1];
    vector<vector<int>> result;
    while (first_index < encoded1.size() && second_index < encoded2.size())
    {
        int product = encoded1[first_index][0] * encoded2[second_index][0];
        int freq = min(first_freq, second_freq);
        if (result.empty() || result.back()[0] != product)
        {
            result.push_back({ product, freq });
        }
        else
        {
            result.back()[1] += freq;
        }
        first_freq -= freq;
        second_freq -= freq;
        if (first_freq == 0)
        {
            first_index++;
            if (first_index < encoded1.size()) first_freq = encoded1[first_index][1];
        }
        if (second_freq == 0)
        {
            second_index++;
            if (second_index < encoded2.size()) second_freq = encoded2[second_index][1];
        }
    }
    return result;
}

/// <summary>
/// Leet Code 1885. Count Pairs in Two Arrays
///                                                                 
/// Medium
///
/// Given two integer arrays nums1 and nums2 of length n, count the pairs 
/// of indices (i, j) such that i < j and 
/// nums1[i] + nums1[j] > nums2[i] + nums2[j].
///
/// Return the number of pairs satisfying the condition.
///
/// Example 1:
/// Input: nums1 = [2,1,2,1], nums2 = [1,2,1,2]
/// Output: 1
/// Explanation: The pairs satisfying the condition are:
/// - (0, 2) where 2 + 2 > 1 + 1.
///
/// Example 2:
/// Input: nums1 = [1,10,6,2], nums2 = [1,4,1,5]
/// Output: 5
/// Explanation: The pairs satisfying the condition are:
/// - (0, 1) where 1 + 10 > 1 + 4.
/// - (0, 2) where 1 + 6 > 1 + 1.
/// - (1, 2) where 10 + 6 > 4 + 1.
/// - (1, 3) where 10 + 2 > 4 + 5.
/// - (2, 3) where 6 + 2 > 1 + 5.
/// 
/// Constraints:
/// 1. n == nums1.length == nums2.length
/// 2. 1 <= n <= 10^5
/// 3. 1 <= nums1[i], nums2[i] <= 10^5
/// </summary>
long long LeetCodeArray::countPairs(vector<int>& nums1, vector<int>& nums2)
{
    long long result = 0;
    vector<long long> diff(nums1.size());
    for (size_t i = 0; i < nums1.size(); i++)
    {
        diff[i] = (long long)nums1[i] - (long long)nums2[i];
    }
    sort(diff.begin(), diff.end());
    int first = 0;
    int last = nums1.size() - 1;
    while (first < last)
    {
        if (diff[first] + diff[last] > 0)
        {
            result += (long long)last - (long long)first;
            last--;
        }
        else
        {
            first++;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 1940. Longest Common Subsequence Between Sorted Arrays
///                                                                 
/// Medium
///
/// Given an array of integer arrays arrays where each arrays[i] is 
/// sorted in strictly increasing order, return an integer array 
/// representing the longest common subsequence between all the arrays.
///
/// A subsequence is a sequence that can be derived from another 
/// sequence by deleting some elements (possibly none) without 
/// changing the order of the remaining elements.
/// 
/// Example 1:
/// Input: arrays = [[1,3,4],
///                  [1,4,7,9]]
/// Output: [1,4]
/// Explanation: The longest common subsequence in the two arrays 
///              is [1,4].
///
/// Example 2:
/// Input: arrays = [[2,3,6,8],
///                  [1,2,3,5,6,7,10],
///                  [2,3,4,6,9]]
/// Output: [2,3,6]
/// Explanation: The longest common subsequence in all three arrays 
/// is [2,3,6].
///
/// Example 3:
/// Input: arrays = [[1,2,3,4,5],
///                  [6,7,8]]
/// Output: []
/// Explanation: There is no common subsequence between the two arrays.
///
/// Constraints:
/// 1. 2 <= arrays.length <= 100
/// 2. 1 <= arrays[i].length <= 100
/// 3. 1 <= arrays[i][j] <= 100
/// 4. arrays[i] is sorted in strictly increasing order.
/// </summary>
vector<int> LeetCodeArray::longestCommonSubsequence(vector<vector<int>>& arrays)
{
    unordered_map<int, int> num_map;
    for (size_t i = 0; i < arrays.size(); i++)
    {
        for (size_t j = 0; j < arrays[i].size(); j++)
        {
            num_map[arrays[i][j]]++;
        }
    }
    vector<int> result;
    for (size_t i = 0; i < arrays[0].size(); i++)
    {
        if (num_map[arrays[0][i]] == arrays.size())
        {
            result.push_back(arrays[0][i]);
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2007. Find Original Array From Doubled Array
///                                                                 
/// Medium
///
/// An integer array original is transformed into a doubled array changed 
/// by appending twice the value of every element in original, and then 
/// randomly shuffling the resulting array.
///
/// Given an array changed, return original if changed is a doubled array. 
/// If changed is not a doubled array, return an empty array. The elements 
/// in original may be returned in any order.
/// 
/// Example 1:
/// Input: changed = [1,3,4,2,6,8]
/// Output: [1,3,4]
/// Explanation: One possible original array could be [1,3,4]:
/// - Twice the value of 1 is 1 * 2 = 2.
/// - Twice the value of 3 is 3 * 2 = 6.
/// - Twice the value of 4 is 4 * 2 = 8.
/// Other original arrays could be [4,3,1] or [3,1,4].
///
/// Example 2:
/// Input: changed = [6,3,0,1]
/// Output: []
/// Explanation: changed is not a doubled array.
///
/// Example 3:
/// Input: changed = [1]
/// Output: []
/// Explanation: changed is not a doubled array.
/// 
/// Constraints:
/// 1. 1 <= changed.length <= 10^5
/// 2. 0 <= changed[i] <= 10^5
/// </summary>
vector<int> LeetCodeArray::findOriginalArray(vector<int>& changed)
{
    map<int, int> num_map;
    for (size_t i = 0; i < changed.size(); i++)
    {
        num_map[changed[i]]++;
    }
    vector<int> result;
    while (!num_map.empty())
    {
        int max_val = num_map.rbegin()->first;
        num_map[max_val]--;
        if (num_map[max_val] == 0) num_map.erase(max_val);
        int val = max_val / 2;
        if (val * 2 != max_val || num_map[val] == 0) return vector<int>();
        num_map[val]--;
        if (num_map[val] == 0) num_map.erase(val);
        result.push_back(val);
    }
    return result;
}

/// <summary>
/// Leet Code 2099. Find Subsequence of Length K With the Largest Sum 
///                                                                 
/// Easy
///
/// You are given an integer array nums and an integer k. You want to find 
/// a subsequence of nums of length k that has the largest sum.
///
/// Return any such subsequence as an integer array of length k.
///
/// A subsequence is an array that can be derived from another array by 
/// deleting some or no elements without changing the order of the 
/// remaining elements.
///
/// Example 1:
/// Input: nums = [2,1,3,3], k = 2
/// Output: [3,3]
/// Explanation:
/// The subsequence has the largest sum of 3 + 3 = 6.
///
/// Example 2:
/// Input: nums = [-1,-2,3,4], k = 3
/// Output: [-1,3,4]
/// Explanation: 
/// The subsequence has the largest sum of -1 + 3 + 4 = 6.
///
/// Example 3:
/// Input: nums = [3,4,3,3], k = 2
/// Output: [3,4]
/// Explanation:
/// The subsequence has the largest sum of 3 + 4 = 7. 
/// Another possible subsequence is [4, 3].
///
/// Constraints:
/// 1. 1 <= nums.length <= 1000
/// 2. -10^5 <= nums[i] <= 10^5
/// 3. 1 <= k <= nums.length
/// </summary>
vector<int> LeetCodeArray::maxSubsequence(vector<int>& nums, int k)
{
    vector<int> temp = nums;
    sort(temp.begin(), temp.end());
    unordered_map<int, int> large_num;
    for (size_t i = temp.size() - k; i < temp.size(); i++)
    {
        large_num[temp[i]]++;
    }
    vector<int> result;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (large_num.count(nums[i]) > 0)
        {
            large_num[nums[i]]--;
            if (large_num[nums[i]] == 0) large_num.erase(nums[i]);
            result.push_back(nums[i]);
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2103. Rings and Rods
///                                                                 
/// Easy
///
/// There are n rings and each ring is either red, green, or blue. The 
/// rings are distributed across ten rods labeled from 0 to 9.
///
/// You are given a string rings of length 2n that describes the n rings 
/// that are placed onto the rods. Every two characters in rings forms 
/// a color-position pair that is used to describe each ring where:
///
/// The first character of the ith pair denotes the ith ring's color 
/// ('R', 'G', 'B').
/// The second character of the ith pair denotes the rod that the ith 
/// ring is placed on ('0' to '9').
/// For example, "R3G2B1" describes n == 3 rings: a red ring placed 
/// onto the rod labeled 3, a green ring placed onto the rod labeled 2, 
/// and a blue ring placed onto the rod labeled 1.
///
/// Return the number of rods that have all three colors of rings on them.
/// 
/// Example 1:
/// Input: rings = "B0B6G0R6R0R6G9"
/// Output: 1 
/// Explanation: 
/// - The rod labeled 0 holds 3 rings with all colors: red, green, and 
///   blue.
/// - The rod labeled 6 holds 3 rings, but it only has red and blue.
/// - The rod labeled 9 holds only a green ring.
/// Thus, the number of rods with all three colors is 1.
///
/// Example 2:
/// Input: rings = "B0R0G0R9R0B0G0"
/// Output: 1
/// Explanation: 
/// - The rod labeled 0 holds 6 rings with all colors: red, green, and 
///   blue.
/// - The rod labeled 9 holds only a red ring.
/// Thus, the number of rods with all three colors is 1.
///
/// Example 3:
/// Input: rings = "G4"
/// Output: 0
/// Explanation: 
/// Only one ring is given. Thus, no rods have all three colors.
///
/// Constraints:
/// 1. rings.length == 2 * n
/// 2. 1 <= n <= 100
/// 3. rings[i] where i is even is either 'R', 'G', or 'B' (0-indexed).
/// 4. rings[i] where i is odd is a digit from '0' to '9' (0-indexed).
/// </summary>
int LeetCodeArray::countPoints(string rings)
{
    vector<int>rod(10);
    for (size_t i = 0; i < rings.size(); i += 2)
    {
        int index = rings[i + 1] - '0';
        if (rings[i] == 'R') rod[index] |= 1;
        else if (rings[i] == 'G') rod[index] |= 2;
        else rod[index] |= 4;
    }
    int result = 0;
    for (size_t i = 0; i < rod.size(); i++)
    {
        if (rod[i] == 7) result++;
    }
    return result;
}

/// <summary>
/// Leet Code 1983. Widest Pair of Indices With Equal Range Sum
///                                                                 
/// Medium
///
/// You are given two 0-indexed binary arrays nums1 and nums2. Find the 
/// widest pair of indices (i, j) such that i <= j and nums1[i] + 
/// nums1[i+1] + ... + nums1[j] == nums2[i] + nums2[i+1] + ... + nums2[j].
///
/// The widest pair of indices is the pair with the largest distance 
/// between i and j. The distance between a pair of indices is defined as 
/// j - i + 1.
///
/// Return the distance of the widest pair of indices. If no pair of 
/// indices meets the conditions, return 0.
///
/// Example 1:
/// Input: nums1 = [1,1,0,1], nums2 = [0,1,1,0]
/// Output: 3
/// Explanation:
/// If i = 1 and j = 3:
/// nums1[1] + nums1[2] + nums1[3] = 1 + 0 + 1 = 2.
/// nums2[1] + nums2[2] + nums2[3] = 1 + 1 + 0 = 2.
/// The distance between i and j is j - i + 1 = 3 - 1 + 1 = 3.
///
/// Example 2:
/// Input: nums1 = [0,1], nums2 = [1,1]
/// Output: 1
/// Explanation:
/// If i = 1 and j = 1:
/// nums1[1] = 1.
/// nums2[1] = 1.
/// The distance between i and j is j - i + 1 = 1 - 1 + 1 = 1.
///
/// Example 3:
/// Input: nums1 = [0], nums2 = [1]
/// Output: 0
/// Explanation:
/// There are no pairs of indices that meet the requirements.
///
/// Constraints:
/// 1. n == nums1.length == nums2.length
/// 2. 1 <= n <= 10^5
/// 3. nums1[i] is either 0 or 1.
/// 4. nums2[i] is either 0 or 1.
/// </summary>
int LeetCodeArray::widestPairOfIndices(vector<int>& nums1, vector<int>& nums2)
{
    unordered_map<int, int> dp;
    dp[0] = -1;
    int sum = 0;
    int result = 0;
    for (int i = 0; i < (int)nums1.size(); i++)
    {
        sum += nums1[i];
        sum -= nums2[i];
        if (dp.count(sum) == 0)
        {
            dp[sum] = i;
        }
        result = max(result, i - dp[sum]);
    }
    return result;
}

/// <summary>
/// Leet Code 2012. Sum of Beauty in the Array
///                                                                 
/// Medium
///
/// You are given a 0-indexed integer array nums. For each index i 
/// (1 <= i <= nums.length - 2) the beauty of nums[i] equals:
/// 2, if nums[j] < nums[i] < nums[k], for all 0 <= j < i and for 
/// all i < k <= nums.length - 1.
/// 1, if nums[i - 1] < nums[i] < nums[i + 1], and the previous 
/// condition is not satisfied.
/// 0, if none of the previous conditions holds.
/// Return the sum of beauty of all nums[i] 
/// where 1 <= i <= nums.length - 2.
/// 
/// Example 1:
/// Input: nums = [1,2,3]
/// Output: 2
/// Explanation: For each index i in the range 1 <= i <= 1:
/// - The beauty of nums[1] equals 2.
///
/// Example 2:
/// Input: nums = [2,4,6,4]
/// Output: 1
/// Explanation: For each index i in the range 1 <= i <= 2:
/// - The beauty of nums[1] equals 1.
/// - The beauty of nums[2] equals 0.
///
/// Example 3:
/// Input: nums = [3,2,1]
/// Output: 0
/// Explanation: For each index i in the range 1 <= i <= 1:
/// - The beauty of nums[1] equals 0.
///
/// Constraints:
/// 1. 3 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^5
/// </summary>
int LeetCodeArray::sumOfBeauties(vector<int>& nums)
{
    vector<int> dp(nums.size());
    int prev = INT_MIN;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] > prev) dp[i] += 1;
        prev = max(prev, nums[i]);
    }
    prev = INT_MAX;
    for (int i = (int)nums.size() - 1; i >= 0; i--)
    {
        if (nums[i] < prev) dp[i] += 1;
        prev = min(prev, nums[i]);
    }
    int result = 0;
    for (size_t i = 1; i < nums.size() - 1; i++)
    {
        if (dp[i] == 2) result += 2;
        else if (nums[i - 1] < nums[i] && nums[i] < nums[i + 1])
        {
            result += 1;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2055. Plates Between Candles
///                                                                 
/// Medium
///
/// There is a long table with a line of plates and candles arranged on 
/// top of it. You are given a 0-indexed string s consisting of 
/// characters '*' and '|' only, where a '*' represents a plate and 
/// a '|' represents a candle.
///
/// You are also given a 0-indexed 2D integer array queries where 
/// queries[i] = [lefti, righti] denotes the substring s[lefti...righti] 
/// (inclusive). For each query, you need to find the number of plates 
/// between candles that are in the substring. A plate is considered 
/// between candles if there is at least one candle to its left and at 
/// least one candle to its right in the substring.
///
/// For example, s = "||**||**|*", and a query [3, 8] denotes the 
/// substring "*||**|". The number of plates between candles in this 
/// substring is 2, as each of the two plates has at least one candle 
/// in the substring to its left and right.
/// Return an integer array answer where answer[i] is the answer to the 
/// ith query.
///
/// Example 1:
/// Input: s = "**|**|***|", queries = [[2,5],[5,9]]
/// Output: [2,3]
/// Explanation:
/// - queries[0] has two plates between candles.
/// - queries[1] has three plates between candles.
///
/// Example 2:
/// Input: s = "***|**|*****|**||**|*", 
/// queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]
/// Output: [9,0,0,0,0]
/// Explanation:
/// - queries[0] has nine plates between candles.
/// - The other queries have zero plates between candles.
/// Constraints:
/// 1. 3 <= s.length <= 10^5
/// 2. s consists of '*' and '|' characters.
/// 3. 1 <= queries.length <= 10^5
/// 4. queries[i].length == 2
/// 5. 0 <= lefti <= righti < s.length
/// </summary>
vector<int> LeetCodeArray::platesBetweenCandles(string s, vector<vector<int>>& queries)
{
    vector<int> plates, candles;
    for (size_t i = 0; i < s.size(); i++)
    {
        if (s[i] == '*') plates.push_back(i);
        else candles.push_back(i);
    }
    vector<int> result = vector<int>(queries.size());
    for (size_t i = 0; i < queries.size(); i++)
    {
        int first = lower_bound(candles.begin(), candles.end(), queries[i][0]) - candles.begin();
        int second = upper_bound(candles.begin(), candles.end(), queries[i][1]) - candles.begin() - 1;
        if (first >= second)
        {
            result[i] = 0;
            continue;
        }
        first = lower_bound(plates.begin(), plates.end(), candles[first]) - plates.begin();
        second = upper_bound(plates.begin(), plates.end(), candles[second]) - plates.begin() - 1;
        if (first > second)
        {
            result[i] = 0;
            continue;
        }
        result[i] = second - first + 1;
    }
    return result;
}

/// <summary>
/// Leet Code 2028. Find Missing Observations
///                                                                 
/// Medium
///
/// You have observations of n + m 6-sided dice rolls with each face 
/// numbered from 1 to 6. n of the observations went missing, and you 
/// only have the observations of m rolls. Fortunately, you have also 
/// calculated the average value of the n + m rolls.
///
/// You are given an integer array rolls of length m where rolls[i] 
/// is the value of the ith observation. You are also given the two 
/// integers mean and n.
///
/// Return an array of length n containing the missing observations 
/// such that the average value of the n + m rolls is exactly mean. 
/// If there are multiple valid answers, return any of them. If no 
/// such array exists, return an empty array.
///
/// The average value of a set of k numbers is the sum of the 
/// numbers divided by k.
/// 
/// Note that mean is an integer, so the sum of the n + m rolls should 
/// be divisible by n + m.
/// 
/// Example 1:
/// Input: rolls = [3,2,4,3], mean = 4, n = 2
/// Output: [6,6]
/// Explanation: The mean of all n + m rolls is 
/// (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4.
///
/// Example 2:
/// Input: rolls = [1,5,6], mean = 3, n = 4
/// Output: [2,3,2,2]
/// Explanation: The mean of all n + m rolls is 
/// (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3.
///
/// Example 3:
/// Input: rolls = [1,2,3,4], mean = 6, n = 4
/// Output: []
/// Explanation: It is impossible for the mean to be 6 no matter 
/// what the 4 missing rolls are.
///
/// Example 4:
/// Input: rolls = [1], mean = 3, n = 1
/// Output: [5]
/// Explanation: The mean of all n + m rolls is (1 + 5) / 2 = 3.
/// 
/// Constraints:
/// 1. m == rolls.length
/// 2. 1 <= n, m <= 10^5
/// 3. 1 <= rolls[i], mean <= 6
/// </summary>
vector<int> LeetCodeArray::missingRolls(vector<int>& rolls, int mean, int n)
{
    int sum = 0;
    for (size_t i = 0; i < rolls.size(); i++)
    {
        sum += rolls[i];
    }
    int diff = mean * (rolls.size() + n) - sum;
    vector<int> result;
    if (diff < 1 * n || diff > 6 * n)
    {
        return result;
    }
    int dividend = diff / n;
    int remainder = diff % n;
    for (int i = 0; i < n; i++)
    {
        result.push_back(dividend + (remainder > 0 ? 1 : 0));
        remainder -= (remainder > 0 ? 1 : 0);
    }
    return result;
}

/// <summary>
/// Leet Code 2091. Removing Minimum and Maximum From Array
///                                                                 
/// Medium
///
/// You are given a 0-indexed array of distinct integers nums.
///
/// There is an element in nums that has the lowest value and an element 
/// that has the highest value. We call them the minimum and maximum 
/// respectively. Your goal is to remove both these elements from the 
/// array.
///
/// A deletion is defined as either removing an element from the front of 
/// the array or removing an element from the back of the array.
///
/// Return the minimum number of deletions it would take to remove both 
/// the minimum and maximum element from the array.
/// 
/// Example 1:
///
/// Input: nums = [2,10,7,5,4,1,8,6]
/// Output: 5
/// Explanation: 
/// The minimum element in the array is nums[5], which is 1.
/// The maximum element in the array is nums[1], which is 10.
/// We can remove both the minimum and maximum by removing 2 elements from 
/// the front and 3 elements from the back.
/// This results in 2 + 3 = 5 deletions, which is the minimum number 
/// possible.
///
/// Example 2:
/// Input: nums = [0,-4,19,1,8,-2,-3,5]
/// Output: 3
/// Explanation: 
/// The minimum element in the array is nums[1], which is -4.
/// The maximum element in the array is nums[2], which is 19.
/// We can remove both the minimum and maximum by removing 3 elements 
/// from the front.
/// This results in only 3 deletions, which is the minimum number possible.
///
/// Example 3:
/// Input: nums = [101]
/// Output: 1
/// Explanation:  
/// There is only one element in the array, which makes it both the 
/// minimum and maximum element.
/// We can remove it with 1 deletion.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. -10^5 <= nums[i] <= 10^5
/// 3. The integers in nums are distinct.
/// </summary>
int LeetCodeArray::minimumDeletions(vector<int>& nums)
{
    int min_index = 0;
    int max_index = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] < nums[min_index])
        {
            min_index = i;
        }
        if (nums[i] > nums[max_index])
        {
            max_index = i;
        }
    }
    if (min_index > max_index) std::swap(min_index, max_index);
    int result = max_index + 1;
    result = min(result, (int)nums.size() - min_index);
    result = min(result, (int)nums.size() - max_index + min_index + 1);
    return result;
}

/// <summary>
/// Leet Code 2113. Elements in Array After Removing and Replacing Elements
///                                                                 
/// Medium
///
/// You are given a 0-indexed integer array nums. Initially on minute 0, 
/// the array is unchanged. Every minute, the leftmost element in nums is 
/// removed until no elements remain. Then, every minute, one element is 
/// appended to the end of nums, in the order they were removed in, until 
/// the original array is restored. This process repeats indefinitely.
///
/// For example, the array [0,1,2] would change as follows: [0,1,2] -> 
/// [1,2] -> [2] -> [] -> [0] -> [0,1] -> [0,1,2] -> [1,2] -> [2] -> 
/// [] -> [0] -> [0,1] -> [0,1,2] -> ...
/// You are also given a 2D integer array queries of size n where 
/// queries[j] = [timej, indexj]. The answer to the jth query is:
///
/// nums[indexj] if indexj < nums.length at minute timej
/// -1 if indexj >= nums.length at minute timej
/// Return an integer array ans of size n where ans[j] is the answer 
/// to the jth query.
/// 
/// Example 1:
/// Input: nums = [0,1,2], queries = [[0,2],[2,0],[3,2],[5,0]]
/// Output: [2,2,-1,0]
/// Explanation:
/// Minute 0: [0,1,2] - All elements are in the nums.
/// Minute 1: [1,2]   - The leftmost element, 0, is removed.
/// Minute 2: [2]     - The leftmost element, 1, is removed.
/// Minute 3: []      - The leftmost element, 2, is removed.
/// Minute 4: [0]     - 0 is added to the end of nums.
/// Minute 5: [0,1]   - 1 is added to the end of nums.
///
/// At minute 0, nums[2] is 2.
/// At minute 2, nums[0] is 2.
/// At minute 3, nums[2] does not exist.
/// At minute 5, nums[0] is 0.
///
/// Example 2:
/// Input: nums = [2], queries = [[0,0],[1,0],[2,0],[3,0]]
/// Output: [2,-1,2,-1]
/// Minute 0: [2] - All elements are in the nums.
/// Minute 1: []  - The leftmost element, 2, is removed.
/// Minute 2: [2] - 2 is added to the end of nums.
/// Minute 3: []  - The leftmost element, 2, is removed.
///
/// At minute 0, nums[0] is 2.
/// At minute 1, nums[0] does not exist.
/// At minute 2, nums[0] is 2.
/// At minute 3, nums[0] does not exist.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 100
/// 2. 0 <= nums[i] <= 100
/// 3. n == queries.length
/// 4. 1 <= n <= 10^5
/// 5. queries[j].length == 2
/// 6. 0 <= timej <= 10^5
/// 7. 0 <= indexj < nums.length
/// </summary>
vector<int> LeetCodeArray::elementInNums(vector<int>& nums, vector<vector<int>>& queries)
{
    int n = nums.size();
    vector<int> result(queries.size());

    for (size_t i = 0; i < queries.size(); i++)
    {
        int round = queries[i][0] % (2 * n);
        int size = 0;
        if (round <= n)
        {
            if (round + queries[i][1] < n)
            {
                result[i] = nums[round + queries[i][1]];
            }
            else
            {
                result[i] = -1;
            }
        }
        else
        {
            if (queries[i][1] < round - n)
            {
                result[i] = nums[queries[i][1]];
            }
            else
            {
                result[i] = -1;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2100. Find Good Days to Rob the Bank
///                                                                 
/// Medium
///
/// You and a gang of thieves are planning on robbing a bank. You are 
/// given a 0-indexed integer array security, where security[i] is the 
/// number of guards on duty on the ith day. The days are numbered 
/// starting from 0. You are also given an integer time.
///
/// The ith day is a good day to rob the bank if:
/// There are at least time days before and after the ith day,
/// The number of guards at the bank for the time days before i 
/// are non-increasing, and
/// The number of guards at the bank for the time days after i are 
/// non-decreasing.
/// More formally, this means day i is a good day to rob the bank 
/// if and only if security[i - time] >= security[i - time + 1] 
/// >= ... >= security[i] <= ... <= security[i + time - 1] <= 
/// security[i + time].
///
/// Return a list of all days (0-indexed) that are good days to rob the 
/// bank. The order that the days are returned in does not matter.
///
/// Example 1:
/// Input: security = [5,3,3,3,5,6,2], time = 2
/// Output: [2,3]
/// Explanation:
/// On day 2, we have security[0] >= security[1] >= security[2] 
/// <= security[3] <= security[4].
/// On day 3, we have security[1] >= security[2] >= security[3] 
/// <= security[4] <= security[5].
/// No other days satisfy this condition, so days 2 and 3 are 
/// the only good days to rob the bank.
///
/// Example 2:
/// Input: security = [1,1,1,1,1], time = 0
/// Output: [0,1,2,3,4]
/// Explanation:
/// Since time equals 0, every day is a good day to rob the bank, 
/// so return every day.
///
/// Example 3:
/// Input: security = [1,2,3,4,5,6], time = 2
/// Output: []
/// Explanation:
/// No day has 2 days before it that have a non-increasing number 
/// of guards.
/// Thus, no day is a good day to rob the bank, so return an empty list.
///
/// Constraints:
/// 1. 1 <= security.length <= 10^5
/// 2. 0 <= security[i], time <= 10^5
/// </summary>
vector<int> LeetCodeArray::goodDaysToRobBank(vector<int>& security, int time)
{
    vector<vector<int>> dp(security.size(), vector<int>(2));
    for (size_t i = 0; i < security.size(); i++)
    {
        if (i == 0)
        {
            dp[i][0] = 0;
            dp[i][1] = 0;
        }
        else if (security[i] < security[i - 1])
        {
            dp[i][0] = dp[i - 1][0] + 1;
            dp[i][1] = 0;
        }
        else if (security[i] > security[i - 1])
        {
            dp[i][0] = 0;
            dp[i][1] = dp[i - 1][1] + 1;
        }
        else
        {
            dp[i][0] = dp[i - 1][0] + 1;
            dp[i][1] = dp[i - 1][1] + 1;
        }
    }
    vector<int> result;
    for (int i = time; i < (int)security.size() - time; i++)
    {
        if (dp[i-time][0] + time == dp[i][0] && dp[i][1] + time == dp[i+time][1])
        {
            result.push_back(i);
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2024. Maximize the Confusion of an Exam
///                                                                 
/// Medium
///
/// A teacher is writing a test with n true/false questions, with 'T' 
/// denoting true and 'F' denoting false. He wants to confuse the 
/// students by maximizing the number of consecutive questions with 
/// the same answer (multiple trues or multiple falses in a row).
///
/// You are given a string answerKey, where answerKey[i] is the 
/// original answer to the ith question. In addition, you are given 
/// an integer k, the maximum number of times you may perform the 
/// following operation:
///
/// Change the answer key for any question to 'T' or 'F' (i.e., 
/// set answerKey[i] to 'T' or 'F').
/// Return the maximum number of consecutive 'T's or 'F's in the 
/// answer key after performing the operation at most k times.
/// 
/// Example 1:
/// Input: answerKey = "TTFF", k = 2
/// Output: 4
/// Explanation: We can replace both the 'F's with 'T's to make 
/// answerKey = "TTTT".
/// There are four consecutive 'T's.
///
/// Example 2:
/// Input: answerKey = "TFFT", k = 1
/// Output: 3
/// Explanation: We can replace the first 'T' with an 'F' to make 
/// answerKey = "FFFT".
/// Alternatively, we can replace the second 'T' with an 'F' to make 
/// answerKey = "TFFF".
/// In both cases, there are three consecutive 'F's.
///
/// Example 3:
/// Input: answerKey = "TTFTTFTT", k = 1
/// Output: 5
/// Explanation: We can replace the first 'F' to make 
/// answerKey = "TTTTTFTT"
/// Alternatively, we can replace the second 'F' to make 
/// answerKey = "TTFTTTTT". 
/// In both cases, there are five consecutive 'T's.
///
/// Constraints:
/// 1. n == answerKey.length
/// 2. 1 <= n <= 5 * 10^4
/// 3. answerKey[i] is either 'T' or 'F'
/// 4. 1 <= k <= n
/// </summary>
int LeetCodeArray::maxConsecutiveAnswers(string answerKey, int k)
{
    vector<int> T = { -1 }, F = { -1 };
    int result = 0;
    for (int i = 0; i < (int)answerKey.size(); i++)
    {
        if (answerKey[i] == 'T') T.push_back(i);
        else F.push_back(i);
        if ((int)F.size() > k)
        {
            result = max(result, i - F[F.size() - 1 - k]);
        }
        else
        {
            result = max(result, i - F[0]);
        }
        if ((int)T.size() > k)
        {
            result = max(result, i - T[T.size() - 1 - k]);
        }
        else
        {
            result = max(result, i - T[0]);
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2031. Count Subarrays With More Ones Than Zeros
///                                                                 
/// Medium
///
/// You are given a binary array nums containing only the integers 0 
/// and 1. Return the number of subarrays in nums that have more 1's 
/// than 0's. Since the answer may be very large, return it modulo 
/// 10^9 + 7.
///
/// A subarray is a contiguous sequence of elements within an array.
/// 
/// Example 1:
/// Input: nums = [0,1,1,0,1]
/// Output: 9
/// Explanation:
/// The subarrays of size 1 that have more ones than zeros 
/// are: [1], [1], [1]
/// The subarrays of size 2 that have more ones than zeros 
/// are: [1,1]
/// The subarrays of size 3 that have more ones than zeros 
/// are: [0,1,1], [1,1,0], [1,0,1]
/// The subarrays of size 4 that have more ones than zeros 
/// are: [1,1,0,1]
/// The subarrays of size 5 that have more ones than zeros 
/// are: [0,1,1,0,1]
///
/// Example 2:
/// Input: nums = [0]
/// Output: 0
/// Explanation:
/// No subarrays have more ones than zeros.
/// Example 3:
/// Input: nums = [1]
/// Output: 1
/// Explanation:
/// The subarrays of size 1 that have more ones than zeros are: [1]
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 1
/// </summary>
int LeetCodeArray::subarraysWithMoreZerosThanOnes(vector<int>& nums)
{
    int sum = 0;
    vector<int> dp(2 * nums.size() + 1);
    int index = nums.size();
    dp[index] = 1;
    int result = 0;
    int M = 1000000007;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] == 1)
        {
            sum += dp[index];
            index++;
            dp[index]++;
        }
        else
        {
            index--;
            sum -= dp[index];
            dp[index]++;
        }
        result = (result + sum) % M;
    }
    return result;
}


/// <summary>
/// Leet Code 2063. Vowels of All Substrings
///                                                                 
/// Medium
///
/// Given a string word, return the sum of the number of vowels ('a', 
/// 'e', 'i', 'o', and 'u') in every substring of word.
///
/// A substring is a contiguous (non-empty) sequence of characters 
/// within a string.
///
/// Note: Due to the large constraints, the answer may not fit in a 
/// signed 32-bit integer. Please be careful during the calculations.
///
/// Example 1:
/// Input: word = "aba"
/// Output: 6
/// Explanation: 
/// All possible substrings are: "a", "ab", "aba", "b", "ba", and "a".
/// - "b" has 0 vowels in it
/// - "a", "ab", "ba", and "a" have 1 vowel each
/// - "aba" has 2 vowels in it
/// Hence, the total sum of vowels = 0 + 1 + 1 + 1 + 1 + 2 = 6. 
///
/// Example 2:
/// Input: word = "abc"
/// Output: 3
/// Explanation: 
/// All possible substrings are: "a", "ab", "abc", "b", "bc", and "c".
/// - "a", "ab", and "abc" have 1 vowel each
/// - "b", "bc", and "c" have 0 vowels each
/// Hence, the total sum of vowels = 1 + 1 + 1 + 0 + 0 + 0 = 3. 
///
/// Example 3:
/// Input: word = "ltcd"
/// Output: 0
/// Explanation: There are no vowels in any substring of "ltcd".
///
/// Example 4:
/// Input: word = "noosabasboosa"
/// Output: 237
/// Explanation: There are a total of 237 vowels in all the substrings.
/// 
/// Constraints:
/// 1. 1 <= word.length <= 10^5
/// 2. word consists of lowercase English letters.
/// </summary>
long long LeetCodeArray::countVowels(string word)
{
    long long result = 0;
    long long sum = 0;
    for (size_t i = 0; i < word.size(); i++)
    {
        if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')
        {
            sum += (long long)i + (long long)1;
        }
        result += sum;
    }
    return result;
}

/// <summary>
/// Leet Code 2110. Number of Smooth Descent Periods of a Stock
///                                                                 
/// Medium
///
/// You are given an integer array prices representing the daily price 
/// history of a stock, where prices[i] is the stock price on the ith day.
///
/// A smooth descent period of a stock consists of one or more contiguous 
/// days such that the price on each day is lower than the price on the 
/// preceding day by exactly 1. The first day of the period is exempted 
/// from this rule.
///
/// Return the number of smooth descent periods.
///
/// Example 1:
/// Input: prices = [3,2,1,4]
/// Output: 7
/// Explanation: There are 7 smooth descent periods:
/// [3], [2], [1], [4], [3,2], [2,1], and [3,2,1]
/// Note that a period with one day is a smooth descent period by the 
/// definition.
///
/// Example 2:
/// Input: prices = [8,6,7,7]
/// Output: 4
/// Explanation: There are 4 smooth descent periods: [8], [6], [7], and [7]
/// Note that [8,6] is not a smooth descent period as 8 - 6 != 1.
///
/// Example 3:
/// Input: prices = [1]
/// Output: 1
/// Explanation: There is 1 smooth descent period: [1]
///
/// Constraints:
/// 1. 1 <= prices.length <= 10^5
/// 2. 1 <= prices[i] <= 10^5
/// </summary>
long long LeetCodeArray::getDescentPeriods(vector<int>& prices)
{
    long long result = 0;
    int count = 0;
    for (size_t i = 0; i < prices.size(); i++)
    {
        if (i == 0 || prices[i] + 1 != prices[i - 1])
        {
            count = 1;
        }
        else
        {
            count++;
        }
        result += (long long) count;
    }
    return result;
}

/// <summary>
/// Leet Code 2033. Minimum Operations to Make a Uni-Value Grid
///                                                                 
/// Medium
///
/// You are given a 2D integer grid of size m x n and an integer x. In one 
/// operation, you can add x to or subtract x from any element in the grid.
///
/// A uni-value grid is a grid where all the elements of it are equal.
/// Return the minimum number of operations to make the grid uni-value. 
/// If it is not possible, return -1.
///
/// Example 1:
/// Input: grid = [[2,4],[6,8]], x = 2
/// Output: 4
/// Explanation: We can make every element equal to 4 by doing the following: 
/// - Add x to 2 once.
/// - Subtract x from 6 once.
/// - Subtract x from 8 twice.
/// A total of 4 operations were used.
///
/// Example 2:
/// Input: grid = [[1,5],[2,3]], x = 1
/// Output: 5
/// Explanation: We can make every element equal to 3.
///
/// Example 3:
/// Input: grid = [[1,2],[3,4]], x = 2
/// Output: -1
/// Explanation: It is impossible to make every element equal.
///
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 1 <= m, n <= 10^5
/// 4. 1 <= m * n <= 10^5
/// 5. 1 <= x, grid[i][j] <= 10^4
/// </summary>
int LeetCodeArray::minOperations(vector<vector<int>>& grid, int x)
{
    vector<int> arr(grid.size() * grid[0].size());

    for (size_t i = 0; i < grid.size(); i++)
    {
        for (size_t j = 0; j < grid[0].size(); j++)
        {
            arr[i * grid[0].size() + j] = grid[i][j];
        }
    }
    sort(arr.begin(), arr.end());
    vector<vector<int>>dp(arr.size(), vector<int>(2));
    int result = INT_MAX;
    for (size_t i = 0; i < arr.size(); i++)
    {
        if (i == 0)
        {
            dp[i][0] = 0;
        }
        else if (arr[i] == arr[i - 1])
        {
            dp[i][0] = dp[i - 1][0];
        }
        else if ((arr[i] - arr[i - 1]) % x != 0)
        {
            return -1;
        }
        else
        {
            dp[i][0] = dp[i - 1][0] + (arr[i] - arr[i - 1]) / x * i;
        }
    }

    for (int i = arr.size() - 1; i >= 0; i--)
    {
        if (i == arr.size() - 1)
        {
            dp[i][1] = 0;
        }
        else if (arr[i] == arr[i + 1])
        {
            dp[i][1] = dp[i + 1][1];
        }
        else
        {
            dp[i][1] = dp[i + 1][1] + (arr[i + 1] - arr[i]) / x * (arr.size() - 1 - i);
        }
        result = min(result, dp[i][0] + dp[i][1]);
    }
    return result;
}

/// <summary>
/// Leet Code 2120. Execution of All Suffix Instructions Staying in a Grid
///                                                                 
/// Medium
///
/// There is an n x n grid, with the top-left cell at (0, 0) and the 
/// bottom-right cell at (n - 1, n - 1). You are given the integer n and 
/// an integer array startPos where startPos = [startrow, startcol] 
/// indicates that a robot is initially at cell (startrow, startcol).
///
/// You are also given a 0-indexed string s of length m where s[i] is 
/// the ith instruction for the robot: 'L' (move left), 'R' (move right), 
/// 'U' (move up), and 'D' (move down).
///
/// The robot can begin executing from any ith instruction in s. It 
/// executes the instructions one by one towards the end of s but it 
/// stops if either of these conditions is met:
///
/// The next instruction will move the robot off the grid.
/// There are no more instructions left to execute.
/// Return an array answer of length m where answer[i] is the number of 
/// instructions the robot can execute if the robot begins executing 
/// from the ith instruction in s.
/// 
/// Example 1:
/// Input: n = 3, startPos = [0,1], s = "RRDDLU"
/// Output: [1,5,4,3,1,0]
/// Explanation: Starting from startPos and beginning execution from the 
/// ith instruction:
/// - 0th: "RRDDLU". Only one instruction "R" can be executed before it 
///   moves off the grid.
/// - 1st:  "RDDLU". All five instructions can be executed while it stays 
///   in the grid and ends at (1, 1).
/// - 2nd:   "DDLU". All four instructions can be executed while it 
///   stays in the grid and ends at (1, 0).
/// - 3rd:    "DLU". All three instructions can be executed while it 
///   stays in the grid and ends at (0, 0).
/// - 4th:     "LU". Only one instruction "L" can be executed 
///   before it moves off the grid.
/// - 5th:      "U". If moving up, it would move off the grid.
///
/// Example 2:
/// Input: n = 2, startPos = [1,1], s = "LURD"
/// Output: [4,1,0,0]
/// Explanation:
/// - 0th: "LURD".
/// - 1st:  "URD".
/// - 2nd:   "RD".
/// - 3rd:    "D".
///
/// Example 3:
/// Input: n = 1, startPos = [0,0], s = "LRUD"
/// Output: [0,0,0,0]
/// Explanation: No matter which instruction the robot begins execution 
/// from, it would move off the grid.
///
/// Constraints:
/// 1. m == s.length
/// 2. 1 <= n, m <= 500
/// 3. startPos.length == 2
/// 4. 0 <= startrow, startcol < n
/// 5. s consists of 'L', 'R', 'U', and 'D'.
/// </summary>
vector<int> LeetCodeArray::executeInstructions(int n, vector<int>& startPos, string s)
{
    int h = 1000, v = 1000, m = s.size();
    vector<int> hor(2001, m), ver(2001, m), res(m);
    for (int i = m - 1; i >= 0; --i)
    {
        hor[h] = ver[v] = i;
        h += s[i] == 'L' ? 1 : s[i] == 'R' ? -1 : 0;
        v += s[i] == 'U' ? 1 : s[i] == 'D' ? -1 : 0;
        res[i] = min({ m, hor[h - startPos[1] - 1], hor[h - startPos[1] + n], ver[v - startPos[0] - 1], ver[v - startPos[0] + n] }) - i;
    }
    return res;
}

/// <summary>
/// Leet Code 2122. Recover the Original Array
///                                                                 
/// Hard
///
/// Alice had a 0-indexed array arr consisting of n positive integers. 
/// She chose an arbitrary positive integer k and created two new 
/// 0-indexed integer arrays lower and higher in the following manner:
///  
/// lower[i] = arr[i] - k, for every index i where 0 <= i < n
/// higher[i] = arr[i] + k, for every index i where 0 <= i < n
/// Unfortunately, Alice lost all three arrays. However, she remembers 
/// the integers that were present in the arrays lower and higher, but 
/// not the array each integer belonged to. Help Alice and recover the 
/// original array.
///
/// Given an array nums consisting of 2n integers, where exactly n of 
/// the integers were present in lower and the remaining in higher, 
/// return the original array arr. In case the answer is not unique, 
/// return any valid array.
///
/// Note: The test cases are generated such that there exists at least 
/// one valid array arr.
///
/// Example 1:
/// Input: nums = [2,10,6,4,8,12]
/// Output: [3,7,11]
/// Explanation:
/// If arr = [3,7,11] and k = 1, we get lower = [2,6,10] and 
/// higher = [4,8,12].
/// Combining lower and higher gives us [2,6,10,4,8,12], which is a 
/// permutation of nums.
/// Another valid possibility is that arr = [5,7,9] and k = 3. In that 
/// case, lower = [2,4,6] and higher = [8,10,12]. 
///
/// Example 2:
/// Input: nums = [1,1,3,3]
/// Output: [2,2]
/// Explanation:
/// If arr = [2,2] and k = 1, we get lower = [1,1] and higher = [3,3].
/// Combining lower and higher gives us [1,1,3,3], which is equal to nums.
/// Note that arr cannot be [1,3] because in that case, the only possible 
/// way to obtain [1,1,3,3] is with k = 0.
/// This is invalid since k must be positive.
///
/// Example 3:
/// Input: nums = [5,435]
/// Output: [220]
/// Explanation:
/// The only possible combination is arr = [220] and k = 215. Using them, 
/// we get lower = [5] and higher = [435].
///    
/// Constraints:
/// 1. 2 * n == nums.length
/// 2. 1 <= n <= 1000
/// 3. 1 <= nums[i] <= 10^9
/// 4. The test cases are generated such that there exists at least
///    one valid array arr.
/// </summary>
vector<int> LeetCodeArray::recoverArray(vector<int>& nums)
{
    int min_val = INT_MAX;
    sort(nums.begin(), nums.end());
    vector<int> diff;
    for (size_t i = 1; i < nums.size(); i++)
    {
        if ((nums[i] != nums[0]) && ((nums[i] - nums[0]) % 2 == 0)) diff.push_back(nums[i] - nums[0]);
    }
    for (size_t i = 0; i < diff.size(); i++)
    {
        int gap = diff[i];
        multiset<int> num_set(nums.begin(), nums.end());
        vector<int> result;
        while (!num_set.empty())
        {
            auto low = num_set.begin();
            auto high = num_set.find(*low + gap);
            if (high == num_set.end()) break;
            result.push_back(*low + gap / 2);
            num_set.erase(low);
            num_set.erase(high);
        }
        if (result.size() == nums.size() / 2) return result;
    }
    return vector<int>();
}

/// <summary>
/// Leet Code 2121. Intervals Between Identical Elements
///                                                                 
/// Medium
///
/// You are given a 0-indexed array of n integers arr.
///
/// The interval between two elements in arr is defined as the absolute 
/// difference between their indices. More formally, the interval 
/// between arr[i] and arr[j] is |i - j|.
///
/// Return an array intervals of length n where intervals[i] is the sum of 
/// intervals between arr[i] and each element in arr with the same value 
/// as arr[i].
/// Note: |x| is the absolute value of x.
///
/// Example 1:
/// Input: arr = [2,1,3,1,2,3,3]
/// Output: [4,2,7,2,4,4,5]
/// Explanation:
/// - Index 0: Another 2 is found at index 4. |0 - 4| = 4
/// - Index 1: Another 1 is found at index 3. |1 - 3| = 2
/// - Index 2: Two more 3s are found at indices 5 and 6. 
///   |2 - 5| + |2 - 6| = 7
/// - Index 3: Another 1 is found at index 1. |3 - 1| = 2
/// - Index 4: Another 2 is found at index 0. |4 - 0| = 4
/// - Index 5: Two more 3s are found at indices 2 and 6. 
///   |5 - 2| + |5 - 6| = 4
/// - Index 6: Two more 3s are found at indices 2 and 5. 
///   |6 - 2| + |6 - 5| = 5
///
/// Example 2:
/// Input: arr = [10,5,10,10]
/// Output: [5,0,3,4]
/// Explanation:
/// - Index 0: Two more 10s are found at indices 2 and 3. 
///   |0 - 2| + |0 - 3| = 5
/// - Index 1: There is only one 5 in the array, so its sum of intervals 
///   to identical elements is 0.
/// - Index 2: Two more 10s are found at indices 0 and 3. 
///   |2 - 0| + |2 - 3| = 3
/// - Index 3: Two more 10s are found at indices 0 and 2. 
///   |3 - 0| + |3 - 2| = 4
/// 
/// Constraints:
/// 1. n == arr.length
/// 2. 1 <= n <= 10^5
/// 3. 1 <= arr[i] <= 10^5
/// </summary>
vector<long long> LeetCodeArray::getDistances(vector<int>& arr)
{
    unordered_map<int, pair<long long, long long>> sum_map;
    vector<long long> result(arr.size());
    for (size_t i = 0; i < arr.size(); i++)
    {
        result[i] += (long long)sum_map[arr[i]].first * (long long)i - sum_map[arr[i]].second;
        sum_map[arr[i]].first++;
        sum_map[arr[i]].second += i;
    }
    sum_map.clear();
    for (int i = arr.size() - 1; i >= 0; i--)
    {
        result[i] += sum_map[arr[i]].second - (long long)sum_map[arr[i]].first * (long long)i;
        sum_map[arr[i]].first++;
        sum_map[arr[i]].second += i;
    }
    return result;
}

/// <summary>
/// Leet Code 2132. Stamping the Grid
///                                                                 
/// Hard
///
/// You are given an m x n binary matrix grid where each cell is either 0 
/// (empty) or 1 (occupied).
///
/// You are then given stamps of size stampHeight x stampWidth. We want to 
/// fit the stamps such that they follow the given restrictions and 
/// requirements:
///
/// Cover all the empty cells.
/// Do not cover any of the occupied cells.
/// We can put as many stamps as we want.
/// Stamps can overlap with each other.
/// Stamps are not allowed to be rotated.
/// Stamps must stay completely inside the grid.
/// Return true if it is possible to fit the stamps while following the 
/// given restrictions and requirements. Otherwise, return false.
/// 
/// Example 1:
/// Input: grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], 
/// stampHeight = 4, stampWidth = 3
/// Output: true
/// Explanation: We have two overlapping stamps (labeled 1 and 2 in the 
/// image) that are able to cover all the empty cells.
///
/// Example 2:
/// Input: grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], 
/// stampHeight = 2, stampWidth = 2 
/// Output: false 
/// Explanation: There is no way to fit the stamps onto all the empty 
/// cells without the stamps going outside the grid.
///
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[r].length
/// 3. 1 <= m, n <= 10^5
/// 4. 1 <= m * n <= 2 * 10^5
/// 5. grid[r][c] is either 0 or 1.
/// 6. 1 <= stampHeight, stampWidth <= 105
/// </summary>
bool LeetCodeArray::possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth)
{
    int m = grid.size();
    int n = grid[0].size();
    vector<vector<int>> sum(m+1, vector<int>(n+1));
    vector<vector<int>> stamp(m+1, vector<int>(n+1));
    for (int i = 1; i <= m; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            sum[i][j] = sum[i][j - 1] + sum[i - 1][j] + grid[i-1][j-1] - sum[i - 1][j - 1];
            if (i >= stampHeight && j >= stampWidth)
            {
                int stamp_sum = sum[i][j];
                stamp_sum -= sum[i - stampHeight][j];
                stamp_sum -= sum[i][j - stampWidth];
                stamp_sum += sum[i - stampHeight][j - stampWidth];
                stamp[i][j] = stamp[i][j - 1] + stamp[i - 1][j] - stamp[i - 1][j - 1];
                if (stamp_sum == 0)
                {
                    stamp[i][j] += 1;
                }
            }
        }
    }

    for (int i = 1; i <= m; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            if (grid[i - 1][j - 1] == 1) continue;
            int bottom = min(m, i - 1 + stampHeight);
            int right = min(n, j - 1 + stampWidth);
            int stamp_sum = stamp[bottom][right];
            stamp_sum -= stamp[i - 1 ][right];
            stamp_sum -= stamp[bottom][j - 1];
            stamp_sum += stamp[i - 1][j - 1];
            if (stamp_sum == 0) return false;
        }
    }
    return true;
}

/// <summary>
/// Leet Code 2133. Check if Every Row and Column Contains All Numbers
///                                                                 
/// Easy
///
/// An n x n matrix is valid if every row and every column contains all 
/// the integers from 1 to n (inclusive).
///
/// Given an n x n integer matrix matrix, return true if the matrix is 
/// valid. Otherwise, return false.
/// 
/// Example 1:
/// Input: matrix = [[1,2,3],[3,1,2],[2,3,1]]
/// Output: true
/// Explanation: In this case, n = 3, and every row and column contains 
/// the numbers 1, 2, and 3.
/// Hence, we return true.
///
/// Example 2:
/// Input: matrix = [[1,1,1],[1,2,3],[1,2,3]]
/// Output: false
/// Explanation: In this case, n = 3, but the first row and the first 
/// column do not contain the numbers 2 or 3.
/// Hence, we return false.
/// 
/// Constraints:
/// 1. n == matrix.length == matrix[i].length
/// 2. 1 <= n <= 100
/// 3. 1 <= matrix[i][j] <= n
/// </summary>
bool LeetCodeArray::checkValid(vector<vector<int>>& matrix)
{
    int n = matrix.size();
    vector<unordered_set<int>> row(n), col(n);
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            row[i].insert(matrix[i][j]);
            col[j].insert(matrix[i][j]);
        }
    }
    for (int i = 0; i < n; i++)
    {
        if (row[i].size() != n || col[i].size() != n)
        {
            return false;
        }
    }
    return true;
}

/// <summary>
/// Leet Code 2128. Remove All Ones With Row and Column Flips
///                                                                 
/// Medium
///
/// You are given an m x n binary matrix grid.
/// In one operation, you can choose any row or column and flip each value 
/// in that row or column (i.e., changing all 0's to 1's, and all 
/// 1's to 0's).
///
/// Return true if it is possible to remove all 1's from grid using any 
/// number of operations or false otherwise.
/// 
/// Example 1:
/// Input: grid = [[0,1,0],[1,0,1],[0,1,0]]
/// Output: true
/// Explanation: One possible way to remove all 1's from grid is to:
/// - Flip the middle row
/// - Flip the middle column
///
/// Example 2:
/// Input: grid = [[1,1,0],[0,0,0],[0,0,0]]
/// Output: false
/// Explanation: It is impossible to remove all 1's from grid.
///
/// Example 3:
/// Input: grid = [[0]]
/// Output: true
/// Explanation: There are no 1's in grid.
///
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 1 <= m, n <= 300
/// 4. grid[i][j] is either 0 or 1.
/// </summary>
bool LeetCodeArray::removeOnes(vector<vector<int>>& grid)
{
    for (size_t i = 0; i < grid.size(); i++)
    {
        if (grid[i][0] == 1)
        {
            for (size_t j = 0; j < grid[i].size(); j++)
            {
                grid[i][j] = 1 - grid[i][j];
            }
        }
    }
    for (size_t j = 0; j < grid[0].size(); j++)
    {
        if (grid[0][j] == 1)
        {
            for (size_t i = 0; i < grid.size(); i++)
            {
                grid[i][j] = 1 - grid[i][j];
            }
        }
    }

    for (size_t i = 0; i < grid.size(); i++)
    {
        for (size_t j = 0; j < grid[i].size(); j++)
        {
            if (grid[i][j] == 1) return false;
        }
    }
    return true;
}

/// <summary>
/// Leet Code 2125. Number of Laser Beams in a Bank
///                                                                 
/// Medium
///
/// Anti-theft security devices are activated inside a bank. You are given 
/// a 0-indexed binary string array bank representing the floor plan of 
/// the bank, which is an m x n 2D matrix. bank[i] represents the ith row, 
/// consisting of '0's and '1's. '0' means the cell is empty, while'1' 
/// means the cell has a security device.
///
/// There is one laser beam between any two security devices if both 
/// conditions are met:
///
/// The two devices are located on two different rows: r1 and r2, where 
/// r1 < r2.
/// For each row i where r1 < i < r2, there are no security devices in 
/// the ith row.
/// Laser beams are independent, i.e., one beam does not interfere nor 
/// join with another.
///
/// Return the total number of laser beams in the bank.
/// 
/// Example 1:
/// Input: bank = ["011001","000000","010100","001000"]
/// Output: 8
/// Explanation: Between each of the following device pairs, there is one 
/// beam. In total, there are 8 beams:
/// * bank[0][1] -- bank[2][1]
/// * bank[0][1] -- bank[2][3]
/// * bank[0][2] -- bank[2][1]
/// * bank[0][2] -- bank[2][3]
/// * bank[0][5] -- bank[2][1]
/// * bank[0][5] -- bank[2][3]
/// * bank[2][1] -- bank[3][2]
/// * bank[2][3] -- bank[3][2]
/// Note that there is no beam between any device on the 0th row with any 
/// on the 3rd row.
/// This is because the 2nd row contains security devices, which breaks 
/// the second condition.
///
/// Example 2:
///
/// Input: bank = ["000","111","000"]
/// Output: 0
/// Explanation: There does not exist two devices located on two different
/// rows.
/// 
/// Constraints:
/// 1. m == bank.length
/// 2. n == bank[i].length
/// 3. 1 <= m, n <= 500
/// 4. bank[i][j] is either '0' or '1'.
/// </summary>
int LeetCodeArray::numberOfBeams(vector<string>& bank)
{
    int prev = 0;
    int result = 0;
    for (size_t i = 0; i < bank.size(); i++)
    {
        int current = 0;
        for (size_t j = 0; j < bank[i].size(); j++)
        {
            if (bank[i][j] == '1') current++;
        }
        if (current > 0)
        {
            result += prev * current;
            prev = current;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2134. Minimum Swaps to Group All 1's Together II
///                                                                 
/// Medium
///
/// A swap is defined as taking two distinct positions in an array and 
/// swapping the values in them.
///
/// A circular array is defined as an array where we consider the first 
/// element and the last element to be adjacent.
///
/// Given a binary circular array nums, return the minimum number of 
/// swaps required to group all 1's present in the array together at 
/// any location.
/// 
/// Example 1:
/// Input: nums = [0,1,0,1,1,0,0]
/// Output: 1
/// Explanation: Here are a few of the ways to group all the 1's together:
/// [0,0,1,1,1,0,0] using 1 swap.
/// [0,1,1,1,0,0,0] using 1 swap.
/// [1,1,0,0,0,0,1] using 2 swaps (using the circular property of the 
/// array).
/// There is no way to group all 1's together with 0 swaps.
/// Thus, the minimum number of swaps required is 1.
///
/// Example 2:
/// Input: nums = [0,1,1,1,0,0,1,1,0]
/// Output: 2
/// Explanation: Here are a few of the ways to group all the 1's together:
/// [1,1,1,0,0,0,0,1,1] using 2 swaps (using the circular property of the 
/// array).
/// [1,1,1,1,1,0,0,0,0] using 2 swaps.
/// There is no way to group all 1's together with 0 or 1 swaps.
/// Thus, the minimum number of swaps required is 2.
///
/// Example 3:
/// Input: nums = [1,1,0,0,1]
/// Output: 0
/// Explanation: All the 1's are already grouped together due to the 
/// circular property of the array.
/// Thus, the minimum number of swaps required is 0.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. nums[i] is either 0 or 1.
/// </summary>
int LeetCodeArray::minSwapsII(vector<int>& nums)
{
    int length = 0;
    int n = nums.size();
    for (int i = 0; i < n; i++)
    {
        length += nums[i];
    }
    int left = -1;
    int sum = 0;
    int max_sum = 0;
    for (int right = 0; right < 2 * n; right++)
    {
        sum += nums[right % n];
        // consider full array and circle
        if ((right - left) == length || 
            (right + n - left) % n  == length)
        {
            max_sum = max(max_sum, sum);
            left++;
            sum -= nums[left % n];
        }
    }
    return length - max_sum;
}

/// <summary>
/// Leet Code 2147. Number of Ways to Divide a Long Corridor
///                                                                 
/// Hard
///
/// Along a long library corridor, there is a line of seats and decorative 
/// plants. You are given a 0-indexed string corridor of length n 
/// consisting of letters 'S' and 'P' where each 'S' represents a seat and 
/// each 'P' represents a plant.
///
/// One room divider has already been installed to the left of index 0, 
/// and another to the right of index n - 1. Additional room dividers can 
/// be installed. For each position between indices i - 1 and i 
/// (1 <= i <= n - 1), at most one divider can be installed.
///
/// Divide the corridor into non-overlapping sections, where each section 
/// has exactly two seats with any number of plants. There may be multiple 
/// ways to perform the division. Two ways are different if there is a 
/// position with a room divider installed in the first way but not in 
/// the second way.
///
/// Return the number of ways to divide the corridor. Since the answer may 
/// be very large, return it modulo 109 + 7. If there is no way, return 0.
///
/// Example 1:
/// Input: corridor = "SSPPSPS"
/// Output: 3
/// Explanation: There are 3 different ways to divide the corridor.
/// The black bars in the above image indicate the two room dividers 
/// already installed.
/// Note that in each of the ways, each section has exactly two seats.
///
/// Example 2:
/// Input: corridor = "PPSPSP"
/// Output: 1
/// Explanation: There is only 1 way to divide the corridor, by not 
/// installing any additional dividers.
/// Installing any would create some section that does not have exactly 
/// two seats.
///
/// Example 3:
/// Input: corridor = "S"
/// Output: 0
/// Explanation: There is no way to divide the corridor because there 
/// will always be a section that does not have exactly two seats.
/// 
/// Constraints:
/// n == corridor.length
/// 1 <= n <= 10^5
/// corridor[i] is either 'S' or 'P'.
/// </summary>
long long LeetCodeArray::numberOfWays(string corridor)
{
    int sum = 0;
    for (char ch : corridor)
    {
        if (ch == 'S') sum++;
    }
    if (sum == 0 || sum % 2 == 1) return 0;
    long long result = 1;
    int last_seat = -1, seat = 0;
    long long M = 1000000007;
    for (size_t i = 0; i < corridor.size(); i++)
    {
        if (corridor[i] == 'S')
        {
            if (last_seat > 0 && seat % 2 == 0)
            {
                result = (result * ((long long)i - (long long)last_seat)) % M;
            }
            seat++;
            last_seat = i;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2154. Keep Multiplying Found Values by Two 
///                                                                 
/// Easy
///
/// You are given an array of integers nums. You are also given an integer 
/// original which is the first number that needs to be searched for in 
/// nums.
///
/// You then do the following steps:
/// If original is found in nums, multiply it by two (i.e., set 
/// original = 2 * original).
/// Otherwise, stop the process.
/// Repeat this process with the new number as long as you keep finding 
/// the number.
/// Return the final value of original.
/// 
/// Example 1:
/// Input: nums = [5,3,6,1,12], original = 3 
/// Output: 24
/// Explanation: 
/// 1. - 3 is found in nums. 3 is multiplied by 2 to obtain 6.
/// 2. - 6 is found in nums. 6 is multiplied by 2 to obtain 12.
/// 3. - 12 is found in nums. 12 is multiplied by 2 to obtain 24.
/// 4. - 24 is not found in nums. Thus, 24 is returned.
///
/// Example 2:
/// Input: nums = [2,7,9], original = 4
/// Output: 4
/// Explanation:
/// - 4 is not found in nums. Thus, 4 is returned.
///
/// Constraints:
/// 1. 1 <= nums.length <= 1000
/// 2. 1 <= nums[i], original <= 1000
/// </summary>
int LeetCodeArray::findFinalValue(vector<int>& nums, int original)
{
    unordered_set<int> nums_set = unordered_set<int>(nums.begin(), nums.end());
    while (nums_set.count(original) > 0)
    {
        original = original * 2;
    }
    return original;
}

/// <summary>
/// Leet Code 2149. Rearrange Array Elements by Sign
///                                                                 
/// Medium
///
/// You are given a 0-indexed integer array nums of even length consisting 
/// of an equal number of positive and negative integers.
///
/// You should rearrange the elements of nums such that the modified array 
/// follows the given conditions:
///
/// Every consecutive pair of integers have opposite signs.
/// For all integers with the same sign, the order in which they were 
/// present in nums is preserved.
/// The rearranged array begins with a positive integer.
/// Return the modified array after rearranging the elements to satisfy 
/// the aforementioned conditions.
/// 
/// Example 1:
/// Input: nums = [3,1,-2,-5,2,-4]
/// Output: [3,-2,1,-5,2,-4]
/// Explanation:
/// The positive integers in nums are [3,1,2]. The negative integers 
/// are [-2,-5,-4].
/// The only possible way to rearrange them such that they satisfy all 
/// conditions is [3,-2,1,-5,2,-4].
/// Other ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], 
/// [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or 
/// more conditions.  
///
/// Example 2:
/// Input: nums = [-1,1]
/// Output: [1,-1]
/// Explanation:
/// 1 is the only positive integer and -1 the only negative integer in 
/// nums.
/// So nums is rearranged to [1,-1].
/// 
/// Constraints:
/// 1. 2 <= nums.length <= 2 * 10^5
/// 2. nums.length is even
/// 3. 1 <= |nums[i]| <= 105
/// 4. nums consists of equal number of positive and negative integers.
/// </summary>
vector<int> LeetCodeArray::rearrangeArray(vector<int>& nums)
{
    int positive = 0;
    int negative = 0;
    vector<int> result;
    for (size_t i = 0; i < nums.size(); i+=2)
    {
        while (nums[positive] < 0) positive++;
        while (nums[negative] > 0) negative++;

        result.push_back(nums[positive]);
        result.push_back(nums[negative]);
        
        positive++;
        negative++;
    }
    return result;
}

/// <summary>
/// Leet Code 2155. All Divisions With the Highest Score of a Binary Array
///                                                                 
/// Medium
///
/// You are given a 0-indexed binary array nums of length n. nums can be 
/// divided at index i (where 0 <= i <= n) into two arrays (possibly 
/// empty) numsleft and numsright:
///
/// numsleft has all the elements of nums between index 0 and i - 1 
/// (inclusive), while numsright has all the elements of nums between 
/// index i and n - 1 (inclusive).
/// If i == 0, numsleft is empty, while numsright has all the elements 
/// of nums.
/// If i == n, numsleft has all the elements of nums, while numsright 
/// is empty.
/// The division score of an index i is the sum of the number of 0's 
/// in numsleft and the number of 1's in numsright.
///
/// Return all distinct indices that have the highest possible division 
/// score. You may return the answer in any order.
/// 
/// Example 1:
/// Input: nums = [0,0,1,0]
/// Output: [2,4]
/// Explanation: Division at index
/// - 0: numsleft is []. numsright is [0,0,1,0]. The score is 0 + 1 = 1.
/// - 1: numsleft is [0]. numsright is [0,1,0]. The score is 1 + 1 = 2.
/// - 2: numsleft is [0,0]. numsright is [1,0]. The score is 2 + 1 = 3.
/// - 3: numsleft is [0,0,1]. numsright is [0]. The score is 2 + 0 = 2.
/// - 4: numsleft is [0,0,1,0]. numsright is []. The score is 3 + 0 = 3.
/// Indices 2 and 4 both have the highest possible division score 3.
/// Note the answer [4,2] would also be accepted.
///
/// Example 2:
/// Input: nums = [0,0,0]
/// Output: [3]
/// Explanation: Division at index
/// - 0: numsleft is []. numsright is [0,0,0]. The score is 0 + 0 = 0.
/// - 1: numsleft is [0]. numsright is [0,0]. The score is 1 + 0 = 1.
/// - 2: numsleft is [0,0]. numsright is [0]. The score is 2 + 0 = 2.
/// - 3: numsleft is [0,0,0]. numsright is []. The score is 3 + 0 = 3.
/// Only index 3 has the highest possible division score 3.
///
/// Example 3:
/// Input: nums = [1,1]
/// Output: [0]
/// Explanation: Division at index
/// - 0: numsleft is []. numsright is [1,1]. The score is 0 + 2 = 2.
/// - 1: numsleft is [1]. numsright is [1]. The score is 0 + 1 = 1.
/// - 2: numsleft is [1,1]. numsright is []. The score is 0 + 0 = 0.
/// Only index 0 has the highest possible division score 2.
///
/// Constraints:
/// 1. n == nums.length
/// 2. 1 <= n <= 10^5
/// 3. nums[i] is either 0 or 1.
/// </summary>
vector<int> LeetCodeArray::maxScoreIndices(vector<int>& nums)
{
    int left = 0;
    int right = 0;
    int max_score = 0;
    vector<int> result;
    for (size_t i = 0; i < nums.size(); i++) right++;
    for (size_t i = 0; i <= nums.size(); i++)
    {
        if (left + right > max_score)
        {
            max_score = left + right;
            result.clear();
            result.push_back(i);
        }
        else if (left + right == max_score)
        {
            result.push_back(i);
        }
        if (i < nums.size())
        {
            if (nums[i] == 0) left++;
            else right--;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2161. Partition Array According to Given Pivot
///                                                                 
/// Medium
///
/// You are given a 0-indexed integer array nums and an integer pivot. 
/// Rearrange nums such that the following conditions are satisfied:
///
/// Every element less than pivot appears before every element greater 
/// than pivot.
/// Every element equal to pivot appears in between the elements less 
/// than and greater than pivot.
/// The relative order of the elements less than pivot and the elements 
/// greater than pivot is maintained.
/// More formally, consider every pi, pj where pi is the new position of 
/// the ith element and pj is the new position of the jth element. For 
/// elements less than pivot, if i < j and nums[i] < pivot and 
/// nums[j] < pivot, then pi < pj. Similarly for elements greater than 
/// pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.
/// Return nums after the rearrangement.
///
/// Example 1:
/// Input: nums = [9,12,5,10,14,3,10], pivot = 10
/// Output: [9,5,3,10,10,12,14]
/// Explanation: 
/// The elements 9, 5, and 3 are less than the pivot so they are on the 
/// left side of the array.
/// The elements 12 and 14 are greater than the pivot so they are on the 
/// right side of the array.
/// The relative ordering of the elements less than and greater than pivot 
/// is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.
///
/// Example 2:
/// Input: nums = [-3,4,3,2], pivot = 2
/// Output: [-3,2,4,3]
/// Explanation: 
/// The element -3 is less than the pivot so it is on the left side of 
/// the array.
/// The elements 4 and 3 are greater than the pivot so they are on the 
/// right side of the array.
/// The relative ordering of the elements less than and greater than 
/// pivot is also maintained. [-3] and [4, 3] are the respective orderings.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. -10^6 <= nums[i] <= 10^6
/// 3. pivot equals to an element of nums.
/// </summary>
vector<int> LeetCodeArray::pivotArray(vector<int>& nums, int pivot)
{
    vector<int> result;
    for (int i = 0; i < 3; i++)
    {
        for (size_t j = 0; j < nums.size(); j++)
        {
            if (i == 0 && nums[j] < pivot)
            {
                result.push_back(nums[j]);
            }
            else if (i == 1 && nums[j] == pivot)
            {
                result.push_back(nums[j]);
            }
            else if (i == 2 && nums[j] > pivot)
            {
                result.push_back(nums[j]);
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2163. Minimum Difference in Sums After Removal of Elements
///                                                                 
/// Hard
///
/// You are given a 0-indexed integer array nums consisting of 3 * n 
/// elements.
///
/// You are allowed to remove any subsequence of elements of size exactly 
/// n from nums. The remaining 2 * n elements will be divided into two 
/// equal parts:
///
/// The first n elements belonging to the first part and their sum is 
/// sumfirst.
/// The next n elements belonging to the second part and their sum is 
/// sumsecond.
/// The difference in sums of the two parts is denoted as 
/// sumfirst - sumsecond.
///
/// For example, if sumfirst = 3 and sumsecond = 2, their difference is 1.
/// Similarly, if sumfirst = 2 and sumsecond = 3, their difference is -1.
/// Return the minimum difference possible between the sums of the two 
/// parts after the removal of n elements.
/// 
/// Example 1:
/// Input: nums = [3,1,2]
/// Output: -1
/// Explanation: Here, nums has 3 elements, so n = 1. 
/// Thus we have to remove 1 element from nums and divide the array into 
/// two equal parts.
/// - If we remove nums[0] = 3, the array will be [1,2]. The difference in 
///   sums of the two parts will be 1 - 2 = -1.
/// - If we remove nums[1] = 1, the array will be [3,2]. The difference in 
///   sums of the two parts will be 3 - 2 = 1.
/// - If we remove nums[2] = 2, the array will be [3,1]. The difference in 
///   sums of the two parts will be 3 - 1 = 2.
/// The minimum difference between sums of the two parts is 
/// min(-1,1,2) = -1. 
///
/// Example 2:
/// Input: nums = [7,9,5,8,1,3]
/// Output: 1
/// Explanation: Here n = 2. So we must remove 2 elements and divide the 
/// remaining array into two parts containing two elements each.
/// If we remove nums[2] = 5 and nums[3] = 8, the resultant array will be 
/// [7,9,1,3]. The difference in sums will be (7+9) - (1+3) = 12.
/// To obtain the minimum difference, we should remove nums[1] = 9 and 
/// nums[4] = 1. The resultant array becomes [7,5,8,3]. The difference in 
/// sums of the two parts is (7+5) - (8+3) = 1.
/// It can be shown that it is not possible to obtain a difference smaller 
/// than 1.
///
/// Constraints:
/// 1. nums.length == 3 * n
/// 2. 1 <= n <= 10^5
/// 3. 1 <= nums[i] <= 10^5
/// </summary>
long long LeetCodeArray::minimumDifference(vector<int>& nums)
{
    vector<long long> left(nums.size()), right(nums.size());
    int n = nums.size() / 3;
    set<pair<long long, int>> min_heap, max_heap;
    long long sum = 0;
    for (int i = 0; i <= 2 * n; i++)
    {
        if (i < n)
        {
            left[i] = -1;
        }
        else
        {
            left[i] = sum;
        }
        min_heap.insert(make_pair(nums[i], i));
        sum += nums[i];
        if ((int)min_heap.size() > n)
        {
            sum -= min_heap.rbegin()->first;
            min_heap.erase(make_pair(min_heap.rbegin()->first, min_heap.rbegin()->second));
        }
    }
    sum = 0;
    for (int i = nums.size() - 1; i >= n; i--)
    {
        max_heap.insert(make_pair(nums[i], i));
        sum += nums[i];
        if ((int)max_heap.size() > n)
        {
            sum -= max_heap.begin()->first;
            max_heap.erase(max_heap.begin());
        }
        if (i > (int)nums.size() - n)
        {
            right[i] = -1;
        }
        else
        {
            right[i] = sum;
        }
    }
    long long result = LLONG_MAX;
    for (int i = n; i <= 2 * n; i++)
    {
        result = min(result, left[i] - right[i]);
    }
    return result;
}

/// <summary>
/// Leet Code 2170. Minimum Operations to Make the Array Alternating
///                                                                                  
/// Medium
///
/// You are given a 0-indexed array nums consisting of n positive integers.
///
/// The array nums is called alternating if:
///
/// nums[i - 2] == nums[i], where 2 <= i <= n - 1.
/// nums[i - 1] != nums[i], where 1 <= i <= n - 1.
/// In one operation, you can choose an index i and change nums[i] into 
/// any positive integer.
///
/// Return the minimum number of operations required to make the array 
/// alternating.
/// 
/// Example 1:
/// Input: nums = [3,1,3,2,4,3]
/// Output: 3
/// Explanation:
/// One way to make the array alternating is by converting it to 
/// [3,1,3,1,3,1].
/// The number of operations required in this case is 3.
/// It can be proven that it is not possible to make the array alternating 
/// in less than 3 operations. 
///
/// Example 2:
/// Input: nums = [1,2,2,2,2]
/// Output: 2
/// Explanation:
/// One way to make the array alternating is by converting it to 
/// [1,2,1,2,1].
/// The number of operations required in this case is 2.
/// Note that the array cannot be converted to [2,2,2,2,2] because in this 
/// case nums[0] == nums[1] which violates the conditions of an 
/// alternating array.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^5
/// </summary>
int LeetCodeArray::minimumOperations(vector<int>& nums)
{
    unordered_map<int, int> frequency;
    for (size_t i = 0; i < nums.size(); i += 2)
    {
        frequency[nums[i]]++;
    }
    set<pair<int, int>> even;
    for (auto& itr : frequency)
    {
        even.insert(make_pair(itr.second, itr.first));
        if (even.size() > 2) even.erase(even.begin());
    }
    frequency.clear();
    for (size_t i = 1; i < nums.size(); i += 2)
    {
        frequency[nums[i]]++;
    }
    set<pair<int, int>> odd;
    for (auto& itr : frequency)
    {
        odd.insert(make_pair(itr.second, itr.first));
        if (odd.size() > 2) odd.erase(odd.begin());
    }
    size_t result = INT_MAX;
    if (odd.empty()) return 0;
    if (even.rbegin()->second != odd.rbegin()->second)
    {
        result = nums.size() - even.rbegin()->first - odd.rbegin()->first;
    }
    if ((even.begin()->second != odd.rbegin()->second))
    {
        result = min(result, nums.size() - even.begin()->first - odd.rbegin()->first);
    }
    if ((even.rbegin()->second != odd.begin()->second))
    {
        result = min(result, nums.size() - even.rbegin()->first - odd.begin()->first);
    }
    if ((even.rbegin()->second != odd.begin()->second))
    {
        result = min(result, nums.size() - even.rbegin()->first - odd.begin()->first);
    }
    result = min(result, nums.size() - max(even.rbegin()->first, odd.rbegin()->first));
    return result;
}

/// <summary>
/// Leet Code 2176. Count Equal and Divisible Pairs in an Array
///                                                                                  
/// Easy
///
/// Given a 0-indexed integer array nums of length n and an integer k, 
/// return the number of pairs (i, j) where 0 <= i < j < n, such that 
/// nums[i] == nums[j] and (i * j) is divisible by k.
///
/// Example 1:
/// Input: nums = [3,1,2,2,2,1,3], k = 2
/// Output: 4
/// Explanation:
/// There are 4 pairs that meet all the requirements:
/// - nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2.
/// - nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2.
/// - nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2.
/// - nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2.
///
/// Example 2:
/// Input: nums = [1,2,3,4], k = 1
/// Output: 0
/// Explanation: Since no value in nums is repeated, there are no 
/// pairs (i,j) that meet all the requirements.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 100
/// 2. 1 <= nums[i], k <= 100
/// </summary>
int LeetCodeArray::countPairs(vector<int>& nums, int k)
{
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        for (size_t j = 0; j < i; j++)
        {
            if (i * j % k == 0 && nums[i] == nums[j])
            {
                result++;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2179. Count Good Triplets in an Array
///                                                                                  
/// Hard
///
/// You are given two 0-indexed arrays nums1 and nums2 of length n, both 
/// of which are permutations of [0, 1, ..., n - 1].
///
/// A good triplet is a set of 3 distinct values which are present in 
/// increasing order by position both in nums1 and nums2. In other words, 
/// if we consider pos1v as the index of the value v in nums1 and pos2v 
/// as the index of the value v in nums2, then a good triplet will be a 
/// set (x, y, z) where 0 <= x, y, z <= n - 1, such that 
/// pos1x < pos1y < pos1z and pos2x < pos2y < pos2z.
///
/// Return the total number of good triplets.
/// 
/// Example 1:
/// Input: nums1 = [2,0,1,3], nums2 = [0,1,2,3]
/// Output: 1
/// Explanation: 
/// There are 4 triplets (x,y,z) such that pos1x < pos1y < pos1z. They 
/// are (2,0,1), (2,0,3), (2,1,3), and (0,1,3). 
/// Out of those triplets, only the triplet (0,1,3) satisfies 
/// pos2x < pos2y < pos2z. Hence, there is only 1 good triplet.
///
/// Example 2:
/// Input: nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]
/// Output: 4
/// Explanation: The 4 good triplets are (4,0,3), (4,0,2), (4,1,3), 
/// and (4,1,2).
/// 
/// Constraints:
/// 1. n == nums1.length == nums2.length
/// 2. 3 <= n <= 10^5
/// 3. 0 <= nums1[i], nums2[i] <= n - 1
/// 4. nums1 and nums2 are permutations of [0, 1, ..., n - 1].
/// </summary>
long long LeetCodeArray::goodTriplets(vector<int>& nums1, vector<int>& nums2)
{
    int n = nums1.size();
    vector<int> nums2_pos(n);
    for (size_t i = 0; i < nums2.size(); i++)
    {
         nums2_pos[nums2[i]] = i + 1;
    }
    vector<int> prefix(n+1);
    vector<vector<int>> dp(n, vector<int>(2));
    for (int i = 0; i < n; i++)
    {
        int pos = nums2_pos[nums1[i]];
        while (pos <= n)
        {
            prefix[pos] += 1;
            pos += (pos & -pos);
        }
        pos = nums2_pos[nums1[i]] - 1;
        int less = 0;
        while (pos != 0)
        {
            less += prefix[pos];
            pos -= (pos & -pos);
        }
        dp[i][0] = less;
    }
    vector<int> suffix(n+1);
    for (int i = n - 1; i >=0; i--)
    {
        int pos = n - nums2_pos[nums1[i]] + 1;
        while (pos <= n)
        {
            suffix[pos] += 1;
            pos += (pos & -pos);
        }
        pos = n - nums2_pos[nums1[i]];
        int less = 0;
        while (pos != 0)
        {
            less += suffix[pos];
            pos -= (pos & -pos);
        }
        dp[i][1] = less;
    }
    long long result = 0;
    for (int i = 0; i < n; i++)
    {
        result += (long long)dp[i][0] * (long long)dp[i][1];
    }
    return result;
}

/// <summary>
/// Leet Code 2190. Most Frequent Number Following Key In an Array
///                                                                                   
/// Easy
///
/// You are given a 0-indexed integer array nums. You are also given an 
/// integer key, which is present in nums.
///
/// For every unique integer target in nums, count the number of times 
/// target immediately follows an occurrence of key in nums. In other 
/// words, count the number of indices i such that:
///
/// 0 <= i <= nums.length - 2,
/// nums[i] == key and,
/// nums[i + 1] == target.
/// Return the target with the maximum count. The test cases will be 
/// generated such that the target with maximum count is unique.
/// 
/// Example 1:
/// Input: nums = [1,100,200,1,100], key = 1
/// Output: 100
/// Explanation: For target = 100, there are 2 occurrences at indices 1 
/// and 4 which follow an occurrence of key.
/// No other integers follow an occurrence of key, so we return 100.
///
/// Example 2:
/// Input: nums = [2,2,2,2,3], key = 2
/// Output: 2
/// Explanation: For target = 2, there are 3 occurrences at indices 1, 2, 
/// and 3 which follow an occurrence of key.
/// For target = 3, there is only one occurrence at index 4 which follows 
/// an occurrence of key.
/// target = 2 has the maximum number of occurrences following an 
/// occurrence of key, so we return 2.
/// 
/// Constraints:
/// 1. 2 <= nums.length <= 1000
/// 2. 1 <= nums[i] <= 1000
/// 3. The test cases will be generated such that the answer is unique.
/// </summary>
int LeetCodeArray::mostFrequent(vector<int>& nums, int key)
{
    vector<int> num_count(1001);
    for (size_t i = 1; i < nums.size(); i++)
    {
        if (nums[i - 1] == key) num_count[nums[i]]++;
    }
    int max_count = 0;
    int result = 0;
    for (size_t i = 1; i < num_count.size(); i++)
    {
        if (num_count[i] > max_count)
        {
            max_count = num_count[i];
            result = i;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2200. Find All K-Distant Indices in an Array
///                                                       
/// Easy
///
/// You are given a 0-indexed integer array nums and two integers key and 
/// k. A k-distant index is an index i of nums for which there exists at 
/// least one index j such that |i - j| <= k and nums[j] == key.
///
/// Return a list of all k-distant indices sorted in increasing order.
/// 
/// Example 1:
/// Input: nums = [3,4,9,1,3,9,5], key = 9, k = 1
/// Output: [1,2,3,4,5,6]
/// Explanation: Here, nums[2] == key and nums[5] == key.
/// - For index 0, |0 - 2| > k and |0 - 5| > k, so there is no j where 
/// |0 - j| <= k and nums[j] == key. Thus, 0 is not a k-distant index.
/// - For index 1, |1 - 2| <= k and nums[2] == key, so 1 is a k-distant 
/// index.
/// - For index 2, |2 - 2| <= k and nums[2] == key, so 2 is a k-distant 
/// index.
/// - For index 3, |3 - 2| <= k and nums[2] == key, so 3 is a k-distant 
/// index.
/// - For index 4, |4 - 5| <= k and nums[5] == key, so 4 is a k-distant 
/// index.
/// - For index 5, |5 - 5| <= k and nums[5] == key, so 5 is a k-distant 
/// index.
/// - For index 6, |6 - 5| <= k and nums[5] == key, so 6 is a k-distant 
/// index.
/// Thus, we return [1,2,3,4,5,6] which is sorted in increasing order. 
///
/// Example 2:
/// Input: nums = [2,2,2,2,2], key = 2, k = 2
/// Output: [0,1,2,3,4]
/// Explanation: For all indices i in nums, there exists some index 
/// j such that |i - j| <= k and nums[j] == key, so every index is a 
/// k-distant index. 
/// Hence, we return [0,1,2,3,4].
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 1000
/// 2. 1 <= nums[i] <= 1000
/// 3. key is an integer from the array nums.
/// 4. 1 <= k <= nums.length
/// </summary>
vector<int> LeetCodeArray::findKDistantIndices(vector<int>& nums, int key, int k)
{
    vector<int> result;
    int prev = -1;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] == key)
        {
            int left = max(prev + 1, ((int)i - k));
            int right = min((int)nums.size() - 1, ((int)i + k));
            for (int j = left; j <= right; j++)
            {
                result.push_back(j);
            }
            prev = right;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2214. Minimum Health to Beat Game
///                                                                                   
/// Medium
///
/// You are playing a game that has n levels numbered from 0 to n - 1. 
/// You are given a 0-indexed integer array damage where damage[i] is 
/// the amount of health you will lose to complete the ith level.
///
/// You are also given an integer armor. You may use your armor ability 
/// at most once during the game on any level which will protect you 
/// from at most armor damage.
///
/// You must complete the levels in order and your health must be greater 
/// than 0 at all times to beat the game.
///
/// Return the minimum health you need to start with to beat the game.
/// 
/// Example 1:
/// Input: damage = [2,7,4,3], armor = 4
/// Output: 13
/// Explanation: One optimal way to beat the game starting at 13 health is:
/// On round 1, take 2 damage. You have 13 - 2 = 11 health.
/// On round 2, take 7 damage. You have 11 - 7 = 4 health.
/// On round 3, use your armor to protect you from 4 damage. You 
/// have 4 - 0 = 4 health.
/// On round 4, take 3 damage. You have 4 - 3 = 1 health.
/// Note that 13 is the minimum health you need to start with to beat the 
/// game.
///
/// Example 2:
/// Input: damage = [2,5,3,4], armor = 7
/// Output: 10
/// Explanation: One optimal way to beat the game starting at 10 health is:
/// On round 1, take 2 damage. You have 10 - 2 = 8 health.
/// On round 2, use your armor to protect you from 5 damage. You 
/// have 8 - 0 = 8 health.
/// On round 3, take 3 damage. You have 8 - 3 = 5 health.
/// On round 4, take 4 damage. You have 5 - 4 = 1 health.
/// Note that 10 is the minimum health you need to start with to beat 
/// the game.
///
/// Example 3:
/// Input: damage = [3,3,3], armor = 0
/// Output: 10
/// Explanation: One optimal way to beat the game starting at 10 health is:
/// On round 1, take 3 damage. You have 10 - 3 = 7 health.
/// On round 2, take 3 damage. You have 7 - 3 = 4 health.
/// On round 3, take 3 damage. You have 4 - 3 = 1 health.
/// Note that you did not use your armor ability.
/// 
/// Constraints:
/// 1. n == damage.length
/// 2. 1 <= n <= 10^5
/// 3. 0 <= damage[i] <= 10^5
/// 4. 0 <= armor <= 10^5
/// </summary>
long long LeetCodeArray::minimumHealth(vector<int>& damage, int armor)
{
    int max_damage = 0;
    long long result = 1;
    for (size_t i = 0; i < damage.size(); i++)
    {
        max_damage = max(max_damage, damage[i]);
        result += (long long)damage[i];
    }
    if (max_damage >= armor)
    {
        result -= (long long)armor;
    }
    else
    {
        result -= (long long)max_damage;
    }
    return result;
}

/// <summary>
/// Leet Code 2210. Count Hills and Valleys in an Array
///                                                                                   
/// Easy
///
/// You are given a 0-indexed integer array nums. An index i is part of a 
/// hill in nums if the closest non-equal neighbors of i are smaller than 
/// nums[i]. Similarly, an index i is part of a valley in nums if the 
/// closest non-equal neighbors of i are larger than nums[i]. Adjacent 
/// indices i and j are part of the same hill or valley if 
/// nums[i] == nums[j].
/// 
/// Note that for an index to be part of a hill or valley, it must have a 
/// non-equal neighbor on both the left and right of the index.
///
/// Return the number of hills and valleys in nums.
/// 
/// Example 1:
/// Input: nums = [2,4,1,1,6,5]
/// Output: 3
/// Explanation:
/// At index 0: There is no non-equal neighbor of 2 on the left, so 
/// index 0 is neither a hill nor a valley.
/// At index 1: The closest non-equal neighbors of 4 are 2 and 1. 
/// Since 4 > 2 and 4 > 1, index 1 is a hill. 
/// At index 2: The closest non-equal neighbors of 1 are 4 and 6. 
/// Since 1 < 4 and 1 < 6, index 2 is a valley.
/// At index 3: The closest non-equal neighbors of 1 are 4 and 6. 
/// Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it 
/// is part of the same valley as index 2.
/// At index 4: The closest non-equal neighbors of 6 are 1 and 5. 
/// Since 6 > 1 and 6 > 5, index 4 is a hill.
/// At index 5: There is no non-equal neighbor of 5 on the right, so 
/// index 5 is neither a hill nor a valley. 
/// There are 3 hills and valleys so we return 3.
///
/// Example 2:
/// Input: nums = [6,6,5,5,4,1]
/// Output: 0
/// Explanation:
/// At index 0: There is no non-equal neighbor of 6 on the left, so 
/// index 0 is neither a hill nor a valley.
/// At index 1: There is no non-equal neighbor of 6 on the left, so 
/// index 1 is neither a hill nor a valley.
/// At index 2: The closest non-equal neighbors of 5 are 6 and 4. 
/// Since 5 < 6 and 5 > 4, index 2 is neither a hill nor a valley.
/// At index 3: The closest non-equal neighbors of 5 are 6 and 4. 
/// Since 5 < 6 and 5 > 4, index 3 is neither a hill nor a valley.
/// At index 4: The closest non-equal neighbors of 4 are 5 and 1. 
/// Since 4 < 5 and 4 > 1, index 4 is neither a hill nor a valley.
/// At index 5: There is no non-equal neighbor of 1 on the right, 
/// so index 5 is neither a hill nor a valley.
/// There are 0 hills and valleys so we return 0.
///
/// Constraints:
/// 1. 3 <= nums.length <= 100
/// 2. 1 <= nums[i] <= 100
/// </summary>
int LeetCodeArray::countHillValley(vector<int>& nums)
{
    int prev = 0;
    int accum = 0;
    int result = 0;
    for (size_t i = 1; i < nums.size(); i++)
    {
        int curr = 0;
        if (nums[i] < nums[i - 1]) curr = -1;
        else if (nums[i] > nums[i - 1]) curr = 1;
        else curr = 0;
        if (curr == 0) accum++;
        else accum = 1;

        if (curr != 0)
        {
            if (curr * prev == -1) result += accum;
            prev = curr;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2207. Maximize Number of Subsequences in a String
///                                                                                   
/// Medium
///
/// You are given a 0-indexed string text and another 0-indexed string 
/// pattern of length 2, both of which consist of only lowercase English 
/// letters.
///
/// You can add either pattern[0] or pattern[1] anywhere in text exactly 
/// once. Note that the character can be added even at the beginning or 
/// at the end of text.
///
/// Return the maximum number of times pattern can occur as a subsequence 
/// of the modified text.
///
/// A subsequence is a string that can be derived from another string by 
/// deleting some or no characters without changing the order of the 
/// remaining characters.
/// 
/// Example 1:
/// Input: text = "abdcdbc", pattern = "ac"
/// Output: 4
/// Explanation:
/// If we add pattern[0] = 'a' in between text[1] and text[2], we get 
/// "abadcdbc". Now, the number of times "ac" occurs as a subsequence is 4.
/// Some other strings which have 4 subsequences "ac" after adding a 
/// character to text are "aabdcdbc" and "abdacdbc".
/// However, strings such as "abdcadbc", "abdccdbc", and "abdcdbcc", 
/// although obtainable, have only 3 subsequences "ac" and are thus 
/// suboptimal.
/// It can be shown that it is not possible to get more than 4 
/// subsequences "ac" by adding only one character.
///
/// Example 2:
/// Input: text = "aabb", pattern = "ab"
/// Output: 6
/// Explanation:
/// Some of the strings which can be obtained from text and have 6 
/// subsequences "ab" are "aaabb", "aaabb", and "aabbb".
///
/// Constraints:
/// 1. 1 <= text.length <= 10^5
/// 2. pattern.length == 2
/// 3. text and pattern consist only of lowercase English letters.
/// </summary>
long long LeetCodeArray::maximumSubsequenceCount(string text, string pattern)
{
    int left = 0;
    int right = 0;
    long long result = 0;;
    for (size_t i = 0; i < text.size(); i++)
    {
        if (text[i] == pattern[1])
        {
            result += (long long)left;
        }
        if (text[i] == pattern[0])
        {
            left++;
        }
        else if (text[i] == pattern[1])
        {
            right++;
        }
    }
    result += (long long)max(left, right);
    return result;
}

/// <summary>
/// Leet Code 2208. Minimum Operations to Halve Array Sum
///                                                                                   
/// Medium
///
/// You are given an array nums of positive integers. In one operation, 
/// you can choose any number from nums and reduce it to exactly half 
/// the number. (Note that you may choose this reduced number in future 
/// operations.)
///
/// Return the minimum number of operations to reduce the sum of nums by 
/// at least half.
///
/// Example 1:
/// Input: nums = [5,19,8,1]
/// Output: 3
/// Explanation: The initial sum of nums is equal to 5 + 19 + 8 + 1 = 33.
/// The following is one of the ways to reduce the sum by at least half:
/// Pick the number 19 and reduce it to 9.5.
/// Pick the number 9.5 and reduce it to 4.75.
/// Pick the number 8 and reduce it to 4.
/// The final array is [5, 4.75, 4, 1] with a total sum of 
/// 5 + 4.75 + 4 + 1 = 14.75. 
/// The sum of nums has been reduced by 33 - 14.75 = 18.25, which is at 
/// least half of the initial sum, 18.25 >= 33/2 = 16.5.
/// Overall, 3 operations were used so we return 3.
/// It can be shown that we cannot reduce the sum by at least half in less 
/// than 3 operations.
///
/// Example 2:
/// Input: nums = [3,8,20]
/// Output: 3
/// Explanation: The initial sum of nums is equal to 3 + 8 + 20 = 31.
/// The following is one of the ways to reduce the sum by at least half:
/// Pick the number 20 and reduce it to 10.
/// Pick the number 10 and reduce it to 5.
/// Pick the number 3 and reduce it to 1.5.
/// The final array is [1.5, 8, 5] with a total sum of 1.5 + 8 + 5 = 14.5. 
/// The sum of nums has been reduced by 31 - 14.5 = 16.5, which is at 
/// least half of the initial sum, 16.5 >= 31/2 = 16.5.
/// Overall, 3 operations were used so we return 3.
/// It can be shown that we cannot reduce the sum by at least half in less 
/// than 3 operations.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^7
/// </summary>
int LeetCodeArray::halveArray(vector<int>& nums)
{
    priority_queue<double> pq;
    double sum = 0;
    double remain = 0;
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        pq.push(nums[i]);
        sum += nums[i];
    }
    remain = sum;
    while (remain > sum / 2)
    {
        double max_val = pq.top();
        pq.pop();
        max_val /= 2;
        pq.push(max_val);
        remain -= max_val;
        result++;
    }
    return result;
}

/// <summary>
/// Leet Code 2216. Minimum Deletions to Make Array Beautiful
///                                                                                   
/// Medium
///
/// You are given a 0-indexed integer array nums. The array nums is 
/// beautiful if:
/// nums.length is even.
/// nums[i] != nums[i + 1] for all i % 2 == 0.
/// Note that an empty array is considered beautiful.
/// You can delete any number of elements from nums. When you delete 
/// an element, all the elements to the right of the deleted element 
/// will be shifted one unit to the left to fill the gap created and 
/// all the elements to the left of the deleted element will remain 
/// unchanged.
/// 
/// Return the minimum number of elements to delete from nums to 
/// make it beautiful.
/// 
/// Example 1:
/// Input: nums = [1,1,2,3,5]
/// Output: 1
/// Explanation: You can delete either nums[0] or nums[1] to make 
/// nums = [1,2,3,5] which is beautiful. It can be proven you 
/// need at least 1 deletion to make nums beautiful.
///
/// Example 2:
/// Input: nums = [1,1,2,2,3,3]
/// Output: 2
/// Explanation: You can delete nums[0] and nums[5] to make 
/// nums = [1,2,2,3] which is beautiful. It can be proven you need 
/// at least 2 deletions to make nums beautiful.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 10^5
/// </summary>
int LeetCodeArray::minDeletion(vector<int>& nums)
{
    vector<int> arr;
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if ((arr.size() % 2 == 1) && (nums[i] == arr.back()))
        {
            result++;
        }
        else
        {
            arr.push_back(nums[i]);
        }
    }
    if (arr.size() % 2 == 1)
    {
        arr.pop_back();
        result++;
    }
    return result;
}

/// <summary>
/// Leet Code 2219. Maximum Sum Score of Array
///                                                                                   
/// Medium
///
/// You are given a 0-indexed integer array nums of length n.
///
/// The sum score of nums at an index i where 0 <= i < n is the maximum of:
///
/// The sum of the first i + 1 elements of nums.
/// The sum of the last n - i elements of nums.
/// Return the maximum sum score of nums at any index.
/// 
/// Example 1:
/// Input: nums = [4,3,-2,5]
/// Output: 10
/// Explanation:
/// The sum score at index 0 is max(4, 4 + 3 + -2 + 5) = max(4, 10) = 10.
/// The sum score at index 1 is max(4 + 3, 3 + -2 + 5) = max(7, 6) = 7.
/// The sum score at index 2 is max(4 + 3 + -2, -2 + 5) = max(5, 3) = 5.
/// The sum score at index 3 is max(4 + 3 + -2 + 5, 5) = max(10, 5) = 10.
/// The maximum sum score of nums is 10.
///
/// Example 2:
/// Input: nums = [-3,-5]
/// Output: -3
/// Explanation:
/// The sum score at index 0 is max(-3, -3 + -5) = max(-3, -8) = -3.
/// The sum score at index 1 is max(-3 + -5, -5) = max(-8, -5) = -5.
/// The maximum sum score of nums is -3.
/// 
/// Constraints:
/// 1. n == nums.length
/// 2. 1 <= n <= 10^5
/// 3. -10^5 <= nums[i] <= 10^5
/// </summary>
long long LeetCodeArray::maximumSumScore(vector<int>& nums)
{
    long long left = 0;
    long long right = 0;
    long long result = LLONG_MIN;
    for (size_t i = 0; i < nums.size(); i++) right += (long long)nums[i];
    for (size_t i = 0; i < nums.size(); i++)
    {
        left += (long long)nums[i];
        result = max(result, left);
        result = max(result, right);
        right -= (long long)nums[i];
    }
    return result;
}

/// <summary>
/// Leet Code 2221. Find Triangular Sum of an Array
///                                                                                   
/// Medium
///
/// You are given a 0-indexed integer array nums, where nums[i] is a 
/// digit between 0 and 9 (inclusive).
///
/// The triangular sum of nums is the value of the only element present 
/// in nums after the following process terminates:
///
/// Let nums comprise of n elements. If n == 1, end the process. 
/// Otherwise, create a new 0-indexed integer array newNums of length 
/// n - 1.
/// For each index i, where 0 <= i < n - 1, assign the value of 
/// newNums[i] as (nums[i] + nums[i+1]) % 10, where % denotes modulo 
/// operator.
/// Replace the array nums with newNums.
/// Repeat the entire process starting from step 1.
/// Return the triangular sum of nums.
///
/// Example 1:
/// Input: nums = [1,2,3,4,5]
/// Output: 8 
/// Explanation:
/// The above diagram depicts the process from which we obtain the 
/// triangular sum of the array.
/// 
/// Example 2:
/// Input: nums = [5]
/// Output: 5
/// Explanation:
/// Since there is only one element in nums, the triangular sum is the 
/// value of that element itself.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 1000
/// 2. 0 <= nums[i] <= 9
/// </summary>
int LeetCodeArray::triangularSum(vector<int>& nums)
{
    vector<vector<int>>dp(2);
    int curr = 0;
    int next = 1;
    for (size_t i = 0; i < nums.size(); i++)
    {
        dp[curr].push_back(nums[i]);
    }
    while (dp[curr].size() > 1)
    {
        dp[next].clear();
        for (size_t i = 1; i < dp[curr].size(); i++)
        {
            dp[next].push_back((dp[curr][i - 1] + dp[curr][i]) % 10);
        }
        std::swap(curr, next);
    }
    return dp[curr][0];
}

/// <summary>
/// Leet Code 2225. Find Players With Zero or One Losses
///                                                                                   
/// Medium
///
/// You are given an integer array matches where matches[i] = 
/// [winneri, loseri] indicates that the player winneri defeated 
/// player loseri in a match.
///
/// Return a list answer of size 2 where:
///
/// answer[0] is a list of all players that have not lost any matches.
/// answer[1] is a list of all players that have lost exactly one match.
/// The values in the two lists should be returned in increasing order.
///
/// Note:
/// You should only consider the players that have played at least one match.
/// The testcases will be generated such that no two matches will have the 
/// same outcome.
/// 
/// Example 1:
/// Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],
/// [10,4],[10,9]]
/// Output: [[1,2,10],[4,5,7,8]]
/// Explanation:
/// Players 1, 2, and 10 have not lost any matches.
/// Players 4, 5, 7, and 8 each have lost one match.
/// Players 3, 6, and 9 each have lost two matches.
/// Thus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].
/// 
/// Example 2:
/// Input: matches = [[2,3],[1,3],[5,4],[6,4]]
/// Output: [[1,2,5,6],[]]
/// Explanation:
/// Players 1, 2, 5, and 6 have not lost any matches.
/// Players 3 and 4 each have lost two matches.
/// Thus, answer[0] = [1,2,5,6] and answer[1] = [].
/// 
/// Constraints:
/// 1. 1 <= matches.length <= 10^5
/// 2. matches[i].length == 2
/// 3. 1 <= winneri, loseri <= 10^5
/// 4. winneri != loseri
/// 5. All matches[i] are unique.
/// </summary>
vector<vector<int>> LeetCodeArray::findWinners(vector<vector<int>>& matches)
{
    vector<vector<int>> result(2);
    vector<int> winners(100001), losers(100001);
    for (size_t i = 0; i < matches.size(); i++)
    {
        winners[matches[i][0]]++;
        losers[matches[i][1]]++;
    }
    for (size_t i = 0; i < winners.size(); i++)
    {
        if (winners[i] + losers[i] == 0) continue;
        if (losers[i] == 0) result[0].push_back(i);
        else if (losers[i] == 1) result[1].push_back(i);
    }
    return result;
}

/// <summary>
/// Leet Code 2229. Check if an Array Is Consecutive
///                                                                                   
/// Easy
///
/// Given an integer array nums, return true if nums is consecutive, 
/// otherwise return false.
///
/// An array is consecutive if it contains every number in the range 
/// [x, x + n - 1] (inclusive), where x is the minimum number in the 
/// array and n is the length of the array.
///
/// Example 1:
/// Input: nums = [1,3,4,2]
/// Output: true
/// Explanation:
/// The minimum value is 1 and the length of nums is 4.
/// All of the values in the range [x, x + n - 1] = [1, 1 + 4 - 1] = 
/// [1, 4] = (1, 2, 3, 4) occur in nums.
/// Therefore, nums is consecutive.
///
/// Example 2:
/// Input: nums = [1,3]
/// Output: false
/// Explanation:
/// The minimum value is 1 and the length of nums is 2.
/// The value 2 in the range [x, x + n - 1] = [1, 1 + 2 - 1], 
/// = [1, 2] = (1, 2) does not occur in nums.
/// Therefore, nums is not consecutive.
///
/// Example 3:
/// Input: nums = [3,5,4]
/// Output: true
/// Explanation:
/// The minimum value is 3 and the length of nums is 3.
/// All of the values in the range [x, x + n - 1] = [3, 3 + 3 - 1] 
/// = [3, 5] = (3, 4, 5) occur in nums.
/// Therefore, nums is consecutive.
///  
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 10^5
/// </summary>
bool LeetCodeArray::isConsecutive(vector<int>& nums)
{
    vector<int> temp = nums;
    sort(temp.begin(), temp.end());
    for (size_t i = 1; i < temp.size(); i++)
    {
        if (temp[i] != temp[i - 1] + 1) return false;
    }
    return true;
}

/// <summary>
/// Leet Code 2245. Maximum Trailing Zeros in a Cornered Path
///                                                                                      
/// Medium
/// 
/// You are given a 2D integer array grid of size m x n, where each cell 
/// contains a positive integer.
/// A cornered path is defined as a set of adjacent cells with at most one 
/// turn. More specifically, the path should exclusively move either 
/// horizontally or vertically up to the turn (if there is one), without 
/// returning to a previously visited cell. After the turn, the path will 
/// then move exclusively in the alternate direction: move vertically if 
/// it moved horizontally, and vice versa, also without returning to a 
/// previously visited cell.
///
/// The product of a path is defined as the product of all the values 
/// in the path.
///
/// Return the maximum number of trailing zeros in the product of a 
/// cornered path found in grid.
///
/// Note:
/// Horizontal movement means moving in either the left or right direction.
/// Vertical movement means moving in either the up or down direction.
///
/// Example 1:
/// Input: grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],
///                [40,9,1,10,6],[22,7,4,5,3]]
/// Output: 3
/// Explanation: The grid on the left shows a valid cornered path.
/// It has a product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing 
/// zeros.
/// It can be shown that this is the maximum trailing zeros in the product 
/// of a cornered path.
///
/// The grid in the middle is not a cornered path as it has more than 
/// one turn.
/// The grid on the right is not a cornered path as it requires a return 
/// to a previously visited cell.
///
/// Example 2:
/// Input: grid = [[4,3,2],[7,6,1],[8,8,8]]
/// Output: 0
/// Explanation: The grid is shown in the figure above.
/// There are no cornered paths in the grid that result in a product with 
/// a trailing zero.
/// 
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 1 <= m, n <= 10^5
/// 4. 1 <= m * n <= 10^5
/// 5. 1 <= grid[i][j] <= 1000
/// </summary>
int LeetCodeArray::maxTrailingZeros(vector<vector<int>>& grid)
{
    int m = grid.size();
    int n = grid[0].size();
    int result = 0;
    for (int d = 0; d < 4; d++)
    {
        vector<int> row_10(m), row_5(m), row_2(m);
        vector<int> col_10(n), col_5(n), col_2(n);
        int r1 = 0, r2 = 0, ri = 0,  c1 = 0, c2 = 0, ci = 0;
        if (d / 2 == 0)
        {
            r1 = 0; r2 = m; ri = 1;
        }
        else
        {
            r1 = m - 1; r2 = -1; ri = -1;
        }
        if (d % 2 == 0)
        {
            c1 = 0; c2 = n; ci = 1;
        }
        else
        {
            c1 = n - 1; c2 = -1; ci = -1;
        }
        for (int i = r1; i != r2; i += ri)
        {
            for (int j = c1; j != c2; j += ci)
            {
                int count_10 = 0;
                int count_5 = 0;
                int count_2 = 0;
                int val = grid[i][j];
                while (val % 10 == 0)
                {
                    count_10++;
                    val /= 10;
                }
                while (val % 5 == 0)
                {
                    count_5++;
                    val /= 5;
                }
                while (val % 2 == 0)
                {
                    count_2++;
                    val /= 2;
                }
                int sum = count_10 + row_10[i] + col_10[j];
                sum += min(row_5[i] + col_5[j] + count_5, row_2[i] + col_2[j] + count_2);
                result = max(result, sum);
                row_10[i] += count_10;
                col_10[j] += count_10;
                row_5[i] += count_5;
                col_5[j] += count_5;
                row_2[i] += count_2;
                col_2[j] += count_2;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2256. Minimum Average Difference
///                                                           
/// Medium
/// 
/// You are given a 0-indexed integer array nums of length n.
///
/// The average difference of the index i is the absolute difference 
/// between the average of the first i + 1 elements of nums and the 
/// average of the last n - i - 1 elements. Both averages should be 
/// rounded down to the nearest integer.
///
/// Return the index with the minimum average difference. If there are 
/// multiple such indices, return the smallest one.
///
/// Note:
/// The absolute difference of two numbers is the absolute value of their 
/// difference.
/// The average of n elements is the sum of the n elements divided (integer 
/// division) by n.
/// The average of 0 elements is considered to be 0.
///
/// Example 1:
/// Input: nums = [2,5,3,9,5,3]
/// Output: 3
/// Explanation:
/// - The average difference of index 0 is: |2 / 1 - (5 + 3 + 9 + 5 + 3) / 
///   5| = |2 / 1 - 25 / 5| = |2 - 5| = 3.
/// - The average difference of index 1 is: |(2 + 5) / 2 - (3 + 9 + 
///   5 + 3) / 4| = |7 / 2 - 20 / 4| = |3 - 5| = 2.
/// - The average difference of index 2 is: |(2 + 5 + 3) / 3 - 
///  (9 + 5 + 3) / 3| = |10 / 3 - 17 / 3| = |3 - 5| = 2.
/// - The average difference of index 3 is: |(2 + 5 + 3 + 9) / 4 - 
///   (5 + 3) / 2| = |19 / 4 - 8 / 2| = |4 - 4| = 0.
/// - The average difference of index 4 is: |(2 + 5 + 3 + 9 + 5) / 5 - 3 / 
///   1| = |24 / 5 - 3 / 1| = |4 - 3| = 1.
/// - The average difference of index 5 is: |(2 + 5 + 3 + 9 + 5 + 3) / 
///   6 - 0| = |27 / 6 - 0| = |4 - 0| = 4.
/// The average difference of index 3 is the minimum average difference 
/// so return 3.
///
/// Example 2:
/// Input: nums = [0]
/// Output: 0
/// Explanation:
/// The only index is 0 so return 0.
/// The average difference of index 0 is: |0 / 1 - 0| = |0 - 0| = 0.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 10^5
/// </summary>
int LeetCodeArray::minimumAverageDifference(vector<int>& nums)
{
    long long left_sum = 0;
    long long right_sum = 0;
    int min_val = INT_MAX;
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++) right_sum += (long long)nums[i];
    for (size_t i = 0; i < nums.size(); i++)
    {
        left_sum += (long long)nums[i];
        right_sum -= (long long)nums[i];
        int diff = 0;
        if (i == nums.size() - 1)
        {
            diff = (int)(left_sum / ((long long)i + 1));
        }
        else
        {
            diff = (int)abs(left_sum / ((long long)i + 1) - (right_sum / (long long)(nums.size() - (i + 1))));
        }
        if (diff < min_val)
        {
            min_val = diff;
            result = i;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2270. Number of Ways to Split Array
///                                                           
/// Medium
/// 
/// You are given a 0-indexed integer array nums of length n.
/// nums contains a valid split at index i if the following are true:
///
/// The sum of the first i + 1 elements is greater than or equal to the 
/// sum of the last n - i - 1 elements.
/// There is at least one element to the right of i. That is, 0 <= i < 
/// n - 1.
/// Return the number of valid splits in nums.
/// 
/// Example 1:
/// Input: nums = [10,4,-8,7]
/// Output: 2
/// Explanation: 
/// There are three ways of splitting nums into two non-empty parts: 
/// - Split nums at index 0. Then, the first part is [10], and its sum 
///   is 10. The second part is [4,-8,7], and its sum is 3. Since 10 >= 3, 
///   i = 0 is a valid split.
/// - Split nums at index 1. Then, the first part is [10,4], and its sum 
///   is 14. The second part is [-8,7], and its sum is -1. Since 14 >= -1, 
///   i = 1 is a valid split.
/// - Split nums at index 2. Then, the first part is [10,4,-8], and its 
///   sum is 6. The second part is [7], and its sum is 7. Since 6 < 7, 
///   i = 2 is not a valid split.
/// Thus, the number of valid splits in nums is 2.
///
/// Example 2:
/// Input: nums = [2,3,1,0]
/// Output: 2
/// Explanation: 
/// There are two valid splits in nums:
/// - Split nums at index 1. Then, the first part is [2,3], and its sum 
///   is 5. The second part is [1,0], and its sum is 1. Since 5 >= 1, 
///   i = 1 is a valid split. 
/// - Split nums at index 2. Then, the first part is [2,3,1], and its 
///   sum is 6. The second part is [0], and its sum is 0. Since 6 >= 0, 
///   i = 2 is a valid split.
/// 
/// Constraints:
/// 1. 2 <= nums.length <= 10^5
/// 2. -10^5 <= nums[i] <= 10^5
/// </summary>
int LeetCodeArray::waysToSplitArray(vector<int>& nums)
{
    long long left_sum = 0;
    long long right_sum = 0;
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++) right_sum += (long long)nums[i];
    for (size_t i = 0; i < nums.size() - 1; i++)
    {
        left_sum += (long long)nums[i];
        right_sum -= (long long)nums[i];
        if (left_sum >= right_sum) result++;
    }
    return result;
}

/// <summary>
/// Leet Code 2261. K Divisible Elements Subarrays
///                                                           
/// Medium
/// 
/// Given an integer array nums and two integers k and p, return the 
/// number of distinct subarrays which have at most k elements divisible 
/// by p.
///
/// Two arrays nums1 and nums2 are said to be distinct if:
/// They are of different lengths, or
/// There exists at least one index i where nums1[i] != nums2[i].
/// A subarray is defined as a non-empty contiguous sequence of elements 
/// in an array.
/// 
/// Example 1:
/// Input: nums = [2,3,3,2,2], k = 2, p = 2
/// Output: 11
/// Explanation:
/// The elements at indices 0, 3, and 4 are divisible by p = 2.
/// The 11 distinct subarrays which have at most k = 2 elements divisible 
/// by 2 are:
/// [2], [2,3], [2,3,3], [2,3,3,2], [3], [3,3], [3,3,2], [3,3,2,2], [3,2], 
/// [3,2,2], and [2,2].
/// Note that the subarrays [2] and [3] occur more than once in nums, but 
/// they should each be counted only once.
/// The subarray [2,3,3,2,2] should not be counted because it has 3 
/// elements that are divisible by 2.
///
/// Example 2:
/// Input: nums = [1,2,3,4], k = 4, p = 1
/// Output: 10
/// Explanation:
/// All element of nums are divisible by p = 1.
/// Also, every subarray of nums will have at most 4 elements that are 
/// divisible by 1.
/// Since all subarrays are distinct, the total number of subarrays 
/// satisfying all the constraints is 10.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 200
/// 2. 1 <= nums[i], p <= 200
/// 3. 1 <= k <= nums.length
/// </summary>
int LeetCodeArray::countDistinct(vector<int>& nums, int k, int p)
{
    unordered_set<string> dictionary;
    for (size_t i = 0; i < nums.size(); i++)
    {
        string str;
        int count = 0;
        for (size_t j = i; j < nums.size(); j++)
        {
            str.push_back(nums[j]);
            if (nums[j] % p == 0)
            {
                count++;
            }
            if (count > k)
            {
                break;
            }
            dictionary.insert(str);
        }
    }
    return dictionary.size();
}

/// <summary>
/// Leet Code 2260. Minimum Consecutive Cards to Pick Up
///                                                           
/// Medium
/// 
/// You are given an integer array cards where cards[i] represents the 
/// value of the ith card. A pair of cards are matching if the cards 
/// have the same value.
///
/// Return the minimum number of consecutive cards you have to pick up 
/// to have a pair of matching cards among the picked cards. If it is 
/// impossible to have matching cards, return -1.
/// 
/// Example 1:
/// Input: cards = [3,4,2,3,4,7]
/// Output: 4
/// Explanation: We can pick up the cards [3,4,2,3] which contain a 
/// matching pair of cards with value 3. Note that picking up the 
/// cards [4,2,3,4] is also optimal.
///
/// Example 2:
/// Input: cards = [1,0,5,3]
/// Output: -1
/// Explanation: There is no way to pick up a set of consecutive cards 
/// that contain a pair of matching cards.
/// 
/// Constraints:
/// 1. 1 <= cards.length <= 10^5
/// 2. 0 <= cards[i] <= 10^6
/// </summary>
int LeetCodeArray::minimumCardPickup(vector<int>& cards)
{
    unordered_map<int, int> card_map;
    int result = INT_MAX;
    for (int i = 0; i < (int)cards.size(); i++)
    {
        if (card_map.count(cards[i]) > 0)
        {
            result = min(result, i - card_map[cards[i]] + 1);
        }
        card_map[cards[i]] = i;
    }
    return (result == INT_MAX ? -1 : result);
}

/// <summary>
/// Leet Code 2293. Min Max Game
///                                                           
/// Easy
/// 
/// You are given a 0-indexed integer array nums whose length is a power 
/// of 2.
///
/// Apply the following algorithm on nums:
/// 
/// Let n be the length of nums. If n == 1, end the process. Otherwise, 
/// create a new 0-indexed integer array newNums of length n / 2.
/// For every even index i where 0 <= i < n / 2, assign the value of 
/// newNums[i] as min(nums[2 * i], nums[2 * i + 1]).
/// For every odd index i where 0 <= i < n / 2, assign the value of 
/// newNums[i] as max(nums[2 * i], nums[2 * i + 1]).
/// Replace the array nums with newNums.
/// Repeat the entire process starting from step 1.
/// Return the last number that remains in nums after applying the 
/// algorithm.
/// 
/// Example 1:
/// Input: nums = [1,3,5,2,4,8,2,2]
/// Output: 1
/// Explanation: The following arrays are the results of applying the 
/// algorithm repeatedly.
/// First: nums = [1,5,4,2]
/// Second: nums = [1,4]
/// Third: nums = [1]
/// 1 is the last remaining number, so we return 1.
///
/// Example 2:
/// Input: nums = [3]
/// Output: 3
/// Explanation: 3 is already the last remaining number, so we return 3.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 1024
/// 2. 1 <= nums[i] <= 10^9
/// 3. nums.length is a power of 2.
/// </summary>
int LeetCodeArray::minMaxGame(vector<int>& nums)
{
    queue<int> queue;
    for (auto x : nums) queue.push(x);
    int seq = 0;
    while (queue.size() > 1)
    {
        int a = queue.front();
        queue.pop();
        int b = queue.front();
        queue.pop();
        if (seq == 0) queue.push(min(a, b));
        else queue.push(max(a, b));
        seq = 1 - seq;
    }
    return queue.front();
}

/// <summary>
/// Leet Code 2294. Partition Array Such That Maximum Difference Is K
///                                                           
/// Medium
/// 
/// You are given an integer array nums and an integer k. You may 
/// partition nums into one or more subsequences such that each 
/// element in nums appears in exactly one of the subsequences.
///
/// Return the minimum number of subsequences needed such that the 
/// difference between the maximum and minimum values in each 
/// subsequence is at most k.
///
/// A subsequence is a sequence that can be derived from another 
/// sequence by deleting some or no elements without changing the 
/// order of the remaining elements.
/// 
/// Example 1:
/// Input: nums = [3,6,1,2,5], k = 2
/// Output: 2
/// Explanation:
/// We can partition nums into the two subsequences [3,1,2] and [6,5].
/// The difference between the maximum and minimum value in the first 
/// subsequence is 3 - 1 = 2.
/// The difference between the maximum and minimum value in the second 
/// subsequence is 6 - 5 = 1.
/// Since two subsequences were created, we return 2. It can be shown 
/// that 2 is the minimum number of subsequences needed.
///
/// Example 2:
/// Input: nums = [1,2,3], k = 1
/// Output: 2
/// Explanation:
/// We can partition nums into the two subsequences [1,2] and [3].
/// The difference between the maximum and minimum value in the first 
/// subsequence is 2 - 1 = 1.
/// The difference between the maximum and minimum value in the second 
/// subsequence is 3 - 3 = 0.
/// Since two subsequences were created, we return 2. Note that another 
/// optimal solution is to partition nums into the two subsequences [1] 
/// and [2,3].
///
/// Example 3:
/// Input: nums = [2,2,4,5], k = 0
/// Output: 3
/// Explanation:
/// We can partition nums into the three subsequences [2,2], [4], and [5].
/// The difference between the maximum and minimum value in the first 
/// subsequences is 2 - 2 = 0.
/// The difference between the maximum and minimum value in the second 
/// subsequences is 4 - 4 = 0.
/// The difference between the maximum and minimum value in the third 
/// subsequences is 5 - 5 = 0.
/// Since three subsequences were created, we return 3. It can be shown 
/// that 3 is the minimum number of subsequences needed.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 10^5
/// 3. 0 <= k <= 10^5
/// </summary>
int LeetCodeArray::partitionArray(vector<int>& nums, int k)
{
    sort(nums.begin(), nums.end());
    int result = 1;
    int first = nums[0];
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] - first > k)
        {
            first = nums[i];
            result++;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2304. Minimum Path Cost in a Grid
///                                                           
/// Medium
/// 
/// You are given a 0-indexed m x n integer matrix grid consisting of 
/// distinct integers from 0 to m * n - 1. You can move in this matrix 
/// from a cell to any other cell in the next row. That is, if you are 
/// in cell (x, y) such that x < m - 1, you can move to any of the 
/// cells (x + 1, 0), (x + 1, 1), ..., (x + 1, n - 1). Note that it is 
/// not possible to move from cells in the last row.
///
/// Each possible move has a cost given by a 0-indexed 2D array moveCost 
/// of size (m * n) x n, where moveCost[i][j] is the cost of moving from 
/// a cell with value i to a cell in column j of the next row. The cost 
/// of moving from cells in the last row of grid can be ignored.
///
/// The cost of a path in grid is the sum of all values of cells visited 
/// plus the sum of costs of all the moves made. Return the minimum cost 
/// of a path that starts from any cell in the first row and ends at any 
/// cell in the last row.
/// 
/// Example 1:
/// Input: grid = [[5,3],[4,0],[2,1]], 
/// moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]
/// Output: 17
/// Explanation: The path with the minimum possible cost is the 
/// path 5 -> 0 -> 1.
/// - The sum of the values of cells visited is 5 + 0 + 1 = 6.
/// - The cost of moving from 5 to 0 is 3.
/// - The cost of moving from 0 to 1 is 8.
/// So the total cost of the path is 6 + 3 + 8 = 17.
/// Example 2:
///
/// Input: grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],
/// [21,7,1],[8,1,13],[9,10,25],[5,3,2]]
/// Output: 6
/// Explanation: The path with the minimum possible cost is the 
/// path 2 -> 3.
/// - The sum of the values of cells visited is 2 + 3 = 5.
/// - The cost of moving from 2 to 3 is 1.
/// So the total cost of this path is 5 + 1 = 6.
/// 
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 2 <= m, n <= 50
/// 4. grid consists of distinct integers from 0 to m * n - 1.
/// 5. moveCost.length == m * n
/// 6. moveCost[i].length == n
/// 7. 1 <= moveCost[i][j] <= 100
/// </summary>
int LeetCodeArray::minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost)
{
    int m = grid.size();
    int n = grid[0].size();
    vector<int> curr, next;
    for (int i = 0; i < m - 1; i++)
    {
        if (i == 0) curr = grid[0];
        else curr = next;
        next = vector<int>(n, INT_MAX);
        for (int j = 0; j < n; j++)
        {
            for (int k = 0; k < n; k++)
            {
                next[k] = min(next[k], curr[j] + grid[i + 1][k] + moveCost[grid[i][j]][k]);
            }
        }
    }
    int result = INT_MAX;
    for (int i = 0; i < n; i++)
    {
        result = min(result, next[i]);
    }
    return result;
}


/// <summary>
/// Leet Code 2319. Check if Matrix Is X-Matrix
///                                                           
/// Easy
///
/// A square matrix is said to be an X-Matrix if both of the following 
/// conditions hold:
///
/// All the elements in the diagonals of the matrix are non-zero.
/// All other elements are 0.
/// Given a 2D integer array grid of size n x n representing a square 
/// matrix, return true if grid is an X-Matrix. Otherwise, return false.
///
/// Example 1:
/// Input: grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]
/// Output: true
/// Explanation: Refer to the diagram above. 
/// An X-Matrix should have the green elements (diagonals) be non-zero 
/// and the red elements be 0.
/// Thus, grid is an X-Matrix.
///
/// Example 2:
/// Input: grid = [[5,7,0],[0,3,1],[0,5,0]]
/// Output: false
/// Explanation: Refer to the diagram above.
/// An X-Matrix should have the green elements (diagonals) be non-zero 
/// and the red elements be 0.
/// Thus, grid is not an X-Matrix.
/// 
/// Constraints:
/// 1. n == grid.length == grid[i].length
/// 2. 3 <= n <= 100
/// 3. 0 <= grid[i][j] <= 10^5
/// </summary>
bool LeetCodeArray::checkXMatrix(vector<vector<int>>& grid)
{
    for (size_t i = 0; i < grid.size(); i++)
    {
        for (size_t j = 0; j < grid[i].size(); j++)
        {
            if (i == j || i + j == grid.size() - 1)
            {
                if (grid[i][j] == 0) return false;
            }
            else
            {
                if (grid[i][j] != 0) return false;
            }
        }
    }
    return true;
}

/// <summary>
/// Leet Code 2321. Maximum Score Of Spliced Array
///                                                           
/// Hard
///
/// You are given two 0-indexed integer arrays nums1 and nums2, both of 
/// length n.
///
/// You can choose two integers left and right where 
/// 0 <= left <= right < n and swap the subarray nums1[left...right] 
/// with the subarray nums2[left...right].
///
/// For example, if nums1 = [1,2,3,4,5] and nums2 = [11,12,13,14,15] and 
/// you choose left = 1 and right = 2, nums1 becomes [1,12,13,4,5] and 
/// nums2 becomes [11,2,3,14,15].
/// You may choose to apply the mentioned operation once or not do 
/// anything.
///
/// The score of the arrays is the maximum of sum(nums1) and sum(nums2), 
/// where sum(arr) is the sum of all the elements in the array arr.
///
/// Return the maximum possible score.
///
/// A subarray is a contiguous sequence of elements within an array. 
/// arr[left...right] denotes the subarray that contains the elements 
/// of nums between indices left and right (inclusive).
/// 
/// Example 1:
/// Input: nums1 = [60,60,60], nums2 = [10,90,10]
/// Output: 210
/// Explanation: Choosing left = 1 and right = 1, we have 
/// nums1 = [60,90,60] and nums2 = [10,60,10].
/// The score is max(sum(nums1), sum(nums2)) = max(210, 80) = 210.
///
/// Example 2:
/// Input: nums1 = [20,40,20,70,30], nums2 = [50,20,50,40,20]
/// Output: 220
/// Explanation: Choosing left = 3, right = 4, we have 
/// nums1 = [20,40,20,40,20] and nums2 = [50,20,50,70,30].
/// The score is max(sum(nums1), sum(nums2)) = max(140, 220) = 220.
///
/// Example 3:
/// Input: nums1 = [7,11,13], nums2 = [1,1,1]
/// Output: 31
/// Explanation: We choose not to swap any subarray.
/// The score is max(sum(nums1), sum(nums2)) = max(31, 3) = 31.
///
/// Constraints:
/// 1. n == nums1.length == nums2.length
/// 2. 1 <= n <= 10^5
/// 3. 1 <= nums1[i], nums2[i] <= 10^4
/// </summary>
int LeetCodeArray::maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2)
{
    deque<int> pos_queue;
    deque<int> neg_queue;
    int pos_val = 0;
    int neg_val = 0;
    int max_val = INT_MIN;
    int min_val = INT_MAX;
    int n = nums1.size();
    int sum1_val = 0;
    int sum2_val = 0;
    for (int i = 0; i < n; i++)
    {
        pos_val += nums1[i] - nums2[i];
        if (pos_val < 0) pos_val = 0;
        max_val = max(max_val, pos_val);

        neg_val += nums1[i] - nums2[i];
        if (neg_val > 0) neg_val = 0;
        min_val = min(min_val, neg_val);

        sum1_val += nums1[i];
        sum2_val += nums2[i];

    }
    int result = max(sum1_val  - min_val, sum2_val + max_val);
    return result;
}

/// <summary>
/// Leet Code 2326. Spiral Matrix IV
///                                                           
/// Medium
///
/// You are given two integers m and n, which represent the dimensions of 
/// a matrix.
///
/// You are also given the head of a linked list of integers.
///
/// Generate an m x n matrix that contains the integers in the linked list 
/// presented in spiral order (clockwise), starting from the top-left of 
/// the matrix. If there are remaining empty spaces, fill them with -1.
///
/// Return the generated matrix.
///
/// Example 1:
/// Input: m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]
/// Output: [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]
/// Explanation: The diagram above shows how the values are printed in the 
/// matrix.
/// Note that the remaining spaces in the matrix are filled with -1.
///
/// Example 2:
/// Input: m = 1, n = 4, head = [0,1,2]
/// Output: [[0,1,2,-1]]
/// Explanation: The diagram above shows how the values are printed from 
/// left to right in the matrix.
/// The last space in the matrix is set to -1.
/// 
/// Constraints:
/// 1. 1 <= m, n <= 10^5
/// 2. 1 <= m * n <= 10^5
/// 3. The number of nodes in the list is in the range [1, m * n].
/// 4. 0 <= Node.val <= 1000
/// </summary>
vector<vector<int>> LeetCodeArray::spiralMatrix(int m, int n, ListNode* head)
{
    vector<vector<int>> result(m, vector<int>(n, -1));
    vector<vector<int>> directions = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} };
    int r = 0, c = 0, d = 0;
    ListNode* ptr = head;
    while (ptr != nullptr)
    {
        result[r][c] = ptr->val;
        int n_r = r + directions[d][0], n_c = c + directions[d][1];
        if (n_r < 0 || n_r == m || n_c < 0 || n_c == n || result[n_r][n_c] != -1)
        {
            d = (d + 1) % 4;
        }
        r = r + directions[d][0];
        c = c + directions[d][1];
        ptr = ptr->next;
    }
    return result;
}

/// <summary>
/// Leet Code 2340. Minimum Adjacent Swaps to Make a Valid Array
///                                                           
/// Medium
///
/// You are given a 0-indexed integer array nums.
///
/// Swaps of adjacent elements are able to be performed on nums.
///
/// A valid array meets the following conditions:
///
/// The largest element (any of the largest elements if there are 
/// multiple) is at the rightmost position in the array.
/// The smallest element (any of the smallest elements if there are 
/// multiple) is at the leftmost position in the array.
/// Return the minimum swaps required to make nums a valid array.
///
/// Example 1:
/// Input: nums = [3,4,5,5,3,1]
/// Output: 6
/// Explanation: Perform the following swaps:
/// - Swap 1: Swap the 3rd and 4th elements, nums is then [3,4,5,3,5,1].
/// - Swap 2: Swap the 4th and 5th elements, nums is then [3,4,5,3,1,5].
/// - Swap 3: Swap the 3rd and 4th elements, nums is then [3,4,5,1,3,5].
/// - Swap 4: Swap the 2nd and 3rd elements, nums is then [3,4,1,5,3,5].
/// - Swap 5: Swap the 1st and 2nd elements, nums is then [3,1,4,5,3,5].
/// - Swap 6: Swap the 0th and 1st elements, nums is then [1,3,4,5,3,5].
/// It can be shown that 6 swaps is the minimum swaps required to make a 
/// valid array.
///
/// Example 2:
/// Input: nums = [9]
/// Output: 0
/// Explanation: The array is already valid, so we return 0.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^5
/// </summary>
int LeetCodeArray::minimumSwaps(vector<int>& nums)
{
    pair<int, int> min_num, max_num;
    min_num.first = nums[0];
    min_num.second = 0;
    max_num.first = nums[0];
    max_num.second = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] < min_num.first)
        {
            min_num.first = nums[i];
            min_num.second = i;
        }
        if (nums[i] >= max_num.first)
        {
            max_num.first = nums[i];
            max_num.second = i;
        }
    }
    int result = min_num.second + (nums.size() - 1 - max_num.second);
    if (min_num.second > max_num.second)
    {
        result--;
    }
    return result;
}

/// <summary>
/// Leet Code 2341. Maximum Number of Pairs in Array
///                                                           
/// Easy
///
/// You are given a 0-indexed integer array nums. In one operation, you 
/// may do the following:
///
/// Choose two integers in nums that are equal.
/// Remove both integers from nums, forming a pair.
/// The operation is done on nums as many times as possible.
///
/// Return a 0-indexed integer array answer of size 2 where answer[0] is 
/// the number of pairs that are formed and answer[1] is the number of 
/// leftover integers in nums after doing the operation as many times as 
/// possible.
///
/// Example 1:
/// Input: nums = [1,3,2,1,3,2,2]
/// Output: [3,1]
/// Explanation:
/// Form a pair with nums[0] and nums[3] and remove them from nums. Now, 
/// nums = [3,2,3,2,2].
/// Form a pair with nums[0] and nums[2] and remove them from nums. Now, 
/// nums = [2,2,2].
/// Form a pair with nums[0] and nums[1] and remove them from nums. Now, 
/// nums = [2].
/// No more pairs can be formed. A total of 3 pairs have been formed, and 
/// there is 1 number leftover in nums.
///
/// Example 2:
/// Input: nums = [1,1]
/// Output: [1,0]
/// Explanation: Form a pair with nums[0] and nums[1] and remove them 
/// from nums. Now, nums = [].
/// No more pairs can be formed. A total of 1 pair has been formed, and 
/// there are 0 numbers leftover in nums.
///
/// Example 3:
/// Input: nums = [0]
/// Output: [0,1]
/// Explanation: No pairs can be formed, and there is 1 number leftover 
/// in nums.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 100
/// 2. 0 <= nums[i] <= 100
/// </summary>
vector<int> LeetCodeArray::numberOfPairs(vector<int>& nums)
{
    vector<int> dp(101), result(2);
    for (size_t i = 0; i < nums.size(); i++)
    {
        dp[nums[i]]++;
    }
    for (size_t i = 0; i < dp.size(); i++)
    {
        result[0] += dp[i] / 2;
        result[1] += dp[i] % 2;
    }
    return result;
}

/// <summary>
/// Leet Code 2363. Merge Similar Items
///                                                           
/// Easy
///
/// You are given two 2D integer arrays, items1 and items2, representing 
/// two sets of items. Each array items has the following properties:
///
/// items[i] = [valuei, weighti] where valuei represents the value and 
/// weighti represents the weight of the ith item.
/// The value of each item in items is unique.
/// Return a 2D integer array ret where ret[i] = [valuei, weighti], with 
/// weighti being the sum of weights of all items with value valuei.
///
/// Note: ret should be returned in ascending order by value.
///
/// Example 1:
/// Input: items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]
/// Output: [[1,6],[3,9],[4,5]]
/// Explanation: 
/// The item with value = 1 occurs in items1 with weight = 1 and in 
/// items2 with weight = 5, total weight = 1 + 5 = 6.
/// The item with value = 3 occurs in items1 with weight = 8 and in 
/// items2 with weight = 1, total weight = 8 + 1 = 9.
/// The item with value = 4 occurs in items1 with weight = 5, total 
/// weight = 5.  
/// Therefore, we return [[1,6],[3,9],[4,5]].
///
/// Example 2:
/// Input: items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]
/// Output: [[1,4],[2,4],[3,4]]
/// Explanation: 
/// The item with value = 1 occurs in items1 with weight = 1 and in 
/// items2 with weight = 3, total weight = 1 + 3 = 4.
/// The item with value = 2 occurs in items1 with weight = 3 and in 
/// items2 with weight = 1, total weight = 3 + 1 = 4.
/// The item with value = 3 occurs in items1 with weight = 2 and in 
/// items2 with weight = 2, total weight = 2 + 2 = 4.
/// Therefore, we return [[1,4],[2,4],[3,4]].
///
/// Example 3:
/// Input: items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]
/// Output: [[1,7],[2,4],[7,1]]
/// Explanation:
/// The item with value = 1 occurs in items1 with weight = 3 and in 
/// items2 with weight = 4, total weight = 3 + 4 = 7. 
/// The item with value = 2 occurs in items1 with weight = 2 and in 
/// items2 with weight = 2, total weight = 2 + 2 = 4. 
/// The item with value = 7 occurs in items2 with weight = 1, 
/// total weight = 1.
/// Therefore, we return [[1,7],[2,4],[7,1]].
///
/// Constraints:
/// 1. 1 <= items1.length, items2.length <= 1000
/// 2. items1[i].length == items2[i].length == 2
/// 3. 1 <= valuei, weighti <= 1000
/// 4. Each valuei in items1 is unique.
/// 5. Each valuei in items2 is unique.
/// </summary>
vector<vector<int>> LeetCodeArray::mergeSimilarItems(
    vector<vector<int>>& items1, vector<vector<int>>& items2)
{
    vector<vector<int>> result;
    unordered_map<int, int> item_map;
    for (size_t i = 0; i < items1.size(); i++)
    {
        item_map[items1[i][0]] += items1[i][1];
    }
    for (size_t i = 0; i < items2.size(); i++)
    {
        item_map[items2[i][0]] += items2[i][1];
    }
    for (auto & itr : item_map)
    {
        result.push_back({ itr.first, itr.second });
    }
    return result;
}

/// <summary>
/// Leet Code 2373. Largest Local Values in a Matrix
///                                                           
/// Easy
///
/// You are given an n x n integer matrix grid.
///
/// Generate an integer matrix maxLocal of size (n - 2) x (n - 2) such 
/// that:
///
/// maxLocal[i][j] is equal to the largest value of the 3 x 3 matrix 
/// in grid centered around row i + 1 and column j + 1.
/// In other words, we want to find the largest value in every 
/// contiguous 3 x 3 matrix in grid.
///
/// Return the generated matrix.
/// 
/// Example 1:
/// Input: grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]
/// Output: [[9,9],[8,6]]
/// Explanation: The diagram above shows the original matrix 
/// and the generated matrix.
/// Notice that each value in the generated matrix corresponds to the 
/// largest value of a contiguous 3 x 3 matrix in grid.
///
/// Example 2:
/// Input: grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],
///                [1,1,1,1,1]]
/// Output: [[2,2,2],[2,2,2],[2,2,2]]
/// Explanation: Notice that the 2 is contained within every 
/// contiguous 3 x 3 matrix in grid.
///
/// Constraints:
/// n == grid.length == grid[i].length
/// 3 <= n <= 100
/// 1 <= grid[i][j] <= 100
/// </summary>
vector<vector<int>> LeetCodeArray::largestLocal(vector<vector<int>>& grid)
{
    int n = grid.size() - 2;
    vector<vector<int>> result(n, vector<int>(n));
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            int v = 0;
            for (int r = i; r < i + 3; r++)
            {
                for (int c = j; c < j + 3; c++)
                {
                    v = max(grid[r][c], v);
                }
            }
            result[i][j] = v;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2383. Minimum Hours of Training to Win a Competition
///                                                           
/// Easy
///
/// You are entering a competition, and are given two positive integers 
/// initialEnergy and initialExperience denoting your initial energy and 
/// initial experience respectively.
/// You are also given two 0-indexed integer arrays energy and 
/// experience, both of length n.
/// You will face n opponents in order. The energy and experience of the 
/// ith opponent is denoted by energy[i] and experience[i] respectively. 
/// When you face an opponent, you need to have both strictly greater 
/// experience and energy to defeat them and move to the next opponent 
/// if available.
///
/// Defeating the ith opponent increases your experience by experience[i], 
/// but decreases your energy by energy[i].
///
/// Before starting the competition, you can train for some number of 
/// hours. After each hour of training, you can either choose to increase 
/// your initial experience by one, or increase your initial energy by 
/// one.
///
/// Return the minimum number of training hours required to defeat all 
/// n opponents.
///
/// Example 1:
/// Input: initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], 
/// experience = [2,6,3,1]
/// Output: 8
/// Explanation: You can increase your energy to 11 after 6 hours of 
/// training, and your experience to 5 after 2 hours of training.
/// You face the opponents in the following order:
/// - You have more energy and experience than the 0th opponent so you win.
///   Your energy becomes 11 - 1 = 10, and your experience 
///   becomes 5 + 2 = 7.
/// - You have more energy and experience than the 1st opponent so you win.
///   Your energy becomes 10 - 4 = 6, and your experience 
///   becomes 7 + 6 = 13.
/// - You have more energy and experience than the 2nd opponent so you win.
///   Your energy becomes 6 - 3 = 3, and your experience 
///   becomes 13 + 3 = 16.
/// - You have more energy and experience than the 3rd opponent so you win.
///   Your energy becomes 3 - 2 = 1, and your experience 
///   becomes 16 + 1 = 17.
///   You did a total of 6 + 2 = 8 hours of training before the 
///   competition, so we return 8.
/// It can be proven that no smaller answer exists.
///
/// Example 2:
/// Input: initialEnergy = 2, initialExperience = 4, energy = [1], 
/// experience = [3]
/// Output: 0
/// Explanation: You do not need any additional energy or experience to 
/// win the competition, so we return 0.
///
/// Constraints:
/// 1. n == energy.length == experience.length
/// 2. 1 <= n <= 100
/// 3. 1 <= initialEnergy, initialExperience, energy[i], 
///    experience[i] <= 100
/// </summary>
int LeetCodeArray::minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience)
{
    int result = 0;
    for (size_t i = 0; i < energy.size(); i++)
    {
        if (initialEnergy < energy[i] + 1)
        {
            result += energy[i] + 1 - initialEnergy;
            initialEnergy = energy[i] + 1;
        }
        initialEnergy -= energy[i];
        if (initialExperience < experience[i] + 1)
        {
            result += experience[i] + 1 - initialExperience;
            initialExperience = experience[i] + 1;
        }
        initialExperience += experience[i];
    }
    return result;
}

/// <summary>
/// Leet Code 2352. Equal Row and Column Pairs
///                                                           
/// Medium
///
/// Given a 0-indexed n x n integer matrix grid, return the number of 
/// pairs (Ri, Cj) such that row Ri and column Cj are equal.
///
/// A row and column pair is considered equal if they contain the same 
/// elements in the same order (i.e. an equal array).
///
/// Example 1:
/// Input: grid = [[3,2,1],[1,7,6],[2,7,7]]
/// Output: 1
/// Explanation: There is 1 equal row and column pair:
/// - (Row 2, Column 1): [2,7,7]
/// Example 2:
/// Input: grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]
/// Output: 3
/// Explanation: There are 3 equal row and column pairs:
/// - (Row 0, Column 0): [3,1,2,2]
/// - (Row 2, Column 2): [2,4,2,2]
/// - (Row 3, Column 2): [2,4,2,2]
/// 
/// Constraints:
/// 1. n == grid.length == grid[i].length
/// 2. 1 <= n <= 200
/// 3. 1 <= grid[i][j] <= 10^5
/// </summary>
int LeetCodeArray::equalPairs(vector<vector<int>>& grid)
{
    unordered_map<string, int> rows;
    for (size_t i = 0; i < grid.size(); i++)
    {
        string row;
        for (size_t j = 0; j < grid[i].size(); j++)
        {
            row += to_string(grid[i][j]) + "_";
        }
        rows[row]++;
    }
    int result = 0;
    for (size_t i = 0; i < grid[0].size(); i++)
    {
        string col;
        for (size_t j = 0; j < grid.size(); j++)
        {
            col += to_string(grid[j][i]) + "_";
        }
        if (rows.count(col) == 0) continue;
        result += rows[col];
    }
    return result;
}

/// <summary>
/// Leet Code 2364. Count Number of Bad Pairs
///                                                           
/// Medium
///
/// You are given a 0-indexed integer array nums. A pair of indices 
/// (i, j) is a bad pair if i < j and j - i != nums[j] - nums[i].
///
/// Return the total number of bad pairs in nums.
///
/// Example 1:
/// Input: nums = [4,1,3,3]
/// Output: 5
/// Explanation: The pair (0, 1) is a bad pair since 1 - 0 != 1 - 4.
/// The pair (0, 2) is a bad pair since 2 - 0 != 3 - 4, 2 != -1.
/// The pair (0, 3) is a bad pair since 3 - 0 != 3 - 4, 3 != -1.
/// The pair (1, 2) is a bad pair since 2 - 1 != 3 - 1, 1 != 2.
/// The pair (2, 3) is a bad pair since 3 - 2 != 3 - 3, 1 != 0.
/// There are a total of 5 bad pairs, so we return 5.
///
/// Example 2:
/// Input: nums = [1,2,3,4,5]
/// Output: 0
/// Explanation: There are no bad pairs.
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^9
/// </summary>
long long LeetCodeArray::countBadPairs(vector<int>& nums)
{
    unordered_map<int, int> num_map;
    int n = nums.size();
    for (int i = 0; i < n; i++)
    {
        num_map[nums[i] - i]++;
    }
    long long result = 0;
    for (int i = 0; i < n; i++)
    {
        int diff = nums[i] - i;
        result += (long long)n - (long long)num_map[nums[i] - i];
    }
    return result / 2;
}

/// <summary>
/// Leet Code 2366. Minimum Replacements to Sort the Array
///                                                  
/// Hard
///
/// You are given a 0-indexed integer array nums. In one operation you 
/// can replace any element of the array with any two elements that sum 
/// to it.
///
/// For example, consider nums = [5,6,7]. In one operation, we can 
/// replace nums[1] with 2 and 4 and convert nums to [5,2,4,7].
/// Return the minimum number of operations to make an array that is 
/// sorted in non-decreasing order.
///
/// Example 1:
///
/// Input: nums = [3,9,3]
/// Output: 2
/// Explanation: Here are the steps to sort the array in non-decreasing 
/// order:
/// - From [3,9,3], replace the 9 with 3 and 6 so the array 
///   becomes [3,3,6,3]
/// - From [3,3,6,3], replace the 6 with 3 and 3 so the array 
///   becomes [3,3,3,3,3]
/// There are 2 steps to sort the array in non-decreasing order. 
/// Therefore, we return 2.
///
/// Example 2:
/// Input: nums = [1,2,3,4,5]
/// Output: 0
/// Explanation: The array is already in non-decreasing order. 
/// Therefore, we return 0. 
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^9
/// </summary>
long long LeetCodeArray::minimumReplacement(vector<int>& nums)
{
    long long result = 0;
    int upper = 0;
    for (int i = nums.size() - 1; i >= 0; i--)
    {
        if (i == nums.size() - 1)
        {
            upper = nums[i];
        }
        else
        {
            int count = (nums[i] - 1) / upper;
            upper = nums[i] / (count + 1);
            result = result + (long long)count;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2348. Number of Zero-Filled Subarrays
///                                                  
/// Medium
///
/// Given an integer array nums, return the number of subarrays filled 
/// with 0.
///
/// A subarray is a contiguous non-empty sequence of elements within 
/// an array.
///
/// Example 1:
/// Input: nums = [1,3,0,0,2,0,0,4]
/// Output: 6
/// Explanation: 
/// There are 4 occurrences of [0] as a subarray.
/// There are 2 occurrences of [0,0] as a subarray.
/// There is no occurrence of a subarray with a size more than 2 
/// filled with 0. Therefore, we return 6.
///
/// Example 2:
/// Input: nums = [0,0,0,2,0,0]
/// Output: 9
/// Explanation:
/// There are 5 occurrences of [0] as a subarray.
/// There are 3 occurrences of [0,0] as a subarray.
/// There is 1 occurrence of [0,0,0] as a subarray.
/// There is no occurrence of a subarray with a size more than 3 
/// filled with 0. Therefore, we return 9.
///
/// Example 3:
/// 
/// Input: nums = [2,10,2019]
/// Output: 0
/// Explanation: There is no subarray filled with 0. 
/// Therefore, we return 0.
///
/// Constraints:
///  1. 1 <= nums.length <= 10^5
/// 2. -10^9 <= nums[i] <= 10^9
/// </summary>
long long LeetCodeArray::zeroFilledSubarray(vector<int>& nums)
{
    long long result = 0;
    int count = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] == 0) count++;
        else count = 0;
        result = result + (long long)count;
    }
    return result;
}

/// <summary>
/// Leet Code 2391. Minimum Amount of Time to Collect Garbage
///                                                  
/// Medium
///
/// You are given a 0-indexed array of strings garbage where garbage[i] 
/// represents the assortment of garbage at the ith house. garbage[i] 
/// consists only of the characters 'M', 'P' and 'G' representing one 
/// unit of metal, paper and glass garbage respectively. Picking up one 
/// unit of any type of garbage takes 1 minute.
///
/// You are also given a 0-indexed integer array travel where travel[i] 
/// is the number of minutes needed to go from house i to house i + 1.
///
/// There are three garbage trucks in the city, each responsible for 
/// picking up one type of garbage. Each garbage truck starts at house 0 
/// and must visit each house in order; however, they do not need to 
/// visit every house.
///
/// Only one garbage truck may be used at any given moment. While one 
/// truck is driving or picking up garbage, the other two trucks cannot 
/// do anything.
///
/// Return the minimum number of minutes needed to pick up all the garbage.
/// 
/// Example 1:
///
/// Input: garbage = ["G","P","GP","GG"], travel = [2,4,3]
/// Output: 21
/// Explanation:
/// The paper garbage truck:
/// 1. Travels from house 0 to house 1
/// 2. Collects the paper garbage at house 1
/// 3. Travels from house 1 to house 2
/// 4. Collects the paper garbage at house 2
/// Altogether, it takes 8 minutes to pick up all the paper garbage.
/// The glass garbage truck:
/// 1. Collects the glass garbage at house 0
/// 2. Travels from house 0 to house 1
/// 3. Travels from house 1 to house 2
/// 4. Collects the glass garbage at house 2
/// 5. Travels from house 2 to house 3
/// 6. Collects the glass garbage at house 3
/// Altogether, it takes 13 minutes to pick up all the glass garbage.
/// Since there is no metal garbage, we do not need to consider the 
/// metal garbage truck.
/// Therefore, it takes a total of 8 + 13 = 21 minutes to collect 
/// all the garbage.
///
/// Example 2:
/// Input: garbage = ["MMM","PGM","GP"], travel = [3,10]
/// Output: 37
/// Explanation:
/// The metal garbage truck takes 7 minutes to pick up all the metal 
/// garbage.
/// The paper garbage truck takes 15 minutes to pick up all the paper 
/// garbage.
/// The glass garbage truck takes 15 minutes to pick up all the glass 
/// garbage.
/// It takes a total of 7 + 15 + 15 = 37 minutes to collect all the garbage.
///
/// Constraints:
/// 1. 2 <= garbage.length <= 10^5
/// 2. garbage[i] consists of only the letters 'M', 'P', and 'G'.
/// 3. 1 <= garbage[i].length <= 10
/// 4. travel.length == garbage.length - 1
/// 5. 1 <= travel[i] <= 100
/// </summary>
int LeetCodeArray::garbageCollection(vector<string>& garbage, vector<int>& travel)
{
    int result = 0;
    for (int i = 0; i < 3; i++)
    {
        char type;
        if (i == 0) type = 'M';
        else if (i == 1) type = 'P';
        else type = 'G';
        int travel_time = 0;
        for (size_t j = 0; j < garbage.size(); j++)
        {
            if (j > 0) travel_time += travel[j - 1];
            int count = 0;
            for (size_t k = 0; k < garbage[j].size(); k++)
            {
                if (garbage[j][k] == type) count++;
            }
            if (count > 0)
            {
                result += travel_time;
                result += count;
                travel_time = 0;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2371. Minimize Maximum Value in a Grid
///                                                  
/// Hard
///
/// You are given an m x n integer matrix grid containing distinct 
/// positive integers.
///
/// You have to replace each integer in the matrix with a positive 
/// integer satisfying the following conditions:
///
/// The relative order of every two elements that are in the same 
/// row or column should stay the same after the replacements.
/// The maximum number in the matrix after the replacements should 
/// be as small as possible.
/// The relative order stays the same if for all pairs of elements 
/// in the original matrix such that grid[r1][c1] > grid[r2][c2] 
/// where either r1 == r2 or c1 == c2, then it must be true that 
/// grid[r1][c1] > grid[r2][c2] after the replacements.
///
/// For example, if grid = [[2, 4, 5], [7, 3, 9]] then a good 
/// replacement could be either grid = [[1, 2, 3], [2, 1, 4]] or 
/// grid = [[1, 2, 3], [3, 1, 4]].
/// Return the resulting matrix. If there are multiple answers, 
/// return any of them.
/// 
/// Example 1:
/// Input: grid = [[3,1],[2,5]]
/// Output: [[2,1],[1,2]]
/// Explanation: The above diagram shows a valid replacement.
/// The maximum number in the matrix is 2. It can be shown that no 
/// smaller value can be obtained.
///
/// Example 2:
/// Input: grid = [[10]]
/// Output: [[1]]
/// Explanation: We replace the only number in the matrix with 1.
/// 
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 1 <= m, n <= 1000
/// 4. 1 <= m * n <= 10^5
/// 5. 1 <= grid[i][j] <= 10^9
/// 6. grid consists of distinct integers.
/// </summary>
vector<vector<int>> LeetCodeArray::minScore(vector<vector<int>>& grid)
{
    int m = grid.size();
    int n = grid[0].size();
    vector<vector<int>> result(m, vector<int>(n));
    vector<int> row(m), col(n);
    set<vector<int>> pq;
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            pq.insert({ grid[i][j],i,j });
        }
    }
    while (!pq.empty())
    {
        vector<int> cell = *pq.begin();
        pq.erase(pq.begin());
        int r = cell[1];
        int c = cell[2];
        result[r][c] = max(row[r], col[c]) + 1;
        row[r] = result[r][c];
        col[c] = result[r][c];
    }
    return result;
}

/// <summary>
/// Leet Code 2393. Count Strictly Increasing Subarrays
///                                                  
/// Medium
///
/// You are given an array nums consisting of positive integers.
///
/// Return the number of subarrays of nums that are in strictly 
/// increasing order.
///
/// A subarray is a contiguous part of an array.
/// 
/// Example 1:
///
/// Input: nums = [1,3,5,4,4,6]
/// Output: 10
/// Explanation: The strictly increasing subarrays are the following:
/// - Subarrays of length 1: [1], [3], [5], [4], [4], [6].
/// - Subarrays of length 2: [1,3], [3,5], [4,6].
/// - Subarrays of length 3: [1,3,5].
/// The total number of subarrays is 6 + 3 + 1 = 10.
///
/// Example 2:
/// Input: nums = [1,2,3,4,5]
/// Output: 15
/// Explanation: Every subarray is strictly increasing. There 
/// are 15 possible subarrays that we can take.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^6
/// </summary>
long long LeetCodeArray::countSubarrays(vector<int>& nums)
{
    long long result = 0;
    long long count = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (i > 0 && nums[i] <= nums[i - 1]) count = 1;
        else count++;
        result = result + count;
    }
    return result;
}

/// <summary>
/// Leet Code 2395. Find Subarrays With Equal Sum
///                                                  
/// Easy
///
/// Given a 0-indexed integer array nums, determine whether there exist 
/// two subarrays of length 2 with equal sum. Note that the two 
/// subarrays must begin at different indices.
///
/// Return true if these subarrays exist, and false otherwise.
/// A subarray is a contiguous non-empty sequence of elements 
/// within an array.
///
/// Example 1:
/// Input: nums = [4,2,4]
/// Output: true
/// Explanation: The subarrays with elements [4,2] and [2,4] have the 
/// same sum of 6.
///
/// Example 2:
///
/// Input: nums = [1,2,3,4,5]
/// Output: false
/// Explanation: No two subarrays of size 2 have the same sum.
///
/// Example 3:
/// Input: nums = [0,0,0]
/// Output: true
/// Explanation: The subarrays [nums[0],nums[1]] and [nums[1],nums[2]] 
/// have the same sum of 0. 
/// Note that even though the subarrays have the same content, the two 
/// subarrays are considered different because they are in different 
/// positions in the original array.
///
/// Constraints:
/// 1. 2 <= nums.length <= 1000
/// 2. -10^9 <= nums[i] <= 10^9
/// </summary>
bool LeetCodeArray::findSubarrays(vector<int>& nums)
{
    unordered_set<long long> sum;
    for (size_t i = 1; i < nums.size(); i++)
    {
        if (sum.count((long long)nums[i - 1] + (long long)nums[i]) == 0)
        {
            sum.insert((long long)nums[i - 1] + (long long)nums[i]);
        }
        else
        {
            return true;
        }
    }
    return false;
}

/// <summary>
/// Leet Code 2389. Longest Subsequence With Limited Sum
///                                                  
/// Easy
///
/// You are given an integer array nums of length n, and an integer array 
/// queries of length m.
///
/// Return an array answer of length m where answer[i] is the maximum 
/// size of a subsequence that you can take from nums such that the sum 
/// of its elements is less than or equal to queries[i].
///
/// A subsequence is an array that can be derived from another array by 
/// deleting some or no elements without changing the order of the 
/// remaining elements.
///
/// Example 1:
/// Input: nums = [4,5,2,1], queries = [3,10,21]
/// Output: [2,3,4]
/// Explanation: We answer the queries as follows:
/// - The subsequence [2,1] has a sum less than or equal to 3. It can be 
///   proven that 2 is the maximum size of such a subsequence, so 
///   answer[0] = 2.
/// - The subsequence [4,5,1] has a sum less than or equal to 10. It can be 
///   proven that 3 is the maximum size of such a subsequence, so 
///   answer[1] = 3.
/// - The subsequence [4,5,2,1] has a sum less than or equal to 21. It can 
///   be proven that 4 is the maximum size of such a subsequence, so 
///   answer[2] = 4.
///
/// Example 2:
/// Input: nums = [2,3,4,5], queries = [1]
/// Output: [0]
/// Explanation: The empty subsequence is the only subsequence that has a 
/// sum less than or equal to 1, so answer[0] = 0.
///
/// Constraints:
/// 1. n == nums.length
/// 2. m == queries.length
/// 3. 1 <= n, m <= 1000
/// 4. 1 <= nums[i], queries[i] <= 10^6
/// </summary>
vector<int> LeetCodeArray::answerQueries(vector<int>& nums, vector<int>& queries)
{
    sort(nums.begin(), nums.end());
    vector<pair<int, int>> query_pairs;
    for (size_t i = 0; i < queries.size(); i++)
    {
        query_pairs.push_back(make_pair(queries[i], i));
    }
    sort(query_pairs.begin(), query_pairs.end());
    vector<int> result(queries.size());
    long long sum = 0;
    int index = 0;
    for (size_t i = 0; i < query_pairs.size(); i++)
    {
        while (index < (int)nums.size()) 
        {
            if ((sum + (long long)nums[index]) > (long long)query_pairs[i].first)
            {
                break;
            }
            sum += (long long)nums[index];
            index++;
        }
        result[query_pairs[i].second] = index;
    }
    return result;
}

/// <summary>
/// Leet Code 2397. Maximum Rows Covered by Columns
///                                                  
/// Medium
///
/// You are given a 0-indexed m x n binary matrix matrix and an integer 
/// numSelect, which denotes the number of distinct columns you must 
/// select from matrix.
///
/// Let us consider s = {c1, c2, ...., cnumSelect} as the set of columns 
/// selected by you. A row row is covered by s if:
///
/// For each cell matrix[row][col] (0 <= col <= n - 1) where 
/// matrix[row][col] == 1, col is present in s or,
/// No cell in row has a value of 1.
/// You need to choose numSelect columns such that the number of rows that 
/// are covered is maximized.
///
/// Return the maximum number of rows that can be covered by a set of 
/// numSelect columns.
/// 
/// Example 1:
/// 
/// Input: matrix = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], numSelect = 2
/// Output: 3
/// Explanation: One possible way to cover 3 rows is shown in the diagram 
/// above.
/// We choose s = {0, 2}.
/// - Row 0 is covered because it has no occurrences of 1.
/// - Row 1 is covered because the columns with value 1, i.e. 0 and 2 are 
///   present in s.
/// - Row 2 is not covered because matrix[2][1] == 1 but 1 is not 
///   present in s.
/// - Row 3 is covered because matrix[2][2] == 1 and 2 is present in s.
/// Thus, we can cover three rows.
/// Note that s = {1, 2} will also cover 3 rows, but it can be shown that 
/// no more than three rows can be covered.
///
/// Example 2:
/// 
/// Input: matrix = [[1],[0]], numSelect = 1
/// Output: 2
/// Explanation: Selecting the only column will result in both rows being 
/// covered since the entire matrix is selected.
/// Therefore, we return 2.
///
/// Constraints:
/// 1. m == matrix.length
/// 2. n == matrix[i].length
/// 3. 1 <= m, n <= 12
/// 4. matrix[i][j] is either 0 or 1.
/// 5. 1 <= numSelect <= n
/// </summary>
int LeetCodeArray::maximumRows(vector<vector<int>>& matrix, int numSelect)
{
    vector<int> nums;
    for (size_t i = 0; i < matrix.size(); i++)
    {
        int num = 0;
        for (size_t j = 0; j < matrix[i].size(); j++)
        {
            num = (num << 1) + matrix[i][j];
        }
        nums.push_back(num);
    }
    int result = 0;
    for (int i = 1; i < (1 << matrix[0].size()); i++)
    {
        int bit = i;
        int count = 0;
        while (bit != 0)
        {
            if ((bit % 2) == 1) count++;
            bit /= 2;
        }
        if (count != numSelect) continue;
        count = 0;
        for (size_t j = 0; j < nums.size(); j++)
        {
            if ((nums[j] & i) == nums[j]) count++;
        }
        result = max(result, count);
    }
    return result;
}

/// <summary>
/// Leet Code 2401. Longest Nice Subarray 
///                                                  
/// Medium
///
/// You are given an array nums consisting of positive integers.
///
/// We call a subarray of nums nice if the bitwise AND of every pair 
/// of elements that are in different positions in the subarray is 
/// equal to 0.
///
/// Return the length of the longest nice subarray.
///
/// A subarray is a contiguous part of an array.
///
/// Note that subarrays of length 1 are always considered nice.
///
/// Example 1:
/// Input: nums = [1,3,8,48,10]
/// Output: 3
/// Explanation: The longest nice subarray is [3,8,48]. This subarray 
/// satisfies the conditions:
/// - 3 AND 8 = 0.
/// - 3 AND 48 = 0.
/// - 8 AND 48 = 0.
/// It can be proven that no longer nice subarray can be obtained, 
/// so we return 3.
///
/// Example 2:
/// Input: nums = [3,1,5,11,13]
/// Output: 1
/// Explanation: The length of the longest nice subarray is 1. Any 
/// subarray of length 1 can be chosen.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^9
/// </summary>
int LeetCodeArray::longestNiceSubarray(vector<int>& nums)
{
    vector<pair<int, int>> dp(32, { -1, -1 });
    int result = 0;
    for (int i = 0; i < (int)nums.size(); i++)
    {
        int val = nums[i];
        int distance = i + 1;
        for (int j = 0; j < 32; j++)
        {
            if (val % 2 == 1)
            {
                dp[j].first = dp[j].second;
                dp[j].second = i;
            }
            val /= 2;
            distance = min(distance, i - dp[j].first);
        }
        result = max(result, distance);
    }
    return result;
}

/// <summary>
/// Leet Code 2428. Maximum Sum of an Hourglass
///                                                  
/// Medium
///
/// You are given an m x n integer matrix grid.
///
/// We define an hourglass as a part of the matrix with the following form:
///
/// Return the maximum sum of the elements of an hourglass.
///
/// Note that an hourglass cannot be rotated and must be entirely contained 
/// within the matrix.
/// 
///
/// Example 1:
/// Input: grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]
/// Output: 30
/// Explanation: The cells shown above represent the hourglass with the 
/// maximum sum: 6 + 2 + 1 + 2 + 9 + 2 + 8 = 30.
///
/// Example 2:
/// Input: grid = [[1,2,3],[4,5,6],[7,8,9]]
/// Output: 35
/// Explanation: There is only one hourglass in the matrix, with the 
/// sum: 1 + 2 + 3 + 5 + 7 + 8 + 9 = 35.
/// 
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 3 <= m, n <= 150
/// 4. 0 <= grid[i][j] <= 10^6
/// </summary>
int LeetCodeArray::maxSum(vector<vector<int>>& grid)
{
    int m = grid.size();
    int n = grid[0].size();
    int result = 0;
    for (int i = 1; i < m - 1; i++)
    {
        for (int j = 1; j < n - 1; j++)
        {
            int sum = grid[i][j];
            sum += grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1];
            sum += grid[i + 1][j - 1] + grid[i + 1][j] + grid[i + 1][j + 1];
            result = max(result, sum);
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2420. Find All Good Indices
///                                                  
/// Medium
///
/// You are given a 0-indexed integer array nums of size n and a positive 
/// integer k.
///
/// We call an index i in the range k <= i < n - k good if the following 
/// conditions are satisfied:
///
/// The k elements that are just before the index i are in non-increasing 
/// order.
/// The k elements that are just after the index i are in non-decreasing 
/// order.
/// Return an array of all good indices sorted in increasing order.
///
/// Example 1:
/// Input: nums = [2,1,1,1,3,4,1], k = 2
/// Output: [2,3]
/// Explanation: There are two good indices in the array:
/// - Index 2. The subarray [2,1] is in non-increasing order, and the 
///   subarray [1,3] is in non-decreasing order.
/// - Index 3. The subarray [1,1] is in non-increasing order, and the 
///   subarray [3,4] is in non-decreasing order.
/// Note that the index 4 is not good because [4,1] is not non-decreasing.
///
/// Example 2:
/// Input: nums = [2,1,1,2], k = 2
/// Output: []
/// Explanation: There are no good indices in this array.
/// 
/// Constraints:
/// 1. n == nums.length
/// 2. 3 <= n <= 10^5
/// 3. 1 <= nums[i] <= 10^6
/// 4. 1 <= k <= n / 2
/// </summary>
vector<int> LeetCodeArray::goodIndices(vector<int>& nums, int k)
{
    int n = nums.size();
    vector<pair<int, int>> dp(n);
    for (int i = 0; i < n; i++)
    {
        if (i == 0) dp[i].first = 1;
        else
        {
            if (nums[i] <= nums[i - 1])
            {
                dp[i].first = dp[i - 1].first + 1;
            }
            else
            {
                dp[i].first = 1;
            }
        }
    }
    for (int i = n - 1; i >= 0; i--)
    {
        if (i == n - 1) dp[i].second = 1;
        else
        {
            if (nums[i] <= nums[i + 1])
            {
                dp[i].second = dp[i + 1].second + 1;
            }
            else
            {
                dp[i].second = 1;
            }
        }
    }
    vector<int> result;
    for (int i = 1; i < n - 1; i++)
    {
        if (dp[i - 1].first >= k && dp[i + 1].second >= k)
        {
            result.push_back(i);
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2419. Longest Subarray With Maximum Bitwise AND
///                                                  
/// Medium
///
/// You are given an integer array nums of size n.
///
/// Consider a non-empty subarray from nums that has the maximum possible 
/// bitwise AND.
///
/// In other words, let k be the maximum value of the bitwise AND of any 
/// subarray of nums. Then, only subarrays with a bitwise AND equal to k 
/// should be considered.
/// Return the length of the longest such subarray.
///
/// The bitwise AND of an array is the bitwise AND of all the numbers in 
/// it.
///
/// A subarray is a contiguous sequence of elements within an array.
/// 
/// Example 1:
///
/// Input: nums = [1,2,3,3,2,2]
/// Output: 2
/// Explanation:
/// The maximum possible bitwise AND of a subarray is 3.
/// The longest subarray with that value is [3,3], so we return 2.
///
/// Example 2:
/// Input: nums = [1,2,3,4]
/// Output: 1
/// Explanation:
/// The maximum possible bitwise AND of a subarray is 4.
/// The longest subarray with that value is [4], so we return 1.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^6
/// </summary>
int LeetCodeArray::longestSubarrayAnd(vector<int>& nums)
{
    int max_val = 0;
    int count = 0;
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] > max_val)
        {
            max_val = nums[i];
            count = 1;
            result = 1;
        }
        else if (nums[i] == max_val)
        {
            count++;
            result = max(result, count);
        }
        else
        {
            count = 0;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2411. Smallest Subarrays With Maximum Bitwise OR
///                                                  
/// Medium
///
/// You are given a 0-indexed array nums of length n, consisting of 
/// non-negative integers. For each index i from 0 to n - 1, you must 
/// determine the size of the minimum sized non-empty subarray of nums 
/// starting at i (inclusive) that has the maximum possible bitwise OR.
///
/// In other words, let Bij be the bitwise OR of the subarray nums[i...j]. 
/// You need to find the smallest subarray starting at i, such that 
/// bitwise OR of this subarray is equal to max(Bik) where i <= k <= n - 1.
/// The bitwise OR of an array is the bitwise OR of all the numbers in it.
///
/// Return an integer array answer of size n where answer[i] is the length 
/// of the minimum sized subarray starting at i with maximum bitwise OR.
/// 
/// A subarray is a contiguous non-empty sequence of elements within an 
/// array.
///
/// Example 1:
/// Input: nums = [1,0,2,1,3]
/// Output: [3,3,2,2,1]
/// Explanation:
/// The maximum possible bitwise OR starting at any index is 3. 
/// - Starting at index 0, the shortest subarray that yields it is [1,0,2].
/// - Starting at index 1, the shortest subarray that yields the maximum 
///   bitwise OR is [0,2,1].
/// - Starting at index 2, the shortest subarray that yields the maximum 
///   bitwise OR is [2,1].
/// - Starting at index 3, the shortest subarray that yields the maximum 
///   bitwise OR is [1,3].
/// - Starting at index 4, the shortest subarray that yields the maximum 
///   bitwise OR is [3].
/// Therefore, we return [3,3,2,2,1]. 
///
/// Example 2:
/// Input: nums = [1,2]
/// Output: [2,1]
/// Explanation:
/// Starting at index 0, the shortest subarray that yields the maximum 
/// bitwise OR is of length 2.
/// Starting at index 1, the shortest subarray that yields the maximum 
/// bitwise OR is of length 1.
/// Therefore, we return [2,1].
/// 
/// Constraints:
/// 1. n == nums.length
/// 2. 1 <= n <= 10^5
/// 3. 0 <= nums[i] <= 10^9
/// </summary>
vector<int> LeetCodeArray::smallestSubarraysOr(vector<int>& nums)
{
    int n = nums.size();
    vector<int> bits(32);
    vector<int> result(n);
    for (int i = n - 1; i >= 0; i--)
    {
        int num = nums[i];
        int gap = 0;
        for (int j = 0; j < 32; j++)
        {
            if (num % 2 == 1)
            {
                bits[j] = i;
            }
            if (bits[j] != 0)
            {
                gap = max(gap, bits[j] - i);
            }
            num /= 2;
        }
        result[i] = gap + 1;
    }
    return result;
}

/// <summary>
/// Leet Code 2426. Number of Pairs Satisfying Inequality
///                                                  
/// Hard
///
/// You are given two 0-indexed integer arrays nums1 and nums2, each of 
/// size n, and an integer diff. Find the number of pairs (i, j) such that:
///
/// 0 <= i < j <= n - 1 and
/// nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff.
/// Return the number of pairs that satisfy the conditions.
///
/// Example 1:
/// Input: nums1 = [3,2,5], nums2 = [2,2,1], diff = 1
/// Output: 3
/// Explanation:
/// There are 3 pairs that satisfy the conditions:
/// 1. i = 0, j = 1: 3 - 2 <= 2 - 2 + 1. 
///    Since i < j and 1 <= 1, this pair satisfies the conditions.
/// 2. i = 0, j = 2: 3 - 5 <= 2 - 1 + 1. 
///    Since i < j and -2 <= 2, this pair satisfies the conditions.
/// 3. i = 1, j = 2: 2 - 5 <= 2 - 1 + 1. 
/// Since i < j and -3 <= 2, this pair satisfies the conditions.
/// Therefore, we return 3.
///
/// Example 2:
/// Input: nums1 = [3,-1], nums2 = [-2,2], diff = -1
/// Output: 0
/// Explanation:
/// Since there does not exist any pair that satisfies the conditions, 
/// we return 0.
///
/// Constraints:
/// 1. n == nums1.length == nums2.length
/// 2. 2 <= n <= 10^5
/// 3. -10^4 <= nums1[i], nums2[i] <= 10^4
/// 4. -10^4 <= diff <= 10^4
/// </summary>
long long LeetCodeArray::numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff)
{
    struct BinaryIndexTree
    {
    private:
        vector<long long> m_sum;
    public:
        BinaryIndexTree(int n)
        {
            m_sum = vector<long long>(n + 2);
        }
        long long sum(int i)
        {
            long long result = 0;
            int index = i + 1;
            while (index != 0)
            {
                result += m_sum[index];
                index -= index & -index;
            }
            return result;
        }
        void add(int i, int value)
        {
            int index = i + 1;
            while (index < (int)m_sum.size())
            {
                m_sum[index] += value;
                index += (index & -index);
            }
        }
    };
    BinaryIndexTree tree(60000);
    long long result = 0;
    for (size_t i = 0; i < nums1.size(); i++)
    {
        int delta = nums1[i] - nums2[i];
        result += tree.sum(delta + 30000 + diff);
        tree.add(delta + 30000, 1);
    }
    return result;
}

/// <summary>
/// Leet Code 2432. The Employee That Worked on the Longest Task
///                                                  
/// Easy
///
/// There are n employees, each with a unique id from 0 to n - 1.
///
/// You are given a 2D integer array logs where 
/// logs[i] = [idi, leaveTimei] where:
///
/// idi is the id of the employee that worked on the ith task, and
/// leaveTimei is the time at which the employee finished the ith task. 
/// All the values leaveTimei are unique.
/// Note that the ith task starts the moment right after the (i - 1)th 
/// task ends, and the 0th task starts at time 0.
///
/// Return the id of the employee that worked the task with the longest 
/// time. If there is a tie between two or more employees, return the 
/// smallest id among them.
///
/// Example 1:
/// Input: n = 10, logs = [[0,3],[2,5],[0,9],[1,15]]
/// Output: 1
/// Explanation: 
/// Task 0 started at 0 and ended at 3 with 3 units of times.
/// Task 1 started at 3 and ended at 5 with 2 units of times.
/// Task 2 started at 5 and ended at 9 with 4 units of times.
/// Task 3 started at 9 and ended at 15 with 6 units of times.
/// The task with the longest time is task 3 and the employee with 
/// id 1 is the one that worked on it, so we return 1.
///
/// Example 2:
/// Input: n = 26, logs = [[1,1],[3,7],[2,12],[7,17]]
/// Output: 3
/// Explanation: 
/// Task 0 started at 0 and ended at 1 with 1 unit of times.
/// Task 1 started at 1 and ended at 7 with 6 units of times.
/// Task 2 started at 7 and ended at 12 with 5 units of times.
/// Task 3 started at 12 and ended at 17 with 5 units of times.
/// The tasks with the longest time is task 1. The employees that worked 
/// on it is 3, so we return 3.
///
/// Example 3:
/// Input: n = 2, logs = [[0,10],[1,20]]
/// Output: 0
/// Explanation: 
/// Task 0 started at 0 and ended at 10 with 10 units of times.
/// Task 1 started at 10 and ended at 20 with 10 units of times.
/// The tasks with the longest time are tasks 0 and 1. The employees that 
/// worked on them are 0 and 1, so we return the smallest id 0.
///
/// Constraints:
/// 1. 2 <= n <= 500
/// 2. 1 <= logs.length <= 500
/// 3. logs[i].length == 2
/// 4. 0 <= idi <= n - 1
/// 5. 1 <= leaveTimei <= 500
/// 6. idi != idi+1
/// 7. leaveTimei are sorted in a strictly increasing order.
/// </summary>
int LeetCodeArray::hardestWorker(int n, vector<vector<int>>& logs)
{
    vector<int> dp(n);
    int prev = 0;
    for (size_t i = 0; i < logs.size(); i++)
    {
        int id = logs[i][0];
        int time = logs[i][1] - prev;
        dp[id] = max(dp[id], time);
        prev = logs[i][1];
    }
    int max_time = 0;
    int result = 0;
    for (int i = 0; i < n; i++)
    {
        if (dp[i] > max_time)
        {
            max_time = dp[i];
            result = i;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2445. Number of Nodes With Value One   
///                                                  
/// Hard
///
/// You are given two positive integer arrays nums and target, of the 
/// same length.
///
/// In one operation, you can choose any two distinct indices i and j 
/// where 0 <= i, j < nums.length and:
///
/// set nums[i] = nums[i] + 2 and
/// set nums[j] = nums[j] - 2.
/// Two arrays are considered to be similar if the frequency of each 
/// element is the same.
///
/// Return the minimum number of operations required to make nums 
/// similar to target. The test cases are generated such that nums 
/// can always be similar to target.
///
/// Example 1:
///
/// Input: nums = [8,12,6], target = [2,14,10]
/// Output: 2
/// Explanation: It is possible to make nums similar to target in two 
/// operations:
/// - Choose i = 0 and j = 2, nums = [10,12,4].
/// - Choose i = 1 and j = 2, nums = [10,14,2].
/// It can be shown that 2 is the minimum number of operations needed.
///
/// Example 2:
/// Input: nums = [1,2,5], target = [4,1,3]
/// Output: 1
/// Explanation: We can make nums similar to target in one operation:
/// - Choose i = 1 and j = 2, nums = [1,4,3].
///
/// Example 3:
/// Input: nums = [1,1,1,1,1], target = [1,1,1,1,1]
/// Output: 0
/// Explanation: The array nums is already similiar to target.
/// 
/// Constraints:
/// 1. n == nums.length == target.length
/// 2. 1 <= n <= 10^5
/// 3. 1 <= nums[i], target[i] <= 10^6
/// 4. It is possible to make nums similar to target.
/// </summary>
long long LeetCodeArray::makeSimilar(vector<int>& nums, vector<int>& target)
{
    vector<int> odd_nums, even_nums;
    vector<int> odd_target, even_target;

    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] % 2 == 0) even_nums.push_back(nums[i]);
        if (nums[i] % 2 == 1) odd_nums.push_back(nums[i]);

        if (target[i] % 2 == 0) even_target.push_back(target[i]);
        if (target[i] % 2 == 1) odd_target.push_back(target[i]);
    }
    sort(even_nums.begin(), even_nums.end());
    sort(odd_nums.begin(), odd_nums.end());
    sort(even_target.begin(), even_target.end());
    sort(odd_target.begin(), odd_target.end());
    long long result = 0;
    for (size_t i = 0; i < even_nums.size(); i++)
    {
        result += (long long)abs((even_target[i] - even_nums[i]) / 2);
    }
    for (size_t i = 0; i < odd_nums.size(); i++)
    {
        result += (long long)abs((odd_target[i] - odd_nums[i]) / 2);
    }
    return result / 2;
}

/// <summary>
/// Leet Code 2460. Apply Operations to an Array 
///                                                  
/// Easy
///
/// You are given a 0-indexed array nums of size n consisting of non-
/// negative integers.
///
/// You need to apply n - 1 operations to this array where, in the ith 
/// operation (0-indexed), you will apply the following on the ith 
/// element of nums:
///
/// If nums[i] == nums[i + 1], then multiply nums[i] by 2 and set 
/// nums[i + 1] to 0. Otherwise, you skip this operation.
/// After performing all the operations, shift all the 0's to the end 
/// of the array.
///
/// For example, the array [1,0,2,0,0,1] after shifting all its 0's to 
/// the end, is [1,2,1,0,0,0].
/// Return the resulting array.
///
/// Note that the operations are applied sequentially, not all at once.
///
/// Example 1:
/// Input: nums = [1,2,2,1,1,0]
/// Output: [1,4,2,0,0,0]
/// Explanation: We do the following operations:
/// - i = 0: nums[0] and nums[1] are not equal, so we skip this operation.
/// - i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and 
/// change nums[2] to 0. The array becomes [1,4,0,1,1,0].
/// - i = 2: nums[2] and nums[3] are not equal, so we skip this operation.
/// - i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and 
/// change nums[4] to 0. The array becomes [1,4,0,2,0,0].
/// - i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and 
/// change nums[5] to 0. The array becomes [1,4,0,2,0,0].
/// After that, we shift the 0's to the end, which gives the array 
/// [1,4,2,0,0,0].
///
/// Example 2:
/// Input: nums = [0,1]
/// Output: [1,0]
/// Explanation: No operation can be applied, we just shift the 0 to 
/// the end.
///
/// Constraints:
/// 1. 2 <= nums.length <= 2000
/// 2. 0 <= nums[i] <= 1000
/// </summary>
vector<int> LeetCodeArray::applyOperations(vector<int>& nums)
{
    vector<int> arr = nums;
    for (size_t i = 0; i < arr.size()-1; i++)
    {
        if (arr[i] == arr[i + 1])
        {
            arr[i] = arr[i] * 2;
            arr[i + 1] = 0;
        }
    }
    vector<int> result;
    for (size_t i = 0; i < arr.size(); i++)
    {
        if (arr[i] != 0) result.push_back(arr[i]);
    }
    result.resize(nums.size());
    return result;
}

/// <summary>
/// Leet Code 2459. Sort Array by Moving Items to Empty Space
/// 
/// Hard
///	
/// You are given an integer array nums of size n containing each element 
/// from 0 to n - 1 (inclusive). Each of the elements from 1 to n - 1 
/// represents an item, and the element 0 represents an empty space.
/// 
/// In one operation, you can move any item to the empty space. nums is 
/// considered to be sorted if the numbers of all the items are in 
/// ascending order and the empty space is either at the beginning or 
/// at the end of the array.
/// 
/// For example, if n = 4, nums is sorted if:
/// 
/// nums = [0,1,2,3] or
/// nums = [1,2,3,0]
/// ...and considered to be unsorted otherwise.
///
/// Return the minimum number of operations needed to sort nums.
///
/// Example 1:
/// Input: nums = [4,2,0,3,1]
/// Output: 3
/// Explanation:
/// - Move item 2 to the empty space. Now, nums = [4,0,2,3,1].
/// - Move item 1 to the empty space. Now, nums = [4,1,2,3,0].
/// - Move item 4 to the empty space. Now, nums = [0,1,2,3,4].
/// It can be proven that 3 is the minimum number of operations needed.
///
/// Example 2:
/// Input: nums = [1,2,3,4,0]
/// Output: 0
/// Explanation: nums is already sorted so return 0.
///
/// Example 3:
/// Input: nums = [1,0,2,4,3]
/// Output: 2
/// Explanation:
/// - Move item 2 to the empty space. Now, nums = [1,2,0,4,3].
/// - Move item 3 to the empty space. Now, nums = [1,2,3,4,0].
/// It can be proven that 2 is the minimum number of operations needed.
/// 
/// Constraints:
/// 1. n == nums.length
/// 2. 2 <= n <= 105
/// 3. 0 <= nums[i] < n
/// 4. All the values of nums are unique.
/// </summary>
int LeetCodeArray::sortArray(vector<int>& nums)
{
    int n = nums.size();

    vector<int> npos(n);
    for (int i = 0; i < n; ++i) npos[nums[i]] = i;

    // note that 'npos' is passed by value INTENTIONALLY,
    // because it calls copy constructor;
    // if we pass it by referece then the same 'npos'
    // will be used for both s=0 and s=1
    auto permute = [n](vector<int> npos, int s) -> int
    {
        int cnt = 0, nxt = 1, ni;
        while (nxt < n)
        {
            if (npos[0] == s * (n - 1))
            {
                while (npos[nxt] == nxt - s)
                    if (++nxt == n) return cnt;
                ni = nxt;
            }
            else ni = npos[0] + s;
            std::swap(npos[0], npos[ni]);
            ++cnt;
        }
        return cnt;
    };

    return min(permute(npos, 0), permute(npos, 1));
}

/// <summary>
/// Leet Code 2475. Number of Unequal Triplets in Array
/// 
/// Easy
///	
/// You are given a 0-indexed array of positive integers nums. Find the 
/// number of triplets (i, j, k) that meet the following conditions:
///
/// 0 <= i < j < k < nums.length
/// nums[i], nums[j], and nums[k] are pairwise distinct.
/// In other words, nums[i] != nums[j], nums[i] != nums[k], and 
/// nums[j] != nums[k].
/// Return the number of triplets that meet the conditions.
/// 
/// Example 1:
///
/// Input: nums = [4,4,2,4,3]
/// Output: 3
/// Explanation: The following triplets meet the conditions:
/// - (0, 2, 4) because 4 != 2 != 3
/// - (1, 2, 4) because 4 != 2 != 3
/// - (2, 3, 4) because 2 != 4 != 3
/// Since there are 3 triplets, we return 3.
/// Note that (2, 0, 4) is not a valid triplet because 2 > 0.
///
/// Example 2:
///  
/// Input: nums = [1,1,1,1,1]
/// Output: 0
/// Explanation: No triplets meet the conditions so we return 0.
/// 
/// Constraints:
/// 1. 3 <= nums.length <= 100
/// 2. 1 <= nums[i] <= 1000
/// </summary>
int LeetCodeArray::unequalTriplets(vector<int>& nums)
{
    int result = 0;
    sort(nums.begin(), nums.end());
    for (size_t i = 0; i < nums.size(); i++)
    {
        for (size_t j = i + 1; j < nums.size(); j++)
        {
            if (nums[i] == nums[j]) continue;
            for (size_t k = j + 1; k < nums.size(); k++)
            {
                if (nums[j] == nums[k]) continue;
                result++;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2465. Number of Distinct Averages
/// 
/// Easy
///	
/// You are given a 0-indexed integer array nums of even length.
///
/// As long as nums is not empty, you must repetitively:
///
/// Find the minimum number in nums and remove it.
/// Find the maximum number in nums and remove it.
/// Calculate the average of the two removed numbers.
/// The average of two numbers a and b is (a + b) / 2.
///
/// For example, the average of 2 and 3 is (2 + 3) / 2 = 2.5.
/// Return the number of distinct averages calculated using the above 
/// process.
///
/// Note that when there is a tie for a minimum or maximum number, any 
/// can be removed.
/// 
/// Example 1:
/// Input: nums = [4,1,4,0,3,5]
/// Output: 2
/// Explanation:
/// 1. Remove 0 and 5, and the average is (0 + 5) / 2 = 2.5. Now, 
///    nums = [4,1,4,3].
/// 2. Remove 1 and 4. The average is (1 + 4) / 2 = 2.5, and 
///    nums = [4,3].
/// 3. Remove 3 and 4, and the average is (3 + 4) / 2 = 3.5.
/// Since there are 2 distinct numbers among 2.5, 2.5, and 3.5, we 
/// return 2.
///
/// Example 2:
/// Input: nums = [1,100]
/// Output: 1
/// Explanation:
/// There is only one average to be calculated after removing 1 and 100, 
/// so we return 1.
/// 
/// Constraints:
/// 1. 2 <= nums.length <= 100
/// 2. nums.length is even.
/// 3. 0 <= nums[i] <= 100
/// </summary>
int LeetCodeArray::distinctAverages(vector<int>& nums)
{
    unordered_set<int> set;
    sort(nums.begin(), nums.end());
    int left = 0; 
    int right = nums.size() - 1;
    while (left < right)
    {
        set.insert(nums[left] + nums[right]);
        left++;
        right--;
    }
    return set.size();
}

/// <summary>
/// Leet Code 2482. Difference Between Ones and Zeros in Row and Column
/// 
/// Medium
///	
/// You are given a 0-indexed m x n binary matrix grid.
///
/// A 0-indexed m x n difference matrix diff is created with the following 
/// procedure:
///
/// Let the number of ones in the ith row be onesRowi.
/// Let the number of ones in the jth column be onesColj.
/// Let the number of zeros in the ith row be zerosRowi.
/// Let the number of zeros in the jth column be zerosColj.
/// diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj
/// Return the difference matrix diff.
///
/// Example 1:
/// 
/// Input: grid = [[0,1,1],[1,0,1],[0,0,1]]
/// Output: [[0,0,4],[0,0,4],[-2,-2,2]]
/// Explanation:
/// - diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 
///   2 + 1 - 1 - 2 = 0 
/// - diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 
///   2 + 1 - 1 - 2 = 0 
/// - diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 
///   2 + 3 - 1 - 0 = 4 
/// - diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 
///   2 + 1 - 1 - 2 = 0 
/// - diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 
///   2 + 1 - 1 - 2 = 0 
/// - diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 
///   2 + 3 - 1 - 0 = 4 
/// - diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0 = 
///   1 + 1 - 2 - 2 = -2
/// - diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1 = 
///   1 + 1 - 2 - 2 = -2
/// - diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2 = 
///   1 + 3 - 2 - 0 = 2
///
/// Example 2:
/// Input: grid = [[1,1,1],[1,1,1]]
/// Output: [[5,5,5],[5,5,5]]
/// Explanation:
/// - diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 
///   3 + 2 - 0 - 0 = 5
/// - diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 
///   3 + 2 - 0 - 0 = 5
/// - diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 
//    3 + 2 - 0 - 0 = 5
/// - diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 
///   3 + 2 - 0 - 0 = 5
/// - diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 
///   3 + 2 - 0 - 0 = 5
/// - diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 
///   3 + 2 - 0 - 0 = 5
/// 
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 1 <= m, n <= 105
/// 4. 1 <= m * n <= 105
/// 5. grid[i][j] is either 0 or 1.
/// </summary>
vector<vector<int>> LeetCodeArray::onesMinusZeros(vector<vector<int>>& grid)
{
    vector<int> row(grid.size());
    vector<int> col(grid[0].size());
    vector<vector<int>> result(grid.size(), vector<int>(grid[0].size()));
    for (size_t i = 0; i < grid.size(); i++)
    {
        for (size_t j = 0; j < grid[i].size(); j++)
        {
            if (grid[i][j] == 1)
            {
                row[i]++;
                col[j]++;
            }
            else
            {
                row[i]--;
                col[j]--;
            }
        }
    }

    for (size_t i = 0; i < grid.size(); i++)
    {
        for (size_t j = 0; j < grid[i].size(); j++)
        {
            result[i][j] = row[i] + col[j];
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2483. Minimum Penalty for a Shop
/// 
/// Medium
///	
/// You are given the customer visit log of a shop represented by a 
/// 0-indexed string customers consisting only of characters 'N' and 'Y':
///
/// if the ith character is 'Y', it means that customers come at the ith 
/// hour
/// whereas 'N' indicates that no customers come at the ith hour.
/// If the shop closes at the jth hour (0 <= j <= n), the penalty is 
/// calculated as follows:
///
/// For every hour when the shop is open and no customers come, the 
/// penalty increases by 1.
/// For every hour when the shop is closed and customers come, the 
/// penalty increases by 1.
/// Return the earliest hour at which the shop must be closed to incur a 
/// minimum penalty.
///
/// Note that if a shop closes at the jth hour, it means the shop is 
/// closed at the hour j.
/// 
/// Example 1:
/// Input: customers = "YYNY"
/// Output: 2
/// Explanation: 
/// - Closing the shop at the 0th hour incurs in 1+1+0+1 = 3 penalty.
/// - Closing the shop at the 1st hour incurs in 0+1+0+1 = 2 penalty.
/// - Closing the shop at the 2nd hour incurs in 0+0+0+1 = 1 penalty.
/// - Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty.
/// - Closing the shop at the 4th hour incurs in 0+0+1+0 = 1 penalty.
/// Closing the shop at 2nd or 4th hour gives a minimum penalty. 
/// Since 2 is earlier, the optimal closing time is 2.
///
/// Example 2:
/// Input: customers = "NNNNN"
/// Output: 0
/// Explanation: It is best to close the shop at the 0th hour as no 
/// customers arrive.
///
/// Example 3:
/// Input: customers = "YYYY"
/// Output: 4
/// Explanation: It is best to close the shop at the 4th hour as 
/// customers arrive at each hour.
///
/// 
/// Constraints:
/// 
/// 1. 1 <= customers.length <= 10^5
/// 2. customers consists only of characters 'Y' and 'N'.
/// </summary>
int LeetCodeArray::bestClosingTime(string customers)
{
    int total_yes = 0;
    for (size_t i = 0; i < customers.size(); i++)
    {
        if (customers[i] == 'Y') total_yes++;
    }
    int current_no = 0;
    int current_yes = 0;
    int min_penalty = INT_MAX;
    int result = -1;
    for (size_t i = 0; i <= customers.size(); i++)
    {
        int penalty = current_no + total_yes - current_yes;
        if (penalty < min_penalty)
        {
            min_penalty = penalty;
            result = i;
        }
        if (i == customers.size()) break;
        if (customers[i] == 'Y') current_yes++;
        else current_no++;
    }
    return result;
}

/// <summary>
/// Leet Code 2500. Delete Greatest Value in Each Row
/// 
/// Easy
///	
/// You are given an m x n matrix grid consisting of positive integers.
///
/// Perform the following operation until grid becomes empty:
///
/// Delete the element with the greatest value from each row. If multiple 
/// such elements exist, delete any of them.
/// Add the maximum of deleted elements to the answer.
/// Note that the number of columns decreases by one after each operation.
///
/// Return the answer after performing the operations described above.
/// 
/// Example 1:
/// Input: grid = [[1,2,4],[3,3,1]]
/// Output: 8
/// Explanation: The diagram above shows the removed values in each step.
/// - In the first operation, we remove 4 from the first row and 3 from 
///   the second row (notice that, there are two cells with value 3 and 
///   we can remove any of them). We add 4 to the answer.
/// - In the second operation, we remove 2 from the first row and 3 from 
///   the second row. We add 3 to the answer.
/// - In the third operation, we remove 1 from the first row and 1 from 
///   the second row. We add 1 to the answer.
/// The final answer = 4 + 3 + 1 = 8.
///
/// Example 2:
/// Input: grid = [[10]]
/// Output: 10
/// Explanation: The diagram above shows the removed values in each step.
/// - In the first operation, we remove 10 from the first row. We add 10 
///   to the answer.
/// The final answer = 10.
///
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 1 <= m, n <= 50
/// 4. 1 <= grid[i][j] <= 100
/// </summary>
int LeetCodeArray::deleteGreatestValue(vector<vector<int>>& grid)
{
    int m = grid.size();
    int n = grid[0].size();
    for (int i = 0; i < m; i++)
    {
        sort(grid[i].begin(), grid[i].end());
    }
    int result = 0;
    for (int i = 0; i < n; i++)
    {
        int val = 0;
        for (int j = 0; j < m; j++)
        {
            val = max(val, grid[j][i]);
        }
        result += val;
    }
    return result;
}

/// <summary>
/// Leet Code 2470. Number of Subarrays With LCM Equal to K
/// 
/// Medium
///	
/// Given an integer array nums and an integer k, return the number of 
/// subarrays of nums where the least common multiple of the subarray's 
/// elements is k.
///
/// A subarray is a contiguous non-empty sequence of elements within an 
/// array.
///
/// The least common multiple of an array is the smallest positive 
/// integer that is divisible by all the array elements.
///
/// Example 1:
///  
/// Input: nums = [3,6,2,7,1], k = 6
/// Output: 4
/// Explanation: The subarrays of nums where 6 is the least common 
/// multiple of all the subarray's elements are:
/// - [3,6,2,7,1]
/// - [3,6,2,7,1]
/// - [3,6,2,7,1]
/// - [3,6,2,7,1]
///
/// Example 2:
/// Input: nums = [3], k = 2
/// Output: 0
/// Explanation: There are no subarrays of nums where 2 is the least 
/// common multiple of all the subarray's elements.
///  
/// Constraints:
/// 1. 1 <= nums.length <= 1000
/// 2. 1 <= nums[i], k <= 1000
/// </summary>
int LeetCodeArray::subarrayLCM(vector<int>& nums, int k)
{
    int left = 0;
    int lcm = 0;
    int n = nums.size();
    int result = 0;
    for (int i = 0; i < n; i++)
    {
        for (int j = i; j >= 0; j--)
        {
            if (j == i)
            {
                lcm = nums[i];
            }
            else
            {
                int a = lcm;
                int b = nums[j];
                while (a != 0 && b != 0)
                {
                    if (a < b) swap(a, b);
                    a = a % b;
                }
                lcm = lcm * nums[j] / b;
            }
            if (lcm == k) result++;
            else if (k % lcm != 0) break;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2489. Number of Substrings With Fixed Ratio
/// 
/// Medium
///	
/// You are given a binary string s, and two integers num1 and num2. num1 
/// and num2 are coprime numbers.
///
/// A ratio substring is a substring of s where the ratio between the 
/// number of 0's and the number of 1's in the substring is exactly 
/// num1 : num2.
///
/// For example, if num1 = 2 and num2 = 3, then "01011" and "1110000111" 
/// are ratio substrings, while "11000" is not.
/// Return the number of non-empty ratio substrings of s.
///
/// Note that:
/// A substring is a contiguous sequence of characters within a string.
/// Two values x and y are coprime if gcd(x, y) == 1 where gcd(x, y) is 
/// the greatest common divisor of x and y.
/// 
/// Example 1:
/// Input: s = "0110011", num1 = 1, num2 = 2
/// Output: 4
/// Explanation: There exist 4 non-empty ratio substrings.
/// - The substring s[0..2]: "0110011". It contains one 0 and two 1's. 
///   The ratio is 1 : 2.
/// - The substring s[1..4]: "0110011". It contains one 0 and two 1's. 
///   The ratio is 1 : 2.
/// - The substring s[4..6]: "0110011". It contains one 0 and two 1's. 
///   The ratio is 1 : 2.
/// - The substring s[1..6]: "0110011". It contains two 0's and four 1's. 
///   The ratio is 2 : 4 == 1 : 2.
/// It can be shown that there are no more ratio substrings.
///
/// Example 2:
/// Input: s = "10101", num1 = 3, num2 = 1
/// Output: 0
/// Explanation: There is no ratio substrings of s. We return 0.
/// 
/// Constraints:
/// 1. 1 <= s.length <= 10^5
/// 2. 1 <= num1, num2 <= s.length
/// 3. num1 and num2 are coprime integers.
/// </summary>
long long LeetCodeArray::fixedRatio(string s, int num1, int num2)
{
    long long result = 0;
    unordered_map<long long, long long> prefix_sum;
    prefix_sum[0] = 1;
    long long sum = 0;
    for (size_t i = 0; i < s.size(); i++)
    {
        if (s[i] == '0') sum += (long long)num2;
        else sum -= (long long)num1;
        result += prefix_sum[sum];
        prefix_sum[sum]++;
    }
    return result;
}

/// <summary>
/// Leet Code 2498. Frog Jump II
/// 
/// Medium
///	
/// You are given a 0-indexed integer array stones sorted in strictly 
/// increasing order representing the positions of stones in a river.
///
/// A frog, initially on the first stone, wants to travel to the last 
/// stone and then return to the first stone. However, it can jump to 
/// any stone at most once.
///
/// The length of a jump is the absolute difference between the position 
/// of the stone the frog is currently on and the position of the stone 
/// to which the frog jumps.
///
/// More formally, if the frog is at stones[i] and is jumping to 
/// stones[j], the length of the jump is |stones[i] - stones[j]|.
/// The cost of a path is the maximum length of a jump among all jumps 
/// in the path.
/// 
/// Return the minimum cost of a path for the frog.
/// Example 1:
/// Input: stones = [0,2,5,6,7]
/// Output: 5
/// Explanation: The above figure represents one of the optimal paths 
/// the frog can take.
/// The cost of this path is 5, which is the maximum length of a jump.
/// Since it is not possible to achieve a cost of less than 5, we return 
/// it.
///
/// Example 2:
/// Input: stones = [0,3,9]
/// Output: 9
/// Explanation: 
/// The frog can jump directly to the last stone and come back to the 
/// first stone. 
/// In this case, the length of each jump will be 9. The cost for the 
/// path will be max(9, 9) = 9.
/// It can be shown that this is the minimum achievable cost.
/// 
/// Constraints:
/// 1. 2 <= stones.length <= 10^5
/// 2. 0 <= stones[i] <= 10^9
/// 3. stones[0] == 0
/// 4. stones is sorted in a strictly increasing order.
/// </summary>
int LeetCodeArray::maxJump(vector<int>& stones)
{
    int result = 0;
    for (size_t i = 1; i < stones.size(); i++)
    {
        if (i == 1)
        {
            result = max(result, stones[i] - stones[i - 1]);
        }
        else
        {
            result = max(result, stones[i] - stones[i - 2]);
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2488. Count Subarrays With Median K
/// 
/// Hard
///	
/// You are given an array nums of size n consisting of distinct integers 
/// from 1 to n and a positive integer k.
///
/// Return the number of non-empty subarrays in nums that have a median 
/// equal to k.
///
/// Note:
/// The median of an array is the middle element after sorting the array 
/// in ascending order. If the array is of even length, the median is the 
/// left middle element.
/// For example, the median of [2,3,1,4] is 2, and the 
/// median of [8,4,3,5,1] is 4.
/// A subarray is a contiguous part of an array.
/// 
/// Example 1:
/// Input: nums = [3,2,1,4,5], k = 4
/// Output: 3
/// Explanation: The subarrays that have a median equal to 4 are: [4], 
/// [4,5] and [1,4,5].
/// Example 2:
///
/// Input: nums = [2,3,1], k = 3
/// Output: 1
/// Explanation: [3] is the only subarray that has a median equal to 3.
/// 
/// Constraints:
/// 1. n == nums.length
/// 2. 1 <= n <= 10^5
/// 3. 1 <= nums[i], k <= n
/// 4. The integers in nums are distinct.
/// </summary>
int LeetCodeArray::countSubarrays(vector<int>& nums, int k)
{
    unordered_map<int, int> prefix_sum;
    prefix_sum[0] = 1;
    bool is_k_found = false;
    int sum = 0;
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] == k)
        {
            is_k_found = true;
        }
        else if (nums[i] > k)
        {
            sum++;
        }
        else
        {
            sum--;
        }
        if (is_k_found)
        {
            if (prefix_sum.count(sum) > 0)
            {
                result += prefix_sum[sum];
            }
            if (prefix_sum.count(sum - 1) > 0)
            {
                result += prefix_sum[sum - 1];
            }
        }
        else
        {
            prefix_sum[sum]++;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2499. Minimum Total Cost to Make Arrays Unequal
/// 
/// Hard
///	
/// You are given two 0-indexed integer arrays nums1 and nums2, of equal 
/// length n.
///
/// In one operation, you can swap the values of any two indices of nums1. 
/// The cost of this operation is the sum of the indices.
///
/// Find the minimum total cost of performing the given operation any 
/// number of times such that nums1[i] != nums2[i] for all 
/// 0 <= i <= n - 1 after performing all the operations.
///
/// Return the minimum total cost such that nums1 and nums2 satisfy 
/// the above condition. In case it is not possible, return -1.
///
/// Example 1:
/// Input: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]
/// Output: 10
/// Explanation: 
/// One of the ways we can perform the operations is:
/// - Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3. 
///   Now, nums1 = [4,2,3,1,5]
/// - Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3. 
///   Now, nums1 = [4,3,2,1,5].
/// - Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4. 
///   Now, nums1 =[5,3,2,1,4].
/// We can see that for each index i, nums1[i] != nums2[i]. 
/// The cost required here is 10.
/// Note that there are other ways to swap values, but it can be proven 
/// that it is not possible to obtain a cost less than 10.
///
/// Example 2:
/// Input: nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]
/// Output: 10
/// Explanation: 
/// One of the ways we can perform the operations is:
/// - Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5. 
///   Now, nums1 = [2,2,1,2,3].
/// - Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5. 
///   Now, nums1 = [2,3,1,2,2].
/// The total cost needed here is 10, which is the minimum possible.
///
/// Example 3:
/// Input: nums1 = [1,2,2], nums2 = [1,2,2]
/// Output: -1
/// Explanation: 
/// It can be shown that it is not possible to satisfy the given 
/// conditions irrespective of the number of operations we perform.
/// Hence, we return -1.
///
/// Constraints:
/// 1. n == nums1.length == nums2.length
/// 2. 1 <= n <= 10^5
/// 3. 1 <= nums1[i], nums2[i] <= n
/// </summary>
long long LeetCodeArray::minimumTotalCost(vector<int>& nums1, vector<int>& nums2)
{
    int n = nums1.size();
    long long result = 0;
    map<int, int> freq;
    int maxFrequency = 0;
    int maxFrequencyValue = 0; 
    int toSwap = 0;

    for (int i = 0; i < n; i++) 
    {
        if (nums1[i] == nums2[i])
        {
            freq[nums1[i]]++;
            if (freq[nums1[i]] > maxFrequency)
            {
                maxFrequencyValue = nums1[i];
                maxFrequency = freq[nums1[i]];
            }
            toSwap++;
            result += (long long)i;
        }
    }

    for (int i = 0; i < n; i++) 
    {
        if (maxFrequency > toSwap / 2 && 
            nums1[i] != nums2[i] && 
            nums1[i] != maxFrequencyValue && 
            nums2[i] != maxFrequencyValue) 
        {
            result += (long long)i;
            toSwap++;
        }
    }
    if (maxFrequency > toSwap / 2) return -1;
    return result;
}


/// <summary>
/// Leet Code 2511. Maximum Enemy Forts That Can Be Captured
/// 
/// Easy
///	
/// You are given a 0-indexed integer array forts of length n representing 
/// the positions of several forts. forts[i] can be -1, 0, or 1 where:
///
/// -1 represents there is no fort at the ith position.
/// 0 indicates there is an enemy fort at the ith position.
/// 1 indicates the fort at the ith the position is under your command.
/// Now you have decided to move your army from one of your forts at 
/// position i to an empty position j such that:
///
/// 0 <= i, j <= n - 1
/// The army travels over enemy forts only. Formally, for all k 
/// where min(i,j) < k < max(i,j), forts[k] == 0.
/// While moving the army, all the enemy forts that come in the way are 
/// captured.
///
/// Return the maximum number of enemy forts that can be captured. In 
/// case it is impossible to move your army, or you do not have any fort 
/// under your command, return 0.
/// 
/// Example 1:
///
/// Input: forts = [1,0,0,-1,0,0,0,0,1]
/// Output: 4
/// Explanation:
/// - Moving the army from position 0 to position 3 captures 2 enemy 
///   forts, at 1 and 2.
/// - Moving the army from position 8 to position 3 captures 4 enemy forts.
/// Since 4 is the maximum number of enemy forts that can be captured, we 
/// return 4.
///
/// Example 2:
/// Input: forts = [0,0,1,-1]
/// Output: 0
/// Explanation: Since no enemy fort can be captured, 0 is returned.
///
/// Constraints:
/// 1. 1 <= forts.length <= 1000
/// 2. -1 <= forts[i] <= 1
/// </summary>
int LeetCodeArray::captureForts(vector<int>& forts)
{
    int prev = 0;
    int count = 0;
    int result = 0;
    for (size_t i = 0; i < forts.size(); i++)
    {
        if (forts[i] == 0) count++;
        else 
        {
            if (forts[i] * prev == -1)
            {
                result = max(result, count);
            }
            count = 0;
            prev = forts[i];
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2515. Shortest Distance to Target String in a Circular Array
/// 
/// Easy
///	
/// You are given a 0-indexed circular string array words and a string 
/// target. A circular array means that the array's end connects to the 
/// array's beginning.
///
/// Formally, the next element of words[i] is words[(i + 1) % n] and the 
/// previous element of words[i] is words[(i - 1 + n) % n], where n is 
/// the length of words.
/// Starting from startIndex, you can move to either the next word or 
/// the previous word with 1 step at a time.
///
/// Return the shortest distance needed to reach the string target. 
/// If the string target does not exist in words, return -1.
///
/// Example 1:
/// Input: words = ["hello","i","am","leetcode","hello"], 
/// target = "hello", startIndex = 1
/// Output: 1
/// Explanation: We start from index 1 and can reach "hello" by
/// - moving 3 units to the right to reach index 4.
/// - moving 2 units to the left to reach index 4.
/// - moving 4 units to the right to reach index 0.
/// - moving 1 unit to the left to reach index 0.
/// The shortest distance to reach "hello" is 1.
/// Example 2:
/// Input: words = ["a","b","leetcode"], target = "leetcode", 
/// startIndex = 0
/// Output: 1
/// Explanation: We start from index 0 and can reach "leetcode" by
/// - moving 2 units to the right to reach index 3.
/// - moving 1 unit to the left to reach index 3.
/// The shortest distance to reach "leetcode" is 1.
///
/// Example 3:
/// Input: words = ["i","eat","leetcode"], target = "ate", 
/// startIndex = 0
/// Output: -1
/// Explanation: Since "ate" does not exist in words, we return -1.
///
/// Constraints:
/// 1. 1 <= words.length <= 100
/// 2. 1 <= words[i].length <= 100
/// 3. words[i] and target consist of only lowercase English letters.
/// 4. 0 <= startIndex < words.length
/// </summary>
int LeetCodeArray::closetTarget(vector<string>& words, string target, int startIndex)
{
    int result = INT_MAX;
    for (int i = 0; i < (int)words.size(); i++)
    {
        if (words[i] == target)
        {
            if (i <= startIndex)
            {
                result = min(result, startIndex - i);
                result = min(result, i + (int)words.size() - startIndex);
            }
            else
            {
                result = min(result, i - startIndex);
                result = min(result, startIndex + (int)words.size() - i);
            }
        }
    }
    if (result == INT_MAX)
    {
        result = -1;
    }
    return result;
}

/// <summary>
/// Leet Code 2444. Count Subarrays With Fixed Bounds      
///                                                  
/// Hard
///
/// You are given an integer array nums and two integers minK and maxK.
///
/// A fixed-bound subarray of nums is a subarray that satisfies the 
/// following conditions:
///
/// The minimum value in the subarray is equal to minK.
/// The maximum value in the subarray is equal to maxK.
/// Return the number of fixed-bound subarrays.
///
/// A subarray is a contiguous part of an array.
/// 
/// Example 1:
/// Input: nums = [1,3,5,2,7,5], minK = 1, maxK = 5
/// Output: 2
/// Explanation: The fixed-bound subarrays are [1,3,5] and [1,3,5,2].
///
/// Example 2:
/// 
/// Input: nums = [1,1,1,1], minK = 1, maxK = 1
/// Output: 10
/// Explanation: Every subarray of nums is a fixed-bound 
/// subarray. There are 10 possible subarrays.
/// 
/// Constraints:
/// 1. 2 <= nums.length <= 10^5
/// 2. 1 <= nums[i], minK, maxK <= 10^6
/// </summary>
long long LeetCodeArray::countSubarrays(vector<int>& nums, int minK, int maxK)
{
    long long result = 0;
    unordered_map<int, int> set_flag;
    int left = 0;
    set_flag[minK] = -1;
    set_flag[maxK] = -1;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] == minK)
        {
            set_flag[minK] = i;
        }
        if (nums[i] == maxK)
        {
            set_flag[maxK] = i;
        }
        if (nums[i] < minK || nums[i] > maxK)
        {
            set_flag[minK] = -1;
            set_flag[maxK] = -1;
            left = i + 1;
        }
        if (set_flag[minK] >= 0 && set_flag[maxK] >= 0)
        {
            int count = min(set_flag[minK], set_flag[maxK]) - left + 1;
            result += (long long)count;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2535. Difference Between Element Sum and Digit Sum of 
///                 an Array
/// 
/// Easy
///	
/// You are given a positive integer array nums.
///
/// The element sum is the sum of all the elements in nums.
/// The digit sum is the sum of all the digits (not necessarily distinct) 
/// that appear in nums.
/// Return the absolute difference between the element sum and digit 
/// sum of nums.
///
/// Note that the absolute difference between two integers x and y is 
/// defined as |x - y|.
///
/// Example 1:
/// Input: nums = [1,15,6,3]
/// Output: 9
/// Explanation: 
/// The element sum of nums is 1 + 15 + 6 + 3 = 25.
/// The digit sum of nums is 1 + 1 + 5 + 6 + 3 = 16.
/// The absolute difference between the element sum and digit sum 
/// is |25 - 16| = 9.
///
/// Example 2:
/// Input: nums = [1,2,3,4]
/// Output: 0
/// Explanation:
/// The element sum of nums is 1 + 2 + 3 + 4 = 10.
/// The digit sum of nums is 1 + 2 + 3 + 4 = 10.
/// The absolute difference between the element sum and digit 
/// sum is |10 - 10| = 0.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 2000
/// 2. 1 <= nums[i] <= 2000
/// </summary>
int LeetCodeArray::differenceOfSum(vector<int>& nums)
{
    int sum = 0;
    int digit_sum = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        int n = nums[i];
        sum += n;
        while (n > 0)
        {
            digit_sum += n % 10;
            n /= 10;
        }
    }
    return abs(sum - digit_sum);
}

/// <summary>
/// Leet Code 2536. Increment Submatrices by One
/// 
/// Medium
///	
/// You are given a positive integer n, indicating that we initially have 
/// an n x n 0-indexed integer matrix mat filled with zeroes.
///
/// You are also given a 2D integer array query. For each 
/// query[i] = [row1i, col1i, row2i, col2i], you should do the following 
/// operation:
///
/// Add 1 to every element in the submatrix with the top left 
/// corner (row1i, col1i) and the bottom right corner (row2i, col2i). 
/// That is, add 1 to mat[x][y] for for all row1i <= x <= row2i and 
/// col1i <= y <= col2i.
/// Return the matrix mat after performing every query.
/// 
/// Example 1:
/// Input: n = 3, queries = [[1,1,2,2],[0,0,1,1]]
/// Output: [[1,1,0],[1,2,1],[0,1,1]]
/// Explanation: The diagram above shows the initial matrix, the matrix 
/// after the first query, and the matrix after the second query.
/// - In the first query, we add 1 to every element in the submatrix with 
///    the top left corner (1, 1) and bottom right corner (2, 2).
/// - In the second query, we add 1 to every element in the submatrix with 
/// the top left corner (0, 0) and bottom right corner (1, 1).
///
/// Example 2:
/// Input: n = 2, queries = [[0,0,1,1]]
/// Output: [[1,1],[1,1]]
/// Explanation: The diagram above shows the initial matrix and the matrix 
/// after the first query.
/// - In the first query we add 1 to every element in the matrix.
///
/// Constraints:
/// 1. 1 <= n <= 500
/// 2. 1 <= queries.length <= 10^4
/// 3. 0 <= row1i <= row2i < n
/// 4. 0 <= col1i <= col2i < n
/// </summary>
vector<vector<int>> LeetCodeArray::rangeAddQueries(int n, vector<vector<int>>& queries)
{
    vector<vector<int>> dp(n, vector<int>(n));
    for (size_t i = 0; i < queries.size(); i++)
    {
        int r0 = queries[i][0];
        int c0 = queries[i][1];
        int r1 = queries[i][2];
        int c1 = queries[i][3];
        dp[r0][c0]++;
        if (c1 + 1 < n) dp[r0][c1 + 1]--;
        if (r1 + 1 < n) dp[r1 + 1][c0]--;
        if ((r1 + 1 < n) && (c1 + 1 < n)) dp[r1 + 1][c1 + 1]++;
    }
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (i > 0) dp[i][j] += dp[i - 1][j];
        }
    }
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (j > 0) dp[i][j] += dp[i][j - 1];
        }
    }
    return dp;
}

/// <summary>
/// Leet Code 2540. Minimum Common Value
/// 
/// Easy
///	
/// Given two integer arrays nums1 and nums2, sorted in non-decreasing 
/// order, return the minimum integer common to both arrays. If there 
/// is no common integer amongst nums1 and nums2, return -1.
///
/// Note that an integer is said to be common to nums1 and nums2 if both 
/// arrays have at least one occurrence of that integer.
///
/// Example 1:
/// Input: nums1 = [1,2,3], nums2 = [2,4]
/// Output: 2
/// Explanation: The smallest element common to both arrays is 2, so we 
/// return 2.
///
/// Example 2:
/// Input: nums1 = [1,2,3,6], nums2 = [2,3,4,5]
/// Output: 2
/// Explanation: There are two common elements in the array 2 and 3 out 
/// of which 2 is the smallest, so 2 is returned.
///
/// Constraints:
/// 1. 1 <= nums1.length, nums2.length <= 10^5
/// 2. 1 <= nums1[i], nums2[j] <= 10^9
/// 3. Both nums1 and nums2 are sorted in non-decreasing order.
/// </summary>
int LeetCodeArray::getCommon(vector<int>& nums1, vector<int>& nums2)
{
    int p1 = 0;
    int p2 = 0;
    while (p1 < (int)nums1.size() && p2 < (int)nums2.size())
    {
        if (nums1[p1] == nums2[p2])
        {
            return nums1[p1];
        }
        else if (nums1[p1] < nums2[p2])
        {
            p1++;
        }
        else
        {
            p2++;
        }
    }
    return -1;
}

/// <summary>
/// Leet Code 2545. Sort the Students by Their Kth Score
/// 
/// Medium
///	
/// There is a class with m students and n exams. You are given a 
/// 0-indexed m x n integer matrix score, where each row represents one 
/// student and score[i][j] denotes the score the ith student got in the 
/// jth exam. The matrix score contains distinct integers only.
///
/// You are also given an integer k. Sort the students (i.e., the rows of 
/// the matrix) by their scores in the kth (0-indexed) exam from the 
/// highest to the lowest.
///
/// Return the matrix after sorting it.
/// 
/// Example 1:
/// Input: score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2
/// Output: [[7,5,11,2],[10,6,9,1],[4,8,3,15]]
/// Explanation: In the above diagram, S denotes the student, while E 
/// denotes the exam.
/// - The student with index 1 scored 11 in exam 2, which is the highest 
///   score, so they got first place.
/// - The student with index 0 scored 9 in exam 2, which is the second 
///   highest score, so they got second place.
/// - The student with index 2 scored 3 in exam 2, which is the lowest 
///   score, so they got third place.
///
/// Example 2:
/// Input: score = [[3,4],[5,6]], k = 0
/// Output: [[5,6],[3,4]]
/// Explanation: In the above diagram, S denotes the student, while E 
/// denotes the exam.
/// - The student with index 1 scored 5 in exam 0, which is the highest 
///   score, so they got first place.
/// - The student with index 0 scored 3 in exam 0, which is the lowest 
///   score, so they got second place.
///
/// Constraints:
/// 1. m == score.length
/// 2. n == score[i].length
/// 3. 1 <= m, n <= 250
/// 4. 1 <= score[i][j] <= 10^5
/// 5. score consists of distinct integers.
/// 6. 0 <= k < n
/// </summary>
vector<vector<int>> LeetCodeArray::sortTheStudents(vector<vector<int>>& score, int k)
{
    priority_queue<pair<int, int>> pq;
    int n = score.size();
    int m = score[0].size();
    for (int i = 0; i < n; i++)
    {
        pq.push(make_pair(score[i][k], i));
    }
    vector<vector<int>> result(n, vector<int>(m));
    for (int i = 0; i < n; i++)
    {
        int r = pq.top().second;
        pq.pop();
        for (int j = 0; j < m; j++)
        {
            result[i][j] = score[r][j];
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2541. Minimum Operations to Make Array Equal II
/// 
/// Medium
///	
/// You are given two integer arrays nums1 and nums2 of equal length n and 
/// an integer k. You can perform the following operation on nums1:
///
/// Choose two indexes i and j and increment nums1[i] by k and decrement 
/// nums1[j] by k. In other words, nums1[i] = nums1[i] + k and 
/// nums1[j] = nums1[j] - k.
/// nums1 is said to be equal to nums2 if for all indices i such that 
/// 0 <= i < n, nums1[i] == nums2[i].
///
/// Return the minimum number of operations required to make nums1 equal 
/// to nums2. If it is impossible to make them equal, return -1.
///
/// Example 1:
/// Input: nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3
/// Output: 2
/// Explanation: In 2 operations, we can transform nums1 to nums2.
/// 1st operation: i = 2, j = 0. After applying the operation, 
/// nums1 = [1,3,4,4].
/// 2nd operation: i = 2, j = 3. After applying the operation, 
/// nums1 = [1,3,7,1].
/// One can prove that it is impossible to make arrays equal in fewer 
/// operations.
///
/// Example 2:
/// Input: nums1 = [3,8,5,2], nums2 = [2,4,1,6], k = 1
/// Output: -1
/// Explanation: It can be proved that it is impossible to make the 
/// two arrays equal.
///
/// Constraints:
/// 1. n == nums1.length == nums2.length
/// 2. 2 <= n <= 10^5
/// 3. 0 <= nums1[i], nums2[j] <= 10^9
/// 4. 0 <= k <= 10^5
/// </summary>
long long LeetCodeArray::minOperations(vector<int>& nums1, vector<int>& nums2, int k)
{
    long long pos = 0, neg = 0;
    for (size_t i = 0; i < nums1.size(); i++)
    {
        if (nums1[i] == nums2[i]) continue;
        if ((k == 0) || (abs(nums1[i] - nums2[i]) % k != 0))
        {
            return -1;
        }
        if (nums1[i] > nums2[i])
        {
            pos += (nums1[i] - nums2[i]) / k;
        }
        else
        {
            neg += (nums2[i] - nums1[i]) / k;
        }
    }
    if (pos == neg) return pos;
    else return -1;
}


/// <summary>
/// Leet Code 2552. Count Increasing Quadruplets
/// 
/// Hard
///	
/// Given a 0-indexed integer array nums of size n containing all numbers 
/// from 1 to n, return the number of increasing quadruplets.
///
/// A quadruplet (i, j, k, l) is increasing if:
///
/// 0 <= i < j < k < l < n, and
/// nums[i] < nums[k] < nums[j] < nums[l].
///
/// Example 1:
/// Input: nums = [1,3,2,4,5]
/// Output: 2
/// Explanation: 
/// - When i = 0, j = 1, k = 2, and l = 3, nums[i] < nums[k] < 
//    nums[j] < nums[l].
/// - When i = 0, j = 1, k = 2, and l = 4, nums[i] < nums[k] < 
///   nums[j] < nums[l]. 
/// There are no other quadruplets, so we return 2.
///
/// Example 2:
/// Input: nums = [1,2,3,4]
/// Output: 0
/// Explanation: There exists only one quadruplet with i = 0, j = 1, 
/// k = 2, l = 3, but since nums[j] < nums[k], we return 0.
///
/// Constraints:
/// 1. 4 <= nums.length <= 4000
/// 2. 1 <= nums[i] <= nums.length
/// 3. All the integers of nums are unique. nums is a permutation.
/// </summary>
long long LeetCodeArray::countQuadruplets(vector<int>& nums)
{
    int n = nums.size();
    vector<long long> dp(n);
    long long result = 0;
    for (int i = 0; i < n; i++)
    {
        long long smaller = 0;
        for (int j = 0; j < i; j++)
        {
            if (nums[j] < nums[i])
            {
                smaller++;
                result += dp[j];
            }
            else
            {
                dp[j] += smaller;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2559. Count Vowel Strings in Ranges
/// 
/// Medium
///	
/// You are given a 0-indexed array of strings words and a 2D array of 
/// integers queries.
///
/// Each query queries[i] = [li, ri] asks us to find the number of strings 
/// present in the range li to ri (both inclusive) of words that start and 
/// end with a vowel.
///
/// Return an array ans of size queries.length, where ans[i] is the answer 
/// to the ith query.
///
/// Note that the vowel letters are 'a', 'e', 'i', 'o', and 'u'.
///
/// Example 1:
/// Input: words = ["aba","bcb","ece","aa","e"], 
/// queries = [[0,2],[1,4],[1,1]]
/// Output: [2,3,0]
/// Explanation: The strings starting and ending with a vowel are "aba", 
/// "ece", "aa" and "e".
/// The answer to the query [0,2] is 2 (strings "aba" and "ece").
/// to query [1,4] is 3 (strings "ece", "aa", "e").
/// to query [1,1] is 0.
/// We return [2,3,0].
///
/// Example 2:
/// Input: words = ["a","e","i"], queries = [[0,2],[0,1],[2,2]]
/// Output: [3,2,1]
/// Explanation: Every string satisfies the conditions, so we return [3,2,1].
/// 
/// Constraints:
/// 1. 1 <= words.length <= 10^5
/// 2. 1 <= words[i].length <= 40
/// 3. words[i] consists only of lowercase English letters.
/// 4. sum(words[i].length) <= 3 * 10^5
/// 5. 1 <= queries.length <= 10^5
/// 6. 0 <= li <= ri < words.length
/// </summary>
vector<int> LeetCodeArray::vowelStrings(vector<string>& words, vector<vector<int>>& queries)
{
    vector<int> dp(words.size());
    unordered_set<char> vowels = { 'a', 'e', 'i', 'o', 'u' };
    for (size_t i = 0; i < words.size(); i++)
    {
        if (i > 0) dp[i] = dp[i - 1];
        if (vowels.count(words[i][0]) > 0 && vowels.count(words[i].back()) > 0)
        {
            dp[i]++;
        }
    }
    vector<int> result(queries.size());
    for (size_t i = 0; i < queries.size(); i++)
    {
        result[i] = dp[queries[i][1]];
        if (queries[i][0] > 0)
        {
            result[i] -= dp[queries[i][0] - 1];
        }
    }
    return result;
}


/// <summary>
/// Leet Code 2562. Find the Array Concatenation Value
/// 
/// Easy
///	
/// You are given a 0-indexed integer array nums.
///
/// The concatenation of two numbers is the number formed by concatenating 
/// their numerals.
///
/// For example, the concatenation of 15, 49 is 1549.
/// The concatenation value of nums is initially equal to 0. Perform this 
/// operation until nums becomes empty:
///
/// If there exists more than one number in nums, pick the first element 
/// and last element in nums respectively and add the value of their 
/// concatenation to the concatenation value of nums, then delete the 
/// first and last element from nums.
/// If one element exists, add its value to the concatenation value of 
/// nums, then delete it.
/// Return the concatenation value of the nums.
/// 
/// Example 1:
/// Input: nums = [7,52,2,4]
/// Output: 596
/// Explanation: Before performing any operation, nums is [7,52,2,4] and 
/// concatenation value is 0.
///  - In the first operation:
/// We pick the first element, 7, and the last element, 4.
/// Their concatenation is 74, and we add it to the concatenation value, 
/// so it becomes equal to 74.
/// Then we delete them from nums, so nums becomes equal to [52,2].
///  - In the second operation:
/// We pick the first element, 52, and the last element, 2.
/// Their concatenation is 522, and we add it to the concatenation value, 
/// so it becomes equal to 596.
/// Then we delete them from the nums, so nums becomes empty.
/// Since the concatenation value is 596 so the answer is 596.
///
/// Example 2:
/// Input: nums = [5,14,13,8,12]
/// Output: 673
/// Explanation: Before performing any operation, nums is [5,14,13,8,12] 
/// and concatenation value is 0.
/// - In the first operation:
/// We pick the first element, 5, and the last element, 12.
/// Their concatenation is 512, and we add it to the concatenation value, 
/// so it becomes equal to 512.
/// Then we delete them from the nums, so nums becomes equal to [14,13,8].
/// - In the second operation:
/// We pick the first element, 14, and the last element, 8.
/// Their concatenation is 148, and we add it to the concatenation value, 
/// so it becomes equal to 660.
/// Then we delete them from the nums, so nums becomes equal to [13].
///  - In the third operation:
/// nums has only one element, so we pick 13 and add it to the 
/// concatenation value, so it becomes equal to 673.
/// Then we delete it from nums, so nums become empty.
/// Since the concatenation value is 673 so the answer is 673.
///
/// Constraints:
/// 1. 1 <= nums.length <= 1000
/// 2. 1 <= nums[i] <= 10^4
/// </summary>
long long LeetCodeArray::findTheArrayConcVal(vector<int>& nums)
{
    int left = 0;
    int right = nums.size() - 1;
    long long result = 0;
    while (left <= right)
    {
        if (left == right)
        {
            result += (long long)nums[left];
        }
        else
        {
            string str = to_string(nums[left]) + to_string(nums[right]);
            result += atol(str.c_str());
        }
        left++;
        right--;
    }
    return result;
};


/// <summary>
/// Leet Code 2570. Merge Two 2D Arrays by Summing Values
/// 
/// Easy
///	
/// You are given two 2D integer arrays nums1 and nums2.
///
/// nums1[i] = [idi, vali] indicate that the number with the id idi 
/// has a value equal to vali.
/// nums2[i] = [idi, vali] indicate that the number with the id idi 
/// has a value equal to vali.
/// Each array contains unique ids and is sorted in ascending order by id.
///
/// Merge the two arrays into one array that is sorted in ascending order 
/// by id, respecting the following conditions:
///
/// Only ids that appear in at least one of the two arrays should be 
/// included in the resulting array.
/// Each id should be included only once and its value should be the sum 
/// of the values of this id in the two arrays. If the id does not exist 
/// in one of the two arrays then its value in that array is considered 
/// to be 0.
/// Return the resulting array. The returned array must be sorted in 
/// ascending order by id.
/// 
/// Example 1:
/// Input: nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]
/// Output: [[1,6],[2,3],[3,2],[4,6]]
/// Explanation: The resulting array contains the following:
/// - id = 1, the value of this id is 2 + 4 = 6.
/// - id = 2, the value of this id is 3.
/// - id = 3, the value of this id is 2.
/// - id = 4, the value of this id is 5 + 1 = 6.
///
/// Example 2:
/// Input: nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]
/// Output: [[1,3],[2,4],[3,6],[4,3],[5,5]]
/// Explanation: There are no common ids, so we just include each id with 
/// its value in the resulting list.
///
/// Constraints:
/// 1. 1 <= nums1.length, nums2.length <= 200
/// 2. nums1[i].length == nums2[j].length == 2
/// 3. 1 <= idi, vali <= 1000
/// 4. Both arrays contain unique ids.
/// 5. Both arrays are in strictly ascending order by id.
/// </summary>
vector<vector<int>> LeetCodeArray::mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2)
{
    map<int, int> map;
    for (size_t i = 0; i < nums1.size(); i++)
    {
        map[nums1[i][0]] += nums1[i][1];
    }
    for (size_t i = 0; i < nums2.size(); i++)
    {
        map[nums2[i][0]] += nums2[i][1];
    }
    vector<vector<int>> result;
    for (auto itr : map)
    {
        result.push_back({ itr.first, itr.second });
    }
    return result;
}

/// <summary>
/// Leet Code 2573. Find the String with LCP
/// 
/// Hard
///	
/// We define the lcp matrix of any 0-indexed string word of n lowercase 
/// English letters as an n x n grid such that:
///
/// lcp[i][j] is equal to the length of the longest common prefix between 
/// the substrings word[i,n-1] and word[j,n-1].
/// Given an n x n matrix lcp, return the alphabetically smallest string 
/// word that corresponds to lcp. If there is no such string, return an 
/// empty string.
///
/// A string a is lexicographically smaller than a string b (of the same 
/// length) if in the first position where a and b differ, string a has 
/// a letter that appears earlier in the alphabet than the corresponding 
/// letter in b. For example, "aabd" is lexicographically smaller than 
/// "aaca" because the first position they differ is at the third 
/// letter, and 'b' comes before 'c'.
///
/// Example 1:
/// Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]
/// Output: "abab"
/// Explanation: lcp corresponds to any 4 letter string with two 
/// alternating letters. The lexicographically smallest of them is "abab".
///
/// Example 2:
/// Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]
/// Output: "aaaa"
/// Explanation: lcp corresponds to any 4 letter string with a single 
/// distinct letter. The lexicographically smallest of them is "aaaa". 
///
/// Example 3:
/// Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]
/// Output: ""
/// Explanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] 
/// consists of only a single letter; Thus, no answer exists.
///
/// Constraints:
/// 1. 1 <= n == lcp.length == lcp[i].length <= 1000
/// 2. 0 <= lcp[i][j] <= n
/// </summary>
string LeetCodeArray::findTheString(vector<vector<int>>& lcp)
{
    int n = lcp.size();
    string result(n, '#');
    set<char> set;
    for (int i = 0; i < 26; i++) set.insert('a' + i);
    for (int i = 0; i < n; i++)
    {
        char ch = result[i];
        if (result[i] == '#')
        {
            if (set.empty()) return "";
            ch = *set.begin();
            set.erase(ch);
        }
        for (int j = i; j < n; j++)
        {
            if (lcp[i][j] > 0)
            {
                if (result[j] == '#') result[j] = ch;
            }
        }
    }
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (result[i] == result[j])
            {
                if (i == n - 1 || j == n - 1)
                {
                    if (lcp[i][j] != 1) return "";
                }
                else
                {
                    if (lcp[i][j] != lcp[i + 1][j + 1] + 1) return "";
                }
            }
            else
            {
                if (lcp[i][j] != 0) return "";
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2574. Left and Right Sum Differences
/// 
/// Easy
///	
/// Given a 0-indexed integer array nums, find a 0-indexed integer 
/// array answer where:
///
/// answer.length == nums.length.
/// answer[i] = |leftSum[i] - rightSum[i]|.
/// Where:
///
/// leftSum[i] is the sum of elements to the left of the index i in the 
/// array nums. If there is no such element, leftSum[i] = 0.
/// rightSum[i] is the sum of elements to the right of the index i in 
/// the array nums. If there is no such element, rightSum[i] = 0.
/// Return the array answer.
/// 
/// Example 1:
/// Input: nums = [10,4,8,3]
/// Output: [15,1,11,22]
/// Explanation: The array leftSum is [0,10,14,22] and the array 
/// rightSum is [15,11,3,0].
/// The array answer is [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] 
/// = [15,1,11,22].
///
/// Example 2:
/// Input: nums = [1]
/// Output: [0]
/// Explanation: The array leftSum is [0] and the array rightSum is [0].
/// The array answer is [|0 - 0|] = [0].
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 1000
/// 2. 1 <= nums[i] <= 10^5
/// </summary>
vector<int> LeetCodeArray::leftRigthDifference(vector<int>& nums)
{
    vector<int> leftSum(nums.size()), result(nums.size());
    int left = 0, right = 0;

    for (size_t i = 0; i < nums.size(); i++)
    {
        leftSum[i] = left;
        left += nums[i];
    }

    for (int i = nums.size() - 1; i >=  0; i--)
    {
        result[i] = abs(leftSum[i] - right);
        right += nums[i];
    }
    return result;
}

/// <summary>
/// Leet Code 2587. Rearrange Array to Maximize Prefix Score
/// 
/// Medium
///	
/// You are given a 0-indexed integer array nums. You can rearrange the 
/// elements of nums to any order (including the given order).
///
/// Let prefix be the array containing the prefix sums of nums after 
/// rearranging it. In other words, prefix[i] is the sum of the elements 
/// from 0 to i in nums after rearranging it. The score of nums is the 
/// number of positive integers in the array prefix.
///
/// Return the maximum score you can achieve.
/// 
/// Example 1:
/// Input: nums = [2,-1,0,1,-3,3,-3]
/// Output: 6
/// Explanation: We can rearrange the array into nums = [2,3,1,-1,-3,0,-3].
/// prefix = [2,5,6,5,2,2,-1], so the score is 6.
/// It can be shown that 6 is the maximum score we can obtain.
///
/// Example 2:
/// Input: nums = [-2,-3,0]
/// Output: 0
/// Explanation: Any rearrangement of the array will result in a score of 0.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. -10^6 <= nums[i] <= 10^6
/// </summary>
int LeetCodeArray::maxScore(vector<int>& nums)
{
    sort(nums.begin(), nums.end());
    long long sum = 0;
    int result = 0;
    for (int i = nums.size() - 1; i >= 0; i--)
    {
        sum += nums[i];
        if (sum > 0) result++;
    }
    return result;
}

/// <summary>
/// Leet Code 2588. Count the Number of Beautiful Subarrays
/// 
/// Medium
///	
/// You are given a 0-indexed integer array nums. In one operation, you 
/// can:
///
/// Choose two different indices i and j such that 0 <= i, j < nums.length.
/// Choose a non-negative integer k such that the kth bit (0-indexed) in 
/// the binary representation of nums[i] and nums[j] is 1.
/// Subtract 2k from nums[i] and nums[j].
/// A subarray is beautiful if it is possible to make all of its elements 
/// equal to 0 after applying the above operation any number of times.
///
/// Return the number of beautiful subarrays in the array nums.
/// 
/// A subarray is a contiguous non-empty sequence of elements within 
/// an array.
///
/// Example 1:
/// Input: nums = [4,3,1,2,4]
/// Output: 2
/// Explanation: There are 2 beautiful subarrays in nums: [4,3,1,2,4] 
/// and [4,3,1,2,4].
/// - We can make all elements in the subarray [3,1,2] equal to 0 in the 
///   following way:
/// - Choose [3, 1, 2] and k = 1. Subtract 21 from both numbers. The subarray 
///   becomes [1, 1, 0].
/// - Choose [1, 1, 0] and k = 0. Subtract 20 from both numbers. The subarray 
///   becomes [0, 0, 0].
/// - We can make all elements in the subarray [4,3,1,2,4] equal to 0 in the 
///   following way:
/// - Choose [4, 3, 1, 2, 4] and k = 2. Subtract 22 from both numbers. The 
///   subarray becomes [0, 3, 1, 2, 0].
/// - Choose [0, 3, 1, 2, 0] and k = 0. Subtract 20 from both numbers. The 
///   subarray becomes [0, 2, 0, 2, 0].
/// - Choose [0, 2, 0, 2, 0] and k = 1. Subtract 21 from both numbers. The 
///   subarray becomes [0, 0, 0, 0, 0].
///
/// Example 2:
/// Input: nums = [1,10,4]
/// Output: 0
/// Explanation: There are no beautiful subarrays in nums.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 10^6
/// </summary>
long long LeetCodeArray::beautifulSubarrays(vector<int>& nums)
{
    unordered_map<int, int> bit_map;
    bit_map[0] = 1;
    int xor_sum = 0;
    long long result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        xor_sum = xor_sum ^ nums[i];
        result += bit_map[xor_sum];
        bit_map[xor_sum]++;
    }
    return result;
}

/// <summary>
/// Leet Code 2592. Maximize Greatness of an Array
/// 
/// Medium
///	
/// You are given a 0-indexed integer array nums. You are allowed to 
/// permute nums into a new array perm of your choosing.
///
/// We define the greatness of nums be the number of indices 
/// 0 <= i < nums.length for which perm[i] > nums[i].
///
/// Return the maximum possible greatness you can achieve after permuting 
/// nums.
///
/// Example 1:
/// Input: nums = [1,3,5,2,1,3,1]
/// Output: 4
/// Explanation: One of the optimal rearrangements is 
/// perm = [2,5,1,3,3,1,1].
/// At indices = 0, 1, 3, and 4, perm[i] > nums[i]. Hence, we return 4.
///
/// Example 2:
/// Input: nums = [1,2,3,4]
/// Output: 3
/// Explanation: We can prove the optimal perm is [2,3,4,1].
/// At indices = 0, 1, and 2, perm[i] > nums[i]. Hence, we return 3.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 10^9
/// </summary>
int LeetCodeArray::maximizeGreatness(vector<int>& nums)
{
    sort(nums.begin(), nums.end());
    int result = 0, right = nums.size() - 1;
    for (int i = nums.size() - 1; i >= 0; i--)
    {
        if (nums[right] > nums[i])
        {
            right--;
            result++;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2593. Find Score of an Array After Marking All Elements
/// 
/// Medium
///	
/// You are given an array nums consisting of positive integers.
///
/// Starting with score = 0, apply the following algorithm:
///
/// Choose the smallest integer of the array that is not marked. If 
/// there is a tie, choose the one with the smallest index.
/// Add the value of the chosen integer to score.
/// Mark the chosen element and its two adjacent elements if they exist.
/// Repeat until all the array elements are marked.
/// Return the score you get after applying the above algorithm.
///
/// Example 1:
/// Input: nums = [2,1,3,4,5,2]
/// Output: 7
/// Explanation: We mark the elements as follows:
/// - 1 is the smallest unmarked element, so we mark it and its two 
///   adjacent elements: [2,1,3,4,5,2].
/// - 2 is the smallest unmarked element, so we mark it and its left 
///   adjacent element: [2,1,3,4,5,2].
/// - 4 is the only remaining unmarked element, so we mark 
///   it: [2,1,3,4,5,2].
/// Our score is 1 + 2 + 4 = 7.
///
/// Example 2:
/// Input: nums = [2,3,5,1,3,2]
/// Output: 5
/// Explanation: We mark the elements as follows:
/// - 1 is the smallest unmarked element, so we mark it and its two 
///   adjacent elements: [2,3,5,1,3,2].
/// - 2 is the smallest unmarked element, since there are two of them, we 
///   choose the left-most one, so we mark the one at index 0 and its 
///   right adjacent element: [2,3,5,1,3,2].
/// - 2 is the only remaining unmarked element, so we mark it: 
///  [2,3,5,1,3,2].
/// Our score is 1 + 2 + 2 = 5.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^6
/// </summary>
long long LeetCodeArray::findScore(vector<int>& nums)
{
    set<pair<int, int>> pq;
    for (size_t i = 0; i < nums.size(); i++)
    {
        pq.insert(make_pair(nums[i], i));
    }
    long long result = 0;
    while (!pq.empty())
    {
        pair<int, int> pair = *pq.begin();
        pq.erase(pq.begin());
        result += pair.first;
        if (pair.second > 0)
        {
            pq.erase(make_pair(nums[pair.second - 1], pair.second - 1));
        }
        if (pair.second < (int)nums.size() - 1)
        {
            pq.erase(make_pair(nums[pair.second + 1], pair.second + 1));
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2596. Check Knight Tour Configuration
/// 
/// Medium
///	
/// There is a knight on an n x n chessboard. In a valid configuration, 
/// the knight starts at the top-left cell of the board and visits every 
/// cell on the board exactly once.
///
/// You are given an n x n integer matrix grid consisting of distinct 
/// integers from the range [0, n * n - 1] where grid[row][col] indicates 
/// that the cell (row, col) is the grid[row][col]th cell that the knight 
/// visited. The moves are 0-indexed.
///
/// Return true if grid represents a valid configuration of the knight's 
/// movements or false otherwise.
///
/// Note that a valid knight move consists of moving two squares 
/// vertically and one square horizontally, or two squares horizontally 
/// and one square vertically. The figure below illustrates all the 
/// possible eight moves of a knight from some cell.
/// 
/// Example 1:
/// Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],
/// [3,18,23,14,9],[24,13,2,7,22]]
/// Output: true
/// Explanation: The above diagram represents the grid. It can be 
/// shown that it is a valid configuration.
///
/// Example 2:
/// Input: grid = [[0,3,6],[5,8,1],[2,7,4]]
/// Output: false
/// Explanation: The above diagram represents the grid. The 8th move of 
/// the knight is not valid considering its position after the 7th move.
///
/// Constraints:
/// 1. n == grid.length == grid[i].length
/// 2. 3 <= n <= 7
/// 3. 0 <= grid[row][col] < n * n
/// 4. All integers in grid are unique.
/// </summary>
bool LeetCodeArray::checkValidGrid(vector<vector<int>>& grid)
{
    int n = grid.size();
    int m = grid[0].size();
    vector<pair<int, int>> dp(n * m);
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            int k = grid[i][j];
            dp[k].first = i;
            dp[k].second = j;
        }
    }
    if (dp[0].first != 0 || dp[0].second != 0) return false;
    for (int i = 1; i < n * m; i++)
    {
        int delta_y = abs(dp[i].first - dp[i - 1].first);
        int delta_x = abs(dp[i].second - dp[i - 1].second);
        if (delta_y == 2 && delta_x == 1) continue;
        if (delta_y == 1 && delta_x == 2) continue;
        return false;
    }
    return true;
}

/// <summary>
/// Leet Code 2602. Minimum Operations to Make All Array Elements Equal
/// 
/// Medium
///	
/// You are given an array nums consisting of positive integers.
///
/// You are also given an integer array queries of size m. For the ith 
/// query, you want to make all of the elements of nums equal to 
/// queries[i]. You can perform the following operation on the array 
/// any number of times:
///
/// Increase or decrease an element of the array by 1.
/// Return an array answer of size m where answer[i] is the minimum 
/// number of operations to make all elements of nums equal to queries[i].
///
/// Note that after each query the array is reset to its original state.
/// 
/// Example 1:
/// Input: nums = [3,1,6,8], queries = [1,5]
/// Output: [14,10]
/// Explanation: For the first query we can do the following operations:
/// - Decrease nums[0] 2 times, so that nums = [1,1,6,8].
/// - Decrease nums[2] 5 times, so that nums = [1,1,1,8].
/// - Decrease nums[3] 7 times, so that nums = [1,1,1,1].
/// So the total number of operations for the first query is 
/// 2 + 5 + 7 = 14.
/// For the second query we can do the following operations:
/// - Increase nums[0] 2 times, so that nums = [5,1,6,8].
/// - Increase nums[1] 4 times, so that nums = [5,5,6,8].
/// - Decrease nums[2] 1 time, so that nums = [5,5,5,8].
/// - Decrease nums[3] 3 times, so that nums = [5,5,5,5].
/// So the total number of operations for the second query is 
/// 2 + 4 + 1 + 3 = 10.
///
/// Example 2:
/// Input: nums = [2,9,6,3], queries = [10]
/// Output: [20]
/// Explanation: We can increase each value in the array to 10. The total 
/// number of operations will be 8 + 1 + 4 + 7 = 20.
///
/// Constraints:
/// 1. n == nums.length
/// 2. m == queries.length
/// 3. 1 <= n, m <= 10^5
/// 4. 1 <= nums[i], queries[i] <= 10^9
/// </summary>
vector<long long> LeetCodeArray::minOperationsII(vector<int>& nums, vector<int>& queries)
{
    vector<long long> result(queries.size());
    sort(nums.begin(), nums.end());
    vector<long long> dp(nums.size() + 1);
    dp[0] = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        dp[i + 1] += nums[i];
        dp[i + 1] += dp[i];
    }
    for (size_t i = 0; i < queries.size(); i++)
    {
        int index = lower_bound(nums.begin(), nums.end(), queries[i]) - nums.begin() + 1;
        result[i] = ((long long)dp.back() - (long long)dp[index-1]) - ((long long)dp.size() - (long long)index) * (long long)queries[i];
        result[i] += ((long long)index - (long long)1) * (long long)queries[i] - (long long)dp[index - 1];
    }

    return result;
}

/// <summary>
/// Leet Code 2607. Make K-Subarray Sums Equal
/// 
/// Medium
///	
/// You are given a 0-indexed integer array arr and an integer k. The 
/// array arr is circular. In other words, the first element of the 
/// array is the next element of the last element, and the last element 
/// of the array is the previous element of the first element.
///
/// You can do the following operation any number of times:
///
/// Pick any element from arr and increase or decrease it by 1.
/// Return the minimum number of operations such that the sum of each 
/// subarray of length k is equal.
///
/// A subarray is a contiguous part of the array.
///
///
/// Example 1:
/// Input: arr = [1,4,1,3], k = 2
/// Output: 1
/// Explanation: we can do one operation on index 1 to make its value 
/// equal to 3.
/// The array after the operation is [1,3,1,3]
/// - Subarray starts at index 0 is [1, 3], and its sum is 4 
/// - Subarray starts at index 1 is [3, 1], and its sum is 4 
/// - Subarray starts at index 2 is [1, 3], and its sum is 4 
/// - Subarray starts at index 3 is [3, 1], and its sum is 4 
///
/// Example 2:
/// Input: arr = [2,5,5,7], k = 3
/// Output: 5
/// Explanation: we can do three operations on index 0 to make its value 
/// equal to 5 and two operations on index 3 to make its value equal to 5.
/// The array after the operations is [5,5,5,5]
/// - Subarray starts at index 0 is [5, 5, 5], and its sum is 15
/// - Subarray starts at index 1 is [5, 5, 5], and its sum is 15
/// - Subarray starts at index 2 is [5, 5, 5], and its sum is 15
/// - Subarray starts at index 3 is [5, 5, 5], and its sum is 15 
///
/// Constraints:
/// 1. 1 <= k <= arr.length <= 10^5
/// 2. 1 <= arr[i] <= 10^9
/// </summary>
long long LeetCodeArray::makeSubKSumEqual(vector<int>& arr, int k)
{
    vector<int> visited(arr.size());
    long long result = 0;
    for (size_t i = 0; i < arr.size(); i++)
    {
        if (visited[i] == 1) continue;
        int p = i;
        vector<int> sub_arr;
        while (visited[p] == 0)
        {
            visited[p] = 1;
            sub_arr.push_back(arr[p]);
            p = (p + k) % arr.size();
        }
        sort(sub_arr.begin(), sub_arr.end());
        long long left_sum = 0;
        long long right_sum = 0;
        long long sum = 0;
        int n = sub_arr.size();
        for (int j = 0; j < n; j++)
        {
            right_sum += (int64_t)sub_arr[j] - (int64_t)sub_arr[0];
        }
        sum = left_sum + right_sum;
        for (int j = 1; j < n; j++)
        {
            left_sum += ((long long)sub_arr[j] - (long long)sub_arr[j - 1]) * (long long)j;
            right_sum -= ((long long)sub_arr[j] - (long long)sub_arr[j - 1]) * ((long long)n - (long long)j);
            sum = min(sum, left_sum + right_sum);
        }
        result += sum;
    }
    return result;
}

/// <summary>
/// Leet Code 2609. Find the Longest Balanced Substring of a Binary String
/// 
/// Easy
///	
/// You are given a binary string s consisting only of zeroes and ones.
/// A substring of s is considered balanced if all zeroes are before ones 
/// and the number of zeroes is equal to the number of ones inside the 
/// substring. Notice that the empty substring is considered a balanced 
/// substring.
///
/// Return the length of the longest balanced substring of s.
/// A substring is a contiguous sequence of characters within a string.
/// 
/// Example 1:
///
/// Input: s = "01000111"
/// Output: 6
/// Explanation: The longest balanced substring is "000111", which has 
/// length 6.
///
/// Example 2:
/// Input: s = "00111"
/// Output: 4
/// Explanation: The longest balanced substring is "0011", which has 
/// length 4. 
///
/// Example 3:
/// Input: s = "111"
/// Output: 0
/// Explanation: There is no balanced substring except the empty 
/// substring, so the answer is 0.
/// Constraints:
/// 1. 1 <= s.length <= 50
/// 2. '0' <= s[i] <= '1'
/// </summary>
int LeetCodeArray::findTheLongestBalancedSubstring(string s)
{
    int zeros = 0, ones = 0;
    int result = 0;
    for (size_t i = 0; i < s.size(); i++)
    {
        if (s[i] == '0')
        {
            if (ones != 0)
            {
                ones = 0;
                zeros = 0;
            }
            zeros++;
        }
        else
        {
            ones++;
            if (ones <= zeros)
            {
                result = max(result, 2 * ones);
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2610. Convert an Array Into a 2D Array With Conditions
/// 
/// Medium
///	
/// You are given an integer array nums. You need to create a 2D array 
/// from nums satisfying the following conditions:
/// 
/// The 2D array should contain only the elements of the array nums.
/// Each row in the 2D array contains distinct integers.
/// The number of rows in the 2D array should be minimal.
/// Return the resulting array. If there are multiple answers, return 
/// any of them.
///
/// Note that the 2D array can have a different number of elements on each 
/// row.
///
/// Example 1:
/// Input: nums = [1,3,4,1,2,3,1]
/// Output: [[1,3,4,2],[1,3],[1]]
/// Explanation: We can create a 2D array that contains the following rows:
/// - 1,3,4,2
/// - 1,3
/// - 1
/// All elements of nums were used, and each row of the 2D array contains 
/// distinct integers, so it is a valid answer.
/// It can be shown that we cannot have less than 3 rows in a valid array.
///
/// Example 2:
/// Input: nums = [1,2,3,4]
/// Output: [[4,3,2,1]]
/// Explanation: All elements of the array are distinct, so we can keep 
/// all of them in the first row of the 2D array.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 200
/// 2. 1 <= nums[i] <= nums.length
/// </summary>
vector<vector<int>> LeetCodeArray::findMatrix(vector<int>& nums)
{
    unordered_map<int, int> num_map;
    vector<vector<int>> result;
    for (size_t i = 0; i < nums.size(); i++)
    {
        num_map[nums[i]]++;
        if (num_map[nums[i]] > (int)result.size())
        {
            result.push_back(vector<int>());
        }
        result[num_map[nums[i]] - 1].push_back(nums[i]);
    }
    return result;
}

/// <summary>
/// Leet Code 2612. Minimum Reverse Operations
/// </summary>
pair<int, int> LeetCodeArray::getRange(int x, int n, int k)
{
    int l = max(x - k + 1, 0), r = min(x, n - k);
    int L = 2 * l + k - 1 - x, R = 2 * r + k - 1 - x;
    return { L, R };
};

/// <summary>
/// Leet Code 2612. Minimum Reverse Operations
/// 
/// Hard
///	
/// You are given an integer n and an integer p in the range [0, n - 1]. 
/// Representing a 0-indexed array arr of length n where all positions 
/// are set to 0's, except position p which is set to 1.
/// 
/// You are also given an integer array banned containing some positions 
/// from the array. For the ith position in banned, arr[banned[i]] = 0, 
/// and banned[i] != p.
///
/// You can perform multiple operations on arr. In an operation, you can 
/// choose a subarray with size k and reverse the subarray. However, 
/// the 1 in arr should never go to any of the positions in banned. In 
/// other words, after each operation arr[banned[i]] remains 0.
///
/// Return an array ans where for each i from [0, n - 1], ans[i] is the 
/// minimum number of reverse operations needed to bring the 1 to 
/// position i in arr, or -1 if it is impossible.
///
/// A subarray is a contiguous non-empty sequence of elements within an 
/// array.
/// The values of ans[i] are independent for all i's.
/// The reverse of an array is an array containing the values in reverse 
/// order.
///
/// Example 1:
/// Input: n = 4, p = 0, banned = [1,2], k = 4
/// Output: [0,-1,-1,1]
/// Explanation: In this case k = 4 so there is only one possible reverse 
/// operation we can perform, which is reversing the whole array. 
/// Initially, 1 is placed at position 0 so the amount of operations we 
/// need for position 0 is 0. We can never place a 1 on the banned 
/// positions, so the answer for positions 1 and 2 is -1. Finally, with 
/// one reverse operation we can bring the 1 to index 3, so the answer 
/// for position 3 is 1. 
///
/// Example 2:
/// Input: n = 5, p = 0, banned = [2,4], k = 3
/// Output: [0,-1,-1,-1,-1]
/// Explanation: In this case the 1 is initially at position 0, so the 
/// answer for that position is 0. We can perform reverse operations of 
/// size 3. The 1 is currently located at position 0, so we need to 
/// reverse the subarray [0, 2] for it to leave that position, but 
/// reversing that subarray makes position 2 have a 1, which shouldn't 
/// happen. So, we can't move the 1 from position 0, making the result 
/// for all the other positions -1. 
///
/// Example 3:
///
/// Input: n = 4, p = 2, banned = [0,1,3], k = 1
/// Output: [-1,-1,0,-1]
/// Explanation: In this case we can only perform reverse operations 
/// of size 1. So the 1 never changes its position.
///
///
/// Constraints:
/// 1. 1 <= n <= 10^5
/// 2. 0 <= p <= n - 1
/// 3. 0 <= banned.length <= n - 1
/// 4. 0 <= banned[i] <= n - 1
/// 5. 1 <= k <= n 
/// 6. banned[i] != p
/// 7. all values in banned are unique 
/// </summary>
vector<int> LeetCodeArray::minReverseOperations(int n, int p, vector<int>& banned, int k)
{
    set<int> E[2];
    for (int i = 0; i < n; i++) E[i & 1].insert(i);
    int B = (int)banned.size();
    for (int i = 0; i < B; i++) E[banned[i] & 1].erase(banned[i]);
    vector<int> ans(n, -1);
    queue<int> q;
    q.push(p);
    ans[p] = 0;
    E[p & 1].erase(p);
    while (!q.empty())
    {
        int x = q.front(); q.pop();
        pair<int, int> R = getRange(x, n, k);
        set<int>& cur = E[R.first & 1];
        auto it = cur.lower_bound(R.first);
        while (it != cur.end() && *it <= R.second)
        {
            ans[*it] = ans[x] + 1;
            q.push(*it);
            it = cur.erase(it);
        }
    }
    return ans;
}

/// <summary>
/// Leet Code 2615. Sum of Distances
/// 
/// Medium
///	
/// You are given a 0-indexed integer array nums. There exists an array 
/// arr of length nums.length, where arr[i] is the sum of |i - j| over 
/// all j such that nums[j] == nums[i] and j != i. If there is no such j, 
/// set arr[i] to be 0.
///
/// Return the array arr.
/// Example 1:
/// Input: nums = [1,3,1,1,2]
/// Output: [5,0,3,4,0]
/// Explanation: 
/// When i = 0, nums[0] == nums[2] and nums[0] == nums[3]. Therefore, 
/// arr[0] = |0 - 2| + |0 - 3| = 5. 
/// When i = 1, arr[1] = 0 because there is no other index with value 3.
/// When i = 2, nums[2] == nums[0] and nums[2] == nums[3]. Therefore, 
/// arr[2] = |2 - 0| + |2 - 3| = 3. 
/// When i = 3, nums[3] == nums[0] and nums[3] == nums[2]. Therefore, 
/// arr[3] = |3 - 0| + |3 - 2| = 4. 
/// When i = 4, arr[4] = 0 because there is no other index with value 2. 
///
/// Example 2:
///
/// Input: nums = [0,5,3]
/// Output: [0,0,0]
/// Explanation: Since each element in nums is distinct, arr[i] = 0 for 
/// all i.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 10^9
/// </summary>
vector<long long> LeetCodeArray::distance(vector<int>& nums)
{
    map<int, vector<int>> map_arr;
    for (size_t i = 0; i < nums.size(); i++)
    {
        map_arr[nums[i]].push_back(i);
    }
    vector<long long> result(nums.size(), 0);
    for (auto itr : map_arr)
    {
        vector<int> arr = itr.second;
        vector<long long> left(arr.size(), 0);
        vector<long long> right(arr.size(), 0);
        left[0] = arr[0];
        for (size_t i = 1; i < arr.size(); i++)
        {
            left[i] = left[i - 1] + arr[i];
        }
        right[arr.size() - 1] = arr[arr.size() - 1];
        for (int i = arr.size() - 1; i > 0; i--)
        {
            right[i - 1] = right[i] + arr[i - 1];
        }
        for (size_t i = 0; i < arr.size(); i++)
        {
            result[arr[i]] = (long long)arr[i] * ((long long)i + (long long)1) - 
                (long long)left[i] +
                (long long)right[i] - 
                (long long)arr[i] * ((long long)arr.size() - (long long)i);
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2643. Row With Maximum Ones
/// 
/// Easy
///	
/// Given a m x n binary matrix mat, find the 0-indexed position of the 
/// row that contains the maximum count of ones, and the number of ones 
/// in that row.
///
/// In case there are multiple rows that have the maximum count of ones, 
/// the row with the smallest row number should be selected.
///
/// Return an array containing the index of the row, and the number of 
/// ones in it.
///
/// Example 1:
/// Input: mat = [[0,1],[1,0]]
/// Output: [0,1]
/// Explanation: Both rows have the same number of 1's. So we return the 
/// index of the smaller row, 0, and the maximum count of ones (1). So, 
/// the answer is [0,1]. 
///
/// Example 2:
/// Input: mat = [[0,0,0],[0,1,1]]
/// Output: [1,2]
/// Explanation: The row indexed 1 has the maximum count of ones (2). So 
/// we return its index, 1, and the count. So, the answer is [1,2].
///
/// Example 3:
/// Input: mat = [[0,0],[1,1],[0,0]]
/// Output: [1,2]
/// Explanation: The row indexed 1 has the maximum count of ones (2). So 
/// the answer is [1,2].
///
/// Constraints:
/// 1. m == mat.length 
/// 2. n == mat[i].length 
/// 3. 1 <= m, n <= 100 
/// 4. mat[i][j] is either 0 or 1.
/// </summary>
vector<int> LeetCodeArray::rowAndMaximumOnes(vector<vector<int>>& mat)
{
    vector<int> result = { -1, -1 };
    for (size_t i = 0; i < mat.size(); i++)
    {
        int count = 0;
        for (size_t j = 0; j < mat[0].size(); j++)
        {
            if (mat[i][j] == 1) count++;
        }
        if (count > result[1])
        {
            result[0] = i;
            result[1] = count;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2639. Find the Width of Columns of a Grid
/// 
/// Easy
///	
/// You are given a 0-indexed m x n integer matrix grid. The width of a 
/// column is the maximum length of its integers.
///
/// For example, if grid = [[-10], [3], [12]], the width of the only 
/// column is 3 since -10 is of length 3.
/// Return an integer array ans of size n where ans[i] is the width of 
/// the ith column.
///
/// The length of an integer x with len digits is equal to len if x is 
/// non-negative, and len + 1 otherwise.
/// 
/// Example 1:
/// Input: grid = [[1],[22],[333]]
/// Output: [3]
/// Explanation: In the 0th column, 333 is of length 3.
///
/// Example 2:
/// Input: grid = [[-15,1,3],[15,7,12],[5,6,-2]]
/// Output: [3,1,2]
/// Explanation: 
/// In the 0th column, only -15 is of length 3.
/// In the 1st column, all integers are of length 1. 
/// In the 2nd column, both 12 and -2 are of length 2.
///
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 1 <= m, n <= 100 
/// 4. -10^9 <= grid[r][c] <= 10^9
/// </summary>
vector<int> LeetCodeArray::findColumnWidth(vector<vector<int>>& grid)
{
    vector<int> result(grid[0].size());
    for (size_t i = 0; i < grid.size(); i++)
    {
        for (size_t j = 0; j < grid[0].size(); j++)
        {
            result[j] = max(result[j], (int)to_string(grid[i][j]).size());
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2640. Find the Score of All Prefixes of an Array
/// 
/// Medium
///	
/// We define the conversion array conver of an array arr as follows:
///
/// conver[i] = arr[i] + max(arr[0..i]) where max(arr[0..i]) is the 
/// maximum value of arr[j] over 0 <= j <= i.
/// We also define the score of an array arr as the sum of the values 
/// of the conversion array of arr.
///
/// Given a 0-indexed integer array nums of length n, return an array 
/// ans of length n where ans[i] is the score of the prefix nums[0..i].
///
/// Example 1:
/// Input: nums = [2,3,7,5,10]
/// Output: [4,10,24,36,56]
/// Explanation: 
/// For the prefix [2], the conversion array is [4] hence the score is 4
/// For the prefix [2, 3], the conversion array is [4, 6] hence the 
/// score is 10
/// For the prefix [2, 3, 7], the conversion array is [4, 6, 14] hence 
/// the score is 24
/// For the prefix [2, 3, 7, 5], the conversion array is [4, 6, 14, 12] 
/// hence the score is 36
/// For the prefix [2, 3, 7, 5, 10], the conversion array is [4, 6, 14, 
/// 12, 20] hence the score is 56
///
/// Example 2:
/// Input: nums = [1,1,2,4,8,16]
/// Output: [2,4,8,16,32,64]
/// Explanation: 
/// For the prefix [1], the conversion array is [2] hence the score is 2
/// For the prefix [1, 1], the conversion array is [2, 2] hence the 
/// score is 4
/// For the prefix [1, 1, 2], the conversion array is [2, 2, 4] hence 
/// the score is 8
/// For the prefix [1, 1, 2, 4], the conversion array is [2, 2, 4, 8] 
/// hence the score is 16
/// For the prefix [1, 1, 2, 4, 8], the conversion array is [2, 2, 4, 8, 16] 
/// hence the score is 32
/// For the prefix [1, 1, 2, 4, 8, 16], the conversion array is [2, 2, 4, 8, 
/// 16, 32] hence the score is 64
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^9
/// </summary>
vector<long long> LeetCodeArray::findPrefixScore(vector<int>& nums)
{
    vector<long long> result(nums.size());
    int max_val = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        max_val = max(max_val, nums[i]);
        result[i] = (long long)max_val + (long long)nums[i];
        if (i > 0) result[i] += result[i - 1];
    }
    return result;
}

/// <summary>
/// Leet Code 2660. Determine the Winner of a Bowling Game
/// 
/// Easy
///	
/// You are given two 0-indexed integer arrays player1 and player2, that 
/// represent the number of pins that player 1 and player 2 hit in a 
/// bowling game, respectively.
///
/// The bowling game consists of n turns, and the number of pins in each 
/// turn is exactly 10.
///
/// Assume a player hit xi pins in the ith turn. The value of the ith 
/// turn for the player is:
///
/// 2xi if the player hit 10 pins in any of the previous two turns.
/// Otherwise, It is xi.
/// The score of the player is the sum of the values of their n turns.
///
/// Return
/// 
/// 1 if the score of player 1 is more than the score of player 2,
/// 2 if the score of player 2 is more than the score of player 1, and
/// 0 in case of a draw.
/// 
/// Example 1:
/// Input: player1 = [4,10,7,9], player2 = [6,5,2,3]
/// Output: 1
/// Explanation: The score of player1 is 4 + 10 + 2*7 + 2*9 = 46.
/// The score of player2 is 6 + 5 + 2 + 3 = 16.
/// Score of player1 is more than the score of player2, so, player1 is 
/// the winner, and the answer is 1.
///
/// Example 2:
/// Input: player1 = [3,5,7,6], player2 = [8,10,10,2]
/// Output: 2
/// Explanation: The score of player1 is 3 + 5 + 7 + 6 = 21.
/// The score of player2 is 8 + 10 + 2*10 + 2*2 = 42.
/// Score of player2 is more than the score of player1, so, player2 is 
/// the winner, and the answer is 2.
///
/// Example 3:
/// Input: player1 = [2,3], player2 = [4,1]
/// Output: 0
/// Explanation: The score of player1 is 2 + 3 = 5
/// The score of player2 is 4 + 1 = 5
/// The score of player1 equals to the score of player2, so, there is 
/// a draw, and the answer is 0.
/// 
/// Constraints:
/// 1. n == player1.length == player2.length
/// 2. 1 <= n <= 1000
/// 3. 0 <= player1[i], player2[i] <= 10
/// </summary>
int LeetCodeArray::isWinner(vector<int>& player1, vector<int>& player2)
{
    int sum1 = 0, sum2 = 0;
    for (size_t i = 0; i < player1.size(); i++)
    {
        if (i > 0 && player1[i - 1] == 10)
        {
            sum1 += 2 * player1[i];
        }
        else if (i > 1 && player1[i - 2] == 10)
        {
            sum1 += 2 * player1[i];
        }
        else
        {
            sum1 += player1[i];
        }

        if (i > 0 && player2[i - 1] == 10)
        {
            sum2 += 2 * player2[i];
        }
        else if (i > 1 && player2[i - 2] == 10)
        {
            sum2 += 2 * player2[i];
        }
        else
        {
            sum2 += player2[i];
        }
    }
    if (sum1 > sum2) return 1;
    else if (sum1 < sum2) return 2;
    else return 0;
}

/// <summary>
/// Leet Code 2661. First Completely Painted Row or Column
/// 
/// Medium
///	
/// You are given a 0-indexed integer array arr, and an m x n integer 
/// matrix mat. arr and mat both contain all the integers in the range 
/// [1, m * n].
///
/// Go through each index i in arr starting from index 0 and paint the 
/// cell in mat containing the integer arr[i].
///
/// Return the smallest index i at which either a row or a column will 
/// be completely painted in mat.
/// 
/// Example 1:
/// image explanation for example 1
/// Input: arr = [1,3,4,2], mat = [[1,4],[2,3]]
/// Output: 2
/// Explanation: The moves are shown in order, and both the first row 
/// and second column of the matrix become fully painted at arr[2].
///
/// Example 2:
/// image explanation for example 2
/// Input: arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]
/// Output: 3
/// Explanation: The second column becomes fully painted at arr[3].
///
/// Constraints:
/// 1. m == mat.length
/// 2. n = mat[i].length
/// 3. arr.length == m * n
/// 4. 1 <= m, n <= 10^5
/// 5. 1 <= m * n <= 10^5
/// 6. 1 <= arr[i], mat[r][c] <= m * n
/// 7. All the integers of arr are unique.
/// 8. All the integers of mat are unique.
/// </summary>
int LeetCodeArray::firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat)
{
    int m = mat.size(), n = mat[0].size();
    vector<int> row(m), col(n);
    vector<pair<int, int>> pos(m * n + 1);
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            pos[mat[i][j]].first = i;
            pos[mat[i][j]].second = j;
        }
    }
    for (size_t i = 0; i < arr.size(); i++)
    {
        int val = arr[i];
        row[pos[val].first]++;
        col[pos[val].second]++;
        if (row[pos[val].first] == n) return i;
        if (col[pos[val].second] == m) return i;
    }
    return -1;
}

/// <summary>
/// Leet Code 2684. Maximum Number of Moves in a Grid
/// 
/// Medium
///	
/// You are given a 0-indexed m x n matrix grid consisting of positive 
/// integers.
///
/// You can start at any cell in the first column of the matrix, and 
/// traverse the grid in the following way:
///
/// From a cell (row, col), you can move to any of the cells: 
/// (row - 1, col + 1), (row, col + 1) and (row + 1, col + 1) such that 
/// the value of the cell you move to, should be strictly bigger than 
/// the value of the current cell.
/// Return the maximum number of moves that you can perform.
///
/// Example 1:
/// Input: grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]
/// Output: 3
/// Explanation: We can start at the cell (0, 0) and make the following 
/// moves:
/// - (0, 0) -> (0, 1).
/// - (0, 1) -> (1, 2).
/// - (1, 2) -> (2, 3).
/// It can be shown that it is the maximum number of moves that can be 
/// made.
///
/// Example 2:
/// Input: grid = [[3,2,4],[2,1,9],[1,1,7]]
/// Output: 0
/// Explanation: Starting from any cell in the first column we cannot 
/// perform any moves.
/// 
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 2 <= m, n <= 1000
/// 4. 4 <= m * n <= 10^5
/// 5. 1 <= grid[i][j] <= 10^6
/// </summary>
int LeetCodeArray::maxMoves(vector<vector<int>>& grid)
{
    int m = grid.size();
    int n = grid[0].size();
    vector<vector<int>> visited(m, vector<int>(n));
    for (int i = 0; i < m; i++)
    {
        visited[i][0] = 1;
    }
    int result = 0;
    for (int i = 1; i < n; i++)
    {
        bool reach = false;
        for (int j = 0; j < m; j++)
        {
            int val = grid[j][i];
            if (j > 0 && val > grid[j - 1][i - 1] && visited[j - 1][i - 1] > 0)
            {
                visited[j][i] = 1;
                reach = true;
            }
            if (val > grid[j][i - 1] && visited[j][i - 1] > 0)
            {
                visited[j][i] = 1;
                reach = true;
            }
            if (j < m - 1 && val > grid[j + 1][i - 1] && visited[j + 1][i - 1] > 0)
            {
                visited[j][i] = 1;
                reach = true;
            }
        }
        if (reach == false) break;
        result++;
    }
    return result;
}

/// <summary>
/// Leet Code 2681. Power of Heroes
/// 
/// Hard
///	
/// You are given a 0-indexed integer array nums representing the strength 
/// of some heroes. The power of a group of heroes is defined as follows:
///
/// Let i0, i1, ... ,ik be the indices of the heroes in a group. Then, 
/// the power of this group is max(nums[i0], nums[i1], ... ,nums[ik])^2 * 
/// min(nums[i0], nums[i1], ... ,nums[ik]).
/// Return the sum of the power of all non-empty groups of heroes 
/// possible. Since the sum could be very large, return it modulo 10^9 + 7.
/// Example 1:
/// Input: nums = [2,1,4]
/// Output: 141
/// Explanation: 
/// 1st group: [2] has power = 2^2 * 2 = 8.
/// 2nd group: [1] has power = 1^2 * 1 = 1. 
/// 3rd group: [4] has power = 4^2 * 4 = 64. 
/// 4th group: [2,1] has power = 2^2 * 1 = 4. 
/// 5th group: [2,4] has power = 4^2 * 2 = 32. 
/// 6th group: [1,4] has power = 4^2 * 1 = 16. 
/// 7th group: [2,1,4] has power = 4^2 * 1 = 16. 
/// The sum of powers of all groups is 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141.
///
/// Example 2:
/// Input: nums = [1,1,1]
/// Output: 7
/// Explanation: A total of 7 groups are possible, and the power of each 
/// group will be 1. Therefore, the sum of the powers of all groups is 7.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^9
/// </summary>
int LeetCodeArray::sumOfPower(vector<int>& nums)
{
    int64_t result = 0;
    int64_t mod = (int64_t)1e9 + 7;
    int64_t prev_sum = 0;
    sort(nums.begin(), nums.end());
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (i > 0) prev_sum = ((prev_sum * 2) % mod + nums[i-1]) % mod;
        int64_t s = ((int64_t)nums[i] * (int64_t)nums[i]) % mod;
        int64_t t = prev_sum * s % mod;
        result = (result + s * nums[i] % mod + t) % mod;
    }
    return (int)result;
}

/// <summary>
/// Leet Code 2711. Difference of Number of Distinct Values on Diagonals
/// 
/// Easy
///	
/// Given a 0-indexed 2D grid of size m x n, you should find the matrix 
/// answer of size m x n.
///
/// The value of each cell (r, c) of the matrix answer is calculated in 
/// the following way:
///
/// Let topLeft[r][c] be the number of distinct values in the top-left 
/// diagonal of the cell (r, c) in the matrix grid.
/// Let bottomRight[r][c] be the number of distinct values in the 
/// bottom-right diagonal of the cell (r, c) in the matrix grid. 
/// Then answer[r][c] = |topLeft[r][c] - bottomRight[r][c]|. 
///
/// Return the matrix answer.
///
/// A matrix diagonal is a diagonal line of cells starting from some 
/// cell in either the topmost row or leftmost column and going in 
/// the bottom-right direction until reaching the matrix's end.
///
/// A cell (r1, c1) belongs to the top-left diagonal of the cell (r, c), 
/// if both belong to the same diagonal and r1 < r. Similarly is defined 
/// bottom-right diagonal.
///
/// Example 1:
/// Input: grid = [[1,2,3],[3,1,5],[3,2,1]]
/// Output: [[1,1,0],[1,0,1],[0,1,1]]
/// Explanation: The 1st diagram denotes the initial grid. 
/// The 2nd diagram denotes a grid for cell (0,0), where blue-colored 
/// cells are cells on its bottom-right diagonal.
/// The 3rd diagram denotes a grid for cell (1,2), where red-colored 
/// cells are cells on its top-left diagonal.
/// The 4th diagram denotes a grid for cell (1,1), where blue-colored 
/// cells are cells on its bottom-right diagonal and red-colored cells 
/// are cells on its top-left diagonal.
/// - The cell (0,0) contains [1,1] on its bottom-right diagonal and [] 
/// on its top-left diagonal. The answer is |1 - 0| = 1.
/// - The cell (1,2) contains [] on its bottom-right diagonal and [2] 
/// on its top-left diagonal. The answer is |0 - 1| = 1.
/// - The cell (1,1) contains [1] on its bottom-right diagonal and [1] 
/// on its top-left diagonal. The answer is |1 - 1| = 0.
/// The answers of other cells are similarly calculated.
///
/// Example 2:
///
/// Input: grid = [[1]]
/// Output: [[0]]
/// Explanation: - The cell (0,0) contains [] on its bottom-right diagonal 
/// and [] on its top-left diagonal. The answer is |0 - 0| = 0.
/// 
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 1 <= m, n, grid[i][j] <= 50
/// </summary>
vector<vector<int>> LeetCodeArray::differenceOfDistinctValues(vector<vector<int>>& grid)
{
    int m = grid.size();
    int n = grid[0].size();
    vector<vector<int>> result(m, vector<int>(n));
    vector<unordered_map<int, int>>left(m + n), right(m + n);
    for (int r = 0; r < m; r++)
    {
        for (int c = 0; c < n; c++)
        {
            right[r - c + n][grid[r][c]]++;
        }
    }

    for (int r = 0; r < m; r++)
    {
        for (int c = 0; c < n; c++)
        {
            right[r - c + n][grid[r][c]]--;
            if (right[r - c + n][grid[r][c]] == 0)
            {
                right[r - c + n].erase(grid[r][c]);
            }
            result[r][c] = abs((int)(left[r - c + n].size()) -
                (int)(right[r - c + n].size()));
            left[r - c + n][grid[r][c]]++;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2717. Semi-Ordered Permutation
/// 
/// Easy
///
/// You are given a 0-indexed permutation of n integers nums.
///
/// A permutation is called semi-ordered if the first number 
/// equals 1 and the last number equals n. You can perform the 
/// below operation as many times as you want until you make 
/// nums a semi-ordered permutation:
///
/// Pick two adjacent elements in nums, then swap them.
/// Return the minimum number of operations to make nums a 
/// semi-ordered permutation.
///
/// A permutation is a sequence of integers from 1 to n of 
/// length n containing each number exactly once.  
///
/// Example 1:
///
/// Input: nums = [2,1,4,3]
/// Output: 2
/// Explanation: We can make the permutation semi-ordered using these 
/// sequence of operations: 
/// 1 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].
/// 2 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].
/// It can be proved that there is no sequence of less than two 
/// operations that make nums a semi-ordered permutation. 
///
/// Example 2:
/// Input: nums = [2,4,1,3]
/// Output: 3
/// Explanation: We can make the permutation semi-ordered using these 
/// sequence of operations:
/// 1 - swap i = 1 and j = 2. The permutation becomes [2,1,4,3].
/// 2 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].
/// 3 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].
/// It can be proved that there is no sequence of less than three 
/// operations that make nums a semi-ordered permutation.
///
/// Example 3:
/// Input: nums = [1,3,4,2,5]
/// Output: 0
/// Explanation: The permutation is already a semi-ordered permutation.
/// 
/// Constraints:
/// 1. 2 <= nums.length == n <= 50
/// 2. 1 <= nums[i] <= 50
/// 3. nums is a permutation.
/// </summary>
int LeetCodeArray::semiOrderedPermutation(vector<int>& nums)
{
    int first = 0, last = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] == 1) first = i;
        if (nums[i] == nums.size()) last = i;
    }
    int result = first + nums.size() - 1 - last;
    if (last < first) result--;
    return result;
}

/// <summary>
/// Leet Code 2718. Sum of Matrix After Queries
/// 
/// Medium
///
/// You are given an integer n and a 0-indexed 2D array queries where 
/// queries[i] = [typei, indexi, vali].
///
/// Initially, there is a 0-indexed n x n matrix filled with 0's. For 
/// each query, you must apply one of the following changes:
///
/// if typei == 0, set the values in the row with indexi to vali, 
/// overwriting any previous values.
/// if typei == 1, set the values in the column with indexi to vali, 
/// overwriting any previous values.
/// Return the sum of integers in the matrix after all queries are applied.
///
/// Example 1:
/// Input: n = 3, queries = [[0,0,1],[1,2,2],[0,2,3],[1,0,4]]
/// Output: 23
/// Explanation: The image above describes the matrix after each query. 
/// The sum of the matrix after all queries are applied is 23. 
///
/// Example 2:
/// Input: n = 3, queries = [[0,0,4],[0,1,2],[1,0,1],[0,2,3],[1,2,1]]
/// Output: 17
/// Explanation: The image above describes the matrix after each query. 
/// The sum of the matrix after all queries are applied is 17.
/// 
/// Constraints:
/// 1. 1 <= n <= 10^4
/// 2. 1 <= queries.length <= 5 * 10^4
/// 3. queries[i].length == 3
/// 4. 0 <= typei <= 1
/// 5. 0 <= indexi < n
/// 6. 0 <= vali <= 10^5
/// </summary>
long long LeetCodeArray::matrixSumQueries(int n, vector<vector<int>>& queries)
{
    vector<vector<int>> visited(2, vector<int>(n));
    vector<int>count(2);
    long long result = 0;
    for (int i = queries.size() - 1; i >= 0; i--)
    {
        int type = queries[i][0];
        int index = queries[i][1];
        int value = queries[i][2];
        if (visited[type][index] == 1) continue;
        visited[type][index] = 1;
        result = result + ((long long)n - (long long)count[1 - type]) * (long long)value;
        count[type]++;
    }
    return result;
}

/// <summary>
/// Leet Code 2733. Neither Minimum nor Maximum
/// 
/// Easy
///
/// Given an integer array nums containing distinct positive integers, 
/// find and return any number from the array that is neither the 
/// minimum nor the maximum value in the array, or -1 if there is no 
/// such number.
///
/// Return the selected integer.
/// 
/// Example 1:
/// Input: nums = [3,2,1,4]
/// Output: 2
/// Explanation: In this example, the minimum value is 1 and the maximum 
/// value is 4. Therefore, either 2 or 3 can be valid answers.
///
/// Example 2:
/// Input: nums = [1,2]
/// Output: -1
/// Explanation: Since there is no number in nums that is neither the 
/// maximum nor the minimum, we cannot select a number that satisfies 
/// the given condition. Therefore, there is no answer.
///
/// Example 3:
/// Input: nums = [2,1,3]
/// Output: 2
/// Explanation: Since 2 is neither the maximum nor the minimum value in 
/// nums, it is the only valid answer. 
///
/// Constraints:
/// 1. 1 <= nums.length <= 100
/// 2. 1 <= nums[i] <= 100
/// 3. All values in nums are distinct
/// </summary>
int LeetCodeArray::findNonMinOrMax(vector<int>& nums)
{
    int min_val = INT_MAX;
    int max_val = INT_MIN;
    for (size_t i = 0; i < nums.size(); i++)
    {
        min_val = min(min_val, nums[i]);
        max_val = max(max_val, nums[i]);
    }
    int result = -1;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] > min_val && nums[i] < max_val)
        {
            result = nums[i];
            break;
        }
    }
    return result;
}
/// <summary>
/// Leet Code 2728. Count Houses in a Circular Street
/// 
/// Easy
///
/// You are given an object street of class Street that represents a 
/// circular street and a positive integer k which represents a 
/// maximum bound for the number of houses in that street (in other 
/// words, the number of houses is less than or equal to k). Houses' 
/// doors could be open or closed initially.
///
/// Initially, you are standing in front of a door to a house on this 
/// street. Your task is to count the number of houses in the street.
///
/// The class Street contains the following functions which may help you:
///
/// void openDoor(): Open the door of the house you are in front of.
/// void closeDoor(): Close the door of the house you are in front of.
/// boolean isDoorOpen(): Returns true if the door of the current house 
/// is open and false otherwise.
/// void moveRight(): Move to the right house.
/// void moveLeft(): Move to the left house.
/// Return ans which represents the number of houses on this street.
///  
/// Example 1:
/// Input: street = [0,0,0,0], k = 10
/// Output: 4
/// Explanation: There are 4 houses, and all their doors are closed. 
/// The number of houses is less than k, which is 10.
///
/// Example 2:
/// Input: street = [1,0,1,1,0], k = 5
/// Output: 5
/// Explanation: There are 5 houses, and the doors of the 1st, 3rd, 
/// and 4th house (moving in the right direction) are open, and the 
/// rest are closed.
/// The number of houses is equal to k, which is 5.
///
/// Constraints:
/// 1. n == number of houses
/// 2. 1 <= n <= k <= 10^3
/// </summary>
int LeetCodeArray::houseCount(Street* street, int k)
{
    for (int i = 0; i < k; i++)
    {
        street->closeDoor();
        street->moveRight();
    }
    int result = 0;
    for (int i = 0; i < k; i++)
    {
        if (street->isDoorOpen()) return result;
        result++;
        street->openDoor();
        street->moveRight();
    }
    return result;
}

/// <summary>
/// Leet Code 2731. Movement of Robots
/// 
/// Medium
///
/// Some robots are standing on an infinite number line with their initial 
/// coordinates given by a 0-indexed integer array nums and will start 
/// moving once given the command to move. The robots will move a unit 
/// distance each second.
///
/// You are given a string s denoting the direction in which robots will 
/// move on command. 'L' means the robot will move towards the left side 
/// or negative side of the number line, whereas 'R' means the robot 
/// will move towards the right side or positive side of the number line.
///
/// If two robots collide, they will start moving in opposite directions.
///
/// Return the sum of distances between all the pairs of robots d seconds 
/// after the command. Since the sum can be very large, return it 
/// modulo 10^9 + 7.
///
/// Note:
/// For two robots at the index i and j, pair (i,j) and pair (j,i) are 
/// considered the same pair.
/// When robots collide, they instantly change their directions without 
/// wasting any time.
/// Collision happens when two robots share the same place in a moment.
/// For example, if a robot is positioned in 0 going to the right and 
/// another is positioned in 2 going to the left, the next second they'll 
/// be both in 1 and they will change direction and the next second the 
/// first one will be in 0, heading left, and another will be in 2, 
/// heading right.
/// For example, if a robot is positioned in 0 going to the right and 
/// another is positioned in 1 going to the left, the next second the 
/// first one will be in 0, heading left, and another will be in 1, 
/// heading right.
///
/// Example 1:
/// Input: nums = [-2,0,2], s = "RLL", d = 3
/// Output: 8
/// Explanation: 
/// After 1 second, the positions are [-1,-1,1]. Now, the robot at 
/// index 0 will move left, and the robot at index 1 will move right.
/// After 2 seconds, the positions are [-2,0,0]. Now, the robot at index 1 
/// will move left, and the robot at index 2 will move right.
/// After 3 seconds, the positions are [-3,-1,1].
/// The distance between the robot at index 0 and 1 is abs(-3 - (-1)) = 2.
/// The distance between the robot at index 0 and 2 is abs(-3 - 1) = 4.
/// The distance between the robot at index 1 and 2 is abs(-1 - 1) = 2.
/// The sum of the pairs of all distances = 2 + 4 + 2 = 8.
///
/// Example 2:
/// Input: nums = [1,0], s = "RL", d = 2
/// Output: 5
/// Explanation: 
/// After 1 second, the positions are [2,-1].
/// After 2 seconds, the positions are [3,-2].
/// The distance between the two robots is abs(-2 - 3) = 5.
///
/// Constraints:
/// 1. 2 <= nums.length <= 10^5
/// 2. -2 * 10^9 <= nums[i] <= 2 * 10^9
/// 3. 0 <= d <= 10^9
/// 4. nums.length == s.length 
/// 5. s consists of 'L' and 'R' only
/// 6. nums[i] will be unique.
/// </summary>
int LeetCodeArray::sumDistance(vector<int>& nums, string s, int d)
{
    long long M = 1000000007;
    long long result = 0;
    vector<long long> pos;
    for (size_t i = 0; i < nums.size(); i++)
    {
        pos.push_back((long long)nums[i] + (long long)d * (s[i] == 'L' ? -1 : 1));
    }
    sort(pos.begin(), pos.end());
    long long sum = 0;
    for (size_t i = 1; i < pos.size(); i++)
    {
        sum += (pos[i] - pos[i - 1]) * (long long)i;
        sum %= M;
        result += sum;
        result = result % M;
    }
    return (int)result;
}

/// <summary>
/// Leet Code 	2735. Collecting Chocolates
/// 
/// Medium
///
/// You are given a 0-indexed integer array nums of size n representing 
/// the cost of collecting different chocolates. The cost of collecting 
/// the chocolate at the index i is nums[i]. Each chocolate is of a 
/// different type, and initially, the chocolate at the index i is of 
/// ith type.
///
/// In one operation, you can do the following with an incurred cost of x:
/// 
/// Simultaneously change the chocolate of ith type to ((i + 1) mod n)th 
/// type for all chocolates.
/// Return the minimum cost to collect chocolates of all types, given that 
/// you can perform as many operations as you would like.
///
/// Example 1:
/// Input: nums = [20,1,15], x = 5
/// Output: 13
/// Explanation: Initially, the chocolate types are [0,1,2]. We will buy 
/// the 1st type of chocolate at a cost of 1.
/// Now, we will perform the operation at a cost of 5, and the types of 
/// chocolates will become [1,2,0]. We will buy the 2nd type of chocolate 
/// at a cost of 1.
/// Now, we will again perform the operation at a cost of 5, and the 
/// chocolate types will become [2,0,1]. We will buy the 0th type of 
/// chocolate at a cost of 1. 
/// Thus, the total cost will become (1 + 5 + 1 + 5 + 1) = 13. We can 
/// prove that this is optimal.
///
/// Example 2:
/// Input: nums = [1,2,3], x = 4
/// Output: 6
/// Explanation: We will collect all three types of chocolates at their 
/// own price without performing any operations. Therefore, the total 
/// cost is 1 + 2 + 3 = 6.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 1000
/// 2. 1 <= nums[i] <= 10^9
/// 3. 1 <= x <= 10^9
/// </summary>
long long LeetCodeArray::minCost(vector<int>& nums, int x)
{
    int n = nums.size();
    vector<int> cost = nums;
    long long sum = 0;
    int count = 0;
    for (int i = 0; i < n; i++)
    {
        sum += nums[i];
    }
    long long result = sum;
    for (int i = 0; i < n; i++)
    {
        count++;
        int val = cost[0];
        for (int j = 0; j < n - 1; j++)
        {
            if (cost[j] > cost[j + 1])
            {
                sum -= (long long)cost[j] - (long long)cost[j + 1];
                cost[j] = cost[j + 1];
            }
        }
        if (cost[n - 1] > val)
        {
            sum -= (long long)cost[n-1] - (long long)val;
            cost[n-1] = val;
        }
        result = min(result, sum + (long long)count * x);
    }
    return result;
}

/// <summary>
/// Leet Code 2750. Ways to Split Array Into Good Subarrays
/// 
/// Medium
///
/// You are given a binary array nums.
///
/// A subarray of an array is good if it contains exactly one element 
/// with the value 1.
///
/// Return an integer denoting the number of ways to split the array 
/// nums into good subarrays. As the number may be too large, return 
/// it modulo 10^9 + 7.
///
/// A subarray is a contiguous non-empty sequence of elements within 
/// an array.
/// 
/// Example 1:
/// Input: nums = [0,1,0,0,1]
/// Output: 3
/// Explanation: There are 3 ways to split nums into good subarrays:
/// - [0,1] [0,0,1]
/// - [0,1,0] [0,1]
/// - [0,1,0,0] [1]
///
/// Example 2:
/// Input: nums = [0,1,0]
/// Output: 1
/// Explanation: There is 1 way to split nums into good subarrays:
/// - [0,1,0]
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 1
/// </summary>
int LeetCodeArray::numberOfGoodSubarraySplits(vector<int>& nums)
{
    long long M = 1000000007;
    int prev = -1;
    int n = nums.size();
    long long result = 0;
    for (int i = 0; i < n; i++)
    {
        if (nums[i] == 1)
        {
            if (prev == -1) result = 1;
            else result = result * ((long long)i - (long long)prev) % M;
            prev = i;
        }
    }
    return (int)result;
}

/// <summary>
/// Leet Code 2760. Longest Even Odd Subarray With Threshold
/// 
/// Easy
/// 
/// You are given a 0-indexed integer array nums and an integer threshold.
///
/// Find the length of the longest subarray of nums starting at index l 
/// and ending at index r (0 <= l <= r < nums.length) that satisfies the 
/// following conditions:
///
/// nums[l] % 2 == 0
/// For all indices i in the range [l, r - 1], 
/// nums[i] % 2 != nums[i + 1] % 2
/// For all indices i in the range [l, r], nums[i] <= threshold
/// Return an integer denoting the length of the longest such subarray.
///
/// Note: A subarray is a contiguous non-empty sequence of elements 
/// within an array.
///
/// Example 1:
/// Input: nums = [3,2,5,4], threshold = 5
/// Output: 3
/// Explanation: In this example, we can select the subarray that 
/// starts at l = 1 and ends at r = 3 => [2,5,4]. This subarray satisfies 
/// the conditions.
/// Hence, the answer is the length of the subarray, 3. We can show 
/// that 3 is the maximum possible achievable length.
///
/// Example 2:
/// Input: nums = [1,2], threshold = 2
/// Output: 1
/// Explanation: In this example, we can select the subarray that starts 
/// at l = 1 and ends at r = 1 => [2]. 
/// It satisfies all the conditions and we can show that 1 is the maximum 
/// possible achievable length.
///
/// Example 3:
/// Input: nums = [2,3,4,5], threshold = 4
/// Output: 3
/// Explanation: In this example, we can select the subarray that starts 
/// at l = 0 and ends at r = 2 => [2,3,4]. 
/// It satisfies all the conditions.
/// Hence, the answer is the length of the subarray, 3. We can show 
/// that 3 is the maximum possible achievable length.
///
/// Constraints:
/// 1. 1 <= nums.length <= 100 
/// 2. 1 <= nums[i] <= 100 
/// 3. 1 <= threshold <= 100
/// </summary>
int LeetCodeArray::longestAlternatingSubarray(vector<int>& nums, int threshold)
{
    int result = 0;
    int count = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] > threshold)
        {
            count = 0;
            continue;
        }
        if ((nums[i] % 2) == (count % 2))
        {
            count++;
        }
        else if (nums[i] % 2 == 1)
        {
            count = 0;
        }
        else
        {
            count = 1;
        }
        result = max(result, count);
    }
    return result;
}

/// <summary>
/// Leet Code 2753. Count Houses in a Circular Street II
/// 
/// Hard
///
/// You are given an object street of class Street that represents a 
/// circular street and a positive integer k which represents a 
/// maximum bound for the number of houses in that street (in other 
/// words, the number of houses is less than or equal to k). Houses' 
/// doors could be open or closed initially (at least one is open).
///
/// Initially, you are standing in front of a door to a house on this 
/// street. Your task is to count the number of houses in the street.
///
/// The class Street contains the following functions which may help you:
///
/// void closeDoor(): Close the door of the house you are in front of.
/// boolean isDoorOpen(): Returns true if the door of the current house 
/// is open and false otherwise.
/// void moveRight(): Move to the right house.
/// Note that by circular street, we mean if you number the houses from 1 
/// to n, then the right house of housei is housei+1 for i < n, and the 
/// right house of housen is house1.
///
/// Return ans which represents the number of houses on this street.
///
/// Example 1:
/// Input: street = [1,1,1,1], k = 10
/// Output: 4
/// Explanation: There are 4 houses, and all their doors are open. 
/// The number of houses is less than k, which is 10.
///
/// Example 2:
/// Input: street = [1,0,1,1,0], k = 5
/// Output: 5
/// Explanation: There are 5 houses, and the doors of the 1st, 3rd, and 
/// 4th house (moving in the right direction) are open, and the rest 
/// are closed.
/// The number of houses is equal to k, which is 5.
/// 
/// Constraints:
/// 1. n == number of houses
/// 2. 1 <= n <= k <= 10^5
/// 3. street is circular by definition provided in the statement.
/// 4. The input is generated such that at least one of the doors is open.
/// </summary>
int LeetCodeArray::houseCountII(Street* street, int k)
{
    while (!street->isDoorOpen()) street->moveRight();
    street->moveRight();
    int result = 0;
    int count = 0;
    while (count < k)
    {
        count++;
        if (street->isDoorOpen())
        {
            result = count;
            street->closeDoor();
        }
        street->moveRight();
    }
    return result;
}

/// <summary>
/// Leet Code 2765. Longest Alternating Subarray
/// 
/// Easy
///
/// You are given a 0-indexed integer array nums. A subarray s of length 
/// m is called alternating if:
///
/// m is greater than 1.
/// s1 = s0 + 1.
/// The 0-indexed subarray s looks like [s0, s1, s0, s1,...,s(m-1) % 2]. In
/// other words, s1 - s0 = 1, s2 - s1 = -1, s3 - s2 = 1, s4 - s3 = -1, and 
/// so on up to s[m - 1] - s[m - 2] = (-1)m.
/// Return the maximum length of all alternating subarrays present in 
/// nums or -1 if no such subarray exists.
///
/// A subarray is a contiguous non-empty sequence of elements within an 
/// array.
///
/// Example 1:
/// Input: nums = [2,3,4,3,4]
/// Output: 4
/// Explanation: The alternating subarrays are [3,4], [3,4,3], and 
/// [3,4,3,4]. The longest of these is [3,4,3,4], which is of length 4.
///
/// Example 2:
///
/// Input: nums = [4,5,6]
/// Output: 2
/// Explanation: [4,5] and [5,6] are the only two alternating subarrays. 
/// They are both of length 2.
///
///
/// Constraints:
/// 1. 2 <= nums.length <= 100
/// 2. 1 <= nums[i] <= 10^4
/// </summary>
int LeetCodeArray::alternatingSubarray(vector<int>& nums)
{
    int result = -1;
    int count = 0;
    int prev = -1;
    for (size_t i = 1; i < nums.size(); i++)
    {
        if (nums[i] == nums[i - 1] + 1)
        {
            if (prev == -1)
            {
                count++;
            }
            else
            {
                count = 1;
            }
            prev = 1;
        }
        else if (nums[i] == nums[i - 1] - 1)
        {
            if (prev == 1)
            {
                count++;
            }
            else
            {
                count = 0;
            }
            prev = -1;
        }
        else
        {
            count = 0;
            prev = -1;
        }
        if (count > 0)  result = max(result, count + 1);
    }
    return result;
}

/// <summary>
/// Leet Code 2768. Number of Black Blocks
/// 
/// Medium
///
/// You are given two integers m and n representing the dimensions of a 
/// 0-indexed m x n grid.
///
/// You are also given a 0-indexed 2D integer matrix coordinates, where 
/// coordinates[i] = [x, y] indicates that the cell with coordinates 
/// [x, y] is colored black. All cells in the grid that do not appear 
/// in coordinates are white.
///
/// A block is defined as a 2 x 2 submatrix of the grid. More 
/// formally, a block with cell [x, y] as its top-left corner 
/// where 0 <= x < m - 1 and 0 <= y < n - 1 contains the coordinates 
/// [x, y], [x + 1, y], [x, y + 1], and [x + 1, y + 1].
///
/// Return a 0-indexed integer array arr of size 5 such that arr[i] 
/// is the number of blocks that contains exactly i black cells.
///
/// Example 1:
/// Input: m = 3, n = 3, coordinates = [[0,0]]
/// Output: [3,1,0,0,0]
/// Explanation: The grid looks like this:
/// 
/// There is only 1 block with one black cell, and it is the block 
/// starting with cell [0,0].
/// The other 3 blocks start with cells [0,1], [1,0] and [1,1]. They all 
/// have zero black cells.  
/// Thus, we return [3,1,0,0,0]. 
///
/// Example 2:
/// Input: m = 3, n = 3, coordinates = [[0,0],[1,1],[0,2]]
/// Output: [0,2,2,0,0]
/// Explanation: The grid looks like this:
/// There are 2 blocks with two black cells (the ones starting with cell 
/// coordinates [0,0] and [0,1]).
/// The other 2 blocks have starting cell coordinates of [1,0] and [1,1]. 
/// They both have 1 black cell.
/// Therefore, we return [0,2,2,0,0].
///  
/// Constraints:
/// 1. 2 <= m <= 10^5
/// 2. 2 <= n <= 10^5
/// 3. 0 <= coordinates.length <= 10^4
/// 4. coordinates[i].length == 2
/// 5. 0 <= coordinates[i][0] < m
/// 6. 0 <= coordinates[i][1] < n
/// 7. It is guaranteed that coordinates contains pairwise distinct 
///    coordinates.
/// </summary>
vector<long long> LeetCodeArray::countBlackBlocks(int m, int n, vector<vector<int>>& coordinates)
{
    unordered_map<int, unordered_map<int, int>> matrix;
    for (size_t i = 0; i < coordinates.size(); i++)
    {
        int x = coordinates[i][0];
        int y = coordinates[i][1];
        matrix[x][y]++;
        if (x > 0) matrix[x - 1][y]++;
        if (y > 0) matrix[x][y - 1]++;
        if (x > 0 && y > 0) matrix[x - 1][y - 1]++;
    }
    vector<long long> result(5);
    for (auto& itr_1 : matrix)
    {
        int x = itr_1.first;
        for (auto& itr2 : matrix[x])
        {
            int y = itr2.first;
            int z = itr2.second;
            if (z > 4) continue;
            if (x < m - 1 && y < n - 1)
            {
                result[z]++;
            }
        }
    }
    result[0] = ((long long)m - 1LL) * ((long long)n - 1LL);
    for (int i = 1; i < 5; i++)
    {
        result[0] -= result[i];
    }
    return result;
}
/// <summary>
/// Leet Code 2780. Minimum Index of a Valid Split
/// 
/// Medium
///
/// An element x of an integer array arr of length m is dominant if 
/// freq(x) * 2 > m, where freq(x) is the number of occurrences of x 
/// in arr. Note that this definition implies that arr can have at 
/// most one dominant element.
///
/// You are given a 0-indexed integer array nums of length n with one 
/// dominant element.
///
/// You can split nums at an index i into two arrays nums[0, ..., i] and 
/// nums[i + 1, ..., n - 1], but the split is only valid if:
///
/// 0 <= i < n - 1
/// nums[0, ..., i], and nums[i + 1, ..., n - 1] have the same dominant 
/// element.
/// Here, nums[i, ..., j] denotes the subarray of nums starting at index i 
/// and ending at index j, both ends being inclusive. Particularly, 
/// if j < i then nums[i, ..., j] denotes an empty subarray.
///
/// Return the minimum index of a valid split. If no valid split exists, 
/// return -1.
///
/// Example 1:
/// Input: nums = [1,2,2,2]
/// Output: 2
/// Explanation: We can split the array at index 2 to obtain 
/// arrays [1,2,2] and [2]. 
/// In array [1,2,2], element 2 is dominant since it occurs twice in the 
/// array and 2 * 2 > 3. 
/// In array [2], element 2 is dominant since it occurs once in the array 
/// and 1 * 2 > 1.
/// Both [1,2,2] and [2] have the same dominant element as nums, so this 
/// is a valid split. 
/// It can be shown that index 2 is the minimum index of a valid split. 
///
/// Example 2:
/// Input: nums = [2,1,3,1,1,1,7,1,2,1]
/// Output: 4
/// Explanation: We can split the array at index 4 to obtain arrays 
/// [2,1,3,1,1] and [1,7,1,2,1].
/// In array [2,1,3,1,1], element 1 is dominant since it occurs thrice in 
/// the array and 3 * 2 > 5.
/// In array [1,7,1,2,1], element 1 is dominant since it occurs thrice in 
/// the array and 3 * 2 > 5.
/// Both [2,1,3,1,1] and [1,7,1,2,1] have the same dominant element as 
/// nums, so this is a valid split.
/// It can be shown that index 4 is the minimum index of a valid split.
///
/// Example 3:
/// Input: nums = [3,3,3,3,7,2,2]
/// Output: -1
/// Explanation: It can be shown that there is no valid split.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^9
/// 3. nums has exactly one dominant element.
/// </summary>
int LeetCodeArray::minimumIndex(vector<int>& nums)
{
    int n = nums.size();
    unordered_map<int, int> num_count;
    for (auto x : nums) num_count[x]++;
    int val = 0;
    int count = 0;
    for (auto itr : num_count)
    {
        if (itr.second * 2 > n)
        {
            val = itr.first;
            count = itr.second;
            break;
        }
    }
    int left = 0;
    for (int i = 1; i <= n; i++)
    {
        if (nums[i-1] == val) left++;
        if (left * 2 > i && (count - left) * 2 > (n - i))
        {
            return i - 1;

        }
    }
    return -1;
}

/// <summary>
/// Leet Code 2772. Apply Operations to Make All Array Elements Equal to 
///                 Zero
/// 
/// Medium
///
/// You are given a 0-indexed integer array nums and a positive integer k.
///
/// You can apply the following operation on the array any number of times:
/// 
/// Choose any subarray of size k from the array and decrease all its 
/// elements by 1.
/// Return true if you can make all the array elements equal to 0, or false 
/// otherwise.
///
/// A subarray is a contiguous non-empty part of an array.
///
/// Example 1:
/// Input: nums = [2,2,3,1,1,0], k = 3
/// Output: true
/// Explanation: We can do the following operations:
/// - Choose the subarray [2,2,3]. The resulting array will be 
///   nums = [1,1,2,1,1,0].
/// - Choose the subarray [2,1,1]. The resulting array will be 
///   nums = [1,1,1,0,0,0].
/// - Choose the subarray [1,1,1]. The resulting array will be 
///   nums = [0,0,0,0,0,0].
//
/// Example 2:
/// Input: nums = [1,3,1,1], k = 2
/// Output: false
/// Explanation: It is not possible to make all the array 
/// elements equal to 0.
/// 
/// Constraints:
/// 1. 1 <= k <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 10^6
/// </summary>
bool LeetCodeArray::checkArray(vector<int>& nums, int k)
{
    int sum = 0;
    vector<int> delta(nums.size());
    int n = nums.size();
    for (int i = 0; i < (int)nums.size(); i++)
    {
        if (i >= k) sum -= delta[i - k];
        if (nums[i] < sum) return false;
        if (nums[i] > sum && n - i < k) return false;
        delta[i] = nums[i] - sum;
        sum = nums[i];
    }
    return true;
}
/// <summary>
/// Leet Code 2782. Number of Unique Categories
/// 
/// Medium
///
/// You are given an integer n and an object categoryHandler of class 
/// CategoryHandler.
///
/// There are nelements, numbered from 0 to n - 1. Each element has a 
/// category, and your task is to find the number of unique categories.
///
/// The class CategoryHandler contains the following function, which may 
/// help you:
///
/// boolean haveSameCategory(integer a, integer b): Returns true if a and 
/// b are in the same category and false otherwise. Also, if either a or 
/// b is not a valid number (i.e. it's greater than or equal to nor less 
/// than 0), it returns false.
/// Return the number of unique categories.
/// 
/// Example 1:
/// Input: n = 6, catagoryHandler = [1,1,2,2,3,3]
/// Output: 3
/// Explanation: There are 6 elements in this example. The first two 
/// elements belong to category 1, the second two belong to category 2, 
/// and the last two elements belong to category 3. So there are 3 unique 
/// categories.
///
/// Example 2:
/// Input: n = 5, catagoryHandler = [1,2,3,4,5]
/// Output: 5
/// Explanation: There are 5 elements in this example. Each element 
/// belongs to a unique category. So there are 5 unique categories.
///
/// Example 3:
/// Input: n = 3, catagoryHandler = [1,1,1]
/// Output: 1
/// Explanation: There are 3 elements in this example. All of them belong 
/// to one category. So there is only 1 unique category.
///
///
/// Constraints:
/// 1. 1 <= n <= 100
/// </summary>
int LeetCodeArray::numberOfCategories(int n, vector<int>& categoryHandler)
{
    vector<int> arr;
    for (int i = 0; i < n; i++)
    {
        bool same = false;
        for (size_t j = 0; j < arr.size(); j++)
        {
            if (categoryHandler[arr[j]] == categoryHandler[i])
            {
                same = true;
                break;
            }
        }
        if (same == false) arr.push_back(i);
    }
    return arr.size();
}

/// <summary>
/// Leet Code 2784. Check if Array is Good
/// 
/// Easy
///
/// You are given an integer array nums. We consider an array good if it 
/// is a permutation of an array base[n].
///
/// base[n] = [1, 2, ..., n - 1, n, n] (in other words, it is an array 
/// of length n + 1 which contains 1 to n - 1 exactly once, plus two 
/// occurrences of n). For example, base[1] = [1, 1] and 
/// base[3] = [1, 2, 3, 3].
///
/// Return true if the given array is good, otherwise return false.
///
/// Note: A permutation of integers represents an arrangement of these 
/// numbers.
///
/// Example 1:
/// Input: nums = [2, 1, 3]
/// Output: false
/// Explanation: Since the maximum element of the array is 3, the only 
/// candidate n for which this array could be a permutation of base[n], 
/// is n = 3. However, base[3] has four elements but array nums has 
/// three. Therefore, it can not be a permutation of base[3] = 
/// [1, 2, 3, 3]. So the answer is false.
///
/// Example 2:
/// Input: nums = [1, 3, 3, 2]
/// Output: true
/// Explanation: Since the maximum element of the array is 3, the only 
/// candidate n for which this array could be a permutation of base[n], 
/// is n = 3. It can be seen that nums is a permutation of base[3] = 
/// [1, 2, 3, 3] (by swapping the second and fourth elements in nums, 
/// we reach base[3]). Therefore, the answer is true.
///
/// Example 3:
/// Input: nums = [1, 1]
/// Output: true
/// Explanation: Since the maximum element of the array is 1, the only 
/// candidate n for which this array could be a permutation of base[n], 
/// is n = 1. It can be seen that nums is a permutation of 
/// base[1] = [1, 1]. Therefore, the answer is true.
///
/// Example 4:
/// Input: nums = [3, 4, 4, 1, 2, 1]
/// Output: false
/// Explanation: Since the maximum element of the array is 4, the only 
/// candidate n for which this array could be a permutation of base[n], 
/// is n = 4. However, base[4] has five elements but array nums has six. 
/// Therefore, it can not be a permutation of base[4] = [1, 2, 3, 4, 4]. 
/// So the answer is false.
///
/// Constraints:
/// 1. 1 <= nums.length <= 100
/// 2. 1 <= num[i] <= 200
/// </summary>
bool LeetCodeArray::isGood(vector<int>& nums)
{
    vector<int> dp(201);
    for (int x : nums) dp[x]++;
    int n = nums.size() - 1;
    for (int i = 1; i < n; i++)
    {
        if (dp[i] != 1) return false;
    }
    if (dp[n] != 2) return false;
    return true;
}

/// <summary>
/// Leet Code 2789. Largest Element in an Array after Merge Operations
/// 
/// Medium
///
/// You are given a 0-indexed array nums consisting of positive integers.
///
/// You can do the following operation on the array any number of times:
///
/// Choose an integer i such that 0 <= i < nums.length - 1 and 
/// nums[i] <= nums[i + 1]. Replace the element nums[i + 1] with 
/// nums[i] + nums[i + 1] and delete the element nums[i] from the array.
/// Return the value of the largest element that you can possibly obtain 
/// in the final array.
///
/// Example 1:
/// Input: nums = [2,3,7,9,3]
/// Output: 21
/// Explanation: We can apply the following operations on the array:
/// - Choose i = 0. The resulting array will be nums = [5,7,9,3].
/// - Choose i = 1. The resulting array will be nums = [5,16,3].
/// - Choose i = 0. The resulting array will be nums = [21,3].
/// The largest element in the final array is 21. It can be shown that 
/// we cannot obtain a larger element.
///
/// Example 2:
/// Input: nums = [5,3,3]
/// Output: 11
/// Explanation: We can do the following operations on the array:
/// - Choose i = 1. The resulting array will be nums = [5,6].
/// - Choose i = 0. The resulting array will be nums = [11].
/// There is only one element in the final array, which is 11.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^6
/// </summary>
long long LeetCodeArray::maxArrayValue(vector<int>& nums)
{
    long long sum = 0;
    vector<int> arr = nums;
    long long result = 0;
    while (!arr.empty())
    {
        if (sum == 0)
        {
            sum = arr.back();
            arr.pop_back();
        }
        else
        {
            if (sum >= arr.back())
            {
                sum += arr.back();
                arr.pop_back();
            }
            else
            {
                sum = 0;
            }
        }
        result = max(result, sum);
    }
    return result;
}

/// <summary>
/// Leet Code 2798. Number of Employees Who Met the Target
/// 
/// Easy
///
/// There are n employees in a company, numbered from 0 to n - 1. Each 
/// employee i has worked for hours[i] hours in the company.
///
/// The company requires each employee to work for at least target hours.
///
/// You are given a 0-indexed array of non-negative integers hours of 
/// length n and a non-negative integer target.
///
/// Return the integer denoting the number of employees who worked at 
/// least target hours.
///
/// Example 1:
/// Input: hours = [0,1,2,3,4], target = 2
/// Output: 3
/// Explanation: The company wants each employee to work for at least 2 
/// hours.
/// - Employee 0 worked for 0 hours and didn't meet the target.
/// - Employee 1 worked for 1 hours and didn't meet the target.
/// - Employee 2 worked for 2 hours and met the target.
/// - Employee 3 worked for 3 hours and met the target.
/// - Employee 4 worked for 4 hours and met the target.
/// There are 3 employees who met the target.
///
/// Example 2:
/// Input: hours = [5,1,4,2,2], target = 6
/// Output: 0
/// Explanation: The company wants each employee to work for at least 6 
/// hours.
/// There are 0 employees who met the target.
///
/// Constraints:
/// 1. 1 <= n == hours.length <= 50
/// 2. 0 <= hours[i], target <= 10^5
/// </summary>
int LeetCodeArray::numberOfEmployeesWhoMetTarget(vector<int>& hours, int target)
{
    int result = 0;
    for (size_t i = 0; i < hours.size(); i++)
    {
        if (hours[i] >= target)
        {
            result++;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2808. Minimum Seconds to Equalize a Circular Array
/// 
/// Medium
///
/// You are given a 0-indexed array nums containing n integers.
///
/// At each second, you perform the following operation on the array:
///
/// For every index i in the range [0, n - 1], replace nums[i] with 
/// either nums[i], nums[(i - 1 + n) % n], or nums[(i + 1) % n].
/// Note that all the elements get replaced simultaneously.
///
/// Return the minimum number of seconds needed to make all elements 
/// in the array nums equal.
///
/// Example 1:
/// Input: nums = [1,2,1,2]
/// Output: 1
/// Explanation: We can equalize the array in 1 second in the following 
/// way:
/// - At 1st second, replace values at each index with [nums[3],nums[1],
/// nums[3],nums[3]]. After replacement, nums = [2,2,2,2].
/// It can be proven that 1 second is the minimum amount of seconds 
/// needed for equalizing the array.
///
/// Example 2:
/// Input: nums = [2,1,3,3,2]
/// Output: 2
/// Explanation: We can equalize the array in 2 seconds in the following 
/// way:
/// - At 1st second, replace values at each index with [nums[0],nums[2],
///   nums[2],nums[2],nums[3]]. After replacement, nums = [2,3,3,3,3].
/// - At 2nd second, replace values at each index with [nums[1],nums[1],
///   nums[2],nums[3],nums[4]]. After replacement, nums = [3,3,3,3,3].
/// It can be proven that 2 seconds is the minimum amount of seconds 
/// needed for equalizing the array.
///
/// Example 3:
/// Input: nums = [5,5,5,5]
/// Output: 0
/// Explanation: We don't need to perform any operations as all elements 
/// in the initial array are the same.
///
/// Constraints:
/// 1. 1 <= n == nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^9
/// </summary>
int LeetCodeArray::minimumSeconds(vector<int>& nums)
{
    unordered_map<int, int> head, tail, distance;
    int result = nums.size();
    for (size_t i = 0; i < nums.size(); i++)
    {
        int n = nums[i];
        if (head.count(n) > 0)
        {
            distance[n] = max(distance[n], ((int)i - tail[n]) / 2);
        }
        else
        {
            head[n] = i;
        }
        tail[n] = i;
    }
    for (auto itr : head)
    {
        int d = max(distance[itr.first], (head[itr.first] + (int)nums.size() - tail[itr.first]) / 2);
        result = min(result, d);
    }
    return result;
}

/// <summary>
/// Leet Code 2811. Check if it is Possible to Split Array
/// 
/// Medium
///
/// You are given an array nums of length n and an integer m. You need to 
/// determine if it is possible to split the array into n non-empty 
/// arrays by performing a series of steps.
///
/// In each step, you can select an existing array (which may be the 
/// result of previous steps) with a length of at least two and split 
/// it into two subarrays, if, for each resulting subarray, at least 
/// one of the following holds:
///
/// The length of the subarray is one, or
/// The sum of elements of the subarray is greater than or equal to m.
/// Return true if you can split the given array into n arrays, otherwise 
/// return false.
///
/// Note: A subarray is a contiguous non-empty sequence of elements 
/// within an array.
///  
/// Example 1:
/// Input: nums = [2, 2, 1], m = 4
/// Output: true
/// Explanation: We can split the array into [2, 2] and [1] in the 
/// first step. Then, in the second step, we can split [2, 2] into [2] 
/// and [2]. As a result, the answer is true.
///
/// Example 2:
/// Input: nums = [2, 1, 3], m = 5 
/// Output: false
/// Explanation: We can try splitting the array in two different ways: 
/// the first way is to have [2, 1] and [3], and the second way is to 
/// have [2] and [1, 3]. However, both of these ways are not valid. So, 
/// the answer is false.
///
/// Example 3:
/// Input: nums = [2, 3, 3, 2, 3], m = 6
/// Output: true
/// Explanation: We can split the array into [2, 3, 3, 2] and [3] 
/// in the first step. Then, in the second step, we can split 
/// [2, 3, 3, 2] into [2, 3, 3] and [2]. Then, in the third step, 
/// we can split [2, 3, 3] into [2] and [3, 3]. And in the last 
/// step we can split [3, 3] into [3] and [3]. As a result, 
/// the answer is true.
/// 
/// Constraints:
/// 1. 1 <= n == nums.length <= 100
/// 2. 1 <= nums[i] <= 100
/// 3. 1 <= m <= 200
/// </summary>
bool LeetCodeArray::canSplitArray(vector<int>& nums, int m)
{
    int n = nums.size();
    if (n <= 2) return true;
    int sum = accumulate(nums.begin(), nums.end(), 0);
    for (int i = 0; i < n - 1; i++)
    {
        if (sum < m) return false;
        if (nums[i] + nums[i + 1] >= m) return true;
        sum -= nums[i];
    }
    return true;
}

/// <summary>
/// Leet Code 2824. Count Pairs Whose Sum is Less than Target
/// 
/// Easy
///
/// Given a 0-indexed integer array nums of length n and an integer 
/// target, return the number of pairs (i, j) where 0 <= i < j < n and 
/// nums[i] + nums[j] < target.
///
/// Example 1:
/// Input: nums = [-1,1,2,3,1], target = 2
/// Output: 3
/// Explanation: There are 3 pairs of indices that satisfy the conditions 
/// in the statement:
/// - (0, 1) since 0 < 1 and nums[0] + nums[1] = 0 < target
/// - (0, 2) since 0 < 2 and nums[0] + nums[2] = 1 < target 
/// - (0, 4) since 0 < 4 and nums[0] + nums[4] = 0 < target
/// Note that (0, 3) is not counted since nums[0] + nums[3] is not 
/// strictly less than the target.
///
/// Example 2:
/// Input: nums = [-6,2,5,-2,-7,-1,3], target = -2
/// Output: 10
/// Explanation: There are 10 pairs of indices that satisfy the conditions 
/// in the statement:
/// - (0, 1) since 0 < 1 and nums[0] + nums[1] = -4 < target
/// - (0, 3) since 0 < 3 and nums[0] + nums[3] = -8 < target
/// - (0, 4) since 0 < 4 and nums[0] + nums[4] = -13 < target
/// - (0, 5) since 0 < 5 and nums[0] + nums[5] = -7 < target
/// - (0, 6) since 0 < 6 and nums[0] + nums[6] = -3 < target
/// - (1, 4) since 1 < 4 and nums[1] + nums[4] = -5 < target
/// - (3, 4) since 3 < 4 and nums[3] + nums[4] = -9 < target
/// - (3, 5) since 3 < 5 and nums[3] + nums[5] = -3 < target
/// - (4, 5) since 4 < 5 and nums[4] + nums[5] = -8 < target
/// - (4, 6) since 4 < 6 and nums[4] + nums[6] = -4 < target
/// 
/// Constraints:
/// 1. 1 <= nums.length == n <= 50
/// 2. -50 <= nums[i], target <= 50
/// </summary>
int LeetCodeArray::countPairsII(vector<int>& nums, int target)
{
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        for (size_t j = 0; j < i; j++)
        {
            if (nums[i] + nums[j] < target) result++;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2836. Maximize Value of Function in a Ball Passing Game
/// 
/// Hard
///
/// You are given a 0-indexed integer array receiver of length n and an 
/// integer k.
///
/// There are n players having a unique id in the range [0, n - 1] who 
/// will play a ball passing game, and receiver[i] is the id of the 
/// player who receives passes from the player with id i. Players can 
/// pass to themselves, i.e. receiver[i] may be equal to i.
///
/// You must choose one of the n players as the starting player for the 
/// game, and the ball will be passed exactly k times starting from the 
/// chosen player.
///
/// For a chosen starting player having id x, we define a function f(x) 
/// that denotes the sum of x and the ids of all players who receive the 
/// ball during the k passes, including repetitions. In other words, 
/// f(x) = x + receiver[x] + receiver[receiver[x]] + ... + receiver(k)[x].
///
/// Your task is to choose a starting player having id x that maximizes 
/// the value of f(x).
/// 
/// Return an integer denoting the maximum value of the function.
///
/// Note: receiver may contain duplicates.
///
///
///
/// Example 1:
///
/// Pass Number Sender ID   Receiver ID x + Receiver IDs
///             2
/// 1   2   1   3
/// 2   1   0   3
/// 3   0   2   5
/// 4   2   1   6
/// Input: receiver = [2,0,1], k = 4
/// Output: 6
/// Explanation: The table above shows a simulation of the game starting 
/// with the player having id x = 2. 
/// From the table, f(2) is equal to 6. 
/// It can be shown that 6 is the maximum achievable value of the function. 
/// Hence, the output is 6. 
///
/// Example 2:
///
/// Pass Number Sender ID   Receiver ID x + Receiver IDs
///             4
/// 1   4   3   7
/// 2   3   2   9
/// 3   2   1   10
/// Input: receiver = [1,1,1,2,3], k = 3
/// Output: 10
/// Explanation: The table above shows a simulation of the game starting 
/// with the player having id x = 4. 
/// From the table, f(4) is equal to 10. 
/// It can be shown that 10 is the maximum achievable value of the 
/// function. 
/// Hence, the output is 10. 
///
/// Constraints:
/// 1. 1 <= receiver.length == n <= 10^5
/// 2. 0 <= receiver[i] <= n - 1
/// 3. 1 <= k <= 10^10
/// </summary>
long long LeetCodeArray::getMaxFunctionValue(vector<int>& receiver, long long k)
{
    int n = receiver.size();

    vector<vector<pair<long long, int>>> pre_sum(36, vector<pair<long long, int>>(n));
    for (int i = 0; i < 36; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (i == 0) pre_sum[i][j] = make_pair(receiver[j], receiver[j]);
            else
            {
                pre_sum[i][j].first = pre_sum[i - 1][j].first + pre_sum[i - 1][pre_sum[i - 1][j].second].first;
                pre_sum[i][j].second = pre_sum[i - 1][pre_sum[i - 1][j].second].second;
            }
        }
    }
    vector<pair<long long, int>> sum(n);
    for (int i = 0; i < n; i++)
    {
        sum[i].first = i;
        sum[i].second = i;
    }
    for (int i = 0; i < 36; i++)
    {
        if (k % 2 == 1)
        {
            for (int j = 0; j < n; j++)
            {
                sum[j].first += pre_sum[i][sum[j].second].first;
                sum[j].second = pre_sum[i][sum[j].second].second;
            }
        }
        k /= 2;
        if (k == 0) break;
    }
    long long result = 0;
    for (int i = 0; i < n; i++)
    {
        result = max(result, sum[i].first);
    }
    return result;
}

/// <summary>
/// Leet Code 2845. Count of Interesting Subarrays
/// 
/// Medium
///
/// You are given a 0-indexed integer array nums, an integer modulo, 
/// and an integer k.
///
/// Your task is to find the count of subarrays that are interesting.
///
/// A subarray nums[l..r] is interesting if the following condition holds:
///
/// Let cnt be the number of indices i in the range [l, r] such that 
/// nums[i] % modulo == k. Then, cnt % modulo == k.
/// Return an integer denoting the count of interesting subarrays.
///
/// Note: A subarray is a contiguous non-empty sequence of elements 
/// within an array.
/// 
/// Example 1:
/// Input: nums = [3,2,4], modulo = 2, k = 1
/// Output: 3
/// Explanation: In this example the interesting subarrays are: 
/// The subarray nums[0..0] which is [3]. 
/// - There is only one index, i = 0, in the range [0, 0] that satisfies 
///   nums[i] % modulo == k. 
/// - Hence, cnt = 1 and cnt % modulo == k.  
/// The subarray nums[0..1] which is [3,2].
/// - There is only one index, i = 0, in the range [0, 1] that satisfies 
///   nums[i] % modulo == k.  
/// - Hence, cnt = 1 and cnt % modulo == k.
/// The subarray nums[0..2] which is [3,2,4]. 
/// - There is only one index, i = 0, in the range [0, 2] that satisfies 
///   nums[i] % modulo == k. 
/// - Hence, cnt = 1 and cnt % modulo == k. 
/// It can be shown that there are no other interesting subarrays. So, the 
/// answer is 3.
///
/// Example 2:
/// Input: nums = [3,1,9,6], modulo = 3, k = 0
/// Output: 2
/// Explanation: In this example the interesting subarrays are: 
/// The subarray nums[0..3] which is [3,1,9,6]. 
/// - There are three indices, i = 0, 2, 3, in the range [0, 3] that 
///   satisfy nums[i] % modulo == k. 
/// - Hence, cnt = 3 and cnt % modulo == k. 
/// The subarray nums[1..1] which is [1]. 
/// - There is no index, i, in the range [1, 1] that satisfies 
///   nums[i] % modulo == k. 
/// - Hence, cnt = 0 and cnt % modulo == k. 
/// It can be shown that there are no other interesting subarrays. So, 
/// the answer is 2.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5 
/// 2. 1 <= nums[i] <= 109
/// 3. 1 <= modulo <= 109
/// 4. 0 <= k < modulo
/// </summary>
long long LeetCodeArray::countInterestingSubarrays(vector<int>& nums, int modulo, int k)
{
    vector<long long> dp;
    dp.push_back(0);
    int index = 0;
    long long result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if ((nums[i] % modulo) != k)
        {
            dp[index]++;
            if (index - k >= 0)
            {
                result += dp[index - k];
            }
        }
        else
        {
            dp[index]++;
            index++;
            dp.push_back(0);
            if (index - modulo >= 0)
            {  
                dp[index] += dp[index - modulo];
            }
            if (index - k >= 0)
            {
                result += dp[index - k];
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2869. Minimum Operations to Collect Elements
/// 
/// Easy
/// 
/// You are given an array nums of positive integers and an integer k.
///
/// In one operation, you can remove the last element of the array and 
/// add it to your collection.
///
/// Return the minimum number of operations needed to collect 
/// elements 1, 2, ..., k.
/// 
/// Example 1:
/// Input: nums = [3,1,5,4,2], k = 2
/// Output: 4
/// Explanation: After 4 operations, we collect elements 2, 4, 5, and 1, 
/// in this order. Our collection contains elements 1 and 2. Hence, the 
/// answer is 4.
///
/// Example 2:
/// Input: nums = [3,1,5,4,2], k = 5
/// Output: 5
/// Explanation: After 5 operations, we collect elements 2, 4, 5, 1, 
/// and 3, in this order. Our collection contains elements 1 through 5. 
/// Hence, the answer is 5.
///
/// Example 3:
/// Input: nums = [3,2,5,3,1], k = 3
/// Output: 4
/// Explanation: After 4 operations, we collect elements 1, 3, 5, and 2, 
/// in this order. Our collection contains elements 1 through 3. Hence, 
/// the answer is 4.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 50
/// 2. 1 <= nums[i] <= nums.length
/// 3. 1 <= k <= nums.length
/// 4. The input is generated such that you can collect 
///    elements 1, 2, ..., k.
/// </summary>
int LeetCodeArray::minOperationsII(vector<int>& nums, int k)
{
    unordered_set<int> nums_set;
    for (int i = nums.size() - 1; i >= 0; i--)
    {
        if (nums[i] >= 1 && nums[i] <= k)
        {
            nums_set.insert(nums[i]);
        }
        if (nums_set.size() == k)
        {
            return nums.size() - i;
        }
    }
    return -1;
}

/// <summary>
/// Leet Code 2873. Maximum Value of an Ordered Triplet I
/// 
/// Easy
/// 
/// You are given a 0-indexed integer array nums.
///
/// Return the maximum value over all triplets of indices (i, j, k) such 
/// that i < j < k. If all such triplets have a negative value, return 0.
///
/// The value of a triplet of indices (i, j, k) is equal to 
/// (nums[i] - nums[j]) * nums[k].
///
/// Example 1:
/// Input: nums = [12,6,1,2,7]
/// Output: 77
/// Explanation: The value of the triplet (0, 2, 4) is 
/// (nums[0] - nums[2]) * nums[4] = 77.
/// It can be shown that there are no ordered triplets of indices with a 
/// value greater than 77. 
///
/// Example 2:
/// Input: nums = [1,10,3,4,19]
/// Output: 133
/// Explanation: The value of the triplet (1, 2, 4) is 
/// (nums[1] - nums[2]) * nums[4] = 133.
/// It can be shown that there are no ordered triplets of indices 
/// with a value greater than 133.
///
/// Example 3:
/// Input: nums = [1,2,3]
/// Output: 0
/// Explanation: The only ordered triplet of indices (0, 1, 2) has a 
/// negative value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the 
/// answer would be 0.
///
/// Constraints:
/// 1. 3 <= nums.length <= 100
/// 2. 1 <= nums[i] <= 10^6
/// </summary>
long long LeetCodeArray::maximumTripletValue(vector<int>& nums)
{
    int max_val = 0;
    int max_diff = 0;
    long long result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        result = max(result, (long long)nums[i] * (long long)max_diff);
        max_diff = max(max_diff, max_val - nums[i]);
        max_val = max(max_val, nums[i]);
    }
    return result;
}

/// <summary>
/// Leet Code 2874. Maximum Value of an Ordered Triplet II
/// 
/// Medium
/// 
/// You are given a 0-indexed integer array nums.
///
/// Return the maximum value over all triplets of indices (i, j, k) such 
/// that i < j < k. If all such triplets have a negative value, return 0.
///
/// The value of a triplet of indices (i, j, k) is equal to 
/// (nums[i] - nums[j]) * nums[k].
///  
/// Example 1:
/// Input: nums = [12,6,1,2,7]
/// Output: 77
/// Explanation: The value of the triplet (0, 2, 4) is 
/// (nums[0] - nums[2]) * nums[4] = 77.
/// It can be shown that there are no ordered triplets of indices with a 
/// value greater than 77. 
///
/// Example 2:
/// Input: nums = [1,10,3,4,19]
/// Output: 133
/// Explanation: The value of the triplet (1, 2, 4) is 
/// (nums[1] - nums[2]) * nums[4] = 133.
/// It can be shown that there are no ordered triplets of indices with a 
/// value greater than 133.
///
/// Example 3:
/// Input: nums = [1,2,3]
/// Output: 0
/// Explanation: The only ordered triplet of indices (0, 1, 2) has a 
/// negative value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the 
/// answer would be 0.
///
/// Constraints:
/// 1. 3 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^6
/// </summary>
long long LeetCodeArray::maximumTripletValueII(vector<int>& nums)
{
    int max_val = 0;
    int max_diff = 0;
    long long result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        result = max(result, (long long)nums[i] * (long long)max_diff);
        max_diff = max(max_diff, max_val - nums[i]);
        max_val = max(max_val, nums[i]);
    }
    return result;
}

/// <summary>
/// Leet Code 2871. Split Array Into Maximum Number of Subarrays
/// 
/// Medium
/// 
/// You are given an array nums consisting of non-negative integers.
///
/// We define the score of subarray nums[l..r] such that l <= r as 
/// nums[l] AND nums[l + 1] AND ... AND nums[r] where AND is the bitwise 
/// AND operation.
///
/// Consider splitting the array into one or more subarrays such that 
/// the following conditions are satisfied:
///
/// Each element of the array belongs to exactly one subarray.
/// The sum of scores of the subarrays is the minimum possible.
/// Return the maximum number of subarrays in a split that satisfies 
/// the conditions above.
///
/// A subarray is a contiguous part of an array.
///
/// Example 1:
///
/// Input: nums = [1,0,2,0,1,2]
/// Output: 3
/// Explanation: We can split the array into the following subarrays:
/// - [1,0]. The score of this subarray is 1 AND 0 = 0.
/// - [2,0]. The score of this subarray is 2 AND 0 = 0.
/// - [1,2]. The score of this subarray is 1 AND 2 = 0.
/// The sum of scores is 0 + 0 + 0 = 0, which is the minimum possible 
/// score that we can obtain.
/// It can be shown that we cannot split the array into more than 3 
/// subarrays with a total score of 0. So we return 3.
///
/// Example 2:
/// Input: nums = [5,7,1,3]
/// Output: 1
/// Explanation: We can split the array into one subarray: [5,7,1,3] 
/// with a score of 1, which is the minimum possible score that we can 
/// obtain.
/// It can be shown that we cannot split the array into more than 1 
/// subarray with a total score of 1. So we return 1.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 10^6
/// </summary>
int LeetCodeArray::maxSubarrays(vector<int>& nums)
{
    int prev = INT_MAX;
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        prev = nums[i] & prev;
        if (prev == 0)
        {
            result++;
            prev = INT_MAX;
        }
    }
    if (prev != INT_MAX && result == 0)
    {
        result++;
    }
    return result;
}

/// <summary>
/// Leet Code 2875. Minimum Size Subarray in Infinite Array
/// 
/// Medium
/// 
/// You are given a 0-indexed array nums and an integer target.
///
/// A 0-indexed array infinite_nums is generated by infinitely appending 
/// the elements of nums to itself.
///
/// Return the length of the shortest subarray of the array infinite_nums 
/// with a sum equal to target. If there is no such subarray return -1.
///
/// Example 1:
/// Input: nums = [1,2,3], target = 5
/// Output: 2
/// Explanation: In this example infinite_nums = [1,2,3,1,2,3,1,2,...].
/// The subarray in the range [1,2], has the sum equal to target = 5 and 
/// length = 2.
/// It can be proven that 2 is the shortest length of a subarray with sum 
/// equal to target = 5.
///
/// Example 2:
/// Input: nums = [1,1,1,2,3], target = 4
/// Output: 2
/// Explanation: In this example infinite_nums = 
/// [1,1,1,2,3,1,1,1,2,3,1,1,...].
/// The subarray in the range [4,5], has the sum equal to target = 4 and 
/// length = 2.
/// It can be proven that 2 is the shortest length of a subarray with sum 
/// equal to target = 4.
///
/// Example 3:
///
/// Input: nums = [2,4,6,8], target = 3
/// Output: -1
/// Explanation: In this example infinite_nums = [2,4,6,8,2,4,6,8,...].
/// It can be proven that there is no subarray with sum equal to 
/// target = 3.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^5
/// 3. 1 <= target <= 10^9
/// </summary>
int LeetCodeArray::minSizeSubarray(vector<int>& nums, int target)
{
    long long sum = 0;
    for (auto x : nums) sum += (long long) x;
    int round = (int)((long long)target / sum);
    target = (int)((long long)target % sum);
    if (target == 0) return round * nums.size();
    unordered_map<long long, int> sum_positions;
    sum_positions[0] = -1;
    sum = 0;
    int result = INT_MAX;
    for (int i = 0; i < 2; i ++)
    {
        for (size_t j = 0; j < nums.size(); j++)
        {
            int pos = i * nums.size() + j;
            sum += nums[j];
            if (sum_positions.count(sum - target) > 0)
            {
                result = min(result, pos - sum_positions[sum - target]);
            }
            sum_positions[sum] = pos;
        }
    }
    if (result == INT_MAX) return -1;
    else return round * nums.size() + result;
}

/// <summary>
/// Leet Code 2892. Minimizing Array After Replacing Pairs With Their 
///                 Product
/// 
/// Medium
/// 
/// Given an integer array nums and an integer k, you can perform the 
/// following operation on the array any number of times:
///
/// Select two adjacent elements of the array like x and y, such that 
/// x * y <= k, and replace both of them with a single element with 
/// value x * y (e.g. in one operation the array [1, 2, 2, 3] with 
/// k = 5 can become [1, 4, 3] or [2, 2, 3], but can't become [1, 2, 6]).
/// Return the minimum possible length of nums after any number of 
/// operations.
/// 
/// Example 1:
///
/// Input: nums = [2,3,3,7,3,5], k = 20
/// Output: 3
/// Explanation: We perform these operations:
/// 1. [2,3,3,7,3,5] -> [6,3,7,3,5]
/// 2. [6,3,7,3,5] -> [18,7,3,5]
/// 3. [18,7,3,5] -> [18,7,15]
/// It can be shown that 3 is the minimum length possible to achieve with 
/// the given operation.
///
/// Example 2:
/// Input: nums = [3,3,3,3], k = 6
/// Output: 4
/// Explanation: We can't perform any operations since the product of 
/// every two adjacent elements is greater than 6.
/// Hence, the answer is 4.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 10^9
/// 3. 1 <= k <= 10^9
/// </summary>
int LeetCodeArray::minArrayLength(vector<int>& nums, int k)
{
    vector<int> result;
    for (size_t i = 0; i < nums.size(); i++)
    {
        int t = nums[i];
        while (!result.empty() && t * result.back() <= k)
        {
            t *= result.back();
            result.pop_back();
        }
        result.push_back(t);
    }
    return result.size();
}

/// <summary>
/// Leet Code 2898. Maximum Linear Stock Score
/// 
/// Medium
/// 
/// Given a 1-indexed integer array prices, where prices[i] is the price 
/// of a particular stock on the ith day, your task is to select some of 
/// the elements of prices such that your selection is linear.
///
/// A selection indexes, where indexes is a 1-indexed integer array of 
/// length k which is a subsequence of the array [1, 2, ..., n], is 
/// linear if:
///
/// For every 1 < j <= k, prices[indexes[j]] - prices[indexes[j - 1]] == 
/// indexes[j] - indexes[j - 1].
/// A subsequence is an array that can be derived from another array by 
/// deleting some or no elements without changing the order of the 
/// remaining elements.
///
/// The score of a selection indexes, is equal to the sum of the following 
/// array: [prices[indexes[1]], prices[indexes[2]], ..., 
/// prices[indexes[k]].
///
/// Return the maximum score that a linear selection can have.
/// 
/// Example 1:
/// Input: prices = [1,5,3,7,8]
/// Output: 20
/// Explanation: We can select the indexes [2,4,5]. We show that our 
/// selection is linear:
/// For j = 2, we have:
/// indexes[2] - indexes[1] = 4 - 2 = 2.
/// prices[4] - prices[2] = 7 - 5 = 2.
/// For j = 3, we have:
/// indexes[3] - indexes[2] = 5 - 4 = 1.
/// prices[5] - prices[4] = 8 - 7 = 1.
/// The sum of the elements is: prices[2] + prices[4] + prices[5] = 20.
/// It can be shown that the maximum sum a linear selection can have is 20.
///
/// Example 2:
/// Input: prices = [5,6,7,8,9]
/// Output: 35
/// Explanation: We can select all of the indexes [1,2,3,4,5]. Since each 
/// element has a difference of exactly 1 from its previous element, our 
/// selection is linear.
/// The sum of all the elements is 35 which is the maximum possible some 
/// out of every selection.
/// 
/// Constraints:
/// 1. 1 <= prices.length <= 10^5
/// 2. 1 <= prices[i] <= 10^9
/// </summary>
long long LeetCodeArray::maxStockScore(vector<int>& prices)
{
    unordered_map<int, long long> scores;
    for (size_t i = 0; i < prices.size(); i++)
    {
        scores[prices[i] - i - 1] += prices[i];
    }
    long long result = 0;
    for (const auto& itr : scores)
    {
        result = max(result, itr.second);
    }
    return result;
}

/// <summary>
/// Leet Code 2899. Last Visited Integers
/// 
/// Easy
/// 
/// Given a 0-indexed array of strings words where words[i] is either a 
/// positive integer represented as a string or the string "prev".
///
/// Start iterating from the beginning of the array; for every "prev" 
/// string seen in words, find the last visited integer in words which 
/// is defined as follows:
///
/// Let k be the number of consecutive "prev" strings seen so far 
/// (containing the current string). Let nums be the 0-indexed array 
/// of integers seen so far and nums_reverse be the reverse of nums, 
/// then the integer at (k - 1)th index of nums_reverse will be the 
/// last visited integer for this "prev".
/// If k is greater than the total visited integers, then the last 
/// visited integer will be -1.
/// Return an integer array containing the last visited integers.
///
/// Example 1:
/// Input: words = ["1","2","prev","prev","prev"]
/// Output: [2,1,-1]
/// Explanation: 
/// For "prev" at index = 2, last visited integer will be 2 as here 
/// the number of consecutive "prev" strings is 1, and in the array 
/// reverse_nums, 2 will be the first element.
/// For "prev" at index = 3, last visited integer will be 1 as there 
/// are a total of two consecutive "prev" strings including this 
/// "prev" which are visited, and 1 is the second last visited integer.
/// For "prev" at index = 4, last visited integer will be -1 as there 
/// are a total of three consecutive "prev" strings including this "prev" 
/// which are visited, but the total number of integers visited is two.
///
/// Example 2:
/// Input: words = ["1","prev","2","prev","prev"]
/// Output: [1,2,1]
/// Explanation:
/// For "prev" at index = 1, last visited integer will be 1.
/// For "prev" at index = 3, last visited integer will be 2.
/// For "prev" at index = 4, last visited integer will be 1 as there are 
/// a total of two consecutive "prev" strings including this "prev" 
/// which are visited, and 1 is the second last visited integer.
///
/// Constraints:
/// 1. 1 <= words.length <= 100
/// 2. words[i] == "prev" or 1 <= int(words[i]) <= 100
/// </summary>
vector<int> LeetCodeArray::lastVisitedIntegers(vector<string>& words)
{
    vector<int>nums;
    vector<int>result;
    int prev_count = 0;
    for (size_t i = 0; i < words.size(); i++)
    {
        if (words[i] == "prev")
        {
            if (prev_count >= (int)nums.size())
            {
                result.push_back(-1);
            }
            else
            {
                result.push_back(nums[nums.size() - 1 - prev_count]);
            }
            prev_count++;
        }
        else
        {
            prev_count = 0;
            nums.push_back(atoi(words[i].c_str()));
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2900. Longest Unequal Adjacent Groups Subsequence I
/// 
/// Medium
/// 
/// You are given an integer n, a 0-indexed string array words, and a 
/// 0-indexed binary array groups, both arrays having length n.
///
/// You need to select the longest subsequence from an array of indices 
/// [0, 1, ..., n - 1], such that for the subsequence denoted as 
/// [i0, i1, ..., ik - 1] having length k, groups[ij] != groups[ij + 1], 
/// for each j where 0 < j + 1 < k.
///
/// Return a string array containing the words corresponding to the 
/// indices (in order) in the selected subsequence. If there are 
/// multiple answers, return any of them.
///
/// A subsequence of an array is a new array that is formed from the 
/// original array by deleting some (possibly none) of the elements 
/// without disturbing the relative positions of the remaining elements.
///
/// Note: strings in words may be unequal in length.
///
/// Example 1:
/// Input: n = 3, words = ["e","a","b"], groups = [0,0,1]
/// Output: ["e","b"]
/// Explanation: A subsequence that can be selected is [0,2] because 
/// groups[0] != groups[2].
/// So, a valid answer is [words[0],words[2]] = ["e","b"].
/// Another subsequence that can be selected is [1,2] because 
/// groups[1] != groups[2].
/// This results in [words[1],words[2]] = ["a","b"].
/// It is also a valid answer.
/// It can be shown that the length of the longest subsequence of 
/// indices that satisfies the condition is 2.
///
/// Example 2:
/// Input: n = 4, words = ["a","b","c","d"], groups = [1,0,1,1]
/// Output: ["a","b","c"]
/// Explanation: A subsequence that can be selected is [0,1,2] because 
/// groups[0] != groups[1] and groups[1] != groups[2].
/// So, a valid answer is [words[0],words[1],words[2]] = ["a","b","c"].
/// Another subsequence that can be selected is [0,1,3] because 
/// groups[0] != groups[1] and groups[1] != groups[3].
/// This results in [words[0],words[1],words[3]] = ["a","b","d"].
/// It is also a valid answer.
/// It can be shown that the length of the longest subsequence of indices 
/// that satisfies the condition is 3.
///
/// Constraints:
/// 1. 1 <= n == words.length == groups.length <= 100
/// 2. 1 <= words[i].length <= 10
/// 3. 0 <= groups[i] < 2
/// 4. words consists of distinct strings.
/// 5. words[i] consists of lowercase English letters.
/// </summary>
vector<string> LeetCodeArray::getWordsInLongestSubsequence(int n, vector<string>& words, vector<int>& groups)
{
    int prev = -1;
    vector<string> result;
    for (int i = 0; i < n; i++)
    {
        if (result.empty() || prev != groups[i])
        {
            result.push_back(words[i]);
            prev = groups[i];
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2901. Longest Unequal Adjacent Groups Subsequence II
/// 
/// Medium
/// 
/// You are given an integer n, a 0-indexed string array words, and a 
/// 0-indexed array groups, both arrays having length n.
///
/// The hamming distance between two strings of equal length is the number 
/// of positions at which the corresponding characters are different.
///
/// You need to select the longest subsequence from an array of indices 
/// [0, 1, ..., n - 1], such that for the subsequence denoted as 
/// [i0, i1, ..., ik - 1] having length k, the following holds:
///
/// For adjacent indices in the subsequence, their corresponding groups 
/// are unequal, i.e., groups[ij] != groups[ij + 1], for each j 
/// where 0 < j + 1 < k.
/// words[ij] and words[ij + 1] are equal in length, and the hamming 
/// distance between them is 1, where 0 < j + 1 < k, for all indices in 
/// the subsequence.
/// Return a string array containing the words corresponding to the 
/// indices (in order) in the selected subsequence. If there are multiple 
/// answers, return any of them.
///
/// A subsequence of an array is a new array that is formed from the 
/// original array by deleting some (possibly none) of the elements 
/// without disturbing the relative positions of the remaining elements.
///
/// Note: strings in words may be unequal in length.
/// 
/// Example 1:
/// Input: n = 3, words = ["bab","dab","cab"], groups = [1,2,2]
/// Output: ["bab","cab"]
/// Explanation: A subsequence that can be selected is [0,2].
/// - groups[0] != groups[2]
/// - words[0].length == words[2].length, and the hamming distance 
///   between them is 1.
/// So, a valid answer is [words[0],words[2]] = ["bab","cab"].
/// Another subsequence that can be selected is [0,1].
/// - groups[0] != groups[1]
/// - words[0].length == words[1].length, and the hamming distance 
///   between them is 1.
/// So, another valid answer is [words[0],words[1]] = ["bab","dab"].
/// It can be shown that the length of the longest subsequence of indices 
/// that satisfies the conditions is 2.  
///
/// Example 2:
/// Input: n = 4, words = ["a","b","c","d"], groups = [1,2,3,4]
/// Output: ["a","b","c","d"]
/// Explanation: We can select the subsequence [0,1,2,3].
/// It satisfies both conditions.
/// Hence, the answer is [words[0],words[1],words[2],words[3]] = 
/// ["a","b","c","d"].
/// It has the longest length among all subsequences of indices that 
/// satisfy the conditions.
/// Hence, it is the only answer.
///
/// Constraints:
/// 1. 1 <= n == words.length == groups.length <= 1000
/// 2. 1 <= words[i].length <= 10
/// 3. 1 <= groups[i] <= n
/// 4. words consists of distinct strings.
/// 5. words[i] consists of lowercase English letters.
/// </summary>
vector<string> LeetCodeArray::getWordsInLongestSubsequenceII(int n, vector<string>& words, vector<int>& groups)
{
    vector<pair<int, int>> tracking(n, {1, -1});
    int max_len = 1;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < i; j++)
        {
            if (groups[i] == groups[j]) continue;
            if (words[i].size() != words[j].size()) continue;
            int count = 0;
            for (size_t k = 0; k < words[i].size(); k++)
            {
                if (words[i][k] != words[j][k])
                {
                    count++;
                    if (count > 1) break;
                }
            }
            if (count == 1)
            {
                if (tracking[i].first < tracking[j].first + 1)
                {
                    tracking[i].first = tracking[j].first + 1;
                    tracking[i].second = j;
                    max_len = max(max_len, tracking[i].first);
                }
            }
        }
    }
    vector<string> result;
    for (int i = 0; i < n; i++)
    {
        if (tracking[i].first == max_len)
        {
            int x = i;
            while (x != -1)
            {
                result.push_back(words[x]);
                x = tracking[x].second;
            }
            break;
        }
    }
    reverse(result.begin(), result.end());
    return result;
}


/// <summary>
/// Leet Code 2903. Find Indices With Index and Value Difference I
/// 
/// Easy
/// 
/// You are given a 0-indexed integer array nums having length n, an 
/// integer indexDifference, and an integer valueDifference.
///
/// Your task is to find two indices i and j, both in the range 
/// [0, n - 1], that satisfy the following conditions:
///
/// abs(i - j) >= indexDifference, and
/// abs(nums[i] - nums[j]) >= valueDifference
/// Return an integer array answer, where answer = [i, j] if there are 
/// two such indices, and answer = [-1, -1] otherwise. If there are 
/// multiple choices for the two indices, return any of them.
///
/// Note: i and j may be equal.
/// 
/// Example 1:
/// Input: nums = [5,1,4,1], indexDifference = 2, valueDifference = 4
/// Output: [0,3]
/// Explanation: In this example, i = 0 and j = 3 can be selected.
/// abs(0 - 3) >= 2 and abs(nums[0] - nums[3]) >= 4.
/// Hence, a valid answer is [0,3].
/// [3,0] is also a valid answer.
///
/// Example 2:
/// Input: nums = [2,1], indexDifference = 0, valueDifference = 0
/// Output: [0,0]
/// Explanation: In this example, i = 0 and j = 0 can be selected.
/// abs(0 - 0) >= 0 and abs(nums[0] - nums[0]) >= 0.
/// Hence, a valid answer is [0,0].
/// Other valid answers are [0,1], [1,0], and [1,1].
///
/// Example 3:
/// Input: nums = [1,2,3], indexDifference = 2, valueDifference = 4
/// Output: [-1,-1]
/// Explanation: In this example, it can be shown that it is 
/// impossible to find two indices that satisfy both conditions.
/// Hence, [-1,-1] is returned.
/// 
/// Constraints:
/// 1. 1 <= n == nums.length <= 100
/// 2. 0 <= nums[i] <= 50
/// 3. 0 <= indexDifference <= 100
/// 4. 0 <= valueDifference <= 50
/// </summary>
vector<int> LeetCodeArray::findIndices(vector<int>& nums, int indexDifference, int valueDifference)
{
    pair<int, int> min_val = { 1000, -1 };
    pair<int, int> max_val = { -1000, -1 };
    vector<int> result = { -1, -1 };
    for (size_t i = 0; i < nums.size(); i++)
    {
        int k = (int)i - indexDifference;
        if (k >= 0)
        {
            if (nums[k] < min_val.first)
            {
                min_val.first = nums[k];
                min_val.second = k;
            }
            if (nums[k] > max_val.first)
            {
                max_val.first = nums[k];
                max_val.second = k;
            }
        }
        if (nums[i] - min_val.first >= valueDifference)
        {
            result[0] = min_val.second;
            result[1] = i;
            break;
        }
        else if (max_val.first - nums[i] >= valueDifference)
        {
            result[0] = max_val.second;
            result[1] = i;
            break;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2906. Construct Product Matrix
/// 
/// Medium
/// Given a 0-indexed 2D integer matrix grid of size n * m, we define a 
/// 0-indexed 2D matrix p of size n * m as the product matrix of grid if 
/// the following condition is met:
///
/// Each element p[i][j] is calculated as the product of all elements in 
/// grid except for the element grid[i][j]. This product is then taken 
/// modulo 12345.
/// Return the product matrix of grid.
/// 
/// Example 1:
/// Input: grid = [[1,2],[3,4]]
/// Output: [[24,12],[8,6]]
/// Explanation: p[0][0] = grid[0][1] * grid[1][0] * grid[1][1] 
/// = 2 * 3 * 4 = 24
/// p[0][1] = grid[0][0] * grid[1][0] * grid[1][1] = 1 * 3 * 4 = 12
/// p[1][0] = grid[0][0] * grid[0][1] * grid[1][1] = 1 * 2 * 4 = 8
/// p[1][1] = grid[0][0] * grid[0][1] * grid[1][0] = 1 * 2 * 3 = 6
/// So the answer is [[24,12],[8,6]].
///
/// Example 2:
/// Input: grid = [[12345],[2],[1]]
/// Output: [[2],[0],[0]]
/// Explanation: p[0][0] = grid[0][1] * grid[0][2] = 2 * 1 = 2.
/// p[0][1] = grid[0][0] * grid[0][2] = 12345 * 1 = 12345. 
/// 12345 % 12345 = 0. So p[0][1] = 0.
/// p[0][2] = grid[0][0] * grid[0][1] = 12345 * 2 = 24690. 
/// 24690 % 12345 = 0. So p[0][2] = 0.
/// So the answer is [[2],[0],[0]].
///
/// Constraints:
/// 1. 1 <= n == grid.length <= 10^5
/// 2. 1 <= m == grid[i].length <= 10^5
/// 3. 2 <= n * m <= 10^5
/// 4. 1 <= grid[i][j] <= 10^9
/// </summary>
vector<vector<int>> LeetCodeArray::constructProductMatrix(vector<vector<int>>& grid)
{
    long long M = 12345;
    long long product = 1;
    int n = grid.size();
    int m = grid[0].size();
    vector<vector<pair<int, int>>> grid_product(n, vector<pair<int, int>>(m));
    vector<pair<int, int>> row_product(n);
    for (size_t i = 0; i < grid.size(); i++)
    {
        long long product = 1;
        for (size_t j = 0; j < grid[0].size(); j++)
        {
            product = product * (long long)grid[i][j] % M;
            grid_product[i][j].first = (int)product;
        }
        row_product[i].first = (int)product;
        if (i > 0)
        {
            row_product[i].first = (int)(((long long)row_product[i].first * (long long)row_product[i - 1].first) % M);
        }
    }

    for (int i = n - 1; i >= 0; i--)
    {
        long long product = 1;
        for (int j = m - 1; j >= 0; j--)
        {
            product = (product * (long long)grid[i][j]) % M;
            grid_product[i][j].second = (int)product;
        }
        row_product[i].second = (int)product;
        if (i < n - 1)
        {
            row_product[i].second = (row_product[i].second * row_product[i + 1].second) % (int)M;
        }
    }

    vector<vector<int>> result(n, vector<int>(m));
    for (int i = 0; i < (int)grid.size(); i++)
    {
        for (int j = 0; j < (int)grid[0].size(); j++)
        {
            result[i][j] = 1;
            if (i > 0)
            {
                result[i][j] = (int)((long long)result[i][j] * (long long)row_product[i - 1].first % M);
            }
            if (i < n - 1)
            {
                result[i][j] = (int)((long long)result[i][j] * (long long)row_product[i + 1].second % M);
            }
            if (j > 0)
            {
                result[i][j] = (int)((long long)result[i][j] * (long long)grid_product[i][j - 1].first % M);
            }
            if (j < m - 1)
            {
                result[i][j] = (int)((long long)result[i][j] * (long long)grid_product[i][j + 1].second % M);
            }
        }
    }
    return result;
}


/// <summary>
/// Leet Code 2905. Find Indices With Index and Value Difference II
/// 
/// Medium
///
/// You are given a 0-indexed integer array nums having length n, an 
/// integer indexDifference, and an integer valueDifference.
///
/// Your task is to find two indices i and j, both in the range 
/// [0, n - 1], that satisfy the following conditions:
///
/// abs(i - j) >= indexDifference, and 
/// abs(nums[i] - nums[j]) >= valueDifference
/// Return an integer array answer, where answer = [i, j] if there are 
/// two such indices, and answer = [-1, -1] otherwise. If there are 
/// multiple choices for the two indices, return any of them.
///
/// Note: i and j may be equal.
/// 
/// Example 1:
/// Input: nums = [5,1,4,1], indexDifference = 2, valueDifference = 4
/// Output: [0,3]
/// Explanation: In this example, i = 0 and j = 3 can be selected.
/// abs(0 - 3) >= 2 and abs(nums[0] - nums[3]) >= 4.
/// Hence, a valid answer is [0,3].
/// [3,0] is also a valid answer.
///
/// Example 2:
/// Input: nums = [2,1], indexDifference = 0, valueDifference = 0
/// Output: [0,0]
/// Explanation: In this example, i = 0 and j = 0 can be selected.
/// abs(0 - 0) >= 0 and abs(nums[0] - nums[0]) >= 0.
/// Hence, a valid answer is [0,0].
/// Other valid answers are [0,1], [1,0], and [1,1].
///
/// Example 3:
/// Input: nums = [1,2,3], indexDifference = 2, valueDifference = 4
/// Output: [-1,-1]
/// Explanation: In this example, it can be shown that it is impossible to 
/// find two indices that satisfy both conditions.
/// Hence, [-1,-1] is returned.
/// 
/// Constraints:
/// 1. 1 <= n == nums.length <= 10^5
/// 2. 0 <= nums[i] <= 10^9
/// 3. 0 <= indexDifference <= 10^5
/// 4. 0 <= valueDifference <= 10^9
/// </summary>
vector<int> LeetCodeArray::findIndicesII(vector<int>& nums, int indexDifference, int valueDifference)
{
    pair<int, int> min_val = { 1000000001, -1 };
    pair<int, int> max_val = { -1000000001, -1 };
    vector<int> result = { -1, -1 };
    for (size_t i = 0; i < nums.size(); i++)
    {
        int k = (int)i - indexDifference;
        if (k >= 0)
        {
            if (nums[k] < min_val.first)
            {
                min_val.first = nums[k];
                min_val.second = k;
            }
            if (nums[k] > max_val.first)
            {
                max_val.first = nums[k];
                max_val.second = k;
            }
        }
        if (nums[i] - min_val.first >= valueDifference)
        {
            result[0] = min_val.second;
            result[1] = i;
            break;
        }
        else if (max_val.first - nums[i] >= valueDifference)
        {
            result[0] = max_val.second;
            result[1] = i;
            break;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2913. Subarrays Distinct Element Sum of Squares I
/// 
/// Easy
///
/// You are given a 0-indexed integer array nums.
///
/// The distinct count of a subarray of nums is defined as:
/// 
/// Let nums[i..j] be a subarray of nums consisting of all the indices 
/// from i to j such that 0 <= i <= j < nums.length. Then the number of 
/// distinct values in nums[i..j] is called the distinct count of 
/// nums[i..j].
/// Return the sum of the squares of distinct counts of all subarrays 
/// of nums.
///
/// A subarray is a contiguous non-empty sequence of elements within an 
/// array.
///
/// Example 1:
/// Input: nums = [1,2,1]
/// Output: 15
/// Explanation: Six possible subarrays are:
/// [1]: 1 distinct value
/// [2]: 1 distinct value
/// [1]: 1 distinct value
/// [1,2]: 2 distinct values
/// [2,1]: 2 distinct values
/// [1,2,1]: 2 distinct values
/// The sum of the squares of the distinct counts in all subarrays is 
/// equal to 12 + 12 + 12 + 22 + 22 + 22 = 15.
///
/// Example 2:
/// Input: nums = [1,1]
/// Output: 3
/// Explanation: Three possible subarrays are:
/// [1]: 1 distinct value
/// [1]: 1 distinct value
/// [1,1]: 1 distinct value
/// The sum of the squares of the distinct counts in all subarrays is 
/// equal to 12 + 12 + 12 = 3.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 100
/// 2. 1 <= nums[i] <= 100
/// </summary>
int LeetCodeArray::sumCounts(vector<int>& nums)
{
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        unordered_set<int> num_count;
        for (size_t j = i; j < nums.size(); j++)
        {
            num_count.insert(nums[j]);
            int k = num_count.size();
            result = result + k * k;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2914. Minimum Number of Changes to Make Binary String 
///                 Beautiful
/// 
/// Medium
///
/// You are given a 0-indexed binary string s having an even length.
///
/// A string is beautiful if it's possible to partition it into one 
/// or more substrings such that:
///
/// Each substring has an even length.
/// Each substring contains only 1's or only 0's.
/// You can change any character in s to 0 or 1.
///
/// Return the minimum number of changes required to make the string s 
/// beautiful.
///
/// Example 1:
/// Input: s = "1001"
/// Output: 2
/// Explanation: We change s[1] to 1 and s[3] to 0 to get string "1100".
/// It can be seen that the string "1100" is beautiful because we can 
/// partition it into "11|00".
/// It can be proven that 2 is the minimum number of changes needed to 
/// make the string beautiful.
///
/// Example 2:
/// Input: s = "10"
/// Output: 1
/// Explanation: We change s[1] to 1 to get string "11".
/// It can be seen that the string "11" is beautiful because we can 
/// partition it into "11".
/// It can be proven that 1 is the minimum number of changes needed to 
/// make the string beautiful.
///
/// Example 3:
/// Input: s = "0000"
/// Output: 0
/// Explanation: We don't need to make any changes as the string "0000" 
/// is beautiful already.
///  
/// Constraints:
/// 1. 2 <= s.length <= 10^5
/// 2. s has an even length.
/// 3. s[i] is either '0' or '1'.
/// </summary>
int LeetCodeArray::minChanges(string s)
{
    int result = 0;
    int count = 0;
    for (size_t i = 0; i < s.size(); i++)
    {
        if (count == 0)
        {
            count++;
        }
        else if (s[i] == s[i - 1])
        {
            count++;
        }
        else
        {
            if (count % 2 == 1)
            {
                result++;
                count = 0;
            }
            else
            {
                count = 1;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2923. Find Champion I
///  
/// Easy
///
/// There are n teams numbered from 0 to n - 1 in a tournament.
///
/// Given a 0-indexed 2D boolean matrix grid of size n * n. For all i, j 
/// that 0 <= i, j <= n - 1 and i != j team i is stronger than team j if 
/// grid[i][j] == 1, otherwise, team j is stronger than team i.
///
/// Team a will be the champion of the tournament if there is no team b 
/// that is stronger than team a.
///
/// Return the team that will be the champion of the tournament.
///
/// Example 1:
/// Input: grid = [[0,1],[0,0]]
/// Output: 0
/// Explanation: There are two teams in this tournament.
/// grid[0][1] == 1 means that team 0 is stronger than team 1. So team 0 
/// will be the champion.
///
/// Example 2:
/// Input: grid = [[0,0,1],[1,0,1],[0,0,0]]
/// Output: 1
/// Explanation: There are three teams in this tournament.
/// grid[1][0] == 1 means that team 1 is stronger than team 0.
/// grid[1][2] == 1 means that team 1 is stronger than team 2.
/// So team 1 will be the champion.
///
/// Constraints:
/// 1. n == grid.length
/// 2. n == grid[i].length
/// 3. 2 <= n <= 100
/// 4. grid[i][j] is either 0 or 1.
/// 5. For all i, j that i != j, grid[i][j] != grid[j][i].
/// 6. The input is generated such that if team a is stronger than team b 
///    and team b is stronger than team c, then team a is stronger than 
///    team c.
/// </summary>
int LeetCodeArray::findChampion(vector<vector<int>>& grid)
{
    int n = grid[0].size();
    for (int i = 0; i < n; i++)
    {
        int count = 0;
        for (int j = 0; j < n; j++)
        {
            if (grid[i][j] == 0) count++;
        }
        if (count == 1) return i;
    }
    return -1;
}

/// <summary>
/// Leet Code 2934. Minimum Operations to Maximize Last Elements in Arrays
///  
/// Medium
///
/// You are given two 0-indexed integer arrays, nums1 and nums2, both 
/// having length n.
/// 
/// You are allowed to perform a series of operations (possibly none).
///
/// In an operation, you select an index i in the range [0, n - 1] and 
/// swap the values of nums1[i] and nums2[i].
///
/// Your task is to find the minimum number of operations required to 
/// satisfy the following conditions:
///
/// nums1[n - 1] is equal to the maximum value among all elements of 
/// nums1, i.e., nums1[n - 1] = max(nums1[0], nums1[1], ..., nums1[n - 1]).
/// nums2[n - 1] is equal to the maximum value among all elements of 
/// nums2, i.e., nums2[n - 1] = max(nums2[0], nums2[1], ..., nums2[n - 1]).
/// Return an integer denoting the minimum number of operations needed to 
/// meet both conditions, or -1 if it is impossible to satisfy both 
/// conditions.
/// 
/// Example 1:
/// Input: nums1 = [1,2,7], nums2 = [4,5,3]
/// Output: 1
/// Explanation: In this example, an operation can be performed using 
/// index i = 2.
/// When nums1[2] and nums2[2] are swapped, nums1 becomes [1,2,3] and 
/// nums2 becomes [4,5,7].
/// Both conditions are now satisfied.
/// It can be shown that the minimum number of operations needed to be 
/// performed is 1.
/// So, the answer is 1.
///
/// Example 2:
/// Input: nums1 = [2,3,4,5,9], nums2 = [8,8,4,4,4]
/// Output: 2
/// Explanation: In this example, the following operations can be 
/// performed:
/// First operation using index i = 4.
/// When nums1[4] and nums2[4] are swapped, nums1 becomes [2,3,4,5,4], and 
/// nums2 becomes [8,8,4,4,9].
/// Another operation using index i = 3.
/// When nums1[3] and nums2[3] are swapped, nums1 becomes [2,3,4,4,4], and 
/// nums2 becomes [8,8,4,5,9].
/// Both conditions are now satisfied.
/// It can be shown that the minimum number of operations needed to be 
/// performed is 2.
/// So, the answer is 2.   
///
/// Example 3:
/// Input: nums1 = [1,5,4], nums2 = [2,5,3]
/// Output: -1
/// Explanation: In this example, it is not possible to satisfy both 
/// conditions. 
/// So, the answer is -1.
///
/// Constraints:
/// 1. 1 <= n == nums1.length == nums2.length <= 1000
/// 2. 1 <= nums1[i] <= 10^9
/// 3. 1 <= nums2[i] <= 10^9
/// </summary>
int LeetCodeArray::minOperationsSwap(vector<int>& nums1, vector<int>& nums2)
{
    int n = nums1.size();
    vector<int> count(2);
    int max_end = max(nums1[n - 1], nums2[n - 1]);
    int min_end = min(nums1[n - 1], nums2[n - 1]);
    if (min_end == nums1[n - 1]) count[1]++;
    else count[0]++;
    for (int i = 0; i < n - 1; i++)
    {
        if (max(nums1[i], nums2[i]) > max_end) return -1;
        if (min(nums1[i], nums2[i]) > min_end) return -1;
        if (nums1[i] > min_end)
        {
            count[0]++;
        }
        if (nums2[i] > min_end)
        {
            count[1]++;
        }
    }
    return min(count[0], count[1]);
}

/// <summary>
/// Leet Code 2938. Separate Black and White Balls
///  
/// Medium
///
/// There are n balls on a table, each ball has a color black or white.
///
/// You are given a 0-indexed binary string s of length n, where 1 and 0 
/// represent black and white balls, respectively.
///
/// In each step, you can choose two adjacent balls and swap them.
///
/// Return the minimum number of steps to group all the black balls to the 
/// right and all the white balls to the left.
/// 
/// Example 1:
/// Input: s = "101"
/// Output: 1
/// Explanation: We can group all the black balls to the right in the 
/// following way:
/// - Swap s[0] and s[1], s = "011".
/// Initially, 1s are not grouped together, requiring at least 1 step to 
/// group them to the right.
///
/// Example 2:
/// Input: s = "100"
/// Output: 2
/// Explanation: We can group all the black balls to the right in the 
/// following way:
/// - Swap s[0] and s[1], s = "010".
/// - Swap s[1] and s[2], s = "001".
/// It can be proven that the minimum number of steps needed is 2.
///
/// Example 3:
/// Input: s = "0111"
/// Output: 0
/// Explanation: All the black balls are already grouped to the right.
/// 
/// Constraints:
/// 1. 1 <= n == s.length <= 10^5
/// 2. s[i] is either '0' or '1'.
/// </summary>
long long LeetCodeArray::minimumSteps(string s)
{
    int one = 0;
    long long result = 0;
    for (size_t i = 0; i < s.size(); i++)
    {
        if (s[i] == '1') one++;
        else (result += (long long)one);
    }
    return result;
}

/// <summary>
/// Leet Code 2946. Matrix Similarity After Cyclic Shifts
///  
/// Easy
///
/// You are given a 0-indexed m x n integer matrix mat and an integer k. You 
/// have to cyclically right shift odd indexed rows k times and cyclically 
/// left shift even indexed rows k times.
///
/// Return true if the initial and final matrix are exactly the same and false 
/// otherwise.
/// 
/// Example 1:
/// Input: mat = [[1,2,1,2],[5,5,5,5],[6,3,6,3]], k = 2
/// Output: true
/// Explanation:
/// Initially, the matrix looks like the first figure. 
/// Second figure represents the state of the matrix after one right and left 
/// cyclic shifts to even and odd indexed rows.
/// Third figure is the final state of the matrix after two cyclic shifts 
/// which is similar to the initial matrix.
/// Therefore, return true.
///
/// Example 2:
/// Input: mat = [[2,2],[2,2]], k = 3
/// Output: true
/// Explanation: As all the values are equal in the matrix, even after 
/// performing cyclic shifts the matrix will remain the same. Therefeore, 
/// we return true.
///
/// Example 3:
/// Input: mat = [[1,2]], k = 1
/// Output: false
/// Explanation: After one cyclic shift, mat = [[2,1]] which is not equal 
/// to the initial matrix. Therefore we return false.
/// 
/// Constraints:
/// 1. 1 <= mat.length <= 25
/// 2. 1 <= mat[i].length <= 25
/// 3. 1 <= mat[i][j] <= 25
/// 4. 1 <= k <= 50
/// </summary>
bool LeetCodeArray::areSimilar(vector<vector<int>>& mat, int k)
{
    int n = mat[0].size();
    k = k % n;
    for (size_t i = 0; i < mat.size(); i++)
    {
        for (size_t j = 0; j < mat[i].size(); j++)
        {
            if (i % 2 == 0)
            {
                if (mat[i][j] != mat[i][(j + k) % n])
                {
                    return false;
                }
            }
            else
            {
                if (mat[i][j] != mat[i][(j - k + n) % n])
                {
                    return false;
                }
            }
        }
    }
    return true;
}

/// <summary>
/// Leet Code 2945. Find Maximum Non-decreasing Array Length
///  
/// Hard
///
/// You are given a 0-indexed integer array nums.
///
/// You can perform any number of operations, where each operation involves 
/// selecting a subarray of the array and replacing it with the sum of its 
/// elements. For example, if the given array is [1,3,5,6] and you select 
/// subarray [3,5] the array will convert to [1,8,6].
///
/// Return the maximum length of a non-decreasing array that can be made after 
/// applying operations.
///
/// A subarray is a contiguous non-empty sequence of elements within an array.
///
/// Example 1:
/// Input: nums = [5,2,2]
/// Output: 1
/// Explanation: This array with length 3 is not non-decreasing.
/// We have two ways to make the array length two.
/// First, choosing subarray [2,2] converts the array to [5,4].
/// Second, choosing subarray [5,2] converts the array to [7,2].
/// In these two ways the array is not non-decreasing.
/// And if we choose subarray [5,2,2] and replace it with [9] it becomes 
/// non-decreasing. 
/// So the answer is 1.
///
/// Example 2:
/// Input: nums = [1,2,3,4]
/// Output: 4
/// Explanation: The array is non-decreasing. So the answer is 4.
///
/// Example 3:
/// Input: nums = [4,3,2,6]
/// Output: 3
/// Explanation: Replacing [3,2] with [5] converts the given array to [4,5,6] 
/// that is non-decreasing.
/// Because the given array is not non-decreasing, the maximum possible 
/// answer is 3.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^5
/// </summary>
int LeetCodeArray::findMaximumLength(vector<int>& nums)
{
    vector<vector<long long>> arr = { {0, 0, 0} };
    size_t p = 0;
    long long sum = 0;
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        sum += nums[i];
        p = min(p, arr.size() - 1);
        while (p < arr.size())
        {
            if (sum - arr[p][0] < arr[p][1])
            {
                break;
            }
            p++;
        }
        long long last = sum - arr[p - 1][0];
        int count = (int)(arr[p-1][2] + 1);
        while (arr.back()[0] + arr.back()[1] > sum + last)
        {
            arr.pop_back();
        }
        arr.push_back({ sum, last, count });
        result = max(result, (int)count);
    }
    return result;
}

/// <summary>
/// Leet Code 2950. Number of Divisible Substrings
///  
/// Medium
///
/// Each character of the English alphabet has been mapped to a digit as shown 
/// below.
///
/// A string is divisible if the sum of the mapped values of its characters is 
/// divisible by its length.
///
/// Given a string s, return the number of divisible substrings of s.
///
/// A substring is a contiguous non-empty sequence of characters within a string.
///
/// Example 1:
/// Substring   Mapped  Sum Length  Divisible?
/// a   1   1   1   Yes
/// s   7   7   1   Yes
/// d   2   2   1   Yes
/// f   3   3   1   Yes
/// as  1,  7   8   2   Yes
/// sd  7, 2    9   2   No
/// df  2, 3    5   2   No
/// asd 1, 7, 2 10  3   No
/// sdf 7, 2, 3 12  3   Yes
/// asdf    1, 7, 2, 3  13  4   No
/// Input: word = "asdf"
/// Output: 6
/// Explanation: The table above contains the details about every substring of 
/// word, and we can see that 6 of them are divisible.
///
/// Example 2:
/// Input: word = "bdh"
/// Output: 4
/// Explanation: The 4 divisible substrings are: "b", "d", "h", "bdh".
/// It can be shown that there are no other substrings of word that are 
/// divisible.
///
/// Example 3:
/// Input: word = "abcd"
/// Output: 6
/// Explanation: The 6 divisible substrings are: "a", "b", "c", "d", "ab", 
/// "cd".
/// It can be shown that there are no other substrings of word that are 
/// divisible.
/// 
/// Constraints:
/// 1. 1 <= word.length <= 2000
/// </summary>
int LeetCodeArray::countDivisibleSubstrings(string word)
{
    unordered_map<char, int> char_map =
    {
        {'a', 1}, {'b', 1}, {'c', 2}, {'d', 2}, {'e', 2}, {'f', 3}, {'g', 3}, {'h', 3},
        {'i', 4}, {'j', 4}, {'k', 4}, {'l', 5}, {'m', 5}, {'n', 5}, {'o', 6}, {'p', 6}, {'q', 6}, 
        {'r', 7}, {'s', 7}, {'t', 7}, {'u', 8}, {'v', 8}, {'w', 8}, {'x', 9}, {'y', 9}, {'z', 9}
    };
    vector<int> dp(word.size() + 1);
    int result = 0;
    for (int i = 0; i < (int)word.size(); i++)
    {
        dp[i + 1] = char_map[word[i]];
        dp[i + 1] += dp[i];
        for (int j = 0; j < i + 1; j++)
        {
            if ((dp[i + 1] - dp[j]) % (i + 1 - j) == 0)
            {
                result++;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2947. Count Beautiful Substrings I
///  
/// Medium
///
/// You are given a string s and a positive integer k.
///
/// Let vowels and consonants be the number of vowels and consonants in a 
/// string.
///
/// A string is beautiful if:
///
/// vowels == consonants.
/// (vowels * consonants) % k == 0, in other terms the multiplication of 
/// vowels and consonants is divisible by k.
/// Return the number of non-empty beautiful substrings in the given string s.
///
/// A substring is a contiguous sequence of characters in a string.
/// Vowel letters in English are 'a', 'e', 'i', 'o', and 'u'.
/// Consonant letters in English are every letter except vowels.
///
/// Example 1:
/// Input: s = "baeyh", k = 2
/// Output: 2
/// Explanation: There are 2 beautiful substrings in the given string.
/// - Substring "baeyh", vowels = 2 (["a",e"]), consonants = 2 (["y","h"]).
/// You can see that string "aeyh" is beautiful as vowels == consonants and 
/// vowels * consonants % k == 0.
/// - Substring "baeyh", vowels = 2 (["a",e"]), consonants = 2 (["b","y"]). 
/// You can see that string "baey" is beautiful as vowels == consonants and 
/// vowels * consonants % k == 0.
/// It can be shown that there are only 2 beautiful substrings in the given 
/// string.
///
/// Example 2:
/// Input: s = "abba", k = 1
/// Output: 3
/// Explanation: There are 3 beautiful substrings in the given string.
/// - Substring "abba", vowels = 1 (["a"]), consonants = 1 (["b"]). 
/// - Substring "abba", vowels = 1 (["a"]), consonants = 1 (["b"]).
/// - Substring "abba", vowels = 2 (["a","a"]), consonants = 2 (["b","b"]).
/// It can be shown that there are only 3 beautiful substrings in the given 
/// string.
///
/// Example 3:
/// Input: s = "bcdf", k = 1
/// Output: 0
/// Explanation: There are no beautiful substrings in the given string.
/// 
/// Constraints:
/// 1. 1 <= s.length <= 1000
/// 2. 1 <= k <= 1000
/// 3. s consists of only English lowercase letters.
/// </summary>
int LeetCodeArray::beautifulSubstrings(string s, int k)
{
    unordered_map<int, unordered_map<int, int>> hash_map;
    unordered_set vowels = { 'a', 'e', 'i', 'o', 'u' };
    int vowel_count = 0;
    int consonant_count = 0;
    unordered_map<int, int> prime_count;
    for (int i = 2; i <= k; i++)
    {
        while (k % i == 0) { prime_count[i]++; k /= i; }
    }
    int prime = 1;
    for (auto itr : prime_count)
    {
        for (int i = 0; i < (itr.second + 1) / 2; i++)
        {
            prime *= itr.first;
        }
    }
    int result = 0;
    hash_map[0][0] = 1;
    for (size_t i = 0; i < s.size(); i++)
    {
        if (vowels.count(s[i]) > 0)
        {
            vowel_count++;
        }
        else
        {
            consonant_count++;
        }
        int diff = vowel_count - consonant_count;
        int min_val = min(vowel_count, consonant_count);
        if (min_val != 0)
        {
            result += hash_map[diff][min_val % prime];
        }
        hash_map[diff][min_val % prime]++;
    }
    return result;
}

/// <summary>
/// Leet Code 2949. Count Beautiful Substrings II
///  
/// Hard
///
/// You are given a string s and a positive integer k.
/// 
/// Let vowels and consonants be the number of vowels and consonants in a 
/// string.
///
/// A string is beautiful if:
///
/// vowels == consonants.
/// (vowels * consonants) % k == 0, in other terms the multiplication of 
/// vowels and consonants is divisible by k.
/// Return the number of non-empty beautiful substrings in the given string s.
///
/// A substring is a contiguous sequence of characters in a string.
///
/// Vowel letters in English are 'a', 'e', 'i', 'o', and 'u'.
///
/// Consonant letters in English are every letter except vowels.
/// 
/// Example 1:
///
/// Input: s = "baeyh", k = 2
/// Output: 2
/// Explanation: There are 2 beautiful substrings in the given string.
/// - Substring "baeyh", vowels = 2 (["a",e"]), consonants = 2 (["y","h"]).
/// You can see that string "aeyh" is beautiful as vowels == consonants and 
/// vowels * consonants % k == 0.
/// - Substring "baeyh", vowels = 2 (["a",e"]), consonants = 2 (["b","y"]).
/// You can see that string "baey" is beautiful as vowels == consonants and 
/// vowels * consonants % k == 0.
/// It can be shown that there are only 2 beautiful substrings in the given 
/// string.
///
/// Example 2:
/// Input: s = "abba", k = 1
/// Output: 3
/// Explanation: There are 3 beautiful substrings in the given string.
/// - Substring "abba", vowels = 1 (["a"]), consonants = 1 (["b"]).
/// - Substring "abba", vowels = 1 (["a"]), consonants = 1 (["b"]).
/// - Substring "abba", vowels = 2 (["a","a"]), consonants = 2 (["b","b"]).
/// It can be shown that there are only 3 beautiful substrings in the given 
/// string.
///
/// Example 3:
/// Input: s = "bcdf", k = 1
/// Output: 0
/// Explanation: There are no beautiful substrings in the given string.
/// 
/// Constraints:
/// 1. 1 <= s.length <= 5 * 10^4
/// 2. 1 <= k <= 1000
/// 3. s consists of only English lowercase letters.
/// </summary>
long long LeetCodeArray::beautifulSubstringsII(string s, int k)
{
    unordered_map<int, unordered_map<int, long long>> hash_map;
    unordered_set vowels = { 'a', 'e', 'i', 'o', 'u' };
    int vowel_count = 0;
    int consonant_count = 0;
    unordered_map<int, int> prime_count;
    for (int i = 2; i <= k; i++)
    {
        while (k % i == 0) { prime_count[i]++; k /= i; }
    }
    int prime = 1;
    for (auto itr : prime_count)
    {
        for (int i = 0; i < (itr.second + 1) / 2; i++)
        {
            prime *= itr.first;
        }
    }
    long long result = 0;
    hash_map[0][0] = 1;
    for (size_t i = 0; i < s.size(); i++)
    {
        if (vowels.count(s[i]) > 0)
        {
            vowel_count++;
        }
        else
        {
            consonant_count++;
        }
        int diff = vowel_count - consonant_count;
        int min_val = min(vowel_count, consonant_count);
        if (min_val != 0)
        {
            result += hash_map[diff][min_val % prime];
        }
        hash_map[diff][min_val % prime]++;
    }
    return result;
}

/// <summary>
/// Leet Code 2951. Find the Peaks
///  
/// Easy
/// You are given a 0-indexed array mountain. Your task is to find all the 
/// peaks in the mountain array.
///
/// Return an array that consists of indices of peaks in the given array in 
/// any order.
///
/// Notes:
///
/// A peak is defined as an element that is strictly greater than its 
/// neighboring elements.
/// The first and last elements of the array are not a peak.
/// 
/// Example 1:
/// Input: mountain = [2,4,4]
/// Output: []
/// Explanation: mountain[0] and mountain[2] can not be a peak because they 
/// are first and last elements of the array.
/// mountain[1] also can not be a peak because it is not strictly greater than 
/// mountain[2].
/// So the answer is [].
///
/// Example 2:
/// Input: mountain = [1,4,3,8,5]
/// Output: [1,3]
/// Explanation: mountain[0] and mountain[4] can not be a peak because they 
/// are first and last elements of the array.
/// mountain[2] also can not be a peak because it is not strictly greater 
/// than mountain[3] and mountain[1].
/// But mountain [1] and mountain[3] are strictly greater than their 
/// neighboring elements.
/// So the answer is [1,3].
/// 
/// Constraints:
/// 1. 3 <= mountain.length <= 100
/// 2. 1 <= mountain[i] <= 100
/// </summary>
vector<int> LeetCodeArray::findPeaks(vector<int>& mountain)
{
    vector<int> result;
    for (int i = 1; i < (int)mountain.size() - 1; i++)
    {
        if (mountain[i] > mountain[i - 1] && mountain[i] > mountain[i + 1])
        {
            result.push_back(i);
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2955. Number of Same-End Substrings
///  
/// Medium
///
/// You are given a 0-indexed string s, and a 2D array of integers queries, 
/// where queries[i] = [li, ri] indicates a substring of s starting from the 
/// index li and ending at the index ri (both inclusive), i.e. s[li..ri].
///
/// Return an array ans where ans[i] is the number of same-end substrings 
/// of queries[i].
///
/// A 0-indexed string t of length n is called same-end if it has the same 
/// character at both of its ends, i.e., t[0] == t[n - 1].
///
/// A substring is a contiguous non-empty sequence of characters within a 
/// string.
///
/// Example 1:
/// Input: s = "abcaab", queries = [[0,0],[1,4],[2,5],[0,5]]
/// Output: [1,5,5,10]
/// Explanation: Here is the same-end substrings of each query:
/// 1st query: s[0..0] is "a" which has 1 same-end substring: "a".
/// 2nd query: s[1..4] is "bcaa" which has 5 same-end substrings: "bcaa", 
/// "bcaa", "bcaa", "bcaa", "bcaa".
/// 3rd query: s[2..5] is "caab" which has 5 same-end substrings: "caab", 
/// "caab", "caab", "caab", "caab".
/// 4th query: s[0..5] is "abcaab" which has 10 same-end substrings: "abcaab", 
/// "abcaab", "abcaab", "abcaab", "abcaab", "abcaab", "abcaab", "abcaab", 
/// "abcaab", "abcaab".
///
/// Example 2:
/// Input: s = "abcd", queries = [[0,3]]
/// Output: [4]
/// Explanation: The only query is s[0..3] which is "abcd". It has 4 same-
/// end substrings: "abcd", "abcd", "abcd", "abcd".
/// 
/// Constraints:
/// 1. 2 <= s.length <= 3 * 10^4
/// 2. s consists only of lowercase English letters.
/// 3. 1 <= queries.length <= 3 * 10^4
/// 4. queries[i] = [li, ri]
/// 5. 0 <= li <= ri < s.length
/// </summary>
vector<int> LeetCodeArray::sameEndSubstringCount(string s, vector<vector<int>>& queries)
{
    vector<vector<int>> char_count(s.size() + 1, vector<int>(26));
    for (size_t i = 0; i < s.size(); i++)
    {
        char_count[i + 1][s[i] - 'a'] = 1;
        for (int j = 0; j < 26; j++)
        {
            char_count[i + 1][j] += char_count[i][j];
        }
    }
    vector<int> result(queries.size());
    for (size_t i = 0; i < queries.size(); i++)
    {
        int count = 0;
        int first = queries[i][0];
        int second = queries[i][1] + 1;
        for (int j = 0; j < 26; j++)
        {
            int diff = char_count[second][j] - char_count[first][j];
            result[i] += (1 + diff)* diff / 2;
        }
    }
    return result;
}


/// <summary>
/// Leet Code 2960. Count Tested Devices After Test Operations
///  
/// Hard
///
/// You are given a 0-indexed integer array batteryPercentages having length 
/// n, denoting the battery percentages of n 0-indexed devices.
///
/// Your task is to test each device i in order from 0 to n - 1, by performing 
/// the following test operations:
///
/// If batteryPercentages[i] is greater than 0:
/// Increment the count of tested devices.
/// Decrease the battery percentage of all devices with indices j in the 
/// range [i + 1, n - 1] by 1, ensuring their battery percentage never goes 
/// below 0, i.e, batteryPercentages[j] = max(0, batteryPercentages[j] - 1).
/// Move to the next device.
// Otherwise, move to the next device without performing any test.
/// Return an integer denoting the number of devices that will be tested after 
/// performing the test operations in order.
/// 
/// Example 1:
/// Input: batteryPercentages = [1,1,2,1,3]
/// Output: 3
/// Explanation: Performing the test operations in order starting from 
/// device 0:
/// At device 0, batteryPercentages[0] > 0, so there is now 1 tested device, 
/// and batteryPercentages becomes [1,0,1,0,2].
/// At device 1, batteryPercentages[1] == 0, so we move to the next device 
/// without testing.
/// At device 2, batteryPercentages[2] > 0, so there are now 2 tested devices, 
/// and batteryPercentages becomes [1,0,1,0,1].
/// At device 3, batteryPercentages[3] == 0, so we move to the next device 
/// without testing.
/// At device 4, batteryPercentages[4] > 0, so there are now 3 tested devices, 
/// and batteryPercentages stays the same.
/// So, the answer is 3.
///
/// Example 2:
/// Input: batteryPercentages = [0,1,2]
/// Output: 2
/// Explanation: Performing the test operations in order starting from 
/// device 0:
/// At device 0, batteryPercentages[0] == 0, so we move to the next device 
/// without testing.
/// At device 1, batteryPercentages[1] > 0, so there is now 1 tested device, 
/// and batteryPercentages becomes [0,1,1].
/// At device 2, batteryPercentages[2] > 0, so there are now 2 tested 
/// devices, and batteryPercentages stays the same.
/// So, the answer is 2.
/// 
/// Constraints:
/// 1. 1 <= n == batteryPercentages.length <= 100 
/// 2. 0 <= batteryPercentages[i] <= 100
/// </summary>
int LeetCodeArray::countTestedDevices(vector<int>& batteryPercentages)
{
    int deduct = 0;
    int result = 0;
    for (size_t i = 0; i < batteryPercentages.size(); i++)
    {
        if (batteryPercentages[i] - deduct > 0)
        {
            result++;
            deduct++;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2962. Count Subarrays Where Max Element Appears at Least K Times
///  
/// Medium
///
/// You are given an integer array nums and a positive integer k.
///
/// Return the number of subarrays where the maximum element of nums appears 
/// at least k times in that subarray.
///
/// A subarray is a contiguous sequence of elements within an array.
/// 
/// Example 1:
/// Input: nums = [1,3,2,3,3], k = 2
/// Output: 6
/// Explanation: The subarrays that contain the element 3 at least 2 times 
/// are: [1,3,2,3], [1,3,2,3,3], [3,2,3], [3,2,3,3], [2,3,3] and [3,3].
///
/// Example 2:
/// Input: nums = [1,4,2,1], k = 3
/// Output: 0
/// Explanation: No subarray contains the element 4 at least 3 times.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^6
/// 3. 1 <= k <= 10^5
/// </summary>
long long LeetCodeArray::countSubarraysMaxValue(vector<int>& nums, int k)
{
    int max_val = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        max_val = max(max_val, nums[i]);
    }
    long long result = 0;
    vector<int> dp;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] == max_val) dp.push_back(i);
        if ((int)dp.size() >= k)
        {
            result += (long long)dp[dp.size() - k] + 1;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2963. Count the Number of Good Partitions
///  
/// Hard
///
/// You are given a 0-indexed array nums consisting of positive integers.
/// 
/// A partition of an array into one or more contiguous subarrays is called 
/// good if no two subarrays contain the same number.
///
/// Return the total number of good partitions of nums.
///
/// Since the answer may be large, return it modulo 10^9 + 7.
/// 
/// Example 1:
/// Input: nums = [1,2,3,4]
/// Output: 8
/// Explanation: The 8 possible good partitions are: ([1], [2], [3], [4]), 
/// ([1], [2], [3,4]), ([1], [2,3], [4]), ([1], [2,3,4]), ([1,2], [3], [4]), 
/// ([1,2], [3,4]), ([1,2,3], [4]), and ([1,2,3,4]).
///
/// Example 2:
/// Input: nums = [1,1,1,1]
/// Output: 1
/// Explanation: The only possible good partition is: ([1,1,1,1]).
///
/// Example 3:
/// Input: nums = [1,2,1,3]
/// Output: 2
/// Explanation: The 2 possible good partitions are: ([1,2,1], [3]) 
/// and ([1,2,1,3]).
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^9
/// </summary>
int LeetCodeArray::numberOfGoodPartitions(vector<int>& nums)
{
    unordered_map<int, int> num_count;
    for (size_t i = 0; i < nums.size(); i++)
    {
        num_count[nums[i]]++;
    }
    unordered_set<int> num_exist;
    int partition = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        int n = nums[i];
        num_exist.insert(n);
        num_count[n]--;
        if (num_count[n] == 0)
        {
            num_exist.erase(n);
        }
        if (num_exist.empty()) partition++;
    }
    int result = 1;
    int M = 1000000007;
    for (int i = 0; i < partition - 1; i++)
    {
        result = result * 2 % M;
    }
    return result;
}

/// <summary>
/// Leet Code 2965. Find Missing and Repeated Values
///  
/// Easy
///
/// You are given a 0-indexed 2D integer matrix grid of size n * n with values 
/// in the range [1, n^2]. Each integer appears exactly once except a which 
/// appears twice and b which is missing. The task is to find the repeating 
/// and missing numbers a and b.
///
/// Return a 0-indexed integer array ans of size 2 where ans[0] equals to a 
/// and ans[1] equals to b.
///
/// Example 1:
/// Input: grid = [[1,3],[2,2]]
/// Output: [2,4]
/// Explanation: Number 2 is repeated and number 4 is missing so the answer 
/// is [2,4].
///
/// Example 2:
/// Input: grid = [[9,1,7],[8,9,2],[3,4,6]]
/// Output: [9,5]
/// Explanation: Number 9 is repeated and number 5 is missing so the answer 
/// is [9,5].
/// 
/// Constraints:
/// 1. 2 <= n == grid.length == grid[i].length <= 50
/// 2. 1 <= grid[i][j] <= n * n
/// 3. For all x that 1 <= x <= n * n there is exactly one x that is not equal 
///    to any of the grid members.
/// 4. For all x that 1 <= x <= n * n there is exactly one x that is equal to 
///    exactly two of the grid members.
/// 5. For all x that 1 <= x <= n * n except two of them there is exatly one 
///    pair of i, j that 0 <= i, j <= n - 1 and grid[i][j] == x.
/// </summary>
vector<int> LeetCodeArray::findMissingAndRepeatedValues(vector<vector<int>>& grid)
{
    int n = grid.size();
    vector<int> dp(n * n + 1);
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            dp[grid[i][j]]++;
        }
    }
    vector<int> result(2);
    for (int i = 1; i <= n * n; i++)
    {
        if (dp[i] == 2)
        {
            result[0] = i;
        }
        else if (dp[i] == 0)
        {
            result[1] = i;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2966. Divide Array Into Arrays With Max Difference
///  
/// Medium
///
/// You are given an integer array nums of size n and a positive integer k.
/// Divide the array into one or more arrays of size 3 satisfying the 
/// following conditions:
///
/// Each element of nums should be in exactly one array.
/// The difference between any two elements in one array is less than or 
/// equal to k.
/// Return a 2D array containing all the arrays. If it is impossible to 
/// satisfy the conditions, return an empty array. And if there are multiple 
/// answers, return any of them.
/// 
/// Example 1:
/// Input: nums = [1,3,4,8,7,9,3,5,1], k = 2
/// Output: [[1,1,3],[3,4,5],[7,8,9]]
/// Explanation: We can divide the array into the following arrays: [1,1,3], 
/// [3,4,5] and [7,8,9].
/// The difference between any two elements in each array is less than or 
/// equal to 2.
/// Note that the order of elements is not important.
///
/// Example 2:
/// Input: nums = [1,3,3,2,7,3], k = 3
/// Output: []
/// Explanation: It is not possible to divide the array satisfying all the 
/// conditions.
/// 
/// Constraints:
/// 1. n == nums.length
/// 2. 1 <= n <= 10^5
/// 3. n is a multiple of 3.
/// 4. 1 <= nums[i] <= 10^5
/// 5. 1 <= k <= 10^5
/// </summary>
vector<vector<int>> LeetCodeArray::divideArray(vector<int>& nums, int k)
{
    vector<vector<int>> result;
    sort(nums.begin(), nums.end());
    for (size_t i = 2; i < nums.size(); i += 3)
    {
        if (nums[i] - nums[i - 2] > k)
        {
            return result;
        }
    }
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (i % 3 == 0)
        {
            result.push_back(vector<int>());
        }
        result.back().push_back(nums[i]);
    }
    return result;
}

/// <summary>
/// Leet Code 2971. Find Polygon With the Largest Perimeter
///  
/// Medium
///
/// You are given an array of positive integers nums of length n.
///
/// A polygon is a closed plane figure that has at least 3 sides. The longest 
/// side of a polygon is smaller than the sum of its other sides.
///
/// Conversely, if you have k (k >= 3) positive real numbers a1, a2, a3, ..., 
/// ak where a1 <= a2 <= a3 <= ... <= ak and a1 + a2 + a3 + ... + ak-1 > ak, 
/// then there always exists a polygon with k sides whose lengths are a1, a2, 
/// a3, ..., ak.
///
/// The perimeter of a polygon is the sum of lengths of its sides.
///
/// Return the largest possible perimeter of a polygon whose sides can be 
/// formed from nums, or -1 if it is not possible to create a polygon.
///
/// Example 1:
/// Input: nums = [5,5,5]
/// Output: 15
/// Explanation: The only possible polygon that can be made from nums has 3 
/// sides: 5, 5, and 5. The perimeter is 5 + 5 + 5 = 15.
///
/// Example 2:
/// Input: nums = [1,12,1,2,5,50,3]
/// Output: 12
/// Explanation: The polygon with the largest perimeter which can be made from 
/// nums has 5 sides: 1, 1, 2, 3, and 5. The perimeter 
/// is 1 + 1 + 2 + 3 + 5 = 12.
/// We cannot have a polygon with either 12 or 50 as the longest side because 
/// it is not possible to include 2 or more smaller sides that have a greater 
/// sum than either of them.
/// It can be shown that the largest possible perimeter is 12.
///
/// Example 3:
/// Input: nums = [5,5,50]
/// Output: -1
/// Explanation: There is no possible way to form a polygon from nums, as a 
/// polygon has at least 3 sides and 50 > 5 + 5.
/// 
/// Constraints:
/// 1. 3 <= n <= 10^5
/// 2. 1 <= nums[i] <= 10^9
/// </summary>
long long LeetCodeArray::largestPerimeter(vector<int>& nums)
{
    long long sum = 0;
    sort(nums.begin(), nums.end());
    for (auto x : nums) sum += (long long)x;
    for (int i = nums.size() - 1; i > 1; i--)
    {
        if (sum - nums[i] > nums[i]) return sum;
        sum -= nums[i];
    }
    return -1;
}

/// <summary>
/// Leet Code 2974. Minimum Number Game
///  
/// Easy
///
/// You are given a 0-indexed integer array nums of even length and there is 
/// also an empty array arr. Alice and Bob decided to play a game where in 
/// every round Alice and Bob will do one move. The rules of the game are as 
/// follows:
///
/// Every round, first Alice will remove the minimum element from nums, and 
/// then Bob does the same.
/// Now, first Bob will append the removed element in the array arr, and then 
/// Alice does the same.
/// The game continues until nums becomes empty.
/// Return the resulting array arr.
///
///
/// Example 1:
/// Input: nums = [5,4,2,3]
/// Output: [3,2,5,4]
/// Explanation: In round one, first Alice removes 2 and then Bob removes 3. 
/// Then in arr firstly Bob appends 3 and then Alice appends 2. So arr = [3,2].
/// At the begining of round two, nums = [5,4]. Now, first Alice removes 4 and 
/// then Bob removes 5. Then both append in arr which becomes [3,2,5,4].
///
/// Example 2:
/// Input: nums = [2,5]
/// Output: [5,2]
/// Explanation: In round one, first Alice removes 2 and then Bob removes 5. 
/// Then in arr firstly Bob appends and then Alice appends. So arr = [5,2].
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 100
/// 2. 1 <= nums[i] <= 100
/// 3. nums.length % 2 == 0
/// </summary>
vector<int> LeetCodeArray::numberGame(vector<int>& nums)
{
    vector<int> result = nums;
    sort(result.begin(), result.end());
    for (size_t i = 0; i < nums.size(); i += 2)
    {
        swap(result[i], result[i + 1]);
    }
    return result;
}

/// <summary>
/// Leet Code 2975. Maximum Square Area by Removing Fences From a Field
///  
/// Medium
///
/// There is a large (m - 1) x (n - 1) rectangular field with corners 
/// at (1, 1) and (m, n) containing some horizontal and vertical fences 
/// given in arrays hFences and vFences respectively.
///
/// Horizontal fences are from the coordinates (hFences[i], 1) to 
/// (hFences[i], n) and vertical fences are from the coordinates 
/// (1, vFences[i]) to (m, vFences[i]).
///
/// Return the maximum area of a square field that can be formed by 
/// removing some fences (possibly none) or -1 if it is impossible to make 
/// a square field.
///
/// Since the answer may be large, return it modulo 10^9 + 7.
///
/// Note: The field is surrounded by two horizontal fences from the 
/// coordinates (1, 1) to (1, n) and (m, 1) to (m, n) and two vertical fences 
/// from the coordinates (1, 1) to (m, 1) and (1, n) to (m, n). These fences 
/// cannot be removed.
/// 
/// Example 1:
/// Input: m = 4, n = 3, hFences = [2,3], vFences = [2]
/// Output: 4
/// Explanation: Removing the horizontal fence at 2 and the vertical fence 
/// at 2 will give a square field of area 4.
///
/// Example 2:
/// Input: m = 6, n = 7, hFences = [2], vFences = [4]
/// Output: -1
/// Explanation: It can be proved that there is no way to create a square 
/// field by removing fences.
/// 
/// Constraints:
/// 1. 3 <= m, n <= 10^9
/// 2. 1 <= hFences.length, vFences.length <= 600
/// 3. 1 < hFences[i] < m
/// 4. 1 < vFences[i] < n
/// 5. hFences and vFences are unique.
/// </summary>
int LeetCodeArray::maximizeSquareArea(int m, int n, vector<int>& hFences, vector<int>& vFences)
{
    sort(hFences.begin(), hFences.end());
    sort(vFences.begin(), vFences.end());
    int first = 1;
    int last = min(m - 1, n - 1);
    vector<int> h_fences = { 1 };
    for (size_t i = 0; i < hFences.size(); i++)
    {
        h_fences.push_back(hFences[i]);
    }
    h_fences.push_back(m);

    vector<int> v_fences = { 1 };
    for (size_t i = 0; i < vFences.size(); i++)
    {
        v_fences.push_back(vFences[i]);
    }
    v_fences.push_back(n);
    set<int> h_sizes;
    for (size_t i = 0; i < h_fences.size(); i++)
    {
        for (size_t j = i + 1; j < h_fences.size(); j++)
        {
            h_sizes.insert(h_fences[j] - h_fences[i]);
        }
    }
    int result = -1;
    for (size_t i = 0; i < v_fences.size(); i++)
    {
        for (size_t j = i + 1; j < v_fences.size(); j++)
        {
            if (h_sizes.count(v_fences[j] - v_fences[i]) > 0)
            {
                result = max(result, v_fences[j] - v_fences[i]);
            }
        }
    }
    int M = 1000000007;
    if (result == -1) return result;
    else return (long long)result * (long long)result % M;
}

/// <summary>
/// Leet Code 2981. Find Longest Special Substring That Occurs Thrice I
///  
/// Medium
///
/// You are given a string s that consists of lowercase English letters.
///
/// A string is called special if it is made up of only a single character. 
/// For example, the string "abc" is not special, whereas the strings "ddd", 
/// "zz", and "f" are special.
///
/// Return the length of the longest special substring of s which occurs 
/// at least thrice, or -1 if no special substring occurs at least thrice.
///
/// A substring is a contiguous non-empty sequence of characters within a 
/// string.
/// 
/// Example 1:
/// Input: s = "aaaa"
/// Output: 2
/// Explanation: The longest special substring which occurs thrice is "aa": 
/// substrings "aaaa", "aaaa", and "aaaa".
/// It can be shown that the maximum length achievable is 2.
///
/// Example 2:
/// Input: s = "abcdef"
/// Output: -1
/// Explanation: There exists no special substring which occurs at least 
/// thrice. Hence return -1.
///
/// Example 3:
/// Input: s = "abcaba"
/// Output: 1
/// Explanation: The longest special substring which occurs thrice is 
/// "a": substrings "abcaba", "abcaba", and "abcaba".
/// It can be shown that the maximum length achievable is 1.
/// 
/// Constraints:
/// 1. 3 <= s.length <= 50
/// 2. s consists of only lowercase English letters.
/// </summary>
int LeetCodeArray::maximumLength(string s)
{
    vector<map<int, int>> len_count(26);
    int count = 0;
    for (size_t i = 0; i < s.size(); i++)
    {
        count++;
        if (i + 1 == s.size() || s[i] != s[i + 1])
        {
            len_count[s[i] - 'a'][count]++;
            count = 0;
        }
    }
    int result = -1;
    for (size_t i = 0; i < 26; i++)
    {
        pair<int, int> prev = { 0, 0 };
        while (!len_count[i].empty())
        {
            auto itr = len_count[i].rbegin();
            if (prev.second > 0)
            {
                itr->second += prev.second + prev.first - itr->first;
            }
            if ((itr->second == 1) && (itr->first >= 3))
            {
                result = max(result, itr->first - 2);
            }
            else if ((itr->second == 2) && (itr->first >= 2))
            {
                result = max(result, itr->first - 1);
            }
            else if (itr->second >= 3)
            {
                result = max(result, itr->first);
            }
            prev = { itr->first, itr->second };
            len_count[i].erase(itr->first);
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2982. Find Longest Special Substring That Occurs Thrice II
///  
/// Medium
///
/// You are given a string s that consists of lowercase English letters.
///
/// A string is called special if it is made up of only a single character. 
/// For example, the string "abc" is not special, whereas the strings "ddd", 
/// "zz", and "f" are special.
///
/// Return the length of the longest special substring of s which occurs at 
/// least thrice, or -1 if no special substring occurs at least thrice.
///
/// A substring is a contiguous non-empty sequence of characters within a 
/// string.
/// 
/// Example 1:
/// Input: s = "aaaa"
/// Output: 2
/// Explanation: The longest special substring which occurs thrice is "aa": 
/// substrings "aaaa", "aaaa", and "aaaa".
/// It can be shown that the maximum length achievable is 2.
///
/// Example 2:
/// Input: s = "abcdef"
/// Output: -1
/// Explanation: There exists no special substring which occurs at least 
/// thrice. Hence return -1.
///
/// Example 3:
/// Input: s = "abcaba"
/// Output: 1
/// Explanation: The longest special substring which occurs thrice is 
/// "a": substrings "abcaba", "abcaba", and "abcaba".
/// It can be shown that the maximum length achievable is 1.
///  
/// Constraints:
/// 1. 3 <= s.length <= 5 * 10^5
/// 2. s consists of only lowercase English letters.
/// </summary>
int LeetCodeArray::maximumLengthII(string s)
{
    vector<map<int, int>> len_count(26);
    int count = 0;
    for (size_t i = 0; i < s.size(); i++)
    {
        count++;
        if (i + 1 == s.size() || s[i] != s[i + 1])
        {
            len_count[s[i] - 'a'][count]++;
            count = 0;
        }
    }
    int result = -1;
    for (size_t i = 0; i < 26; i++)
    {
        pair<int, int> prev = { 0, 0 };
        while (!len_count[i].empty())
        {
            auto itr = len_count[i].rbegin();
            if (prev.second > 0)
            {
                itr->second += prev.second + prev.first - itr->first;
            }
            if ((itr->second == 1) && (itr->first >= 3))
            {
                result = max(result, itr->first - 2);
            }
            else if ((itr->second == 2) && (itr->first >= 2))
            {
                result = max(result, itr->first - 1);
            }
            else if (itr->second >= 3)
            {
                result = max(result, itr->first);
            }
            prev = { itr->first, itr->second };
            len_count[i].erase(itr->first);
        }
    }
    return result;
}

/// <summary>
/// Leet Code 2996. Smallest Missing Integer Greater Than Sequential 
///                 Prefix Sum
/// 
/// Easy
///
/// You are given a 0-indexed array of integers nums.
///
/// A prefix nums[0..i] is sequential if, for all 1 <= j <= i, 
/// nums[j] = nums[j - 1] + 1. In particular, the prefix consisting only 
/// of nums[0] is sequential.
///
/// Return the smallest integer x missing from nums such that x is greater 
/// than or equal to the sum of the longest sequential prefix.
///
/// Example 1:
/// Input: nums = [1,2,3,2,5]
/// Output: 6
/// Explanation: The longest sequential prefix of nums is [1,2,3] with a 
/// sum of 6. 6 is not in the array, therefore 6 is the smallest missing 
/// integer greater than or equal to the sum of the longest sequential 
/// prefix.
///
/// Example 2:
/// Input: nums = [3,4,5,1,12,14,13]
/// Output: 15
/// Explanation: The longest sequential prefix of nums is [3,4,5] with 
/// a sum of 12. 12, 13, and 14 belong to the array while 15 does not. 
/// Therefore 15 is the smallest missing integer greater than or equal 
/// to the sum of the longest sequential prefix.
///
/// Constraints:
/// 1. 1 <= nums.length <= 50
/// 2. 1 <= nums[i] <= 50
/// </summary>
int LeetCodeArray::missingInteger(vector<int>& nums)
{
    unordered_set<int> num_set;
    int sum = 0;
    int max_val = 0;
    bool sequential = true;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (sequential && (i == 0 || nums[i] == nums[i - 1] + 1))
        {
            sum += nums[i];
        }
        else
        {
            sequential = false;
        }
        max_val = max(max_val, nums[i]);
        num_set.insert(nums[i]);
    }
    int result = sum;
    while (result <= max_val)
    {
        if (num_set.count(result) == 0)
        {
            return result;
        }
        result++;
    }
    return result;
}

/// <summary>
/// Leet Code 3010. Divide an Array Into Subarrays With Minimum Cost I
///                 
/// Easy
/// 
/// You are given an array of integers nums of length n.
/// The cost of an array is the value of its first element. For example, the 
/// cost of [1,2,3] is 1 while the cost of [3,4,1] is 3.
///
/// You need to divide nums into 3 disjoint contiguous subarrays
/// 
/// Return the minimum possible sum of the cost of these subarrays.
/// 
/// Example 1:
/// Input: nums = [1,2,3,12]
/// Output: 6
/// Explanation: The best possible way to form 3 subarrays is: [1], [2], 
/// and [3,12] at a total cost of 1 + 2 + 3 = 6.
/// The other possible ways to form 3 subarrays are:
/// - [1], [2,3], and [12] at a total cost of 1 + 2 + 12 = 15.
/// - [1,2], [3], and [12] at a total cost of 1 + 3 + 12 = 16.
///
/// Example 2:
/// Input: nums = [5,4,3]
/// Output: 12
/// Explanation: The best possible way to form 3 subarrays is: [5], [4], 
/// and [3] at a total cost of 5 + 4 + 3 = 12.
/// It can be shown that 12 is the minimum cost achievable.
///
/// Example 3:
/// Input: nums = [10,3,1,1]
/// Output: 12
/// Explanation: The best possible way to form 3 subarrays is: [10,3], 
/// [1], and [1] at a total cost of 10 + 1 + 1 = 12.
/// It can be shown that 12 is the minimum cost achievable.
/// 
/// Constraints:
/// 1. 3 <= n <= 50
/// 2. 1 <= nums[i] <= 50
/// </summary>
int LeetCodeArray::minimumCostI(vector<int>& nums)
{
    priority_queue<int> pq;
    for (size_t i = 1; i < nums.size(); i++)
    {
        pq.push(nums[i]);
        if (pq.size() > 2) pq.pop();
    }
    int result = nums[0];
    while (!pq.empty())
    {
        result += pq.top();
        pq.pop();
    }
    return result;
}


/// <summary>
/// Leet Code 3026. Maximum Good Subarray Sum
///
/// Medium
///
/// You are given an array nums of length n and a positive integer k.
/// A subarray of nums is called good if the absolute difference between 
/// its first and last element is exactly k, in other words, the subarray 
/// nums[i..j] is good if |nums[i] - nums[j]| == k.
///
/// Return the maximum sum of a good subarray of nums. If there are no 
/// good subarrays, return 0.
/// 
/// Example 1:
/// Input: nums = [1,2,3,4,5,6], k = 1
/// Output: 11
/// Explanation: The absolute difference between the first and last 
/// element must be 1 for a good subarray. All the good subarrays 
/// are: [1,2], [2,3], [3,4], [4,5], and [5,6]. The maximum subarray 
/// sum is 11 for the subarray [5,6].
///
/// Example 2:
/// Input: nums = [-1,3,2,4,5], k = 3
/// Output: 11
/// Explanation: The absolute difference between the first and last 
/// element must be 3 for a good subarray. All the good subarrays are: 
/// [-1,3,2], and [2,4,5]. The maximum subarray sum is 11 for the 
/// subarray [2,4,5].
///
/// Example 3:
/// Input: nums = [-1,-2,-3,-4], k = 2
/// Output: -6
/// Explanation: The absolute difference between the first and last 
/// element must be 2 for a good subarray. All the good subarrays 
/// are: [-1,-2,-3], and [-2,-3,-4]. The maximum subarray sum is -6 
/// for the subarray [-1,-2,-3].
/// 
/// Constraints:
/// 1. 2 <= nums.length <= 10^5
/// 2. -10^9 <= nums[i] <= 10^9
/// 3. 1 <= k <= 10^9
/// </summary>
long long LeetCodeArray::maximumSubarraySum(vector<int>& nums, int k)
{
    unordered_map<int, long long> prefix_sum;
    long long sum = 0;
    bool good_subarray = false;
    long long result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (prefix_sum.count(nums[i]) == 0)
        {
            prefix_sum[nums[i]] = sum;
        }
        else
        {
            prefix_sum[nums[i]] = min(prefix_sum[nums[i]], sum);
        }
        sum += nums[i];
        if (prefix_sum.count(nums[i] - k) > 0)
        {
            if (good_subarray)
            {
                result = max(result, sum - prefix_sum[nums[i] - k]);
            }
            else
            {
                good_subarray = true;
                result = sum - prefix_sum[nums[i] - k];
            }
        }
        if (prefix_sum.count(nums[i] + k) > 0)
        {
            if (good_subarray)
            {
                result = max(result, sum - prefix_sum[nums[i] + k]);
            }
            else
            {
                good_subarray = true;
                result = sum - prefix_sum[nums[i] + k];
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3030. Find the Grid of Region Average
///
/// Medium
///
/// You are given a 0-indexed m x n grid image which represents a 
/// grayscale image, where image[i][j] represents a pixel with 
/// intensity in the range[0..255]. You are also given a non-negative 
/// integer threshold.
///
/// Two pixels image[a][b] and image[c][d] are said to be adjacent 
/// if |a - c| + |b - d| == 1.
///
/// A region is a 3 x 3 subgrid where the absolute difference in 
/// intensity between any two adjacent pixels is less than or equal to 
/// threshold.
///
/// All pixels in a region belong to that region, note that a pixel 
/// can belong to multiple regions.
///
/// You need to calculate a 0-indexed m x n grid result, where 
/// result[i][j] is the average intensity of the region to which 
/// image[i][j] belongs, rounded down to the nearest integer. If 
/// image[i][j] belongs to multiple regions, result[i][j] is the average 
/// of the rounded down average intensities of these regions, rounded 
/// down to the nearest integer. If image[i][j] does not belong to any 
/// region, result[i][j] is equal to image[i][j].
///
/// Return the grid result.
/// 
/// Example 1:
/// Input: image = [[5,6,7,10],[8,9,10,10],[11,12,13,10]], threshold = 3
/// Output: [[9,9,9,9],[9,9,9,9],[9,9,9,9]]
/// Explanation: There exist two regions in the image, which are shown 
/// as the shaded areas in the picture. The average intensity of the 
/// first region is 9, while the average intensity of the second region 
/// is 9.67 which is rounded down to 9. The average intensity of both of 
/// the regions is (9 + 9) / 2 = 9. As all the pixels belong to either 
/// region 1, region 2, or both of them, the intensity of every pixel in 
/// the result is 9. 
/// Please note that the rounded-down values are used when calculating 
/// the average of multiple regions, hence the calculation is done 
/// using 9 as the average intensity of region 2, not 9.67.
///
/// Example 2:
/// Input: image = [[10,20,30],[15,25,35],[20,30,40],[25,35,45]], 
/// threshold = 12
/// Output: [[25,25,25],[27,27,27],[27,27,27],[30,30,30]]
/// Explanation: There exist two regions in the image, which are shown as 
/// the shaded areas in the picture. The average intensity of the first 
/// region is 25, while the average intensity of the second region is 30. 
/// The average intensity of both of the regions is (25 + 30) / 2 = 27.5 
/// which is rounded down to 27. All the pixels in row 0 of the image 
/// belong to region 1, hence all the pixels in row 0 in the result 
/// are 25. Similarly, all the pixels in row 3 in the result are 30. The 
/// pixels in rows 1 and 2 of the image belong to region 1 and region 2, 
/// hence their assigned value is 27 in the result.
///
/// Example 3:
/// Input: image = [[5,6,7],[8,9,10],[11,12,13]], threshold = 1
/// Output: [[5,6,7],[8,9,10],[11,12,13]]
/// Explanation: There does not exist any region in image, hence 
/// result[i][j] == image[i][j] for all the pixels.
/// 
/// Constraints:
/// 1. 3 <= n, m <= 500
/// 2. 0 <= image[i][j] <= 255
/// 3. 0 <= threshold <= 255
/// </summary>
vector<vector<int>> LeetCodeArray::resultGrid(vector<vector<int>>& image, int threshold)
{
    int m = image.size();
    int n = image[0].size();
    vector<vector<pair<int, int>>> grid(m, vector<pair<int, int>>(n));
    vector<vector<int>> result(m, vector<int>(n));
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            bool under_threshold = true;
            int sum = 0;
            if (i + 2 >= m || j + 2 >= n)
            {
                under_threshold = false;
            }
            for (int k = 0; k < 3 && under_threshold; k++)
            {
                for (int l = 0; l < 3 && under_threshold; l++)
                {
                    sum += image[i + k][j + l];
                    if (k > 0 && abs(image[i + k][j + l] - image[i + k - 1][j + l]) > threshold)
                    {
                        under_threshold = false;
                    }
                    else if (l > 0 && abs(image[i + k][j + l] - image[i + k][j + l - 1]) > threshold)
                    {
                        under_threshold = false;
                    }
                }
            }
            if (under_threshold)
            {
                int avg = sum / 9;
                for (int k = 0; k < 3 && under_threshold; k++)
                {
                    for (int l = 0; l < 3 && under_threshold; l++)
                    {
                        grid[i + k][j + l].first += avg;
                        grid[i + k][j + l].second++;
                    }
                }
            }
        }
    }
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (grid[i][j].second > 0)
            {
                result[i][j] = grid[i][j].first / grid[i][j].second;
            }
            else
            {
                result[i][j] = image[i][j];
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3033. Modify the Matrix
///
/// Easy
///
/// Given a 0-indexed m x n integer matrix matrix, create a new 0-indexed 
/// matrix called answer. Make answer equal to matrix, then replace each 
/// element with the value -1 with the maximum element in its respective 
/// column.
///
/// Return the matrix answer.
///
/// Example 1:
/// Input: matrix = [[1,2,-1],[4,-1,6],[7,8,9]]
/// Output: [[1,2,9],[4,8,6],[7,8,9]]
/// Explanation: The diagram above shows the elements that are changed 
/// (in blue).
/// - We replace the value in the cell [1][1] with the maximum value in 
///   the column 1, that is 8.
/// - We replace the value in the cell [0][2] with the maximum value in 
///   the column 2, that is 9.
///
/// Example 2:
/// Input: matrix = [[3,-1],[5,2]]
/// Output: [[3,2],[5,2]]
/// Explanation: The diagram above shows the elements that are changed 
/// (in blue).
/// 
/// Constraints:
/// 1. m == matrix.length
/// 2. n == matrix[i].length
/// 3. 2 <= m, n <= 50
/// 4. -1 <= matrix[i][j] <= 100
/// 5. The input is generated such that each column contains at least 
///    one non-negative integer.
/// </summary>
vector<vector<int>> LeetCodeArray::modifiedMatrix(vector<vector<int>>& matrix)
{
    vector<int> column_max(matrix[0].size());
    for (size_t i = 0; i < matrix.size(); i++)
    {
        for (size_t j = 0; j < matrix[0].size(); j++)
        {
            column_max[j] = max(column_max[j], matrix[i][j]);
        }
    }
    vector<vector<int>> result = matrix;
    for (size_t i = 0; i < matrix.size(); i++)
    {
        for (size_t j = 0; j < matrix[0].size(); j++)
        {
            if (result[i][j] == -1) result[i][j] = column_max[j];
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3038. Maximum Number of Operations With the Same Score I
///
/// Easy
///
/// Given an array of integers called nums, you can perform the following 
/// operation while nums contains at least 2 elements:
///
/// Choose the first two elements of nums and delete them.
/// The score of the operation is the sum of the deleted elements.
///
/// Your task is to find the maximum number of operations that can be 
/// performed, such that all operations have the same score.
///
/// Return the maximum number of operations possible that satisfy the 
/// condition mentioned above.
/// 
/// Example 1:
/// Input: nums = [3,2,1,4,5]
/// Output: 2
/// Explanation: We perform the following operations:
/// - Delete the first two elements, with score 3 + 2 = 5, nums = [1,4,5].
/// - Delete the first two elements, with score 1 + 4 = 5, nums = [5].
/// We are unable to perform any more operations as nums contain only 1 
/// element.
///
/// Example 2:
/// Input: nums = [3,2,6,1,4]
/// Output: 1
/// Explanation: We perform the following operations:
/// - Delete the first two elements, with score 3 + 2 = 5, nums = [6,1,4].
/// We are unable to perform any more operations as the score of the next 
/// operation isn't the same as the previous one.
/// 
/// Constraints:
/// 1. 2 <= nums.length <= 100
/// 2. 1 <= nums[i] <= 1000
/// </summary>
int LeetCodeArray::maxOperationsI(vector<int>& nums)
{
    int result = 0;
    int sum = 0;
    for (size_t i = 0; i  + 1 < nums.size(); i+=2)
    {
        if (result == 0)
        {
            sum = nums[i] + nums[i + 1];
        }
        else
        {
            if (nums[i] + nums[i + 1] != sum) break;
        }
        result++;
    }
    return result;
}


/// <summary>
/// Leet Code 3065. Minimum Operations to Exceed Threshold Value I
///
/// Easy
///
/// You are given a 0-indexed integer array nums, and an integer k.
/// In one operation, you can remove one occurrence of the smallest 
/// element of nums.
///
/// Return the minimum number of operations needed so that all elements 
/// of the array are greater than or equal to k.
///
/// Example 1:
/// Input: nums = [2,11,10,1,3], k = 10
/// Output: 3
///
/// Explanation: After one operation, nums becomes equal to [2, 11, 10, 3].
/// After two operations, nums becomes equal to [11, 10, 3].
/// After three operations, nums becomes equal to [11, 10].
/// At this stage, all the elements of nums are greater than or equal 
/// to 10 so we can stop.
/// It can be shown that 3 is the minimum number of operations needed so 
/// that all elements of the array are greater than or equal to 10.
///
/// Example 2:
/// Input: nums = [1,1,2,4,9], k = 1
/// Output: 0
/// Explanation: All elements of the array are greater than or equal 
/// to 1 so we do not need to apply any operations on nums.
///
/// Example 3:
/// Input: nums = [1,1,2,4,9], k = 9
/// Output: 4
/// Explanation: only a single element of nums is greater than or equal 
/// to 9 so we need to apply the operations 4 times on nums.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 50
/// 2. 1 <= nums[i] <= 10^9
/// 3. 1 <= k <= 10^9
/// 4. The input is generated such that there is at least one index i 
///    such that nums[i] >= k.
/// </summary>
int LeetCodeArray::minOperationsI(vector<int>& nums, int k)
{
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] < k) result++;
    }
    return result;
}

/// <summary>
/// Leet 3069. Distribute Elements Into Two Arrays I
///
/// Easy
///
/// You are given a 1-indexed array of distinct integers nums of length n.
/// You need to distribute all the elements of nums between two arrays 
/// arr1 and arr2 using n operations. In the first operation, append 
/// nums[1] to arr1. In the second operation, append nums[2] to arr2. 
/// Afterwards, in the ith operation:
///
/// If the last element of arr1 is greater than the last element of arr2, 
/// append nums[i] to arr1. Otherwise, append nums[i] to arr2.
/// The array result is formed by concatenating the arrays arr1 and arr2. 
/// For example, if arr1 == [1,2,3] and arr2 == [4,5,6], then 
/// result = [1,2,3,4,5,6].
///
/// Return the array result.
/// 
/// Example 1:
/// Input: nums = [2,1,3]
/// Output: [2,3,1]
/// Explanation: After the first 2 operations, arr1 = [2] and arr2 = [1].
/// In the 3rd operation, as the last element of arr1 is greater than the 
/// last element of arr2 (2 > 1), append nums[3] to arr1.
/// After 3 operations, arr1 = [2,3] and arr2 = [1].
/// Hence, the array result formed by concatenation is [2,3,1].
///
/// Example 2:
/// Input: nums = [5,4,3,8]
/// Output: [5,3,4,8]
/// Explanation: After the first 2 operations, arr1 = [5] and arr2 = [4].
/// In the 3rd operation, as the last element of arr1 is greater than the 
/// last element of arr2 (5 > 4), append nums[3] to arr1, hence arr1 
/// becomes [5,3].
/// In the 4th operation, as the last element of arr2 is greater than the 
/// last element of arr1 (4 > 3), append nums[4] to arr2, hence arr2 
/// becomes [4,8].
/// After 4 operations, arr1 = [5,3] and arr2 = [4,8].
/// Hence, the array result formed by concatenation is [5,3,4,8].
///
/// Constraints:
/// 1. 3 <= n <= 50
/// 2. 1 <= nums[i] <= 100
/// 3. All elements in nums are distinct.
/// </summary>
vector<int> LeetCodeArray::resultArrayI(vector<int>& nums)
{
    vector<int> arr1;
    vector<int> arr2;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (i == 0) arr1.push_back(nums[i]);
        else if (i == 1) arr2.push_back(nums[i]);
        else if (arr1.back() > arr2.back())
        {
            arr1.push_back(nums[i]);
        }
        else
        {
            arr2.push_back(nums[i]);
        }
    }
    vector<int> result = arr1;
    for (size_t i = 0; i < arr2.size(); i++)
    {
        result.push_back(arr2[i]);
    }
    return result;
}

/// <summary>
/// Leet 3071. Minimum Operations to Write the Letter Y on a Grid
///
/// Medium
///
/// You are given a 0-indexed n x n grid where n is odd, and 
/// grid[r][c] is 0, 1, or 2.
///
/// We say that a cell belongs to the Letter Y if it belongs to one of 
/// the following:
///
/// The diagonal starting at the top-left cell and ending at the center 
/// cell of the grid.
/// The diagonal starting at the top-right cell and ending at the center 
/// cell of the grid.
/// The vertical line starting at the center cell and ending at the bottom 
/// border of the grid.
/// The Letter Y is written on the grid if and only if:
///
/// All values at cells belonging to the Y are equal.
/// All values at cells not belonging to the Y are equal.
/// The values at cells belonging to the Y are different from the values 
/// at cells not belonging to the Y.
/// Return the minimum number of operations needed to write the letter Y 
/// on the grid given that in one operation you can change the value at 
/// any cell to 0, 1, or 2.
/// 
/// Example 1:
/// Input: grid = [[1,2,2],[1,1,0],[0,1,0]]
/// Output: 3
/// Explanation: We can write Y on the grid by applying the changes 
/// highlighted in blue in the image above. After the operations, all 
/// cells that belong to Y, denoted in bold, have the same value of 1 
/// while those that do not belong to Y are equal to 0.
/// It can be shown that 3 is the minimum number of operations needed to 
/// write Y on the grid.
///
/// Example 2:
/// Input: grid = [[0,1,0,1,0],[2,1,0,1,2],[2,2,2,0,1],[2,2,2,2,2],
///                [2,1,2,2,2]]
/// Output: 12
/// Explanation: We can write Y on the grid by applying the changes 
/// highlighted in blue in the image above. After the operations, all 
/// cells that belong to Y, denoted in bold, have the same value of 0 
/// while those that do not belong to Y are equal to 2. 
/// It can be shown that 12 is the minimum number of operations needed to 
/// write Y on the grid.
/// 
/// Constraints:
/// 1. 3 <= n <= 49 
/// 2. n == grid.length == grid[i].length
/// 3. 0 <= grid[i][j] <= 2
/// 4. n is odd.
/// </summary>
int LeetCodeArray::minimumOperationsToWriteY(vector<vector<int>>& grid)
{
    int n = grid.size();
    vector<vector<int>> temp = grid;
    vector<int> x(3), y(3);
    for (int i = 0; i < n; i++)
    {
        if (i < n / 2)
        {
            y[temp[i][i]]++;
            temp[i][i] = -1;
            y[temp[i][n-1-i]]++;
            temp[i][n - 1 - i] = -1;
        }
        else
        {
            y[temp[i][n / 2]]++;
            temp[i][n / 2] = -1;
        }
    }
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (temp[i][j] != -1)
            {
                x[temp[i][j]]++;
            }
        }
    }
    int result = n * n;
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            if (i == j) continue;
            result = min(result, n * n - (x[i] + y[j]));
        }
    }
    return result;
}


/// <summary>
/// Leet 3078. Match Alphanumerical Pattern in Matrix I
///
/// Medium
///
/// You are given a 2D integer matrix board and a 2D character matrix 
/// pattern. Where 0 <= board[r][c] <= 9 and each element of pattern 
/// is either a digit or a lowercase English letter.
///
/// Your task is to find a submatrix of board that matches pattern.
///
/// An integer matrix part matches pattern if we can replace cells 
/// containing letters in pattern with some digits (each distinct 
/// letter with a unique digit) in such a way that the resulting matrix 
/// becomes identical to the integer matrix part. In other words,
/// 
/// The matrices have identical dimensions.
/// If pattern[r][c] is a digit, then part[r][c] must be the same digit.
/// If pattern[r][c] is a letter x:
/// For every pattern[i][j] == x, part[i][j] must be the same as 
/// part[r][c].
/// For every pattern[i][j] != x, part[i][j] must be different than 
/// part[r][c].
/// Return an array of length 2 containing the row number and column 
/// number of the upper-left corner of a submatrix of board which matches 
/// pattern. If there is more than one such submatrix, return the 
/// coordinates of the submatrix with the lowest row index, and in case 
/// there is still a tie, return the coordinates of the submatrix with 
/// the lowest column index. If there are no suitable answers, 
/// return [-1, -1].
///
/// Example 1:
/// 1	2	2
/// 2	2	3
/// 2	3	3
/// a	b
/// b	b
/// Input: board = [[1,2,2],[2,2,3],[2,3,3]], pattern = ["ab","bb"]
///
/// Output: [0,0]
/// 
/// Explanation: If we consider this mapping: "a" -> 1 and "b" -> 2; 
/// the submatrix with the upper-left corner (0,0) is a match as outlined 
/// in the matrix above.
///
/// Note that the submatrix with the upper-left corner (1,1) is also a 
/// match but since it comes after the other one, we return [0,0].
///
/// Example 2:
/// 1	1	2
/// 3	3	4
/// 6	6	6
/// a	b
/// 6	6
/// Input: board = [[1,1,2],[3,3,4],[6,6,6]], pattern = ["ab","66"]
/// Output: [1,1]
/// Explanation: If we consider this mapping: "a" -> 3 and "b" -> 4; 
/// the submatrix with the upper-left corner (1,1) is a match as 
/// outlined in the matrix above.
/// Note that since the corresponding values of "a" and "b" must 
/// differ, the submatrix with the upper-left corner (1,0) is not a 
/// match. Hence, we return [1,1].
///
/// Example 3:
/// 1	2
/// 2	1
/// x	x
/// Input: board = [[1,2],[2,1]], pattern = ["xx"]
///
/// Output: [-1,-1]
///
/// Explanation: Since the values of the matched submatrix must be the 
/// same, there is no match. Hence, we return [-1,-1].
/// 
/// Constraints:
/// 1. 1 <= board.length <= 50
/// 2. 1 <= board[i].length <= 50
/// 3. 0 <= board[i][j] <= 9
/// 4. 1 <= pattern.length <= 50
/// 5. 1 <= pattern[i].length <= 50
/// 6. pattern[i][j] is either a digit represented as a string or a 
///    lowercase English letter.
/// </summary>
vector<int> LeetCodeArray::findPattern(vector<vector<int>>& board, vector<string>& pattern)
{
    vector<int> result(2, -1);
    for (size_t i = 0; i < board.size(); i++)
    {
        for (size_t j = 0; j < board[i].size(); j++)
        {
            vector<int> digits(10, -1), letters(26, -1);
            bool match = true;
            for (size_t k = 0; k < pattern.size(); k++)
            {
                if (i + k >= board.size())
                {
                    match = false;
                    break;
                }
                for (size_t l = 0; l < pattern[k].size(); l++)
                {
                    if (j + l >= board[i].size())
                    {
                        match = false;
                        break;
                    }
                    if (pattern[k][l] >= '0' && pattern[k][l] <= '9')
                    {
                        if (board[i + k][j + l] == pattern[k][l] - '0') continue;
                    }
                    else if (pattern[k][l] >= 'a' && pattern[k][l] <= 'z')
                    {
                        if (letters[pattern[k][l] - 'a'] == board[i + k][j + l]) continue;
                        if (letters[pattern[k][l] - 'a'] == -1 && digits[board[i + k][j + l]] == -1)
                        {
                            letters[pattern[k][l] - 'a'] = board[i + k][j + l];
                            digits[board[i + k][j + l]] = pattern[k][l] - 'a';
                            continue;
                        }
                    }
                    match = false;
                    break;
                }
                if (match == false) break;
            }
            if (match)
            {
                result[0] = i;
                result[1] = j;
                return result;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet 3086. Minimum Moves to Pick K Ones
///
/// Hard
///
/// You are given a binary array nums of length n, a positive integer k 
/// and a non-negative integer maxChanges.
///
/// Alice plays a game, where the goal is for Alice to pick up k ones 
/// from nums using the minimum number of moves. When the game starts, 
/// Alice picks up any index aliceIndex in the range [0, n - 1] and 
/// stands there. If nums[aliceIndex] == 1 , Alice picks up the one 
/// and nums[aliceIndex] becomes 0(this does not count as a move). 
/// After this, Alice can make any number of moves (including zero) 
/// where in each move Alice must perform exactly one of the following 
/// actions:
///
/// Select any index j != aliceIndex such that nums[j] == 0 and set 
/// nums[j] = 1. This action can be performed at most maxChanges times.
/// Select any two adjacent indices x and y (|x - y| == 1) such that 
/// nums[x] == 1, nums[y] == 0, then swap their values (set nums[y] = 1 
/// and nums[x] = 0). If y == aliceIndex, Alice picks up the one after 
/// this move and nums[y] becomes 0.
/// Return the minimum number of moves required by Alice to pick 
/// exactly k ones.
///
/// Example 1:
/// Input: nums = [1,1,0,0,0,1,1,0,0,1], k = 3, maxChanges = 1
/// Output: 3
///
/// Explanation: Alice can pick up 3 ones in 3 moves, if Alice performs 
/// the following actions in each move when standing at aliceIndex == 1:
///
/// At the start of the game Alice picks up the one and nums[1] becomes 0. 
/// nums becomes [1,0,1,0,0,1,1,0,0,1].
/// Select j == 2 and perform an action of the first type. nums 
/// becomes [1,0,1,0,0,1,1,0,0,1]
/// Select x == 2 and y == 1, and perform an action of the second type. 
/// nums becomes [1,1,0,0,0,1,1,0,0,1]. As y == aliceIndex, Alice picks 
/// up the one and nums becomes [1,0,0,0,0,1,1,0,0,1].
/// Select x == 0 and y == 1, and perform an action of the second type. 
/// nums becomes [0,1,0,0,0,1,1,0,0,1]. As y == aliceIndex, Alice picks 
/// up the one and nums becomes [0,0,0,0,0,1,1,0,0,1].
/// Note that it may be possible for Alice to pick up 3 ones using some 
/// other sequence of 3 moves.
/// 
/// Example 2:
/// Input: nums = [0,0,0,0], k = 2, maxChanges = 3
/// Output: 4
/// Explanation: Alice can pick up 2 ones in 4 moves, if Alice performs 
/// the following actions in each move when standing at aliceIndex == 0:
///
/// Select j == 1 and perform an action of the first type. nums 
/// becomes [0,1,0,0].
/// Select x == 1 and y == 0, and perform an action of the second type. 
/// nums becomes [1,0,0,0]. As y == aliceIndex, Alice picks up the one 
/// and nums becomes [0,0,0,0].
/// Select j == 1 again and perform an action of the first type. nums 
/// becomes [0,1,0,0].
/// Select x == 1 and y == 0 again, and perform an action of the second 
/// type. nums becomes [1,0,0,0]. As y == aliceIndex, Alice picks up the 
/// one and nums becomes [0,0,0,0].
/// 
/// Constraints:
/// 1. 2 <= n <= 10^5
/// 2. 0 <= nums[i] <= 1
/// 3. 1 <= k <= 10^5
/// 4. 0 <= maxChanges <= 10^5
/// 5. maxChanges + sum(nums) >= k
/// </summary>
long long LeetCodeArray::minimumMoves(vector<int>& nums, int k, int maxChanges)
{
    vector<long long> sum = { 0 };
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] == 0) continue;
        sum.push_back(sum[sum.size() - 1] + i);
    }
    int n = sum.size();
    if (n == 1) return (long long)k * 2;
    int m = max(0, k - 1 - maxChanges);
    long long result = LLONG_MAX;
    for (int i = 1; i < n; i++)
    {
        for (int j = m; j <= min(k-1, max(m, 2)); j++)
        {
            int left = i; 
            if (i + j > n - 1) break;
            int right = i + j;
            int mid_left = left + (right - left) / 2;
            int mid_right = left + (right + 1 - left) / 2;
            long long left_sum = sum[mid_left] - sum[left-1];
            long long right_sum = sum[right] - sum[mid_right - 1];
            long long distance = right_sum - left_sum;
            result = min(result, distance + (long long)(k - (right - left + 1)) * 2);
        }
    }
    return result;
}

/// <summary>
/// Leet 3101. Count Alternating Subarrays
///
/// Medium
///
/// You are given a binary array nums. 
/// We call a subarray alternating if no two adjacent elements in the 
/// subarray have the same value.
///
/// Return the number of alternating subarrays in nums.
/// 
/// Example 1:
/// Input: nums = [0,1,1,1]
/// Output: 5
/// Explanation:
/// The following subarrays are alternating: [0], [1], [1], [1], and [0,1].
///
/// Example 2:
/// Input: nums = [1,0,1,0]
/// Output: 10
/// Explanation:
/// Every subarray of the array is alternating. There are 10 possible 
/// subarrays that we can choose.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. nums[i] is either 0 or 1.
/// </summary>
long long LeetCodeArray::countAlternatingSubarrays(vector<int>& nums)
{
    long long result = 0;
    int count = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (i > 0 && nums[i] != nums[i - 1])
        {
            count++;
        }
        else
        {
            count = 1;
        }
        result += (long long)count;
    }
    return result;
}


/// <summary>
/// Leet 3096. Minimum Levels to Gain More Points
///
/// Medium
///
/// You are given a binary array possible of length n.
///
/// Danielchandg and Bob are playing a game that consists of n levels. 
/// Some of the levels in the game are impossible to clear while others 
/// can always be cleared. In particular, if possible[i] == 0, then the 
/// ith level is impossible to clear for both the players. A player 
/// gains 1 point on clearing a level and loses 1 point if the player 
/// fails to clear it.
///
/// At the start of the game, Danielchandg will play some levels in the 
/// given order starting from the 0th level, after which Bob will play 
/// for the rest of the levels.
///
/// Danielchandg wants to know the minimum number of levels he should 
/// play to gain more points than Bob, if both players play optimally 
/// to maximize their points.
///
/// Return the minimum number of levels danielchandg should play to 
/// gain more points. If this is not possible, return -1.
///
/// Note that each player must play at least 1 level.
/// 
/// Example 1:
/// Input: possible = [1,0,1,0]
/// Output: 1
///
/// Explanation:
/// Let's look at all the levels that Danielchandg can play up to:
///
/// If Danielchandg plays only level 0 and Bob plays the rest of the 
/// levels, Danielchandg has 1 point, while Bob has -1 + 1 - 1 = -1 point.
/// If Danielchandg plays till level 1 and Bob plays the rest of the 
/// levels, Danielchandg has 1 - 1 = 0 points, while Bob has 1 - 1 = 0 
/// points.
/// If Danielchandg plays till level 2 and Bob plays the rest of the 
/// levels, Danielchandg has 1 - 1 + 1 = 1 point, while Bob has -1 point.
/// Danielchandg must play a minimum of 1 level to gain more points.
///
/// Example 2:
/// Input: possible = [1,1,1,1,1]
/// Output: 3 
///
/// Explanation:
/// Let's look at all the levels that Danielchandg can play up to:
/// If Danielchandg plays only level 0 and Bob plays the rest of the 
/// levels, Danielchandg has 1 point, while Bob has 4 points.
/// If Danielchandg plays till level 1 and Bob plays the rest of the 
/// levels, Danielchandg has 2 points, while Bob has 3 points.
/// If Danielchandg plays till level 2 and Bob plays the rest of the 
/// levels, Danielchandg has 3 points, while Bob has 2 points.
/// If Danielchandg plays till level 3 and Bob plays the rest of the 
///  levels, Danielchandg has 4 points, while Bob has 1 point.
/// Danielchandg must play a minimum of 3 levels to gain more points.
///
/// Example 3:
/// Input: possible = [0,0]
/// Output: -1
/// Explanation:
/// The only possible way is for both players to play 1 level each. 
/// Danielchandg plays level 0 and loses 1 point. Bob plays level 1 and 
/// loses 1 point. As both players have equal points, Danielchandg can't 
/// gain more points than Bob.
/// 
/// Constraints:
/// 1. 2 <= n == possible.length <= 10^5
/// 2. possible[i] is either 0 or 1.
/// </summary>
int LeetCodeArray::minimumLevels(vector<int>& possible)
{
    int sum = 0;
    for (size_t i = 0; i < possible.size(); i++)
    {
        sum += (possible[i] == 1) ? 1 : -1;
    }
    int Danielchandg = 0;
    for (size_t i = 0; i < possible.size() - 1; i++)
    {
        Danielchandg += (possible[i] == 1) ? 1 : -1;
        if (Danielchandg > sum - Danielchandg)
        {
            return i + 1;
        }
    }
    return -1;
}


/// <summary>
/// Leet 3105. Longest Strictly Increasing or Strictly Decreasing Subarray
///
/// Easy
///
/// You are given an array of integers nums. Return the length of the 
/// longest subarray of nums which is either strictly increasing or
/// strictly decreasing
///
/// Example 1:
/// Input: nums = [1,4,3,3,2]
/// Output: 2
/// Explanation:
/// The strictly increasing subarrays of nums are [1], [2], [3], [3], [4], 
/// and [1,4].
/// The strictly decreasing subarrays of nums are [1], [2], [3], [3], [4], 
/// [3,2], and [4,3].
/// Hence, we return 2.
///
/// Example 2:
/// Input: nums = [3,3,3,3]
/// Output: 1
/// Explanation:
/// The strictly increasing subarrays of nums are [3], [3], [3], and [3].
/// The strictly decreasing subarrays of nums are [3], [3], [3], and [3].
/// Hence, we return 1.
///
/// Example 3:
/// Input: nums = [3,2,1]
/// Output: 3
/// Explanation:
/// The strictly increasing subarrays of nums are [3], [2], and [1].
/// The strictly decreasing subarrays of nums are [3], [2], [1], [3,2], 
/// [2,1], and [3,2,1].
/// Hence, we return 3.
///
/// Constraints:
/// 1. 1 <= nums.length <= 50
/// 2. 1 <= nums[i] <= 50
/// </summary>
int LeetCodeArray::longestMonotonicSubarray(vector<int>& nums)
{
    int result = 1;
    int count = 0;
    for (size_t i = 1; i < nums.size(); i++)
    {
        if (nums[i] > nums[i - 1])
        {
            if (count <= 0) count = 2;
            else count++;
            result = max(result, count);
        }
        else if (nums[i] < nums[i - 1])
        {
            if (count >= 0) count = -2;
            else count--;
            result = max(result, std::abs(count));
        }
        else
        {
            count = 1;
        }
    }
    return result;
}


/// <summary>
/// Leet 3107. Minimum Operations to Make Median of Array Equal to K 
///
/// Medium
///
/// You are given an integer array nums and a non-negative integer k. 
/// In one operation, you can increase or decrease any element by 1.
///
/// Return the minimum number of operations needed to make the median of 
/// nums equal to k.
///
/// The median of an array is defined as the middle element of the array 
/// when it is sorted in non-decreasing order. If there are two choices 
/// for a median, the larger of the two values is taken.
///
/// Example 1:
/// Input: nums = [2,5,6,8,5], k = 4
/// Output: 2
/// Explanation:
/// We can subtract one from nums[1] and nums[4] to obtain 
/// [2, 4, 6, 8, 4]. The median of the resulting array is equal to k.
/// 
/// Example 2:
/// Input: nums = [2,5,6,8,5], k = 7
/// Output: 3
/// Explanation:
/// We can add one to nums[1] twice and add one to nums[2] once to 
/// obtain [2, 7, 7, 8, 5].
///
/// Example 3:
/// Input: nums = [1,2,3,4,5,6], k = 4
/// Output: 0
/// Explanation:
/// The median of the array is already equal to k.
///  
/// Constraints:
/// 1. 1 <= nums.length <= 2 * 10^5
/// 2. 1 <= nums[i] <= 10^9
/// 3. 1 <= k <= 10^9
/// </summary>
long long LeetCodeArray::minOperationsToMakeMedianK(vector<int>& nums, int k)
{
    int n = nums.size();
    sort(nums.begin(), nums.end());
    int median = n / 2;
    long long result = 0;
    if (nums[median] > k)
    {
        result = nums[median] - k;
        for (int i = median - 1; i >= 0; i--)
        {
            if (nums[i] <= k) break;
            result += nums[i] - k;
        }
    }
    else if (nums[median] < k)
    {
        result = k - nums[median];
        for (int i = median + 1; i < n; i++)
        {
            if (nums[i] >= k) break;
            result += k - nums[i];
        }
    }
    return result;
}

/// <summary>
/// LeetCode 3127. Make a Square with the Same Color
///                
/// Easy
///
/// You are given a 2D matrix grid of size 3 x 3 consisting only of 
/// characters 'B' and 'W'. Character 'W' represents the white color, 
/// and character 'B' represents the black color.
///
/// Your task is to change the color of at most one cell so that the 
/// matrix has a 2 x 2 square where all cells are of the same color.
///
/// Return true if it is possible to create a 2 x 2 square of the same 
/// color, otherwise, return false.
/// 
/// Example 1:
/// Input: grid = [["B","W","B"],["B","W","W"],["B","W","B"]]
/// Output: true
/// Explanation:
/// It can be done by changing the color of the grid[0][2].
///
/// Example 2:
/// Input: grid = [["B","W","B"],["W","B","W"],["B","W","B"]]
/// Output: false
/// Explanation:
/// It cannot be done by changing at most one cell.
///
/// Example 3:
/// Input: grid = [["B","W","B"],["B","W","W"],["B","W","W"]]
/// Output: true
/// Explanation:
/// The grid already contains a 2 x 2 square of the same color.
///
/// Constraints:
/// 1. grid.length == 3
/// 2. grid[i].length == 3
/// 3. grid[i][j] is either 'W' or 'B'.
/// </summary>
bool LeetCodeArray::canMakeSquare(vector<vector<char>>& grid)
{
    vector<vector<int>> matrix(grid.size(), vector<int>(grid[0].size()));
    for (size_t i = 0; i < grid.size(); i++)
    {
        for (size_t j = 0; j < grid[i].size(); j++)
        {
            if (grid[i][j] == 'W') matrix[i][j] = 1;
            if (i > 0 && j > 0)
            {
                int sum = matrix[i - 1][j - 1] + matrix[i - 1][j] + matrix[i][j - 1] + matrix[i][j];
                sum = min(sum, 4 - sum);
                if (sum < 2)
                {
                    return true;
                }
            }
        }
    }
    return false;
}

/// <summary>
/// LeetCode 3128. Right Triangles
///                
/// Medium
///
/// You are given a 2D boolean matrix grid.
/// Return an integer that is the number of right triangles that can be 
/// made with the 3 elements of grid such that all of them have a value 
/// of 1.
///
/// Note:
/// A collection of 3 elements of grid is a right triangle if one of its
/// elements is in the same row with another element and in the same 
/// column with the third element. The 3 elements do not have to be next 
/// to each other.
/// 
/// Example 1:
/// 0	1	0
/// 0	1	1
/// 0	1	0
///
/// Input: grid = [[0,1,0],[0,1,1],[0,1,0]]
/// Output: 2
/// Explanation:
/// There are two right triangles.
///
/// Example 2:
/// 1	0	0	0
/// 0	1	0	1
/// 1	0	0	0
/// Input: grid = [[1,0,0,0],[0,1,0,1],[1,0,0,0]]
/// Output: 0
/// Explanation:
/// There are no right triangles.
////
/// Example 3:
/// 1	0	1
/// 1	0	0
/// 1	0	0
/// Input: grid = [[1,0,1],[1,0,0],[1,0,0]]
/// Output: 2
/// Explanation:
/// There are two right triangles.
///  
/// Constraints:
/// 1. 1 <= grid.length <= 1000
/// 2. 1 <= grid[i].length <= 1000
/// 3. 0 <= grid[i][j] <= 1
/// </summary>
long long LeetCodeArray::numberOfRightTriangles(vector<vector<int>>& grid)
{
    vector<int> row(grid.size()), col(grid[0].size());
    for (size_t i = 0; i < grid.size(); i++)
    {
        for (size_t j = 0; j < grid[i].size(); j++)
        {
            if (grid[i][j] == 1)
            {
                row[i]++;
                col[j]++;
            }
        }
    }
    long long result = 0;
    for (size_t i = 0; i < grid.size(); i++)
    {
        for (size_t j = 0; j < grid[i].size(); j++)
        {
            if (grid[i][j] == 1)
            {
                result += (long long)(row[i] - 1) * (long long)(col[j] - 1);
            }
        }
    }
    return result;
}

/// LeetCode 3131. Find the Integer Added to Array I
///                
/// Easy
///
/// You are given two arrays of equal length, nums1 and nums2.
/// Each element in nums1 has been increased (or decreased in the case of 
/// negative) by an integer, represented by the variable x.
///
/// As a result, nums1 becomes equal to nums2. Two arrays are considered 
/// equal when they contain the same integers with the same frequencies.
///
/// Return the integer x.
/// 
/// Example 1:
/// Input: nums1 = [2,6,4], nums2 = [9,7,5]
/// Output: 3
/// Explanation:
/// The integer added to each element of nums1 is 3.
///
/// Example 2:
/// Input: nums1 = [10], nums2 = [5]
/// Output: -5
/// Explanation:
/// The integer added to each element of nums1 is -5.
///
/// Example 3:
/// Input: nums1 = [1,1,1,1], nums2 = [1,1,1,1]
/// Output: 0
/// Explanation:
/// The integer added to each element of nums1 is 0.
/// 
/// Constraints:
/// 1. 1 <= nums1.length == nums2.length <= 100
/// 2. 0 <= nums1[i], nums2[i] <= 1000
/// 3. The test cases are generated in a way that there is an integer x 
///    such that nums1 can become equal to nums2 by adding x to each 
///    element of nums1.
/// </summary>
int LeetCodeArray::addedIntegerI(vector<int>& nums1, vector<int>& nums2)
{
    sort(nums1.begin(), nums1.end());
    sort(nums2.begin(), nums2.end());
    return nums2[0] - nums1[0];
}


/// <summary>
/// LeetCode 3132. Find the Integer Added to Array II
///                
/// Medium
///
/// You are given two integer arrays nums1 and nums2.
/// From nums1 two elements have been removed, and all other elements have 
/// been increased (or decreased in the case of negative) by an integer, 
/// represented by the variable x.
///
/// As a result, nums1 becomes equal to nums2. Two arrays are considered 
/// equal when they contain the same integers with the same frequencies.
///
/// Return the minimum possible integer x that achieves this equivalence.
///
/// Example 1:
/// Input: nums1 = [4,20,16,12,8], nums2 = [14,18,10]
/// Output: -2
/// Explanation:
/// After removing elements at indices [0,4] and adding -2, nums1 
/// becomes [18,14,10].
///
/// Example 2:
/// Input: nums1 = [3,5,5,3], nums2 = [7,7]
/// Output: 2
/// Explanation:
/// After removing elements at indices [0,3] and adding 2, nums1 
/// becomes [7,7].
///
/// Constraints:
/// 1. 3 <= nums1.length <= 200
/// 2. nums2.length == nums1.length - 2
/// 3. 0 <= nums1[i], nums2[i] <= 1000
/// 4. The test cases are generated in a way that there is an integer x 
///    such that nums1 can become equal to nums2 by removing two elements 
///    and adding x to each element of nums1.
/// </summary>
int LeetCodeArray::addedIntegerII(vector<int>& nums1, vector<int>& nums2)
{
    sort(nums1.begin(), nums1.end());
    sort(nums2.begin(), nums2.end());
    int result = INT_MAX;
    for (int k = 0; k < 3; k++)
    {
        int diff = nums2[0] - nums1[k];
        int j = k + 1;
        for (size_t i = 1; i < nums2.size(); i++)
        {
            if (nums2[i] - nums1[j] == diff)
            {
                j++;
                continue;
            }
            else
            {

                if (j - i > 1)
                {
                    diff = INT_MAX;
                    break;
                }
                j++;
                i--;
            }
        }
        result = min(result, diff);
    }
    return result;
}


/// <summary>
/// LeetCode 3142. Check if Grid Satisfies Conditions
/// 
/// Easy
/// 
/// You are given a 2D matrix grid of size m x n. You need to check if 
/// each cell grid[i][j] is:
///
/// Equal to the cell below it, i.e. grid[i][j] == grid[i + 1][j] (if 
/// it exists).
/// Different from the cell to its right, i.e. grid[i][j] != 
/// grid[i][j + 1] (if it exists).
/// Return true if all the cells satisfy these conditions, otherwise, 
/// return false.
/// 
/// Example 1:
/// Input: grid = [[1,0,2],[1,0,2]]
/// Output: true
/// Explanation:
/// All the cells in the grid satisfy the conditions.
///
/// Example 2:
/// Input: grid = [[1,1,1],[0,0,0]]
/// Output: false
/// Explanation:
/// All cells in the first row are equal.
///
/// Example 3:
/// Input: grid = [[1],[2],[3]]
/// Output: false
/// Explanation:
/// Cells in the first column have different values.
///
/// Constraints:
/// 1. 1 <= n, m <= 10
/// 2. 0 <= grid[i][j] <= 9
/// </summary>
bool LeetCodeArray::satisfiesConditions(vector<vector<int>>& grid)
{
    for (size_t i = 0; i < grid.size(); i++)
    {
        for (size_t j = 0; j < grid[i].size(); j++)
        {
            if (i > 0 && grid[i][j] != grid[i-1][j])
            {
                return false;
            }
            if (j > 0 && grid[i][j] == grid[i][j - 1])
            {
                return false;
            }
        }
    }
    return true;
}

/// <summary>
/// LeetCode 3148. Maximum Difference Score in a Grid
/// 
/// Medium
///
/// You are given an m x n matrix grid consisting of positive integers. 
/// You can move from a cell in the matrix to any other cell that is 
/// either to the bottom or to the right (not necessarily adjacent). 
/// The score of a move from a cell with the value c1 to a cell with the 
/// value c2 is c2 - c1.
///
/// You can start at any cell, and you have to make at least one move.
///
/// Return the maximum total score you can achieve.
/// 
/// Example 1:
/// Input: grid = [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]
/// Output: 9
/// Explanation: We start at the cell (0, 1), and we perform the following 
/// moves:
/// - Move from the cell (0, 1) to (2, 1) with a score of 7 - 5 = 2.
/// - Move from the cell (2, 1) to (2, 2) with a score of 14 - 7 = 7.
/// The total score is 2 + 7 = 9.
///
/// Example 2:
/// Input: grid = [[4,3,2],[3,2,1]]
/// Output: -1
/// Explanation: We start at the cell (0, 0), and we perform one move: 
/// (0, 0) to (0, 1). The score is 3 - 4 = -1.
/// 
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 2 <= m, n <= 1000
/// 4. 4 <= m * n <= 10^5
/// 5. 1 <= grid[i][j] <= 10^5
/// </summary>
int LeetCodeArray::maxScore(vector<vector<int>>& grid)
{
    vector<int> cols(grid[0].size(), INT_MAX);
    int result = INT_MIN;
    for (size_t i = 0; i < grid.size(); i++)
    {
        int min_val = INT_MAX;
        for (size_t j = 0; j < grid[i].size(); j++)
        {
            min_val = min(min_val, cols[j]);
            if (i > 0 || j > 0)
            {
                result = max(result, grid[i][j] - min_val);
            }
            cols[j] = min(cols[j], grid[i][j]);
            min_val = min(min_val, cols[j]);
        }
    }
    return result;
}

/// <summary>
/// LeetCode 3151. Special Array I
/// 
/// Easy
///
/// An array is considered special if every pair of its adjacent elements 
/// contains two numbers with different parity.
///
/// You are given an array of integers nums. Return true if nums is a 
/// special array, otherwise, return false.
/// 
/// Example 1:
/// Input: nums = [1]
///
/// Output: true
///
/// Explanation:
/// There is only one element. So the answer is true.
///
/// Example 2:
/// Input: nums = [2,1,4]
/// Output: true
/// Explanation:
/// There is only two pairs: (2,1) and (1,4), and both of them contain 
/// numbers with different parity. So the answer is true.
///
/// Example 3:
/// Input: nums = [4,3,1,6]
/// Output: false 
/// Explanation:
/// nums[1] and nums[2] are both odd. So the answer is false.
///
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 100
/// 2. 1 <= nums[i] <= 100
/// </summary>
bool LeetCodeArray::isArraySpecial(vector<int>& nums)
{
    for (size_t i = 1; i < nums.size(); i++)
    {
        if ((nums[i] % 2) == (nums[i - 1] % 2))
        {
            return false;
        }
    }
    return true;
}


/// <summary>
/// LeetCode 3152. Special Array II
/// 
/// Medium
///
/// An array is considered special if every pair of its adjacent elements 
/// contains two numbers with different parity.
///
/// You are given an array of integer nums and a 2D integer matrix queries, 
/// where for queries[i] = [fromi, toi] your task is to check that subarray
/// nums[fromi..toi] is special or not.
///
/// Return an array of booleans answer such that answer[i] is true if 
/// nums[fromi..toi] is special.
///
/// Example 1:
/// Input: nums = [3,4,1,2,6], queries = [[0,4]]
/// Output: [false]
///
/// Explanation:
/// The subarray is [3,4,1,2,6]. 2 and 6 are both even.
///
/// Example 2: 
/// Input: nums = [4,3,1,6], queries = [[0,2],[2,3]]
/// Output: [false,true]
/// Explanation:
/// The subarray is [4,3,1]. 3 and 1 are both odd. So the answer to this 
/// query is false.
/// The subarray is [1,6]. There is only one pair: (1,6) and it contains 
/// numbers with different parity. So the answer to this query is true.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^5
/// 3. 1 <= queries.length <= 10^5
/// 4. queries[i].length == 2
/// 5. 0 <= queries[i][0] <= queries[i][1] <= nums.length - 1
/// </summary>
vector<bool> LeetCodeArray::isArraySpecial(vector<int>& nums, vector<vector<int>>& queries)
{
    vector<int> dp(nums.size());
    vector<bool> result(queries.size());
    for (size_t i = 1; i < nums.size(); i++)
    {
        if ((nums[i] % 2) != (nums[i - 1] % 2))
        {
            dp[i] = dp[i-1] + 1;
        }
    }
    for (size_t i = 0; i < queries.size(); i++)
    {
        if (dp[queries[i][1]] >= queries[i][1] - queries[i][0])
        {
            result[i] = true;
        }
        else
        {
            result[i] = false;
        }
    }
    return result;
}

/// <summary>
/// LeetCode 3159. Find Occurrences of an Element in an Array
/// 
/// Medium
/// 
/// You are given an integer array nums, an integer array queries, and an 
/// integer x.
///
/// For each queries[i], you need to find the index of the queries[i]th 
/// occurrence of x in the nums array. If there are fewer than queries[i] 
/// occurrences of x, the answer should be -1 for that query.
///
/// Return an integer array answer containing the answers to all queries.
///
/// Example 1:
/// Input: nums = [1,3,1,7], queries = [1,3,2,4], x = 1
/// Output: [0,-1,2,-1]
/// Explanation:
/// For the 1st query, the first occurrence of 1 is at index 0.
/// For the 2nd query, there are only two occurrences of 1 in nums, so 
/// the answer is -1.
/// For the 3rd query, the second occurrence of 1 is at index 2.
/// For the 4th query, there are only two occurrences of 1 in nums, so 
/// the answer is -1.
///
/// Example 2:
/// Input: nums = [1,2,3], queries = [10], x = 5
/// Output: [-1]
/// Explanation:
/// For the 1st query, 5 doesn't exist in nums, so the answer is -1.
///
/// Constraints:
/// 1. 1 <= nums.length, queries.length <= 10^5
/// 2. 1 <= queries[i] <= 10^5
/// 3. 1 <= nums[i], x <= 10^4
/// </summary>
vector<int> LeetCodeArray::occurrencesOfElement(vector<int>& nums, vector<int>& queries, int x)
{
    vector<int> indexes;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] == x) indexes.push_back(i);
    }
    vector<int> result;
    for (size_t i = 0; i < queries.size(); i++)
    {
        if (queries[i] > (int)indexes.size())
        {
            result.push_back(-1);
        }
        else
        {
            result.push_back(indexes[queries[i] - 1]);
        }
    }
    return result;
}

/// <summary>
/// LeetCode 3175. Find The First Player to win K Games in a Row
/// 
/// Medium
/// 
/// A competition consists of n players numbered from 0 to n - 1.
/// You are given an integer array skills of size n and a positive 
/// integer k, where skills[i] is the skill level of player i. All 
/// integers in skills are unique.
///
/// All players are standing in a queue in order from player 0 to 
/// player n - 1.
///
/// The competition process is as follows:
/// The first two players in the queue play a game, and the player with 
/// the higher skill level wins.
/// After the game, the winner stays at the beginning of the queue, and 
/// the loser goes to the end of it.
/// The winner of the competition is the first player who wins k games 
/// in a row.
/// 
/// Return the initial index of the winning player.
/// 
/// Example 1:
/// Input: skills = [4,2,6,3,9], k = 2
/// Output: 2
/// Explanation:
/// Initially, the queue of players is [0,1,2,3,4]. The following process 
/// happens:
///
/// Players 0 and 1 play a game, since the skill of player 0 is higher 
/// than that of player 1, player 0 wins. The resulting queue is 
/// [0,2,3,4,1].
/// Players 0 and 2 play a game, since the skill of player 2 is higher 
/// than that of player 0, player 2 wins. The resulting queue is 
/// [2,3,4,1,0].
/// Players 2 and 3 play a game, since the skill of player 2 is higher 
/// than that of player 3, player 2 wins. The resulting queue is 
/// [2,4,1,0,3].
/// Player 2 won k = 2 games in a row, so the winner is player 2.
///
/// Example 2:
/// Input: skills = [2,5,4], k = 3
/// Output: 1 
/// Explanation:
/// Initially, the queue of players is [0,1,2]. The following process 
/// happens:
///
/// Players 0 and 1 play a game, since the skill of player 1 is higher 
/// than that of player 0, player 1 wins. The resulting queue is [1,2,0].
/// Players 1 and 2 play a game, since the skill of player 1 is higher 
/// than that of player 2, player 1 wins. The resulting queue is [1,0,2].
/// Players 1 and 0 play a game, since the skill of player 1 is higher 
/// than that of player 0, player 1 wins. The resulting queue is [1,2,0].
/// Player 1 won k = 3 games in a row, so the winner is player 1.
/// 
/// Constraints:
/// 1. n == skills.length
/// 2. 2 <= n <= 10^5
/// 3. 1 <= k <= 10^9 
/// 4. 1 <= skills[i] <= 10^6
/// 5. All integers in skills are unique.
/// </summary>
int LeetCodeArray::findWinningPlayer(vector<int>& skills, int k)
{
    int result = 0, count = 0;
    for (size_t i = 1; i < skills.size(); i++)
    {
        if (skills[i] < skills[result])
        {
            count++;
        }
        else
        {
            result = i;
            count = 1;
        }
        if (count == k) break;
    }
    return result;
}

/// <summary>
/// LeetCode 3179. Find the N-th Value After K Seconds
/// 
/// Medium
///
/// You are given two positive integers n and k. There are n children 
/// numbered from 0 to n - 1 standing in a queue in order from left to 
/// right.
///
/// You are given two integers n and k.
/// Initially, you start with an array a of n integers where a[i] = 1 for 
/// all 0 <= i <= n - 1. After each second, you simultaneously update each 
/// element to be the sum of all its preceding elements plus the element 
/// itself. For example, after one second, a[0] remains the same, a[1] 
/// becomes a[0] + a[1], a[2] becomes a[0] + a[1] + a[2], and so on.
///
/// Return the value of a[n - 1] after k seconds.
/// Since the answer may be very large, return it modulo 10^9 + 7.
/// 
/// Example 1:
/// Input: n = 4, k = 5
/// Output: 56
/// Explanation:
/// Second	State After
/// 0	[1,1,1,1]
/// 1	[1,2,3,4]
/// 2	[1,3,6,10]
/// 3	[1,4,10,20]
/// 4	[1,5,15,35]
/// 5	[1,6,21,56]
///
/// Example 2:
/// Input: n = 5, k = 3
/// Output: 35
/// Explanation:
/// Second	State After
/// 0	[1,1,1,1,1]
/// 1	[1,2,3,4,5]
/// 2	[1,3,6,10,15]
/// 3	[1,4,10,20,35]
///
/// Constraints:
/// 1. 1 <= n, k <= 1000
/// </summary>
int LeetCodeArray::valueAfterKSeconds(int n, int k)
{
    int M = 1000000007;
    vector<int> dp(n, 1);
    for (int i = 0; i < k; i++)
    {
        for (int j = 1; j < n; j++)
        {
            dp[j] = (dp[j] + dp[j - 1]) % M;
        }
    }
    return dp[n - 1];
}

/// <summary>
/// LeetCode 3189. Minimum Moves to Get a Peaceful Board
///
/// Medium
/// 
/// Given a 2D array rooks of length n, where rooks[i] = [xi, yi] 
/// indicates the position of a rook on an n x n chess board. Your 
/// task is to move the rooks 1 cell at a time vertically or horizontally 
/// (to an adjacent cell) such that the board becomes peaceful.
///
/// A board is peaceful if there is exactly one rook in each row and each 
/// column.
///
/// Return the minimum number of moves required to get a peaceful board.
///
/// Note that at no point can there be two rooks in the same cell.
/// 
/// Example 1:
/// Input: rooks = [[0,0],[1,0],[1,1]]
/// Output: 3
/// Explanation:
///
/// Example 2:
/// Input: rooks = [[0,0],[0,1],[0,2],[0,3]]
/// Output: 6
/// Explanation:
///
/// Constraints:
/// 1. 1 <= n == rooks.length <= 500
/// 2. 0 <= xi, yi <= n - 1
/// 3. The input is generated such that there are no 2 rooks in the same 
///    cell.
/// </summary>
int LeetCodeArray::minMoves(vector<vector<int>>& rooks)
{
    int result = 0;
    int n = rooks.size();
    vector<int> rows(n), cols(n);
    for (size_t i = 0; i < rooks.size(); i++)
    {
        rows[rooks[i][0]]++;
        cols[rooks[i][1]]++;
    }
    queue<int> row_dup, row_empty, col_dup, col_empty;
    for (int i = 0; i < n; i++)
    {
        if (rows[i] > 1)
        {
            for (int j = 0; j < rows[i] - 1; j++) row_dup.push(i);
        }
        else if (rows[i] == 0)
        {
            row_empty.push(i);
        }
        if (cols[i] > 1)
        {
            for (int j = 0; j < cols[i] - 1; j++) col_dup.push(i);
        }
        else if (cols[i] == 0)
        {
            col_empty.push(i);
        }
    }
    while (!row_dup.empty())
    {
        result += abs(row_dup.front() - row_empty.front());
        row_dup.pop();
        row_empty.pop();
    }
    while (!col_dup.empty())
    {
        result += abs(col_dup.front() - col_empty.front());
        col_dup.pop();
        col_empty.pop();
    }
    return result;
}

/// <summary>
/// LeetCode 3191. Minimum Operations to Make Binary Array Elements Equal 
///                to One I
///
/// Medium
/// 
/// You are given a binary array nums.
///
/// You can do the following operation on the array any number of times 
/// (possibly zero):
///
/// Choose any 3 consecutive elements from the array and flip all of them.
/// Flipping an element means changing its value from 0 to 1, and from 1 
/// to 0.
///
/// Return the minimum number of operations required to make all elements 
/// in nums equal to 1. If it is impossible, return -1.
///
/// Example 1:
/// Input: nums = [0,1,1,1,0,0]
/// Output: 3
/// Explanation:
/// We can do the following operations:
/// Choose the elements at indices 0, 1 and 2. The resulting array is 
/// nums = [1,0,0,1,0,0].
/// Choose the elements at indices 1, 2 and 3. The resulting array is 
/// nums = [1,1,1,0,0,0].
/// Choose the elements at indices 3, 4 and 5. The resulting array is 
/// nums = [1,1,1,1,1,1].
///
/// Example 2:
/// Input: nums = [0,1,1,1]
/// Output: -1
/// Explanation:
/// It is impossible to make all elements equal to 1.
/// 
/// Constraints:
/// 1. 3 <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 1
/// </summary>
int LeetCodeArray::minOperationsFlipI(vector<int>& nums)
{
    int result = 0;
    vector<int> arr = nums;
    for (size_t i = 0; i < arr.size() - 2; i++)
    {
        if (arr[i] == 0)
        {
            arr[i] = 1 - arr[i];
            arr[i + 1] = 1 - arr[i + 1];
            arr[i + 2] = 1 - arr[i + 2];
            result++;
        }
    }
    int n = arr.size();
    if (arr[n - 1] == 0 || arr[n - 2] == 0) return -1;
    else return result;
}

/// <summary>
/// LeetCode 3192. Minimum Operations to Make Binary Array Elements Equal 
///                to One II 
///
/// Medium
/// 
/// You are given a binary array nums.
/// You can do the following operation on the array any number of times 
/// (possibly zero):
///
/// Choose any index i from the array and flip all the elements from 
/// index i to the end of the array.
/// Flipping an element means changing its value from 0 to 1, and from 1 
/// to 0.
///
/// Return the minimum number of operations required to make all elements 
/// in nums equal to 1.
/// 
/// Example 1:
/// Input: nums = [0,1,1,0,1]
/// Output: 4
/// Explanation:
/// We can do the following operations:
/// Choose the index i = 1. The resulting array will be nums = [0,0,0,1,0].
/// Choose the index i = 0. The resulting array will be nums = [1,1,1,0,1].
/// Choose the index i = 4. The resulting array will be nums = [1,1,1,0,0].
/// Choose the index i = 3. The resulting array will be nums = [1,1,1,1,1].
///
/// Example 2:
/// Input: nums = [1,0,0,0]
/// Output: 1
/// Explanation:
/// We can do the following operation:
/// Choose the index i = 1. The resulting array will be nums = [1,1,1,1].
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 1
/// </summary>
int LeetCodeArray::minOperationsFlipII(vector<int>& nums)
{
    int flip = 0;
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] + flip == 1) continue;
        result++;
        flip = 1 - flip;
    }
    return result;
}

/// <summary>
/// LeetCode 3187. Peaks in Array
/// </summary>
int LeetCodeArray::IsPeak(vector<int>& nums, int i)
{
    if (i == 0 || i == nums.size() - 1) return false;
    if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) return 1;
    else return 0;
}


/// <summary>
/// LeetCode 3187. Peaks in Array
///
/// Hard
///
/// A peak in an array arr is an element that is greater than its previous 
/// and next element in arr.
///
/// You are given an integer array nums and a 2D integer array queries.
///
/// You have to process queries of two types:
/// queries[i] = [1, li, ri], determine the count of peak elements in the 
/// subarray nums[li..ri]. queries[i] = [2, indexi, vali], change 
/// nums[indexi] to vali.
/// Return an array answer containing the results of the queries of the 
/// first type in order.
///
/// Notes:
/// The first and the last element of an array or a subarray cannot be a 
/// peak.
/// 
/// Example 1:
/// Input: nums = [3,1,4,2,5], queries = [[2,3,4],[1,0,4]]
/// Output: [0]
/// Explanation:
/// First query: We change nums[3] to 4 and nums becomes [3,1,4,4,5].
/// Second query: The number of peaks in the [3,1,4,4,5] is 0.
///
/// Example 2:
/// Input: nums = [4,1,4,2,1,5], queries = [[2,2,4],[1,0,2],[1,0,4]]
/// Output: [0,1]
///
/// Explanation:
/// First query: nums[2] should become 4, but it is already set to 4.
/// Second query: The number of peaks in the [4,1,4] is 0.
///
/// Third query: The second 4 is a peak in the [4,1,4,2,1].
/// 
/// Constraints:
/// 1. 3 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^5
/// 3. 1 <= queries.length <= 10^5
/// 4. queries[i][0] == 1 or queries[i][0] == 2
/// 5. For all i that:
///    queries[i][0] == 1: 0 <= queries[i][1] <= queries[i][2] <= 
///    nums.length - 1
///    queries[i][0] == 2: 0 <= queries[i][1] <= nums.length - 1, 
///    1 <= queries[i][2] <= 10^5
/// </summary>
vector<int> LeetCodeArray::countOfPeaks(vector<int>& nums, vector<vector<int>>& queries)
{
    int n = nums.size();
    vector<int> peaks(n);
    BinaryIndexTree tree(n);
    for (int i = 1; i < n - 1; i++)
    {
        if (IsPeak(nums, i))
        {
            peaks[i] = 1;
            tree.add(i, 1);
        }
    }
    vector<int> result;
    for (size_t i = 0; i < queries.size(); i++)
    {
        if (queries[i][0] == 2)
        {
            int a = queries[i][1];
            int b = queries[i][2];
            nums[a] = b;
            if (a > 0 && a < n - 1)
            {
                tree.add(a, IsPeak(nums, a) - peaks[a]);
                peaks[a] = IsPeak(nums, a);
            }
            if (a > 1)
            {
                tree.add(a - 1, IsPeak(nums, a - 1) - peaks[a - 1]);
                peaks[a - 1] = IsPeak(nums, a - 1);
            }
            if (a < n - 2)
            {
                tree.add(a + 1, IsPeak(nums, a + 1) - peaks[a + 1]);
                peaks[a + 1] = IsPeak(nums, a + 1);
            }
        }
        else if (queries[i][0] == 1)
        {
            int a = queries[i][1];
            int b = queries[i][2];
            if (a == b) result.push_back(0);
            else
            {
                result.push_back(tree.sum(b - 1) - tree.sum(a));
            }
        }
    }
    return result;
}

/// <summary>
/// LeetCode 3212. Count Submatrices With Equal Frequency of X and Y
///
/// Medium
///
/// Given a 2D character matrix grid, where grid[i][j] is either 'X', 'Y', 
/// or '.', return the number of submatrices that contains:
/// grid[0][0] an equal frequency of 'X' and 'Y'. at least one 'X'.
///  
/// Example 1:
/// Input: grid = [["X","Y","."],["Y",".","."]]
/// Output: 3
/// Explanation:
/// 
/// Example 2:
/// Input: grid = [["X","X"],["X","Y"]]
/// Output: 0
/// Explanation:
/// No submatrix has an equal frequency of 'X' and 'Y'.
///
/// Example 3:
/// Input: grid = [[".","."],[".","."]]
/// Output: 0
/// Explanation:
/// No submatrix has at least one 'X'.
/// 
/// Constraints:
/// 1. 1 <= grid.length, grid[i].length <= 1000
/// 2. grid[i][j] is either 'X', 'Y', or '.'.
/// </summary>
int LeetCodeArray::numberOfSubmatrices(vector<vector<char>>& grid)
{
    vector<pair<int, int>> cols(grid[0].size());
    int result = 0;
    for (size_t i = 0; i < grid.size(); i++)
    {
        int x = 0, y = 0;
        for (size_t j = 0; j < grid[0].size(); j++)
        {
            if (grid[i][j] == 'X') x++;
            else if (grid[i][j] == 'Y') y++;
            if (i == 0)
            {
                if (x == y && x > 0) result++;
            }
            else
            {
                if (cols[j].first + x == cols[j].second + y && cols[j].first + x > 0)
                {
                    result++;
                }
            }
            cols[j].first += x;
            cols[j].second += y;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3228. Maximum Number of Operations to Move Ones to the End
///
/// Medium
///
/// You are given a binary string s.
/// You can perform the following operation on the string any number of 
/// times:
/// 
/// Choose any index i from the string where i + 1 < s.length such that 
/// s[i] == '1' and s[i + 1] == '0'.
/// Move the character s[i] to the right until it reaches the end of the 
/// string or another '1'. For example, for s = "010010", if we choose 
/// i = 1, the resulting string will be s = "000110".
/// Return the maximum number of operations that you can perform.
/// 
/// Example 1:
/// Input: s = "1001101"
/// Output: 4
/// Explanation:
/// We can perform the following operations:
/// Choose index i = 0. The resulting string is s = "0011101".
/// Choose index i = 4. The resulting string is s = "0011011".
/// Choose index i = 3. The resulting string is s = "0010111".
/// Choose index i = 2. The resulting string is s = "0001111".
///
/// Example 2:
/// Input: s = "00111"
/// Output: 0
/// 
/// Constraints:
/// 1. 1 <= s.length <= 10^5
/// 2. s[i] is either '0' or '1'.
/// </summary>
int LeetCodeArray::maxOperations(string s)
{
    int one = 0;
    int result = 0;
    for (size_t i = 0; i < s.size(); i++)
    {
        if (s[i] == '1') one++;
        else if (i > 0 && s[i-1] == '1') result += one;
    }
    return result;
}


/// <summary>
/// Leet Code 3229. Minimum Operations to Make Array Equal to Target
///
/// Hard
///
/// You are given two positive integer arrays nums and target, of the same 
/// length.
/// In a single operation, you can select any subarray of nums and 
/// increment or decrement each element within that subarray by 1.
///
/// Return the minimum number of operations required to make nums equal to 
/// the array target.
/// 
/// Example 1:
/// Input: nums = [3,5,1,2], target = [4,6,2,4]
/// Output: 2
/// Explanation:
/// We will perform the following operations to make nums equal to target:
/// - Increment nums[0..3] by 1, nums = [4,6,2,3].
/// - Increment nums[3..3] by 1, nums = [4,6,2,4].
/// 
/// Example 2:
/// Input: nums = [1,3,2], target = [2,1,4]
/// Output: 5
/// Explanation:
/// We will perform the following operations to make nums equal to target:
/// - Increment nums[0..0] by 1, nums = [2,3,2].
/// - Decrement nums[1..1] by 1, nums = [2,2,2].
/// - Decrement nums[1..1] by 1, nums = [2,1,2].
/// - Increment nums[2..2] by 1, nums = [2,1,3].
/// - Increment nums[2..2] by 1, nums = [2,1,4].
/// 
/// Constraints:
/// 1. 1 <= nums.length == target.length <= 10^5
/// 2. 1 <= nums[i], target[i] <= 10^8
/// </summary>
long long LeetCodeArray::minimumOperations(vector<int>& nums, vector<int>& target)
{
    long long prev = 0;
    long long result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        long long val = (long long)target[i] - (long long)nums[i];
        if (val * prev <= 0)
        {
            result += abs(val);
        }
        else 
        {
            if (abs(val) > abs(prev))
            {
                result += abs(val) - abs(prev);
            }
        }
        prev = val;
    }
    return result;
}

/// <summary>
/// Leet Code 3237. Alt and Tab Simulation
///
/// Medium
///
/// There are n windows open numbered from 1 to n, we want to simulate
/// using alt + tab to navigate between the windows.
///
/// You are given an array windows which contains the initial order of the 
/// windows (the first element is at the top and the last one is at the 
/// bottom).
///
/// You are also given an array queries where for each query, the window 
/// queries[i] is brought to the top.
///
/// Return the final state of the array windows.
/// 
/// Example 1:
/// Input: windows = [1,2,3], queries = [3,3,2]
/// Output: [2,3,1]
/// Explanation:
/// Here is the window array after each query:
/// Initial order: [1,2,3]
/// After the first query: [3,2,1]
/// After the second query: [3,2,1]
/// After the last query: [2,3,1]
///
/// Example 2:
/// Input: windows = [1,4,2,3], queries = [4,1,3]
/// Output: [3,1,4,2]
///
/// Explanation:
/// Here is the window array after each query:
/// Initial order: [1,4,2,3]
/// After the first query: [4,1,2,3]
/// After the second query: [1,4,2,3]
/// After the last query: [3,1,4,2]
/// 
/// Constraints:
/// 1. 1 <= n == windows.length <= 10^5
/// 2. windows is a permutation of [1, n].
/// 3. 1 <= queries.length <= 105
/// 4. 1 <= queries[i] <= n
/// </summary>
vector<int> LeetCodeArray::simulationResult(vector<int>& windows, vector<int>& queries)
{
    int n = windows.size();
    vector<int> visited(n + 1);
    vector<int> result;
    for (int i = queries.size() - 1; i >= 0; i--)
    {
        if (visited[queries[i]] == 0)
        {
            result.push_back(queries[i]);
            visited[queries[i]] = 1;
        }
    }
    for (int i = 0; i < n; i++)
    {
        if (visited[windows[i]] == 0)
        {
            result.push_back(windows[i]);
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3238. Find the Number of Winning Players
///
/// Easy
///
/// You are given an integer n representing the number of players in a 
/// game and a 2D array pick where pick[i] = [xi, yi] represents that 
/// the player xi picked a ball of color yi.
///
/// Player i wins the game if they pick strictly more than i balls of 
/// the same color. In other words,
///
/// Player 0 wins if they pick any ball.
/// Player 1 wins if they pick at least two balls of the same color.
/// ...
/// Player i wins if they pick at leasti + 1 balls of the same color.
/// Return the number of players who win the game.
///
/// Note that multiple players can win the game.
/// 
/// Example 1:
/// Input: n = 4, pick = [[0,0],[1,0],[1,0],[2,1],[2,1],[2,0]]
/// Output: 2
/// Explanation:
/// Player 0 and player 1 win the game, while players 2 and 3 do not win.
///
/// Example 2:
/// Input: n = 5, pick = [[1,1],[1,2],[1,3],[1,4]]
/// Output: 0
/// Explanation:
/// No player wins the game.
///
/// Example 3:
/// Input: n = 5, pick = [[1,1],[2,4],[2,4],[2,4]]
/// Output: 1
/// Explanation:
/// Player 2 wins the game by picking 3 balls with color 4.
/// 
/// Constraints:
/// 1. 2 <= n <= 10
/// 2. 1 <= pick.length <= 100
/// 3. pick[i].length == 2
/// 4. 0 <= xi <= n - 1 
/// 5. 0 <= yi <= 10
/// </summary>
int LeetCodeArray::winningPlayerCount(int n, vector<vector<int>>& pick)
{
    vector<vector<int>> picks(n, vector<int>(11));
    for (size_t i = 0; i < pick.size(); i++)
    {
        picks[pick[i][0]][pick[i][1]]++;
    }
    int result = 0;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j <= 10; j++)
        {
            if (picks[i][j] > i)
            {
                result++;
                break;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3239. Minimum Number of Flips to Make Binary Grid 
///                Palindromic I
///
/// Medium
///
/// You are given an m x n binary matrix grid.
///
/// A row or column is considered palindromic if its values read the same 
/// forward and backward.
///
/// You can flip any number of cells in grid from 0 to 1, or from 1 to 0.
///
/// Return the minimum number of cells that need to be flipped to make 
/// either all rows palindromic or all columns palindromic.
///
/// Example 1:
/// Input: grid = [[1,0,0],[0,0,0],[0,0,1]]
///
/// Output: 2
///
/// Explanation:
/// Flipping the highlighted cells makes all the rows palindromic.
///
/// Example 2:
/// Input: grid = [[0,1],[0,1],[0,0]]
/// 
/// Output: 1
///
/// Explanation:
/// Flipping the highlighted cell makes all the columns palindromic.
///
/// Example 3:
/// Input: grid = [[1],[0]]
/// Output: 0
/// Explanation:
/// All rows are already palindromic.
/// 
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 1 <= m * n <= 2 * 10^5
/// 4. 0 <= grid[i][j] <= 1
/// </summary>
int LeetCodeArray::minFlipsI(vector<vector<int>>& grid)
{
    int h = 0, v = 0;
    for (size_t i = 0; i < grid.size(); i++)
    {
        for (size_t j = 0; j < grid[0].size(); j++)
        {
            if (j < grid[0].size() / 2 && grid[i][j] != grid[i][grid[0].size() - 1 - j])
            {
                h++;
            }
            if (i < grid.size() / 2 && grid[i][j] != grid[grid.size() - 1 - i][j])
            {
                v++;
            }
        }
    }
    int result = min(h, v);
    return result;
}

/// <summary>
/// Leet Code 3240. Minimum Number of Flips to Make Binary Grid 
///                 Palindromic II 
/// 
/// Medium
///
/// You are given an m x n binary matrix grid.
/// A row or column is considered palindromic if its values read the same 
/// forward and backward.
///
/// You can flip any number of cells in grid from 0 to 1, or from 1 to 0.
///
/// Return the minimum number of cells that need to be flipped to make all 
/// rows and columns palindromic, and the total number of 1's in grid 
/// divisible by 4.
///
/// Example 1:
/// Input: grid = [[1,0,0],[0,1,0],[0,0,1]]
/// Output: 3
///
/// Explanation:
///
/// Example 2:
/// Input: grid = [[0,1],[0,1],[0,0]]
/// Output: 2
/// 
/// Explanation:
///
/// Example 3:
/// Input: grid = [[1],[1]]
/// Output: 2
/// Explanation:
/// 
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 1 <= m * n <= 2 * 10^5
/// 4. 0 <= grid[i][j] <= 1
/// </summary>
int LeetCodeArray::minFlipsII(vector<vector<int>>& grid)
{
    int result = 0;
    int m = grid.size();
    int n = grid[0].size();
    for (int i = 0; i < m / 2; i++)
    {
        for (int j = 0; j < n / 2; j++)
        {
            int count = grid[i][j] + grid[i][n - 1 - j] + grid[m - 1 - i][j] + grid[m - 1 - i][n - 1 - j];
            result += min(count, 4 - count);
        }
    }
    int ones = 0;
    int flips = 0;
    if (m % 2 == 1)
    {
        int i = m / 2;
        for (int j = 0; j < n / 2; j++)
        {
            int count = grid[i][j] + grid[i][n - 1 - j];
            flips += min(count, 2 - count);
            ones += count;
        }
    }
    if (n % 2 == 1)
    {
        int j = n / 2;
        for (int i = 0; i < m / 2; i++)
        {
            int count = grid[i][j] + grid[m - 1 - i][j];
            flips += min(count, 2 - count);
            ones += count;
        }
    }
    if (flips == 0 && ones % 4 == 2) flips += 2;
    result += flips;
    if (m % 2 == 1 && n % 2 == 1 && grid[m / 2][n / 2] == 1) result++;
    return result;
}

/// <summary>
/// Leet Code 3254. Find the Power of K-Size Subarrays I
/// 
/// Medium
///
/// You are given an array of integers nums of length n and a positive 
/// integer k.
///
/// The power of an array is defined as:
/// 
/// Its maximum element if all of its elements are consecutive and sorted 
/// in ascending order.
/// -1 otherwise.
/// You need to find the power of all 
/// subarrays of nums of size k.
/// Return an integer array results of size n - k + 1, where results[i] 
/// is the power of nums[i..(i + k - 1)].
/// 
/// Example 1:
/// Input: nums = [1,2,3,4,3,2,5], k = 3
/// Output: [3,4,-1,-1,-1]
/// Explanation:
/// There are 5 subarrays of nums of size 3:
/// [1, 2, 3] with the maximum element 3.
/// [2, 3, 4] with the maximum element 4.
/// [3, 4, 3] whose elements are not consecutive.
/// [4, 3, 2] whose elements are not sorted.
/// [3, 2, 5] whose elements are not consecutive.
///
/// Example 2:
/// Input: nums = [2,2,2,2,2], k = 4
/// Output: [-1,-1]
///
/// Example 3:
/// Input: nums = [3,2,3,2,3,2], k = 2
/// Output: [-1,3,-1,3,-1]
/// 
/// Constraints:
/// 1. 1 <= n == nums.length <= 500
/// 2. 1 <= nums[i] <= 10^5
/// 3. 1 <= k <= n
/// </summary>
vector<int> LeetCodeArray::resultsArrayI(vector<int>& nums, int k)
{
    int count = 0;
    vector<int> result;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (i == 0) count = 1;
        else if (nums[i] == nums[i - 1] + 1)
        {
            count++;
        }
        else
        {
            count = 1;
        }
        if ((int)i >= k - 1)
        {
            if (count >= k)
            {
                result.push_back(nums[i]);
            }
            else
            {
                result.push_back(-1);
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3255. Find the Power of K - Size Subarrays II
/// 
/// Medium
/// 
/// You are given an array of integers nums of length n and a positive 
/// integer k.
///
/// The power of an array is defined as :
/// Its maximum element if all of its elements are consecutive and sorted 
/// in ascending order.
/// - 1 otherwise.
/// You need to find the power of all subarrays of nums of size k.
///
/// Return an integer array results of size n - k + 1, where results[i] 
/// is the power of nums[i..(i + k - 1)].
/// 
/// Example 1:
/// Input: nums = [1, 2, 3, 4, 3, 2, 5], k = 3
/// Output : [3, 4, -1, -1, -1]
/// Explanation :
/// There are 5 subarrays of nums of size 3 :
/// [1, 2, 3] with the maximum element 3.
/// [2, 3, 4] with the maximum element 4.
/// [3, 4, 3] whose elements are not consecutive.
/// [4, 3, 2] whose elements are not sorted.
/// [3, 2, 5] whose elements are not consecutive.
///
/// Example 2:
/// Input: nums = [2, 2, 2, 2, 2], k = 4
/// Output : [-1, -1]
///
/// Example 3 :
/// Input : nums = [3, 2, 3, 2, 3, 2], k = 2
/// Output : [-1, 3, -1, 3, -1]
///
/// Constraints:
/// 1. 1 <= n == nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^6
/// 3. 1 <= k <= n
/// </summary>
vector<int> LeetCodeArray::resultsArrayII(vector<int>& nums, int k)
{
    int count = 0;
    vector<int> result;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (i == 0) count = 1;
        else if (nums[i] == nums[i - 1] + 1)
        {
            count++;
        }
        else
        {
            count = 1;
        }
        if ((int)i >= k - 1)
        {
            if (count >= k)
            {
                result.push_back(nums[i]);
            }
            else
            {
                result.push_back(-1);
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3256. Maximum Value Sum by Placing Three Rooks I
/// 
/// Hard
/// 
/// You are given a m x n 2D array board representing a chessboard, where 
/// board[i][j] represents the value of the cell (i, j).
///
/// Rooks in the same row or column attack each other. You need to place 
/// three rooks on the chessboard such that the rooks do not attack each 
/// other.
///
/// Return the maximum sum of the cell values on which the rooks are 
/// placed.
/// 
/// Example 1:
/// Input: board = [[-3,1,1,1],[-3,1,-3,1],[-3,2,1,1]]
/// 
/// Output: 4
/// Explanation:
/// We can place the rooks in the cells (0, 2), (1, 3), and (2, 1) for a 
/// sum of 1 + 1 + 2 = 4.
///
/// Example 2:
/// Input: board = [[1,2,3],[4,5,6],[7,8,9]]
/// Output: 15
/// Explanation:
/// We can place the rooks in the cells (0, 0), (1, 1), and (2, 2) for a 
/// sum of 1 + 5 + 9 = 15.
///
/// Example 3:
/// Input: board = [[1,1,1],[1,1,1],[1,1,1]]
/// Output: 3
/// Explanation:
/// We can place the rooks in the cells (0, 2), (1, 1), and (2, 0) for a 
/// sum of 1 + 1 + 1 = 3.
/// 
/// Constraints:
/// 1. 3 <= m == board.length <= 100
/// 2. 3 <= n == board[i].length <= 100
/// 3. -10^9 <= board[i][j] <= 10^9
/// </summary>
long long LeetCodeArray::maximumValueSumI(vector<vector<int>>& board)
{
    int n = board.size();
    int m = board[0].size();
    priority_queue<vector<int>> pq;
    for (int i = 0; i < (int)board.size(); i++)
    {
        for (int j = 0; j < (int)board[i].size(); j++)
        {
            pq.push({ board[i][j], i, j });
        }
    }
    vector<int> row_count(n), col_count(m);
    vector<vector<int>> top_9;
    while (!pq.empty())
    {
        vector<int> cell = pq.top();
        pq.pop();
        if (row_count[cell[1]] < 3 && col_count[cell[2]] < 3)
        {
            top_9.push_back(cell);
            row_count[cell[1]]++; col_count[cell[2]]++;
        }
        if (top_9.size() == 9) break;
    }
    long long result = LLONG_MIN;
    for (int i = 0; i < 9; i++)
    {
        for (int j = i + 1; j < 9; j++)
        {
            if (top_9[i][1] == top_9[j][1] || top_9[i][2] == top_9[j][2])
            {
                continue;
            }
            for (int k = j + 1; k < 9; k++)
            {
                if (top_9[i][1] == top_9[k][1] || top_9[i][2] == top_9[k][2])
                {
                    continue;
                }
                if (top_9[j][1] == top_9[k][1] || top_9[j][2] == top_9[k][2])
                {
                    continue;
                }
                result = max(result, (long long)top_9[i][0] + (long long)top_9[j][0] + (long long)top_9[k][0]);
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3257. Maximum Value Sum by Placing Three Rooks II
/// 
/// Hard
///
/// You are given a m x n 2D array board representing a chessboard, where 
/// board[i][j] represents the value of the cell (i, j).
///
/// Rooks in the same row or column attack each other. You need to place 
/// three rooks on the chessboard such that the rooks do not attack each 
/// other.
///
/// Return the maximum sum of the cell values on which the rooks are 
/// placed.
/// 
/// Example 1:
/// Input: board = [[-3,1,1,1],[-3,1,-3,1],[-3,2,1,1]]
/// Output: 4
/// Explanation:
/// We can place the rooks in the cells (0, 2), (1, 3), and (2, 1) for a 
/// sum of 1 + 1 + 2 = 4.
///
/// Example 2:
/// Input: board = [[1,2,3],[4,5,6],[7,8,9]]
/// Output: 15
/// Explanation:
/// We can place the rooks in the cells (0, 0), (1, 1), and (2, 2) for a 
/// sum of 1 + 5 + 9 = 15.
///
/// Example 3:
/// Input: board = [[1,1,1],[1,1,1],[1,1,1]]
/// Output: 3
/// Explanation:
/// We can place the rooks in the cells (0, 2), (1, 1), and (2, 0) for a 
/// sum of 1 + 1 + 1 = 3.
/// 
/// Constraints:
/// 1. 3 <= m == board.length <= 500
/// 2. 3 <= n == board[i].length <= 500
/// 3. -10^9 <= board[i][j] <= 10^9
/// </summary>
long long LeetCodeArray::maximumValueSumII(vector<vector<int>>& board)
{
    int n = board.size();
    int m = board[0].size();
    priority_queue<vector<int>> pq;
    for (int i = 0; i < (int)board.size(); i++)
    {
        for (int j = 0; j < (int)board[i].size(); j++)
        {
            pq.push({ board[i][j], i, j });
        }
    }
    vector<int> row_count(n), col_count(m);
    vector<vector<int>> top_9;
    while (!pq.empty())
    {
        vector<int> cell = pq.top();
        pq.pop();
        if (row_count[cell[1]] < 3 && col_count[cell[2]] < 3)
        {
            top_9.push_back(cell);
            row_count[cell[1]]++; col_count[cell[2]]++;
        }
        if (top_9.size() == 9) break;
    }
    long long result = LLONG_MIN;
    for (int i = 0; i < 9; i++)
    {
        for (int j = i + 1; j < 9; j++)
        {
            if (top_9[i][1] == top_9[j][1] || top_9[i][2] == top_9[j][2])
            {
                continue;
            }
            for (int k = j + 1; k < 9; k++)
            {
                if (top_9[i][1] == top_9[k][1] || top_9[i][2] == top_9[k][2])
                {
                    continue;
                }
                if (top_9[j][1] == top_9[k][1] || top_9[j][2] == top_9[k][2])
                {
                    continue;
                }
                result = max(result, (long long)top_9[i][0] + (long long)top_9[j][0] + (long long)top_9[k][0]);
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3279. Maximum Total Area Occupied by Pistons
/// 
/// Hard
///
/// There are several pistons in an old car engine, and we want to 
/// calculate the maximum possible area under the pistons.
///
/// You are given:
/// An integer height, representing the maximum height a piston can reach.
/// An integer array positions, where positions[i] is the current position 
/// of piston i, which is equal to the current area under it.
/// A string directions, where directions[i] is the current moving 
/// direction of piston i, 'U' for up, and 'D' for down.
/// Each second:
/// 
/// Every piston moves in its current direction 1 unit. e.g., if the 
/// direction is up, positions[i] is incremented by 1.
/// If a piston has reached one of the ends, i.e., positions[i] == 0 
/// or positions[i] == height, its direction will change.
/// Return the maximum possible area under all the pistons.
///
/// Example 1:
/// Input: height = 5, positions = [2,5], directions = "UD"
/// Output: 7
/// Explanation:
/// The current position of the pistons has the maximum possible area 
/// under it.
///
/// Example 2:
/// Input: height = 6, positions = [0,0,6,3], directions = "UUDU"
/// Output: 15
/// Explanation:
/// After 3 seconds, the pistons will be in positions [3, 3, 3, 6], 
/// which has the maximum possible area under it.
///
/// Constraints:
/// 1. 1 <= height <= 10^6
/// 2. 1 <= positions.length == directions.length <= 10^5
/// 3. 0 <= positions[i] <= height
/// 4. directions[i] is either 'U' or 'D'.
/// </summary>
long long LeetCodeArray::maxArea(int height, vector<int>& positions, string directions)
{
    vector<long long> dp(2 * height);
    long long area = 0;
    for (size_t i = 0; i < positions.size(); i++)
    {
        area += positions[i];
        if (directions[i] == 'U')
        {
            dp[0]++;
            int next = height - positions[i];
            if (next < 2 * height)
            {
                dp[next] -= 2;
            }
            next += height;
            if (next < 2 * height)
            {
                dp[next] += 2;
            }
        }
        else
        {
            dp[0]--;
            int next = positions[i];
            if (next < 2 * height)
            {
                dp[next] += 2;
            }
            next += height;
            if (next < 2 * height)
            {
                dp[next] -= 2;
            }
        }
    }
    long long delta = 0;
    long long result = area;
    for (size_t i = 0; i < dp.size(); i++)
    {
        delta += dp[i];
        area += delta;
        result = max(result, area);
    }
    return result;
}

/// <summary>
/// Leet Code 3285. Find Indices of Stable Mountains
/// 
/// Easy
///
/// There are n mountains in a row, and each mountain has a height. You 
/// are given an integer array height where height[i] represents the 
/// height of mountain i, and an integer threshold.
///
/// A mountain is called stable if the mountain just before it (if it 
/// exists) has a height strictly greater than threshold. Note that 
/// mountain 0 is not stable.
///
/// Return an array containing the indices of all stable mountains in 
/// any order.
///
/// Example 1:
/// Input: height = [1,2,3,4,5], threshold = 2
/// Output: [3,4]
/// Explanation:
/// Mountain 3 is stable because height[2] == 3 is greater than 
/// threshold == 2.
/// Mountain 4 is stable because height[3] == 4 is greater than 
/// threshold == 2.
///
/// Example 2:
/// 
/// Input: height = [10,1,10,1,10], threshold = 3
/// Output: [1,3]
/// Example 3:
/// Input: height = [10,1,10,1,10], threshold = 10
/// Output: []
/// 
/// Constraints:
/// 1. 2 <= n == height.length <= 100
/// 2. 1 <= height[i] <= 100
/// 3. 1 <= threshold <= 100
/// </summary>
vector<int> LeetCodeArray::stableMountains(vector<int>& height, int threshold)
{
    vector<int> result;
    for (size_t i = 1; i < height.size(); i++)
    {
        if (height[i - 1] > threshold)
        {
            result.push_back(i);
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3284. Sum of Consecutive Subarrays
/// 
/// Medium
///
/// We call an array arr of length n consecutive if one of the following 
/// holds:
///
/// arr[i] - arr[i - 1] == 1 for all 1 <= i < n.
/// arr[i] - arr[i - 1] == -1 for all 1 <= i < n.
/// The value of an array is the sum of its elements.
///
/// For example, [3, 4, 5] is a consecutive array of value 12 and [9, 8] 
/// is another of value 17. While [3, 4, 3] and [8, 6] are not consecutive.
///
/// Given an array of integers nums, return the sum of the values of all 
/// consecutive subarrays.
///
/// Since the answer may be very large, return it modulo 10^9 + 7.
///
/// Note that an array of length 1 is also considered consecutive.
///
/// Example 1:
/// Input: nums = [1,2,3]
/// Output: 20
///
/// Explanation:
/// The consecutive subarrays are: [1], [2], [3], [1, 2], [2, 3], 
/// [1, 2, 3].
/// Sum of their values would be: 1 + 2 + 3 + 3 + 5 + 6 = 20.
///
/// Example 2:
/// Input: nums = [1,3,5,7]
/// Output: 16
/// Explanation:
/// The consecutive subarrays are: [1], [3], [5], [7].
/// Sum of their values would be: 1 + 3 + 5 + 7 = 16.
///
/// Example 3:
/// Input: nums = [7,6,1,2]
/// Output: 32
/// Explanation:
/// The consecutive subarrays are: [7], [6], [1], [2], [7, 6], [1, 2].
/// Sum of their values would be: 7 + 6 + 1 + 2 + 13 + 3 = 32.
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^5
/// </summary>
int LeetCodeArray::getSumI(vector<int>& nums)
{
    long long M = 1000000007;
    long long result = 0;
    long long sum = 0;
    int count = 0;
    int diff = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (i == 0)
        {
            sum = 0;
            count = 1;
        }
        else
        {
            if (abs(nums[i] - nums[i - 1]) == 1)
            {
                if (nums[i] - nums[i - 1] == diff)
                {
                    count++;
                }
                else
                {
                    sum = nums[i - 1];
                    count = 2;
                }
            }
            else
            {
                sum = 0;
                count = 1;
            }
            diff = nums[i] - nums[i - 1];
        }
        sum = sum + (long long)count * (long long)nums[i];
        result = (result + sum) % M;
    }
    return (int)result;
}

/// <summary>
/// Leet Code 3299. Sum of Consecutive Subsequences 
/// 
/// Hard
/// 
/// We call an array arr of length n consecutive if one of the following 
/// holds:
/// arr[i] - arr[i - 1] == 1 for all 1 <= i < n.
/// arr[i] - arr[i - 1] == -1 for all 1 <= i < n.
/// The value of an array is the sum of its elements.
/// For example, [3, 4, 5] is a consecutive array of value 12 and [9, 8] 
/// is another of value 17. While [3, 4, 3] and [8, 6] are not consecutive.
///
/// Given an array of integers nums, return the sum of the values of all 
/// consecutive non-empty subsequences.
///
/// Since the answer may be very large, return it modulo 10^9 + 7.
/// Note that an array of length 1 is also considered consecutive.
/// 
/// Example 1:
/// Input: nums = [1,2]
/// Output: 6
/// Explanation:
/// The consecutive subsequences are: [1], [2], [1, 2].
///
/// Example 2:
/// Input: nums = [1,4,2,3]
/// Output: 31
/// Explanation:
/// The consecutive subsequences are: [1], [4], [2], [3], [1, 2], [2, 3], 
/// [4, 3], [1, 2, 3].
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^5
/// </summary>
int LeetCodeArray::getSumII(vector<int>& nums)
{
    long long M = 1000000007;
    int result = 0;
    unordered_map<int, pair<int, int>[2]> seq;
    for (size_t i = 0; i < nums.size(); i++)
    {
        int n = nums[i];
        if (seq.count(n - 1) > 0)
        {
            long long sum = (long long)seq[n - 1][0].first + (long long)(seq[n - 1][0].second + 1) * (long long)n;
            long long count = (long long)seq[n - 1][0].second + 1;
            seq[n][0].first = (int)(((long long)seq[n][0].first + sum) % M);
            seq[n][0].second = (int)(((long long)seq[n][0].second + count) % M) ;
            result = (int)(((long long)result + sum) % M);
        }
        else
        {
            seq[n][0].first = (seq[n][0].first + n) % M;
            seq[n][0].second++;
            result = (result + n) % M;
        }
        if (seq.count(n + 1) > 0)
        {
            long long sum = (long long)seq[n + 1][1].first + (long long)(seq[n + 1][1].second + 1) * (long long)n;
            long long count = (long long)seq[n + 1][1].second + 1;
            seq[n][1].first = (int)(((long long)seq[n][1].first + sum) % M);
            seq[n][1].second = (int)(((long long)seq[n][1].second + count) % M);
            result = (int)(((long long)result + sum) % M);
        }
        else
        {
            seq[n][1].first = (seq[n][1].first + n) % M;
            seq[n][1].second++;
            result = (result + n) % M;
        }
        result = (int)(((long long)result - (long long)n + M) % M);
    }
    return result;
}

/// <summary>
/// Leet Code 3337. Total Characters in String After Transformations II
/// </summary>
vector<vector<long long>> LeetCodeArray::matrixMultiply(vector<vector<long long>>& a, vector<vector<long long>>&b, long long mod)
{
    int x = a.size(), y = b[0].size();
    vector<vector<long long>> result(x, vector<long long>(y));
    for (size_t i = 0; i < a.size(); i++)
    {
        for (size_t j = 0; j < b[0].size(); j++)
        {
            for (size_t k = 0; k < b.size(); k++)
            {
                result[i][j] = (result[i][j] + a[i][k] * b[k][j] % mod) % mod;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3337. Total Characters in String After Transformations II
/// </summary>
vector<vector<long long>> LeetCodeArray::matrixExpo(vector<vector<long long>>& matrix, long long exp, long long mod)
{
    int n = matrix.size();
    vector<vector<long long>> result(n, vector<long long>(n));
    for (int i = 0; i < n; i++) result[i][i] = 1;
    while (exp > 0)
    {
        if (exp % 2 == 1)
        {
            result = matrixMultiply(result, matrix, mod);
        }
        matrix = matrixMultiply(matrix, matrix, mod);
        exp /= 2;
    }
    return result;
}


/// <summary>
/// Leet Code 3337. Total Characters in String After Transformations II
/// 
/// Hard
/// 
/// You are given a string s consisting of lowercase English letters, an 
/// integer t representing the number of transformations to perform, and 
/// an array nums of size 26. In one transformation, every character in s 
/// is replaced according to the following rules:
///
/// Replace s[i] with the next nums[s[i] - 'a'] consecutive characters in 
/// the alphabet. For example, if s[i] = 'a' and nums[0] = 3, the 
/// character 'a' transforms into the next 3 consecutive characters ahead 
/// of it, which results in "bcd".
/// The transformation wraps around the alphabet if it exceeds 'z'. For 
/// example, if s[i] = 'y' and nums[24] = 3, the character 'y' transforms 
/// into the next 3 consecutive characters ahead of it, which results in 
/// "zab".
/// Return the length of the resulting string after exactly t 
/// transformations.
///
/// Since the answer may be very large, return it modulo 10^9 + 7.
/// 
/// Example 1:
/// Input: s = "abcyy", t = 2, 
/// nums = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
///
/// Output: 7
///
/// Explanation:
/// First Transformation (t = 1):
/// 'a' becomes 'b' as nums[0] == 1
/// 'b' becomes 'c' as nums[1] == 1
/// 'c' becomes 'd' as nums[2] == 1
/// 'y' becomes 'z' as nums[24] == 1
/// 'y' becomes 'z' as nums[24] == 1
/// String after the first transformation: "bcdzz"
/// Second Transformation (t = 2):
///
/// 'b' becomes 'c' as nums[1] == 1
/// 'c' becomes 'd' as nums[2] == 1
/// 'd' becomes 'e' as nums[3] == 1
/// 'z' becomes 'ab' as nums[25] == 2
/// 'z' becomes 'ab' as nums[25] == 2
/// String after the second transformation: "cdeabab"
/// Final Length of the string: The string is "cdeabab", which has 7 
/// characters.
///
/// Example 2:
/// Input: s = "azbk", t = 1, 
/// nums = [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]
///
/// Output: 8
/// Explanation:
/// First Transformation (t = 1):
/// 'a' becomes 'bc' as nums[0] == 2
/// 'z' becomes 'ab' as nums[25] == 2
/// 'b' becomes 'cd' as nums[1] == 2
/// 'k' becomes 'lm' as nums[10] == 2
/// String after the first transformation: "bcabcdlm"
/// Final Length of the string: The string is "bcabcdlm", which 
/// has 8 characters.
///
/// Constraints:
/// 1. 1 <= s.length <= 10^5
/// 2. s consists only of lowercase English letters.
/// 3. 1 <= t <= 10^9
/// 4. nums.length == 26
/// 5. 1 <= nums[i] <= 25
/// </summary>
int LeetCodeArray::lengthAfterTransformations(string s, int t, vector<int>& nums)
{
    vector<vector<long long>> matrix(26, vector<long long>(26));
    long long M = 1000000007;
    for (int i = 0; i < 26; i++)
    {
        for (int j = 0; j < nums[i]; j++)
        {
            matrix[i][(i + j + 1) % 26] = 1;
        }
    }
    matrix = matrixExpo(matrix, t, M);
    vector<long long> origin(26);
    for (size_t i = 0; i < s.size(); i++)
    {
        origin[s[i] - 'a']++;
    }
    long long result = 0;
    for (int i = 0; i < 26; i++)
    {
        for (int j = 0; j < 26; j++)
        {
            result = (result + origin[i] * matrix[i][j]) % M;
        }
    }
    return (int)result;
}

/// <summary>
/// Leet Code 3349. Adjacent Increasing Subarrays Detection I
/// 
/// Easy
///
/// Given an array nums of n integers and an integer k, determine whether 
/// there exist two adjacent subarrays of length k such that both 
/// subarrays are strictly increasing. Specifically, check if there are 
/// two subarrays starting at indices a and b (a < b), where:
///
/// Both subarrays nums[a..a + k - 1] and nums[b..b + k - 1] are strictly 
/// increasing.
/// The subarrays must be adjacent, meaning b = a + k.
/// Return true if it is possible to find two such subarrays, and false 
/// otherwise.
///
/// Example 1:
/// Input: nums = [2,5,7,8,9,2,3,4,3,1], k = 3
/// Output: true
/// Explanation:
/// The subarray starting at index 2 is [7, 8, 9], which is strictly 
/// increasing.
/// The subarray starting at index 5 is [2, 3, 4], which is also strictly 
/// increasing.
/// These two subarrays are adjacent, so the result is true.
/// Example 2:
/// Input: nums = [1,2,3,4,4,4,4,5,6,7], k = 5
/// Output: false
///
/// Constraints:
/// 1. 2 <= nums.length <= 100
/// 2. 1 < 2 * k <= nums.length
/// 3. -1000 <= nums[i] <= 1000
/// </summary>
bool LeetCodeArray::hasIncreasingSubarrays(vector<int>& nums, int k)
{
    vector<int> dp(nums.size());
    for (int i = 0; i < (int)nums.size(); i++)
    {
        if (i == 0) dp[i] = 1;
        else if (nums[i] > nums[i - 1]) dp[i] = dp[i - 1] + 1;
        else dp[i] = 1;
        if (dp[i] >= k && i - k >= 0 && dp[i - k] >= k)
        {
            return true;
        }
    }
    return false;
}

/// <summary>
/// Leet Code 3351. Sum of Good Subsequences
/// 
/// Hard
///
/// You are given an integer array nums. A good subsequence is defined as 
/// a subsequence of nums where the absolute difference between any two 
/// consecutive elements in the subsequence is exactly 1.
///
/// Return the sum of all possible good subsequences of nums.
/// Since the answer may be very large, return it modulo 10^9 + 7.
///
/// Note that a subsequence of size 1 is considered good by definition.
/// 
/// Example 1:
/// Input: nums = [1,2,1]
/// Output: 14
/// Explanation:
/// Good subsequences are: [1], [2], [1], [1,2], [2,1], [1,2,1].
/// The sum of elements in these subsequences is 14.
///
/// Example 2:
/// Input: nums = [3,4,5]
/// Output: 40
/// Explanation:
/// Good subsequences are: [3], [4], [5], [3,4], [4,5], [3,4,5].
/// The sum of elements in these subsequences is 40.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 0 <= nums[i] <= 10^5
/// </summary>
int LeetCodeArray::sumOfGoodSubsequences(vector<int>& nums)
{
    long long M = 1000000007;
    int result = 0;
    unordered_map<int, pair<int, int>> seq;
    for (size_t i = 0; i < nums.size(); i++)
    {
        int n = nums[i];
        if (seq.count(n - 1) > 0)
        {
            long long sum = (long long)seq[n - 1].first + (long long)(seq[n - 1].second) * (long long)n;
            long long count = (long long)seq[n - 1].second;
            seq[n].first = (int)(((long long)seq[n].first + sum) % M);
            seq[n].second = (int)(((long long)seq[n].second + count) % M);
            result = (int)(((long long)result + sum) % M);
        }
        if (seq.count(n + 1) > 0)
        {
            long long sum = (long long)seq[n + 1].first + (long long)(seq[n + 1].second) * (long long)n;
            long long count = (long long)seq[n + 1].second;
            seq[n].first = (int)(((long long)seq[n].first + sum) % M);
            seq[n].second = (int)(((long long)seq[n].second + count) % M);
            result = (int)(((long long)result + sum) % M);
        }
        seq[n].first = (seq[n].first + n) % M;
        seq[n].second++;
        result = ((long long)result + n) % M;
    }
    return result;
}

/// <summary>
/// Leet Code 3346. Maximum Frequency of an Element After Performing 
///                 Operations I
/// 
/// Medium
///
/// You are given an integer array nums and two integers k and 
/// numOperations.
///
/// You must perform an operation numOperations times on nums, where in 
/// each operation you:
///
/// Select an index i that was not selected in any previous operations.
/// Add an integer in the range [-k, k] to nums[i].
/// Return the maximum possible frequency of any element in nums after 
/// performing the operations.
/// 
/// Example 1:
/// Input: nums = [1,4,5], k = 1, numOperations = 2
/// Output: 2
/// Explanation:
/// We can achieve a maximum frequency of two by:
/// Adding 0 to nums[1]. nums becomes [1, 4, 5].
/// Adding -1 to nums[2]. nums becomes [1, 4, 4].
///
/// Example 2:
/// Input: nums = [5,11,20,20], k = 5, numOperations = 1
/// Output: 2
/// Explanation:
/// We can achieve a maximum frequency of two by:
/// Adding 0 to nums[1].
///
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^5
/// 3. 0 <= k <= 10^5
/// 4. 0 <= numOperations <= nums.length
/// </summary>
int LeetCodeArray::maxFrequencyI(vector<int>& nums, int k, int numOperations)
{
    int n = nums.size();
    sort(nums.begin(), nums.end());
    unordered_map<int, int> num_count;
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++) num_count[nums[i]]++;
    for (int i = nums[0]; i <= nums[n-1]; i++)
    {
        int prev_index = lower_bound(nums.begin(), nums.end(), i - k) - nums.begin();
        int next_index = upper_bound(nums.begin(), nums.end(), i + k) - nums.begin();
        int frequency = num_count[i] + min(next_index - prev_index - num_count[i], numOperations);
        result = max(result, frequency);
    }
    return result;
}

/// <summary>
/// Leet Code 3347. Maximum Frequency of an Element After Performing 
///                 Operations II 
/// 
/// Hard
///
/// You are given an integer array nums and two integers k and 
/// numOperations.
///
/// You must perform an operation numOperations times on nums, where 
/// in each operation you:
///
/// Select an index i that was not selected in any previous operations.
/// Add an integer in the range [-k, k] to nums[i].
/// Return the maximum possible frequency of any element in nums after 
/// performing the operations.
///
/// Example 1:
/// Input: nums = [1,4,5], k = 1, numOperations = 2
/// Output: 2
/// Explanation:
/// We can achieve a maximum frequency of two by:
/// Adding 0 to nums[1], after which nums becomes [1, 4, 5].
/// Adding -1 to nums[2], after which nums becomes [1, 4, 4].
///
/// Example 2:
/// Input: nums = [5,11,20,20], k = 5, numOperations = 1
/// Output: 2
/// Explanation:
/// We can achieve a maximum frequency of two by:
/// Adding 0 to nums[1].
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^9
/// 3. 0 <= k <= 10^9
/// 4. 0 <= numOperations <= nums.length
/// </summary>
int LeetCodeArray::maxFrequencyII(vector<int>& nums, int k, int numOperations)
{
    int n = nums.size();
    vector<long long> arr(n);
    unordered_map<long long, int> num_count;
    for (size_t i = 0; i < nums.size(); i++)
    {
        arr[i] = nums[i];
        num_count[arr[i]]++;
    }
    sort(arr.begin(), arr.end());
    int result = 0;
    for (int i = 0; i < (int)arr.size(); i++)
    {
        for (long long p = arr[i] - k; p <= arr[i] + k; p += k)
        {
            int prev_index = lower_bound(arr.begin(), arr.end(), p - k) - arr.begin();
            int next_index = upper_bound(arr.begin(), arr.end(), p + k) - arr.begin();
            int frequency = num_count[p] + min(next_index - prev_index - num_count[p], numOperations);
            result = max(result, frequency);
            if (k == 0) break;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3353. Minimum Total Operations
/// 
/// Easy
/// 
/// Given an array of integers nums, you can perform any number of 
/// operations on this array.
///
/// In each operation, you can:
/// Choose a prefix of the array.
/// Choose an integer k (which can be negative) and add k to each element 
/// in the chosen prefix.
/// A prefix of an array is a subarray that starts from the beginning of 
/// the array and extends to any point within it.
///
/// Return the minimum number of operations required to make all elements 
/// in arr equal.
/// 
/// Example 1:
/// Input: nums = [1,4,2]
/// Output: 2
/// Explanation:
/// Operation 1: Choose the prefix [1, 4] of length 2 and add -2 to each 
/// element of the prefix. The array becomes [-1, 2, 2].
/// Operation 2: Choose the prefix [-1] of length 1 and add 3 to it. The 
/// array becomes [2, 2, 2].
/// Thus, the minimum number of required operations is 2.
///
/// Example 2:
/// Input: nums = [10,10,10]
/// Output: 0
/// Explanation:
/// All elements are already equal, so no operations are needed.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. -10^9 <= nums[i] <= 10^9
/// </summary>
int LeetCodeArray::minOperationsEqual(vector<int>& nums)
{
    int result = 0;
    for (int i = nums.size() - 2; i >= 0; i--)
    {
        if (nums[i] != nums[i+1])
        {
            result++;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3354. Make Array Elements Equal to Zero
/// 
/// Easy
///
/// You are given an integer array nums.
/// Start by selecting a starting position curr such that nums[curr] == 0, 
/// and choose a movement direction of either left or right.
///
/// After that, you repeat the following process:
/// If curr is out of the range [0, n - 1], this process ends.
/// If nums[curr] == 0, move in the current direction by incrementing curr 
/// if you are moving right, or decrementing curr if you are moving left.
/// Else if nums[curr] > 0:
/// Decrement nums[curr] by 1.
/// Reverse your movement direction (left becomes right and vice versa).
/// Take a step in your new direction.
/// A selection of the initial position curr and movement direction is 
/// considered valid if every element in nums becomes 0 by the end of the 
/// process.
///
/// Return the number of possible valid selections.
/// Example 1:
/// Input: nums = [1,0,2,0,3]
/// Output: 2
/// Explanation:
/// The only possible valid selections are the following:
/// Choose curr = 3, and a movement direction to the left.
/// [1,0,2,0,3] -> [1,0,2,0,3] -> [1,0,1,0,3] -> [1,0,1,0,3] -> 
/// [1,0,1,0,2] -> [1,0,1,0,2] -> [1,0,0,0,2] -> [1,0,0,0,2] -> 
/// [1,0,0,0,1] -> [1,0,0,0,1] -> [1,0,0,0,1] -> [1,0,0,0,1] -> 
/// [0,0,0,0,1] -> [0,0,0,0,1] -> [0,0,0,0,1] -> [0,0,0,0,1] -> 
/// [0,0,0,0,0].
/// Choose curr = 3, and a movement direction to the right.
/// [1,0,2,0,3] -> [1,0,2,0,3] -> [1,0,2,0,2] -> [1,0,2,0,2] -> 
/// [1,0,1,0,2] -> [1,0,1,0,2] -> [1,0,1,0,1] -> [1,0,1,0,1] -> 
/// [1,0,0,0,1] -> [1,0,0,0,1] -> [1,0,0,0,0] -> [1,0,0,0,0] -> 
/// [1,0,0,0,0] -> [1,0,0,0,0] -> [0,0,0,0,0].
///
/// Example 2:
/// Input: nums = [2,3,4,0,4,1,0]
/// Output: 0
/// Explanation:
/// There are no possible valid selections.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 100
/// 2. 0 <= nums[i] <= 100
/// 3. There is at least one element i where nums[i] == 0.
/// </summary>
int LeetCodeArray::countValidSelections(vector<int>& nums)
{
    int n = nums.size();
    vector<int> left(nums.size()), right(nums.size());
    for (int i = 0; i < n; i++)
    {
        left[i] = nums[i];
        if (i > 0) left[i] += left[i - 1];
    }
    for (int i = n - 1; i >= 0; i--)
    {
        right[i] = nums[i];
        if (i < n - 1) right[i] += right[i + 1];
    }
    int result = 0;
    for (int i = 0; i < n; i++)
    {
        if (nums[i] != 0) continue;
        if (left[i] == right[i])
        {
            result += 2;
        }
        else if (abs(left[i] - right[i]) == 1)
        {
            result += 1;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3364. Minimum Positive Sum Subarray 
/// 
/// Easy
/// 
/// You are given an integer array nums and two integers l and r. Your 
/// task is to find the minimum sum of a subarray whose size is between 
/// l and r (inclusive) and whose sum is greater than 0.
///
/// Return the minimum sum of such a subarray. If no such subarray 
/// exists, return -1.
///
/// A subarray is a contiguous non-empty sequence of elements within an 
/// array.
///
/// Example 1:
/// 
/// Input: nums = [3, -2, 1, 4], l = 2, r = 3
/// Output: 1
/// Explanation:
/// The subarrays of length between l = 2 and r = 3 where the sum is 
/// greater than 0 are:
/// 
/// [3, -2] with a sum of 1
/// [1, 4] with a sum of 5
/// [3, -2, 1] with a sum of 2
/// [-2, 1, 4] with a sum of 3
/// Out of these, the subarray [3, -2] has a sum of 1, which is the smallest 
/// positive sum. Hence, the answer is 1.
///
/// Example 2:
/// Input: nums = [-2, 2, -3, 1], l = 2, r = 3
/// Output: -1
/// Explanation:
/// There is no subarray of length between l and r that has a sum greater 
/// than 0. So, the answer is -1.
/// 
/// Example 3:
/// Input: nums = [1, 2, 3, 4], l = 2, r = 4
/// Output: 3
/// Explanation:
/// The subarray [1, 2] has a length of 2 and the minimum sum greater 
/// than 0. So, the answer is 3.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 100
/// 2. 1 <= l <= r <= nums.length
/// 3. -1000 <= nums[i] <= 1000
/// </summary>
int LeetCodeArray::minimumSumSubarray(vector<int>& nums, int l, int r)
{
    int n = nums.size();
    vector<int> dp(n);
    int result = INT_MAX;
    for (int i = 0; i < n; i++)
    {
        dp[i] = nums[i];
        if (i > 0) dp[i] += dp[i - 1];
        for (int j = max(-1, i - r); j <= i - l; j++)
        {
            int sum = 0;
            if (j >= 0)
            {
                sum = dp[i] - dp[j];
            }
            else
            {
                sum = dp[i];
            }
            if (sum > 0)
            {
                result = min(result, sum);
            }
        }
    }
    if (result == INT_MAX) return -1;
    else return result;
}

/// <summary>
/// Leet Code 3361. Shift Distance Between Two Strings 
/// 
/// Medium
/// 
/// You are given two strings s and t of the same length, and two integer 
/// arrays nextCost and previousCost.
///
/// In one operation, you can pick any index i of s, and perform either 
/// one of the following actions:
///
/// Shift s[i] to the next letter in the alphabet. If s[i] == 'z', you 
/// should replace it with 'a'. This operation costs nextCost[j] where j 
/// is the index of s[i] in the alphabet.
/// Shift s[i] to the previous letter in the alphabet. If s[i] == 'a', 
/// you should replace it with 'z'. This operation costs previousCost[j] 
/// where j is the index of s[i] in the alphabet.
/// The shift distance is the minimum total cost of operations required 
/// to transform s into t.
///
/// Return the shift distance from s to t.
/// Example 1:
/// Input: s = "abab", t = "baba", 
/// nextCost = [100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], 
/// previousCost = [1,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
/// Output: 2
/// Explanation:
/// We choose index i = 0 and shift s[0] 25 times to the previous 
/// character for a total cost of 1.
/// We choose index i = 1 and shift s[1] 25 times to the next character 
/// for a total cost of 0.
/// We choose index i = 2 and shift s[2] 25 times to the previous 
/// character for a total cost of 1.
/// We choose index i = 3 and shift s[3] 25 times to the next 
/// character for a total cost of 0.
///
/// Example 2:
/// Input: s = "leet", t = "code", 
/// nextCost = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1], 
/// previousCost = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
///
/// Output: 31
/// Explanation:
/// We choose index i = 0 and shift s[0] 9 times to the previous character 
/// for a total cost of 9.
/// We choose index i = 1 and shift s[1] 10 times to the next character 
/// for a total cost of 10.
/// We choose index i = 2 and shift s[2] 1 time to the previous character 
/// for a total cost of 1.
/// We choose index i = 3 and shift s[3] 11 times to the next character 
/// for a total cost of 11.
/// 
/// Constraints:
/// 1. 1 <= s.length == t.length <= 10^5
/// 2. s and t consist only of lowercase English letters.
/// 3. nextCost.length == previousCost.length == 26
/// 4. 0 <= nextCost[i], previousCost[i] <= 10^9
/// </summary>
long long LeetCodeArray::shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost)
{
    vector<long long> dp1(52), dp2(52);
    for (int i = 1; i < 52; i++)
    {
        dp1[i] = dp1[i-1] + nextCost[(i - 1) % 26];
        dp2[51 - i] = dp2[52-i] + previousCost[(52 - i) %26];
    }
    long long result = 0;
    for (size_t i = 0; i < s.size(); i++)
    {
        long long cost1 = 0, cost2 = 0;
        int a = s[i] - 'a';
        int b = t[i] - 'a';
        if (a < b)
        {
            cost1 = dp1[b] - dp1[a];
            cost2 = dp2[b] - dp2[26 + a];
        }
        else if (a > b)
        {
            cost1 = dp1[b+26] - dp1[a];
            cost2 = dp2[b] - dp2[a];
        }
        result += min(cost1, cost2);
    }
    return result;
}

/// <summary>
/// Leet Code 3371. Identify the Largest Outlier in an Array
/// 
/// Medium
/// 
/// You are given an integer array nums. This array contains n elements, 
/// where exactly n - 2 elements are special numbers. One of the 
/// remaining two elements is the sum of these special numbers, and the 
/// other is an outlier.
///
/// An outlier is defined as a number that is neither one of the original 
/// special numbers nor the element representing the sum of those numbers.
///
/// Note that special numbers, the sum element, and the outlier must have 
/// distinct indices, but may share the same value.
///
/// Return the largest potential outlier in nums.
/// 
/// Example 1:
/// Input: nums = [2,3,5,10]
/// Output: 10
/// Explanation:
/// The special numbers could be 2 and 3, thus making their sum 5 and the 
/// outlier 10.
///
/// Example 2:
/// Input: nums = [-2,-1,-3,-6,4]
/// Output: 4
/// Explanation:
/// The special numbers could be -2, -1, and -3, thus making their sum -6 
/// and the outlier 4.
///
/// Example 3:
/// Input: nums = [1,1,1,1,1,5,5]
/// Output: 5
/// Explanation:
/// The special numbers could be 1, 1, 1, 1, and 1, thus making their 
/// sum 5 and the other 5 as the outlier.
/// 
/// Constraints:
/// 1. 3 <= nums.length <= 10^5
/// 2. -1000 <= nums[i] <= 1000
/// 3. The input is generated such that at least one potential outlier 
///    exists in nums.
/// </summary>
int LeetCodeArray::getLargestOutlier(vector<int>& nums)
{
    int sum = 0;
    map<int, int> hash_map;
    sort(nums.begin(), nums.end());
    for (size_t i = 0; i < nums.size(); i++)
    {
        sum += nums[i];
        hash_map[nums[i]]++;
    }
    int result = 0;
    for (int i = nums.size() - 1; i >= 0; i--)
    {
        if ((sum - nums[i]) % 2 != 0) continue;
        int half = (sum - nums[i]) / 2;
        if (hash_map.count(half) == 0) continue;
        if (half == nums[i] && hash_map[nums[i]] == 1) continue;
        result = nums[i];
        break;
    }
    return result;
}

/// <summary>
/// Leet Code 3379. Transformed Array 
/// 
/// Easy
///
/// You are given an integer array nums that represents a circular array. 
/// Your task is to create a new array result of the same size, following 
/// these rules:
/// 
/// For each index i (where 0 <= i < nums.length), perform the following 
/// independent actions:
/// If nums[i] > 0: Start at index i and move nums[i] steps to the right 
/// in the circular array. Set result[i] to the value of the index where 
/// you land.
/// If nums[i] < 0: Start at index i and move abs(nums[i]) steps to the 
/// left in the circular array. Set result[i] to the value of the index 
/// where you land.
/// If nums[i] == 0: Set result[i] to nums[i].
/// Return the new array result.
///
/// Note: Since nums is circular, moving past the last element wraps 
/// around to the beginning, and moving before the first element wraps 
/// back to the end.
/// 
/// Example 1:
/// Input: nums = [3,-2,1,1]
/// 
/// Output: [1,1,1,3]
///
/// Explanation:
/// For nums[0] that is equal to 3, If we move 3 steps to right, we 
/// reach nums[3]. So result[0] should be 1.
/// For nums[1] that is equal to -2, If we move 2 steps to left, we 
/// reach nums[3]. So result[1] should be 1.
/// For nums[2] that is equal to 1, If we move 1 step to right, we 
/// reach nums[3]. So result[2] should be 1.
/// For nums[3] that is equal to 1, If we move 1 step to right, 
/// we reach nums[0]. So result[3] should be 3.
///
/// Example 2:
/// Input: nums = [-1,4,-1]
/// Output: [-1,-1,4]
/// Explanation:
/// For nums[0] that is equal to -1, If we move 1 step to left, we 
/// reach nums[2]. So result[0] should be -1.
/// For nums[1] that is equal to 4, If we move 4 steps to right, we 
/// reach nums[2]. So result[1] should be -1.
/// For nums[2] that is equal to -1, If we move 1 step to left, we 
/// reach nums[1]. So result[2] should be 4.
///
/// Constraints:
/// 1. 1 <= nums.length <= 100
/// 2. -100 <= nums[i] <= 100
/// </summary>
vector<int> LeetCodeArray::constructTransformedArray(vector<int>& nums)
{
    vector<int> result = nums;
    int n = nums.size();
    for (int i = 0; i < n; i++)
    {
        if (nums[i] >= 0)
        {
            int index = (i + nums[i]) % n;
            result[i] = nums[index];
        }
        else
        {
            int index = (i + nums[i] + n) % n;
            result[i] = nums[index];
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3381. Maximum Subarray Sum With Length Divisible by K
/// 
/// Medium
///
/// You are given an array of integers nums and an integer k.
/// Return the maximum sum of a non-empty subarray of nums, such that the 
/// size of the subarray is divisible by k.
///
/// A subarray is a contiguous non-empty sequence of elements within an 
/// array.
/// 
/// Example 1:
/// Input: nums = [1,2], k = 1
/// Output: 3
/// Explanation:
/// The subarray [1, 2] with sum 3 has length equal to 2 which is 
/// divisible by 1.
///
/// Example 2:
/// Input: nums = [-1,-2,-3,-4,-5], k = 4
/// Output: -10
/// Explanation:
/// The maximum sum subarray is [-1, -2, -3, -4] which has length equal 
/// to 4 which is divisible by 4.
///
/// Example 3:
/// Input: nums = [-5,1,2,-3,4], k = 2
/// Output: 4
/// Explanation:
/// The maximum sum subarray is [1, 2, -3, 4] which has length equal to 4 
/// which is divisible by 2.
/// 
/// Constraints:
/// 1. 1 <= k <= nums.length <= 2 * 10^5
/// 2. -10^9 <= nums[i] <= 10^9
/// </summary>
long long LeetCodeArray::maxSubarraySum(vector<int>& nums, int k)
{
    vector<long long> prefix_sum(nums.size());
    int n = nums.size();
    for (int i = 0; i < n; i++)
    {
        prefix_sum[i] = nums[i];
        if (i > 0) prefix_sum[i] += prefix_sum[i - 1];
    }
    long long result = LLONG_MIN;
    for (int i = 0; i < k; i++)
    {
        long long sum = 0;
        for (int j = i + k - 1; j < n; j += k)
        {
            if (j < k)
            {
                sum = prefix_sum[j];
            }
            else
            {
                sum += prefix_sum[j] - prefix_sum[j - k];
            }
            result = max(result, sum);
            if (sum < 0) sum = 0;
        }
    }
    return result;
}


/// <summary>
/// Leet Code 3386. Button with Longest Push Time
/// 
/// Easy
///
/// You are given a 2D array events which represents a sequence of events 
/// where a child pushes a series of buttons on a keyboard.
///
/// Each events[i] = [indexi, timei] indicates that the button at index 
/// indexi was pressed at time timei.
///
/// The array is sorted in increasing order of time.
/// The time taken to press a button is the difference in time between 
/// consecutive button presses. The time for the first button is 
/// simply the time at which it was pressed.
/// Return the index of the button that took the longest time to push. 
/// If multiple buttons have the same longest time, return the button with 
/// the smallest index.
///
/// Example 1:
/// Input: events = [[1,2],[2,5],[3,9],[1,15]]
/// Output: 1
/// Explanation:
/// Button with index 1 is pressed at time 2.
/// Button with index 2 is pressed at time 5, so it took 5 - 2 = 3 
/// units of time.
/// Button with index 3 is pressed at time 9, so it took 9 - 5 = 4 
/// units of time.
/// Button with index 1 is pressed again at time 15, so it took 15 - 9 = 6 
/// units of time.
///
/// Example 2:
/// Input: events = [[10,5],[1,7]]
/// Output: 10
/// Explanation:
/// Button with index 10 is pressed at time 5.
/// Button with index 1 is pressed at time 7, so it took 7 - 5 = 2 units 
/// of time.
///
/// Constraints:
/// 1. 1 <= events.length <= 1000
/// 2. events[i] == [indexi, timei]
/// 3. 1 <= indexi, timei <= 10^5
/// 4. The input is generated such that events is sorted in increasing 
///    order of timei.
/// </summary>
int LeetCodeArray::buttonWithLongestTime(vector<vector<int>>& events)
{
    pair<int, int> result = { -1, -1 };
    for (size_t i = 0; i < events.size(); i++)
    {
        int time = 0;
        if (i == 0) time = events[i][1];
        else time = events[i][1] - events[i - 1][1];
        if (time > result.second)
        {
            result.first = events[i][0];
            result.second = time;
        }
        else if (time == result.second)
        {
            result.first = min(events[i][0], result.first);
        }
    }
    return result.first;
}

/// <summary>
/// Leet Code 3392. Count Subarrays of Length Three With a Condition
/// 
/// Easy
///
/// Given an integer array nums, return the number of subarrays of length 
/// 3 such that the sum of the first and third numbers equals exactly half 
/// of the second number.
///
/// A subarray is a contiguous non-empty sequence of elements within an 
/// array.
/// 
/// Example 1:
/// Input: nums = [1,2,1,4,1]
/// Output: 1
/// Explanation:
/// Only the subarray [1,4,1] contains exactly 3 elements where the sum of 
/// the first and third numbers equals half the middle number.
///
/// Example 2:
/// Input: nums = [1,1,1]
/// Output: 0
/// Explanation:
/// [1,1,1] is the only subarray of length 3. However, its first and third 
/// numbers do not add to half the middle number.
///
/// Constraints:
/// 1. 3 <= nums.length <= 100
/// 2. -100 <= nums[i] <= 100
/// </summary>
int LeetCodeArray::countSubarraysII(vector<int>& nums)
{
    int result = 0;
    for (size_t i = 2; i < nums.size(); i++)
    {
        if ((nums[i-2] + nums[i]) * 2 == nums[i-1])
        {
            result++;
        }
    }
    return result;
}


/// <summary>
/// Leet Code 3396. Minimum Number of Operations to Make Elements in Array 
///                 Distinct
/// 
/// Easy
///
/// You are given an integer array nums. You need to ensure that the 
/// elements in the array are distinct. To achieve this, you can perform 
/// the following operation any number of times:
///
/// Remove 3 elements from the beginning of the array. If the array has 
/// fewer than 3 elements, remove all remaining elements.
/// Note that an empty array is considered to have distinct elements. 
/// Return the minimum number of operations needed to make the elements 
/// in the array distinct.
///
/// Example 1:
/// Input: nums = [1,2,3,4,2,3,3,5,7]
/// Output: 2
/// Explanation:
/// In the first operation, the first 3 elements are removed, resulting 
/// in the array [4, 2, 3, 3, 5, 7].
/// In the second operation, the next 3 elements are removed, resulting 
/// in the array [3, 5, 7], which has distinct elements.
/// Therefore, the answer is 2.
///
/// Example 2:
/// Input: nums = [4,5,6,4,4]
/// Output: 2
/// Explanation:
/// In the first operation, the first 3 elements are removed, resulting 
/// in the array [4, 4].
/// In the second operation, all remaining elements are removed, 
/// resulting in an empty array.
/// Therefore, the answer is 2.
///
/// Example 3:
/// Input: nums = [6,7,8,9]
/// Output: 0
/// Explanation:
/// The array already contains distinct elements. Therefore, the answer 
/// is 0.
///
/// Constraints:
/// 1. 1 <= nums.length <= 100
/// 2. 1 <= nums[i] <= 100
/// </summary>
int LeetCodeArray::minimumOperationsII(vector<int>& nums)
{
    unordered_set<int> data_set;
    int result = -1;
    for (int i = nums.size() - 1; i >= 0; i--)
    {
        if (data_set.count(nums[i]) == 0)
        {
            data_set.insert(nums[i]);
        }
        else
        {
            result = i;
            break;
        }
    }
    return (result + 3) / 3;
}

/// <summary>
/// Leet Code 3395. Subsequences with a Unique Middle Mode I
/// </summary>
long long LeetCodeArray::subsequencesWithMiddleMode(unordered_map<int, int>& left,
        unordered_map<int, int>& right, int middle, long long left_sum,
        long long right_sum, long long left_square_sum,
        long long right_square_sum, int left_match_count,
        int right_match_count)
{
    long long result = 0;
    if (left_match_count == 2)
    {
        if (left.count(middle) == 0 || left[middle] < 2) return 0;
        result = (long long)left[middle] * (long long)(left[middle] - 1) / 2;
        if (right_match_count == 2)
        {
            if (right.count(middle) == 0 || right[middle] < 2) return 0;
            result = result * (long long)right[middle] * (long long)(right[middle] - 1) / 2;
        }
        else
        {
            result = result * (long long)right_sum * (long long)(right_sum - 1) / 2;
        }
    }
    else if (left_match_count == 1 && right_match_count == 1)
    {
        if (left.count(middle) == 0 || right.count(middle) == 0)
        {
            return 0;
        }
        result = (long long)left[middle] * (long long)(left_sum - left[middle]);
        result = result * (long long)right[middle] * (long long)(right_sum - right[middle]);
    }
    else if (left_match_count == 1 && right_match_count == 0)
    {
        if (left.count(middle) == 0)
        {
            return 0;
        }
        if (right.count(middle) > 0)
        {
            right_sum -= right[middle];
            right_square_sum = right_square_sum - right[middle] * right[middle];
        }
        for (auto itr : left)
        {
            if (itr.first == middle) continue;
            long long left_count = (long long)left[middle] * (long long) itr.second;
            long long temp_sum = right_sum;
            long long temp_square_sum = right_square_sum;
            if (right.count(itr.first) > 0)
            {
                temp_sum -= right[itr.first];
                temp_square_sum = (temp_square_sum - right[itr.first] * right[itr.first]);
            }
            result += left_count * (temp_sum * temp_sum - temp_square_sum) / 2;
        }
    }

    return result;
}

/// <summary>
/// Leet Code 3395. Subsequences with a Unique Middle Mode I
///   
/// Hard
///
/// Given an integer array nums, find the number of subsequences of size 
/// 5 of nums with a unique middle mode.
///
/// Since the answer may be very large, return it modulo 10^9 + 7.
/// A mode of a sequence of numbers is defined as the element that appears 
/// the maximum number of times in the sequence.
/// 
/// A sequence of numbers contains a unique mode if it has only one mode.
///
/// A sequence of numbers seq of size 5 contains a unique middle mode if 
/// the middle element (seq[2]) is a unique mode.
///
/// Example 1:
/// Input: nums = [1,1,1,1,1,1]
/// Output: 6
/// Explanation:
/// [1, 1, 1, 1, 1] is the only subsequence of size 5 that can be formed, 
/// and it has a unique middle mode of 1. This subsequence can be formed 
/// in 6 different ways, so the output is 6. 
///
/// Example 2:
/// Input: nums = [1,2,2,3,3,4]
/// Output: 4
/// Explanation:
/// [1, 2, 2, 3, 4] and [1, 2, 3, 3, 4] each have a unique middle mode 
/// because the number at index 2 has the greatest frequency in the 
/// subsequence. [1, 2, 2, 3, 3] does not have a unique middle mode 
/// because 2 and 3 appear twice.
///
/// Example 3:
/// 
/// Input: nums = [0,1,2,3,4,5,6,7,8]
/// Output: 0
/// Explanation:
/// There is no subsequence of length 5 with a unique middle mode.
/// Constraints:
/// 1. 5 <= nums.length <= 1000
/// 2. -10^9 <= nums[i] <= 10^9
/// </summary>
int LeetCodeArray::subsequencesWithMiddleMode(vector<int>& nums)
{
    long long M = 1000000007;
    unordered_map<int, int> left, right;
    long long left_sum = 0, right_sum = 0;
    long long left_square_sum = 0, right_square_sum = 0;
    int n = nums.size();
    for (int i = 0; i < n; i++)
    {
        if (i < 2)
        {
            left[nums[i]]++;
        }
        else if (i > 2)
        {
            right[nums[i]]++;
        }
    }
    for (auto itr : left)
    {
        left_sum += itr.second;
        left_square_sum += itr.second * itr.second;
    }
    for (auto itr : right)
    {
        right_sum += itr.second;
        right_square_sum += itr.second * itr.second;
    }

    long long result = 0;
    for (int i = 2; i < n - 2; i++)
    {
        result += subsequencesWithMiddleMode(left, right, nums[i],
            left_sum, right_sum, left_square_sum, right_square_sum, 2, 0);
        result += subsequencesWithMiddleMode(right, left, nums[i],
            right_sum, left_sum, right_square_sum, left_square_sum, 2, 0);
        result -= subsequencesWithMiddleMode(left, right, nums[i],
            left_sum, right_sum, left_square_sum, right_square_sum, 2, 2);
        result += subsequencesWithMiddleMode(left, right, nums[i],
            left_sum, right_sum, left_square_sum, right_square_sum, 1, 1);
        result += subsequencesWithMiddleMode(left, right, nums[i],
            left_sum, right_sum, left_square_sum, right_square_sum, 1, 0);
        result += subsequencesWithMiddleMode(right, left, nums[i],
            right_sum, left_sum, right_square_sum, left_square_sum, 1, 0);
        left_square_sum -= left[nums[i]] * left[nums[i]];
        left[nums[i]]++;
        left_sum ++;
        left_square_sum += left[nums[i]] * left[nums[i]];
        right_square_sum -= right[nums[i + 1]] * right[nums[i + 1]];
        right[nums[i + 1]]--;
        right_sum --;
        right_square_sum += right[nums[i + 1]] * right[nums[i + 1]];
        if (right[nums[i + 1]] == 0)
        {
            right.erase(nums[i + 1]);
        }
        result = result % M;
    }
    return (int)(result % M);
}


/// <summary>
/// Leet Code 3400. Maximum Number of Matching Indices After Right Shifts
///   
/// Medium
///
/// You are given two integer arrays, nums1 and nums2, of the same length.
/// An index i is considered matching if nums1[i] == nums2[i].
///
/// Return the maximum number of matching indices after performing any 
/// number of right shifts on nums1.
///
/// A right shift is defined as shifting the element at index i to 
/// index (i + 1) % n, for all indices.
///
/// Example 1:
/// Input: nums1 = [3,1,2,3,1,2], nums2 = [1,2,3,1,2,3]
/// Output: 6
///
/// Explanation:
/// If we right shift nums1 2 times, it becomes [1, 2, 3, 1, 2, 3]. 
/// Every index matches, so the output is 6.
///
/// Example 2:
/// Input: nums1 = [1,4,2,5,3,1], nums2 = [2,3,1,2,4,6]
/// Output: 3
/// Explanation:
/// If we right shift nums1 3 times, it becomes [5, 3, 1, 1, 4, 2]. 
/// Indices 1, 2, and 4 match, so the output is 3.
/// 
/// Constraints:
/// 1. nums1.length == nums2.length
/// 2. 1 <= nums1.length, nums2.length <= 3000
/// 3. 1 <= nums1[i], nums2[i] <= 10^9
/// </summary>
int LeetCodeArray::maximumMatchingIndices(vector<int>& nums1, vector<int>& nums2)
{
    int n = nums1.size();
    int result = 0;
    for (int i = 0; i < n; i++)
    {
        int count = 0;
        for (int j = 0; j < n; j++)
        {
            if (nums1[(i + j) % n] == nums2[j])
            {
                count++;
            }
        }
        result = max(result, count);
    }
    return result;
}


/// <summary>
/// Leet Code 3402. Minimum Operations to Make Columns Strictly Increasing
///   
/// Easy
///
/// You are given a m x n matrix grid consisting of non-negative integers.
/// 
/// In one operation, you can increment the value of any grid[i][j] by 1.
/// 
/// Return the minimum number of operations needed to make all columns of 
/// grid strictly increasing.
/// 
///
/// Example 1:
/// Input: grid = [[3,2],[1,3],[3,4],[0,1]]
/// Output: 15
/// Explanation:
/// To make the 0th column strictly increasing, we can apply 3 operations 
/// on grid[1][0], 2 operations on grid[2][0], and 6 operations on 
/// grid[3][0].
/// To make the 1st column strictly increasing, we can apply 4 operations 
/// on grid[3][1].
///
/// Example 2:
/// Input: grid = [[3,2,1],[2,1,0],[1,2,3]]
/// Output: 12
/// Explanation:
/// To make the 0th column strictly increasing, we can apply 2 operations 
/// on grid[1][0], and 4 operations on grid[2][0].
/// To make the 1st column strictly increasing, we can apply 2 operations 
/// on grid[1][1], and 2 operations on grid[2][1].
/// To make the 2nd column strictly increasing, we can apply 2 operations 
/// on grid[1][2].
///
/// Constraints:
/// 1. m == grid.length
/// 2. n == grid[i].length
/// 3. 1 <= m, n <= 50
/// 4. 0 <= grid[i][j] < 2500
/// </summary>
int LeetCodeArray::minimumOperationsIncreasing(vector<vector<int>>& grid)
{
    int result = 0;
    for (size_t j = 0; j < grid[0].size(); j++)
    {
        int prev = 0;
        for (size_t i = 0; i < grid.size(); i++)
        {
            if (i == 0) prev = grid[i][j];
            else
            {
                if (grid[i][j] <= prev)
                {
                    result += prev + 1 - grid[i][j];
                    prev++;
                }
                else
                {
                    prev = grid[i][j];
                }
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3404. Count Special Subsequences
///   
/// Medium
///
/// You are given an array nums consisting of positive integers.
///
/// A special subsequence is defined as a subsequence of length 4, 
/// represented by indices(p, q, r, s), where p < q < r < s.This 
/// subsequence must satisfy the following conditions :
///
/// nums[p] * nums[r] == nums[q] * nums[s]
/// There must be at least one element between each pair of indices. In 
/// other words, q - p > 1, r - q > 1 and s - r > 1.
/// A subsequence is a sequence derived from the array by deleting zero or 
/// more elements without changing the order of the remaining elements.
///
/// Return the number of different special subsequences in nums.
/// Example 1:
/// Input: nums = [1, 2, 3, 4, 3, 6, 1]
/// Output : 1
/// Explanation :
/// There is one special subsequence in nums.
/// (p, q, r, s) = (0, 2, 4, 6) :
/// This corresponds to elements(1, 3, 3, 1).
/// nums[p] * nums[r] = nums[0] * nums[4] = 1 * 3 = 3
/// nums[q] * nums[s] = nums[2] * nums[6] = 3 * 1 = 3
///
/// Example 2 :
/// Input : nums = [3, 4, 3, 4, 3, 4, 3, 4]
/// Output : 3
/// Explanation :
/// There are three special subsequences in nums.
/// (p, q, r, s) = (0, 2, 4, 6) :
/// This corresponds to elements(3, 3, 3, 3).
/// nums[p] * nums[r] = nums[0] * nums[4] = 3 * 3 = 9
/// nums[q] * nums[s] = nums[2] * nums[6] = 3 * 3 = 9
/// (p, q, r, s) = (1, 3, 5, 7) :
/// This corresponds to elements(4, 4, 4, 4).
/// nums[p] * nums[r] = nums[1] * nums[5] = 4 * 4 = 16
/// nums[q] * nums[s] = nums[3] * nums[7] = 4 * 4 = 16
/// (p, q, r, s) = (0, 2, 5, 7) :
/// This corresponds to elements(3, 3, 4, 4).
/// nums[p] * nums[r] = nums[0] * nums[5] = 3 * 4 = 12
/// nums[q] * nums[s] = nums[2] * nums[7] = 3 * 4 = 12
///
/// Constraints :
/// 1. 7 <= nums.length <= 1000
/// 2. 1 <= nums[i] <= 1000
/// </summary>
long long LeetCodeArray::numberOfSubsequences(vector<int>& nums)
{
    unordered_map<double, int> freq;
    long long result = 0;
    for (size_t r = 4; r < nums.size(); r++)
    {
        int q = r - 2;
        for (int p = 0; p < q - 1; p++)
        {
            double ratio = 1.0 * nums[p] / nums[q];
            freq[ratio]++;
        }
        for (size_t s = r + 2; s < nums.size(); s++)
        {
            double ratio = 1.0 * nums[s] / nums[r];
            result += freq[ratio];
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3410. Maximize Subarray Sum After Removing All Occurrences 
///                 of One Element
///   
/// Hard
///
/// You are given an integer array nums.
/// You can do the following operation on the array at most once:
/// Choose any integer x such that nums remains non-empty on removing all 
/// occurrences of x.
/// Remove all occurrences of x from the array.
/// Return the maximum subarray sum across all possible resulting arrays.
///
/// Example 1:
/// Input: nums = [-3,2,-2,-1,3,-2,3]
/// Output: 7
/// Explanation:
/// We can have the following arrays after at most one operation:
/// The original array is nums = [-3, 2, -2, -1, 3, -2, 3]. The maximum 
/// subarray sum is 3 + (-2) + 3 = 4.
/// Deleting all occurences of x = -3 results in nums = [2, -2, -1, 3, 
/// -2, 3]. The maximum subarray sum is 3 + (-2) + 3 = 4.
/// Deleting all occurences of x = -2 results in nums = [-3, 2, -1, 3, 3]. 
/// The maximum subarray sum is 2 + (-1) + 3 + 3 = 7.
/// Deleting all occurences of x = -1 results in nums = [-3, 2, -2, 3, 
/// -2, 3]. The maximum subarray sum is 3 + (-2) + 3 = 4.
/// Deleting all occurences of x = 3 results in nums = [-3, 2, -2, 
/// -1, -2]. The maximum subarray sum is 2.
/// The output is max(4, 4, 7, 4, 2) = 7.
///
/// Example 2:
/// Input: nums = [1,2,3,4]
/// Output: 10
/// Explanation:
/// It is optimal to not perform any operations.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. -10^6 <= nums[i] <= 10^6
/// </summary>
long long LeetCodeArray::maxSubarraySum(vector<int>& nums)
{
    long long deductable = 0, prefix = 0,  sum = 0, result = LLONG_MIN;
    unordered_map<int, long long> exclude_sum;
    long long max_exclude = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        sum += nums[i];
        result = max(result, sum - deductable);
        if (nums[i] < 0)
        {
            exclude_sum[nums[i]] = min(prefix, exclude_sum[nums[i]]) + nums[i];
            deductable = min(deductable, exclude_sum[nums[i]]);
        }
        prefix = min(prefix, sum);
        deductable = min(deductable, prefix);
    }
    return result;
}

/// <summary>
/// Leet Code 3417. Zigzag Grid Traversal With Skip
///   
/// Easy
///
/// You are given an m x n 2D array grid of positive integers.
///
/// Your task is to traverse grid in a zigzag pattern while skipping 
/// every alternate cell.
///
/// Zigzag pattern traversal is defined as following the below actions:
/// Start at the top-left cell (0, 0).
/// Move right within a row until the end of the row is reached.
/// Drop down to the next row, then traverse left until the beginning of 
/// the row is reached.
/// Continue alternating between right and left traversal until every row 
/// has been traversed.
/// Note that you must skip every alternate cell during the traversal.
///
/// Return an array of integers result containing, in order, the value of 
/// the cells visited during the zigzag traversal with skips.
/// 
/// Example 1:
/// Input: grid = [[1,2],[3,4]]
/// Output: [1,4]
/// Explanation:
/// 
/// Example 2:
/// Input: grid = [[2,1],[2,1],[2,1]]
/// Output: [2,1,2]
/// Explanation:
/// 
/// Example 3:
/// Input: grid = [[1,2,3],[4,5,6],[7,8,9]]
/// Output: [1,3,5,7,9]
///
/// Explanation:
/// Constraints:
/// 1. 2 <= n == grid.length <= 50
/// 2. 2 <= m == grid[i].length <= 50
/// 3. 1 <= grid[i][j] <= 2500
/// </summary>
vector<int> LeetCodeArray::zigzagTraversal(vector<vector<int>>& grid)
{
    vector<int> result;
    int count = 0;
    for (size_t i = 0; i < grid.size(); i++)
    {
        if (i % 2 == 0)
        {
            for (size_t j = 0; j < grid[0].size(); j++)
            {
                if (count % 2 == 0)
                {
                    result.push_back(grid[i][j]);
                }
                count++;
            }
        }
        else
        {
            for (int j = grid[i].size() - 1; j >= 0; j--)
            {
                if (count % 2 == 0)
                {
                    result.push_back(grid[i][j]);
                }
                count++;
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3423. Maximum Difference Between Adjacent Elements in a 
///                 Circular Array
///   
/// Easy
///
/// Given a circular array nums, find the maximum absolute difference 
/// between adjacent elements.
///
/// Note: In a circular array, the first and last elements are adjacent.
///
/// Example 1:
/// Input: nums = [1,2,4]
/// Output: 3
/// Explanation:
/// Because nums is circular, nums[0] and nums[2] are adjacent. They have 
/// the maximum absolute difference of |4 - 1| = 3.
///
/// Example 2:
/// Input: nums = [-5,-10,-5]
/// Output: 5
/// Explanation:
/// The adjacent elements nums[0] and nums[1] have the maximum absolute 
/// difference of |-5 - (-10)| = 5.
///
/// Constraints:
/// 1. 2 <= nums.length <= 100
/// 2. -100 <= nums[i] <= 100
/// </summary>
int LeetCodeArray::maxAdjacentDistance(vector<int>& nums)
{
    int result = 0;
    int n = nums.size();
    for (int i = 0; i < n; i++)
    {
        result = max(result, std::abs(nums[i] - nums[(i + 1) % n]));
    }
    return result;
}

/// <summary>
/// Leet Code 3427. Sum of Variable Length Subarrays 
///   
/// Easy
///
/// You are given an integer array nums of size n. For each index i where 
/// 0 <= i < n, define a subarray nums[start ... i] where 
/// start = max(0, i - nums[i]).
///
/// Return the total sum of all elements from the subarray defined for 
/// each index in the array.
///
/// Example 1:
/// Input: nums = [2,3,1]
/// Output: 11
/// Explanation:
/// i   Subarray    Sum
/// 0   nums[0] = [2]   2
/// 1   nums[0 ... 1] = [2, 3]  5
/// 2   nums[1 ... 2] = [3, 1]  4
/// Total Sum       11
/// The total sum is 11. Hence, 11 is the output.
///
/// Example 2:
/// Input: nums = [3,1,1,2]
/// Output: 13
/// Explanation:
/// i   Subarray    Sum
/// 0   nums[0] = [3]   3
/// 1   nums[0 ... 1] = [3, 1]  4
/// 2   nums[1 ... 2] = [1, 1]  2
/// 3   nums[1 ... 3] = [1, 1, 2]   4
/// Total Sum       13
/// The total sum is 13. Hence, 13 is the output.
///
/// Constraints:
/// 1. 1 <= n == nums.length <= 100
/// 2. 1 <= nums[i] <= 1000
/// </summary>
int LeetCodeArray::subarraySum(vector<int>& nums)
{
    int n = nums.size();
    vector<int> sum(nums.size());
    for (int i = 0; i < n; i++)
    {
        sum[i] = nums[i];
        if (i > 0) sum[i] += sum[i - 1];
    }
    int result = 0;
    for (int i = 0; i < n; i++)
    {
        int prev_index = i - nums[i] - 1;
        if (prev_index < 0)
        {
            result += sum[i];
        }
        else
        {
            result += sum[i] - sum[prev_index];
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3424. Minimum Cost to Make Arrays Identical
///   
/// Medium
///
/// You are given two integer arrays arr and brr of length n, and an 
/// integer k. You can perform the following operations on arr any 
/// number of times:
///
/// Split arr into any number of contiguous subarrays and rearrange 
/// these subarrays in any order. This operation has a fixed cost of k.
/// Choose any element in arr and add or subtract a positive integer x 
/// to it. The cost of this operation is x.
///
/// Return the minimum total cost to make arr equal to brr.
///
/// Example 1:
/// Input: arr = [-7,9,5], brr = [7,-2,-5], k = 2
/// Output: 13
/// Explanation:
/// Split arr into two contiguous subarrays: [-7] and [9, 5] and rearrange 
/// them as [9, 5, -7], with a cost of 2.
/// Subtract 2 from element arr[0]. The array becomes [7, 5, -7]. The cost 
/// of this operation is 2.
/// Subtract 7 from element arr[1]. The array becomes [7, -2, -7]. The 
/// cost of this operation is 7.
/// Add 2 to element arr[2]. The array becomes [7, -2, -5]. The cost of 
/// this operation is 2.
/// The total cost to make the arrays equal is 2 + 2 + 7 + 2 = 13.
///
/// Example 2:
/// Input: arr = [2,1], brr = [2,1], k = 0
/// Output: 0
/// Explanation:
/// Since the arrays are already equal, no operations are needed, and the 
/// total cost is 0.
/// 
/// Constraints:
/// 1. 1 <= arr.length == brr.length <= 10^5
/// 2. 0 <= k <= 2 * 10^10
/// 3. -10^5 <= arr[i] <= 10^5
/// 4. -10^5 <= brr[i] <= 10^5
/// </summary>
long long LeetCodeArray::minCost(vector<int>& arr, vector<int>& brr, long long k)
{
    long long cost1 = 0;
    long long cost2 = k;
    for (size_t i = 0; i < arr.size(); i++)
    {
        cost1 += abs(arr[i] - brr[i]);
    }
    sort(arr.begin(), arr.end());
    sort(brr.begin(), brr.end());
    for (size_t i = 0; i < arr.size(); i++)
    {
        cost2 += abs(arr[i] - brr[i]);
    }
    return min(cost1, cost2);
}


/// <summary>
/// Leet Code 3432. Count Partitions with Even Sum Difference
///   
/// Easy
///
/// You are given an integer array nums of length n.
///
/// A partition is defined as an index i where 0 <= i < n - 1, splitting 
/// the array into two non-empty subarrays such that:
///
/// Left subarray contains indices [0, i].
/// Right subarray contains indices [i + 1, n - 1].
/// Return the number of partitions where the difference between the sum 
/// of the left and right subarrays is even.
///
/// Example 1:
/// Input: nums = [10,10,3,7,6]
/// Output: 4
///
/// Explanation:
/// The 4 partitions are:
/// [10], [10, 3, 7, 6] with a sum difference of 10 - 26 = -16, which is 
/// even.
/// [10, 10], [3, 7, 6] with a sum difference of 20 - 16 = 4, which is 
/// even.
/// [10, 10, 3], [7, 6] with a sum difference of 23 - 13 = 10, which is 
/// even.
/// [10, 10, 3, 7], [6] with a sum difference of 30 - 6 = 24, which is 
/// even.
///
/// Example 2:
/// Input: nums = [1,2,2]
/// Output: 0
/// Explanation:
/// No partition results in an even sum difference.
///
/// Example 3:
/// Input: nums = [2,4,6,8]
/// Output: 3
/// Explanation:
/// All partitions result in an even sum difference.
///   
/// Constraints:
/// 1. 2 <= n == nums.length <= 100
/// 2. 1 <= nums[i] <= 100
/// </summary>
int LeetCodeArray::countPartitions(vector<int>& nums)
{
    int sum = 0, result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        sum += nums[i];
    }
    if (sum % 2 == 0) result = nums.size() - 1;
    else result = 0;

    return result;
}

/// <summary>
/// Leet Code 3434. Maximum Frequency After Subarray Operation
///   
/// Medium
///
/// You are given an array nums of length n. You are also given an 
/// integer k.
/// You perform the following operation on nums once:
/// Select a subarray nums[i..j] where 0 <= i <= j <= n - 1.
/// Select an integer x and add x to all the elements in nums[i..j].
/// Find the maximum frequency of the value k after the operation.
///
/// Example 1:
/// Input: nums = [1,2,3,4,5,6], k = 1
/// Output: 2
/// Explanation:
/// After adding -5 to nums[2..5], 1 has a frequency of 2 in 
/// [1, 2, -2, -1, 0, 1].
///
/// Example 2:
/// Input: nums = [10,2,3,4,5,5,4,3,2,2], k = 10
/// Output: 4
/// Explanation:
/// After adding 8 to nums[1..9], 10 has a frequency of 4 in [10, 10, 11, 
/// 12, 13, 13, 12, 11, 10, 10].
/// 
/// Constraints:
/// 1. 1 <= n == nums.length <= 10^5
/// 2. 1 <= nums[i] <= 50
/// 3. 1 <= k <= 50
/// </summary>
int LeetCodeArray::maxFrequencyIII(vector<int>& nums, int k)
{
    int freq_k = 0;
    int result = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        if (nums[i] == k) freq_k++;
    }
    for (int i = 1; i <= 50; i++)
    {
        int freq = 0;
        if (i == k) continue;
        for (size_t j = 0; j < nums.size(); j++)
        {
            if (nums[j] == i) freq++;
            else if (nums[j] == k) freq--;
            if (freq < 0)
            {
                freq = 0;
            }
            result = max(result, freq_k + freq);
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3445. Maximum Difference Between Even and Odd Frequency II
///   
/// Hard
/// 
/// You are given a string s and an integer k. Your task is to find the 
/// maximum difference between the frequency of two characters, 
/// freq[a] - freq[b], in a substring subs of s, such that:
/// subs has a size of at least k.
/// Character a has an odd frequency in subs.
/// Character b has an even frequency in subs.
/// Return the maximum difference.
///
/// Note that subs can contain more than 2 distinct characters.
/// 
/// Example 1:
/// Input: s = "12233", k = 4
/// Output: -1
/// Explanation:
/// For the substring "12233", the frequency of '1' is 1 and the frequency 
/// of '3' is 2. The difference is 1 - 2 = -1.
///
/// Example 2:
/// Input: s = "1122211", k = 3
/// Output: 1
/// Explanation:
/// For the substring "11222", the frequency of '2' is 3 and the frequency 
/// of '1' is 2. The difference is 3 - 2 = 1.
///
/// Example 3:
/// Input: s = "110", k = 3
/// Output: -1
/// 
/// Constraints:
/// 1. 3 <= s.length <= 3 * 104
/// 2. s consists only of digits '0' to '4'.
/// 3. The input is generated that at least one substring has a character 
///    with an even frequency and a character with an odd frequency.
/// 4. 1 <= k <= s.length
/// </summary>
int LeetCodeArray::maxDifference(string s, int k)
{
    int n = s.size();
    int result = INT_MIN;
    // check only possible characters combination
    for (char ch1 = '0'; ch1 < '5'; ch1++)
    {
        for (char ch2 = '0'; ch2 < '5'; ch2++)
        {
            vector<deque<pair<int, int>>> lines(4);
            lines[0].push_back(make_pair(-1, 0));
            vector<int> freq_a(n), freq_b(n);
            if (ch1 == ch2) continue;
            int a = 0, b = 0;
            for (int i = 0; i < n; i++)
            {
                if (s[i] == ch1) a++;
                else if (s[i] == ch2) b++;
                freq_a[i] = a;
                freq_b[i] = b;
                int diff = a - b;
                // current odd and even accumulated
                int index = a % 2 * 2 + b % 2;
                // check against previous odd and even
                int prev_index = (1 - a % 2) * 2 + b % 2;
                // monotone stack
                if (lines[index].empty() || lines[index].back().second > diff)
                {
                    lines[index].push_back(make_pair(i, diff));
                }
                // check only more than k distance
                pair<int, int> prev = { INT_MIN, 0 };
                while (!lines[prev_index].empty() && lines[prev_index].front().first + k <= i)
                {
                    prev = lines[prev_index].front();
                    lines[prev_index].pop_front();
                    if ((prev.first >= 0 && freq_a[i] == freq_a[prev.first]) ||
                        (prev.first >= 0 && freq_b[i] == freq_b[prev.first]) ||
                        (prev.first == -1 && (freq_a[i] == 0 || freq_b[i] == 0)))
                    {
                        break;
                    }
                    result = max(result, diff - prev.second);
                }
                if (prev.first != INT_MIN) lines[prev_index].push_front(prev);
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3452. Sum of Good Numbers
///   
/// Easy
///
/// Given an array of integers nums and an integer k, an element nums[i] is 
/// considered good if it is strictly greater than the elements at indices 
/// i - k and i + k (if those indices exist). If neither of these indices 
/// exists, nums[i] is still considered good.
///
/// Return the sum of all the good elements in the array.
/// 
/// Example 1:
/// Input: nums = [1,3,2,1,5,4], k = 2
/// Output: 12
/// Explanation:
/// The good numbers are nums[1] = 3, nums[4] = 5, and nums[5] = 4 because 
/// they are strictly greater than the numbers at indices i - k and i + k.
///
/// Example 2:
/// Input: nums = [2,1], k = 1
/// Output: 2
/// Explanation:
/// The only good number is nums[0] = 2 because it is strictly greater than 
/// nums[1].
///  
/// Constraints:
/// 1. 2 <= nums.length <= 100
/// 2. 1 <= nums[i] <= 1000
/// 3. 1 <= k <= floor(nums.length / 2)
/// </summary>
int LeetCodeArray::sumOfGoodNumbers(vector<int>& nums, int k)
{
    int result = 0;
    int n = nums.size();
    for (int i = 0; i < n; i++)
    {
        if (i - k >= 0 && nums[i] <= nums[i - k])
        {
            continue;
        }
        if (i + k < n && nums[i] <= nums[i + k])
        {
            continue;
        }
        result += nums[i];
    }
    return result;
}

/// <summary>
/// Leet Code 3446. Sort Matrix by Diagonals
///   
/// Medium
/// 
/// You are given an n x n square matrix of integers grid. Return the matrix 
/// such that:
///
/// The diagonals in the bottom-left triangle (including the middle diagonal) 
/// are sorted in non-increasing order.
/// The diagonals in the top-right triangle are sorted in non-decreasing order.
/// 
/// Example 1:
/// Input: grid = [[1,7,3],[9,8,2],[4,5,6]]
/// Output: [[8,2,3],[9,6,7],[4,5,1]]
/// Explanation:
/// 
/// The diagonals with a black arrow (bottom-left triangle) should be sorted 
/// in non-increasing order:
///
/// [1, 8, 6] becomes [8, 6, 1].
/// [9, 5] and [4] remain unchanged.
/// The diagonals with a blue arrow (top-right triangle) should be sorted in 
/// non-decreasing order:
/// [7, 2] becomes [2, 7].
/// [3] remains unchanged.
///
/// Example 2:
/// Input: grid = [[0,1],[1,2]]
/// Output: [[2,1],[1,0]]
/// Explanation:
/// The diagonals with a black arrow must be non-increasing, so [0, 2] is 
/// changed to [2, 0]. The other diagonals are already in the correct order.
///
/// Example 3:
/// Input: grid = [[1]]
/// Output: [[1]]
/// Explanation:
/// Diagonals with exactly one element are already in order, so no changes 
/// are needed.
///
/// Constraints:
/// 1. grid.length == grid[i].length == n
/// 2. 1 <= n <= 10
/// 3. -10^5 <= grid[i][j] <= 10^5
/// </summary>
vector<vector<int>> LeetCodeArray::sortMatrix(vector<vector<int>>& grid)
{
    vector<vector<int>> result = grid;
    int n = grid.size();
    for (int i = 1; i < n; i++)
    {
        int r = 0, c = i;
        vector<int> arr;
        while (r < n && c < n)
        {
            arr.push_back(grid[r][c]);
            r++; 
            c++;
        }
        sort(arr.begin(), arr.end());
        r = 0, c = i;
        while (r < n && c < n)
        {
            result[r][c] = arr[r];
            r++;
            c++;
        }
    }
    for (int i = 0; i < n; i++)
    {
        int r = i, c = 0;
        vector<int> arr;
        while (r < n && c < n)
        {
            arr.push_back(grid[r][c]);
            r++;
            c++;
        }
        sort(arr.begin(), arr.end());
        r = i, c = 0;
        while (r < n && c < n)
        {
            result[r][c] = arr.back();
            arr.pop_back();
            r++;
            c++;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3459. Length of Longest V-Shaped Diagonal Segment
/// </summary>
void LeetCodeArray::lenOfVDiagonal(vector<vector<int>>& grid, vector<vector<vector<int>>>& dimension,
    int direction, int row, int column)
{
    vector<vector<int>> directions = { {1, -1}, {1, 1}, {-1, 1}, {-1, -1} };
    int n = grid.size();
    int m = grid[0].size();
    int len = 0;
    int prev = -1;
    while (row >= 0 && row < n && column >= 0 && column < m)
    {
        if (grid[row][column] == 2 || grid[row][column] == 0)
        {
            if (prev == 2 - grid[row][column])
            {
                len++;
            }
            else
            {
                len = 1;
            }
        }
        else
        {
            len = 0;
        }
        dimension[row][column][direction] = len;
        prev = grid[row][column];
        row += directions[direction][0];
        column += directions[direction][1];
    }
}


/// <summary>
/// Leet Code 3459. Length of Longest V-Shaped Diagonal Segment
///   
/// Hard
/// 
/// You are given a 2D integer matrix grid of size n x m, where each element 
/// is either 0, 1, or 2.
///
/// A V-shaped diagonal segment is defined as:
/// The segment starts with 1.
/// The subsequent elements follow this infinite sequence: 2, 0, 2, 0, ....
/// The segment:
/// Starts along a diagonal direction (top-left to bottom-right, bottom-right 
/// to top-left, top-right to bottom-left, or bottom-left to top-right).
/// Continues the sequence in the same diagonal direction.
/// Makes at most one clockwise 90-degree turn to another diagonal direction 
/// while maintaining the sequence.
///
/// Return the length of the longest V-shaped diagonal segment. If no valid 
/// segment exists, return 0.
///
/// Example 1:
/// Input: grid = [[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]
/// Output: 5
/// Explanation:
/// The longest V-shaped diagonal segment has a length of 5 and follows these 
/// coordinates: (0,2) → (1,3) → (2,4), takes a 90-degree clockwise turn at 
/// (2,4), and continues as (3,3) → (4,2).
///
/// Example 2:
/// Input: grid = [[2,2,2,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]
/// Output: 4
/// Explanation:
/// The longest V-shaped diagonal segment has a length of 4 and follows these 
/// coordinates: (2,3) → (3,2), takes a 90-degree clockwise turn at (3,2), and 
/// continues as (2,1) → (1,0).
///
/// Example 3:
/// Input: grid = [[1,2,2,2,2],[2,2,2,2,0],[2,0,0,0,0],[0,0,2,2,2],[2,0,0,2,0]]
/// Output: 5
/// Explanation:
/// The longest V-shaped diagonal segment has a length of 5 and follows these 
/// coordinates: (0,0) → (1,1) → (2,2) → (3,3) → (4,4).
///
/// Example 4:
/// Input: grid = [[1]]
/// Output: 1
/// Explanation:
/// The longest V-shaped diagonal segment has a length of 1 and follows these 
/// coordinates: (0,0).
/// 
/// Constraints:
/// 1. n == grid.length
/// 2. m == grid[i].length
/// 3. 1 <= n, m <= 500
/// 4. grid[i][j] is either 0, 1 or 2.
/// </summary>
int LeetCodeArray::lenOfVDiagonal(vector<vector<int>>& grid)
{
    vector<vector<int>> directions = { {1, -1}, {1, 1}, {-1, 1}, {-1, -1} };
    int n = grid.size();
    int m = grid[0].size();
    vector<vector<vector<int>>>dimensions(n, vector<vector<int>>(m, vector<int>(4)));

    for (int i = 0; i < m; i++)
    {
        int r = 0, c = i, d = 0;
        lenOfVDiagonal(grid, dimensions, d, r, c);
        r = 0, c = i, d = 1;
        lenOfVDiagonal(grid, dimensions, d, r, c);
        r = n - 1; c = i, d = 2;
        lenOfVDiagonal(grid, dimensions, d, r, c);
        r = n - 1; c = i, d = 3;
        lenOfVDiagonal(grid, dimensions, d, r, c);
    }
    for (int i = 0; i < n; i++)
    {
        int r = i, c = 0, d = 1;
        lenOfVDiagonal(grid, dimensions, d, r, c);
        r = i, c = 0, d = 2;
        lenOfVDiagonal(grid, dimensions, d, r, c);
        r = i, c = m - 1, d = 0;
        lenOfVDiagonal(grid, dimensions, d, r, c);
        r = i, c = m - 1, d = 3;
        lenOfVDiagonal(grid, dimensions, d, r, c);
    }
    int result = 0;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if (grid[i][j] == 1)
            {
                result = max(result, 1);
                continue;
            }
            for (int d = 0; d < 4; d++)
            {
                int start_r = i - directions[d][0] * dimensions[i][j][d];
                int start_c = j - directions[d][1] * dimensions[i][j][d];
                if (start_r >= 0 && start_r < n && start_c >= 0 && start_c < m && 
                    grid[start_r][start_c] == 1 && 
                    grid[start_r+ directions[d][0]][start_c+ directions[d][1]] == 2)
                {
                    result = max(result, dimensions[i][j][d] + dimensions[i][j][(d+1)%4]);
                }
            }
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3461. Check If Digits Are Equal in String After Operations I
///   
/// Easy
/// You are given a string s consisting of digits. Perform the following 
/// operation repeatedly until the string has exactly two digits:
///
/// For each pair of consecutive digits in s, starting from the first digit, 
/// calculate a new digit as the sum of the two digits modulo 10.
/// Replace s with the sequence of newly calculated digits, maintaining the 
/// order in which they are computed.
/// Return true if the final two digits in s are the same; otherwise, return 
/// false.
///
/// Example 1:
/// Input: s = "3902"
/// Output: true
/// Explanation:
/// Initially, s = "3902"
/// First operation:
/// (s[0] + s[1]) % 10 = (3 + 9) % 10 = 2
/// (s[1] + s[2]) % 10 = (9 + 0) % 10 = 9
/// (s[2] + s[3]) % 10 = (0 + 2) % 10 = 2
/// s becomes "292"
/// Second operation:
/// (s[0] + s[1]) % 10 = (2 + 9) % 10 = 1
/// (s[1] + s[2]) % 10 = (9 + 2) % 10 = 1
/// s becomes "11"
/// Since the digits in "11" are the same, the output is true.
///
/// Example 2:
/// Input: s = "34789"
/// Output: false
/// Explanation:
/// Initially, s = "34789".
/// After the first operation, s = "7157".
/// After the second operation, s = "862".
/// After the third operation, s = "48".
/// Since '4' != '8', the output is false.
/// 
///
/// Constraints:
/// 1. 3 <= s.length <= 100
/// 2. s consists of only digits.
/// </summary>
bool LeetCodeArray::hasSameDigitsI(string s)
{
    vector<int> digits(s.size());
    for (size_t i = 0; i < s.size(); i++)
    {
        digits[i] = s[i] - '0';
    }
    while (digits.size() > 2)
    {
        for (size_t i = 0; i < digits.size() - 1; i++)
        {
            digits[i] = (digits[i] + digits[i + 1]) % 10;
        }
        digits.pop_back();
    }
    return (digits[0] == digits[1]);
}


/// <summary>
/// Leet Code 3467. Transform Array by Parity
///   
/// Easy
///
/// You are given an integer array nums. Transform nums by performing the 
/// following operations in the exact order specified:
///
/// Replace each even number with 0.
/// Replace each odd numbers with 1.
/// Sort the modified array in non-decreasing order.
/// Return the resulting array after performing these operations.
///
/// Example 1:
/// Input: nums = [4,3,2,1]
/// Output: [0,0,1,1]
/// Explanation:
/// Replace the even numbers (4 and 2) with 0 and the odd numbers (3 and 1) 
/// with 1. Now, nums = [0, 1, 0, 1].
/// After sorting nums in non-descending order, nums = [0, 0, 1, 1].
///
/// Example 2:
/// Input: nums = [1,5,1,4,2]
/// Output: [0,0,1,1,1]
/// Explanation:
/// Replace the even numbers (4 and 2) with 0 and the odd numbers (1, 5 and 1) 
/// with 1. Now, nums = [1, 1, 1, 0, 0].
/// After sorting nums in non-descending order, nums = [0, 0, 1, 1, 1].
///
/// Constraints:
/// 1. 1 <= nums.length <= 100
/// 2. 1 <= nums[i] <= 1000
/// </summary>
vector<int> LeetCodeArray::transformArrayII(vector<int>& nums)
{
    vector<int> result;
    for (size_t i = 0; i < nums.size(); i++)
    {
        result.push_back(nums[i] % 2);
    }
    sort(result.begin(), result.end());
    return result;
}

/// <summary>
/// Leet Code 3477. Fruits Into Baskets II
///
/// Easy
///
/// You are given two arrays of integers, fruits and baskets, each of length 
/// n, where fruits[i] represents the quantity of the ith type of fruit, 
/// and baskets[j] represents the capacity of the jth basket.
///
/// From left to right, place the fruits according to these rules:
/// Each fruit type must be placed in the leftmost available basket with a 
/// capacity greater than or equal to the quantity of that fruit type.
/// Each basket can hold only one type of fruit.
/// If a fruit type cannot be placed in any basket, it remains unplaced.
/// Return the number of fruit types that remain unplaced after all possible 
/// allocations are made.
///
/// Example 1:
/// Input: fruits = [4,2,5], baskets = [3,5,4]
/// Output: 1
/// Explanation:
/// fruits[0] = 4 is placed in baskets[1] = 5.
/// fruits[1] = 2 is placed in baskets[0] = 3.
/// fruits[2] = 5 cannot be placed in baskets[2] = 4.
/// Since one fruit type remains unplaced, we return 1.
///
/// Example 2:
/// Input: fruits = [3,6,1], baskets = [6,4,7]
/// Output: 0
/// Explanation:
/// fruits[0] = 3 is placed in baskets[0] = 6.
/// fruits[1] = 6 cannot be placed in baskets[1] = 4 (insufficient capacity) 
/// but can be placed in the next available basket, baskets[2] = 7.
/// fruits[2] = 1 is placed in baskets[1] = 4.
/// Since all fruits are successfully placed, we return 0.
///
/// Constraints:
/// 1. n == fruits.length == baskets.length
/// 2. 1 <= n <= 100
/// 3. 1 <= fruits[i], baskets[i] <= 1000
/// </summary>
int LeetCodeArray::numOfUnplacedFruitsII(vector<int>& fruits, vector<int>& baskets)
{
    vector<int> visited(baskets.size());
    int count = 0;
    for (size_t i = 0; i < fruits.size(); i++)
    {
        for (size_t j = 0; j < baskets.size(); j++)
        {
            if (visited[j] == 1 || fruits[i] > baskets[j])
            {
                continue;
            }
            visited[j] = 1;
            count++;
            break;
        }
    }
    return fruits.size() - count;
}

/// <summary>
/// Leet Code 3488. Closest Equal Element Queries
///
/// Medium
///
/// You are given a circular array nums and an array queries.
/// For each query i, you have to find the following:
/// 
/// The minimum distance between the element at index queries[i] and any 
/// other index j in the circular array, where nums[j] == nums[queries[i]]. 
/// If no such index exists, the answer for that query should be -1.
/// Return an array answer of the same size as queries, where answer[i] 
/// represents the result for query i.
///
/// Example 1:
/// Input: nums = [1,3,1,4,1,3,2], queries = [0,3,5]
/// Output: [2,-1,3]
/// Explanation:
/// Query 0: The element at queries[0] = 0 is nums[0] = 1. The nearest 
/// index with the same value is 2, and the distance between them is 2.
/// Query 1: The element at queries[1] = 3 is nums[3] = 4. No other index 
/// contains 4, so the result is -1.
/// Query 2: The element at queries[2] = 5 is nums[5] = 3. The nearest index 
/// with the same value is 1, and the distance between them is 3 (following 
/// the circular path: 5 -> 6 -> 0 -> 1).
///
/// Example 2:
/// Input: nums = [1,2,3,4], queries = [0,1,2,3]
/// Output: [-1,-1,-1,-1]
/// Explanation:
/// Each value in nums is unique, so no index shares the same value as the 
/// queried element. This results in -1 for all queries.
/// 
/// Constraints:
/// 1. 1 <= queries.length <= nums.length <= 10^5
/// 2. 1 <= nums[i] <= 10^6
/// 3. 0 <= queries[i] < nums.length
/// </summary>
vector<int> LeetCodeArray::solveQueries(vector<int>& nums, vector<int>& queries)
{
    unordered_map<int, set<int>> num_pos;
    int n = nums.size();
    for (size_t i = 0; i < nums.size(); i++)
    {
        num_pos[nums[i]].insert(i);
    }
    vector<int> result(queries.size());
    for (size_t i = 0; i < queries.size(); i++)
    {
        int index = queries[i];
        if (num_pos[nums[index]].size() == 1)
        {
            result[i] = -1;
            continue;
        }
        auto itr = num_pos[nums[index]].lower_bound(index);
        auto next = std::next(itr);
        auto prev = std::prev(itr);
        int distance = n;
        if (itr != num_pos[nums[index]].begin())
        {
            distance = min(distance, *itr - *prev);
        }
        else
        {
            int last = *num_pos[nums[index]].rbegin();
            distance = min(distance, *itr + n - last);
        }
        if (next != num_pos[nums[index]].end())
        {
            distance = min(distance, *next - *itr);
        }
        else
        {
            int first = *num_pos[nums[index]].begin();
            distance = min(distance, first + n - *itr);
        }
        result[i] = distance;
    }
    return result;
}

/// <summary>
/// Leet Code 3479. Fruits Into Baskets III
///
/// Medium
/// 
/// You are given two arrays of integers, fruits and baskets, each of length 
/// n, where fruits[i] represents the quantity of the ith type of fruit, and 
/// baskets[j] represents the capacity of the jth basket.
///
/// From left to right, place the fruits according to these rules:
/// 
/// Each fruit type must be placed in the leftmost available basket with a 
/// capacity greater than or equal to the quantity of that fruit type.
/// Each basket can hold only one type of fruit.
/// If a fruit type cannot be placed in any basket, it remains unplaced.
/// Return the number of fruit types that remain unplaced after all possible 
/// allocations are made.
/// 
/// Example 1:
/// Input: fruits = [4,2,5], baskets = [3,5,4]
/// Output: 1
/// Explanation:
/// fruits[0] = 4 is placed in baskets[1] = 5.
/// fruits[1] = 2 is placed in baskets[0] = 3.
/// fruits[2] = 5 cannot be placed in baskets[2] = 4.
/// Since one fruit type remains unplaced, we return 1.
///
/// Example 2:
/// Input: fruits = [3,6,1], baskets = [6,4,7]
/// Output: 0
/// Explanation:
/// fruits[0] = 3 is placed in baskets[0] = 6.
/// fruits[1] = 6 cannot be placed in baskets[1] = 4 (insufficient capacity) 
/// but can be placed in the next available basket, baskets[2] = 7.
/// fruits[2] = 1 is placed in baskets[1] = 4.
/// Since all fruits are successfully placed, we return 0.
/// 
/// Constraints:
/// 1. n == fruits.length == baskets.length
/// 2. 1 <= n <= 10^5
/// 3. 1 <= fruits[i], baskets[i] <= 10^9
/// </summary>
int LeetCodeArray::numOfUnplacedFruits(vector<int>& fruits, vector<int>& baskets)
{
    int n = baskets.size();
    SegmentTreeMax segmentTreeMax(n);
    for (size_t i = 0; i < baskets.size(); i++)
    {
        segmentTreeMax.set(0, 0, n - 1, i, baskets[i]);
    }
    int result = 0;
    for (size_t i = 0; i < fruits.size(); i++)
    {
        int pos = segmentTreeMax.query(0, 0, n - 1, fruits[i]);
        if (pos != -1)
        {
            segmentTreeMax.set(0, 0, n - 1, pos, INT_MIN);
        }
        else
        {
            result++;
        }
    }
    return result;
}

/// <summary>
/// Leet Code 3480. Maximize Subarrays After Removing One Conflicting Pair
///
/// Hard
/// 
/// You are given an integer n which represents an array nums containing the 
/// numbers from 1 to n in order. Additionally, you are given a 2D array 
/// conflictingPairs, where conflictingPairs[i] = [a, b] indicates that a and 
/// b form a conflicting pair.
///
/// Remove exactly one element from conflictingPairs. Afterward, count the 
/// number of non-empty subarrays of nums which do not contain both a and b 
/// for any remaining conflicting pair [a, b].
///
/// Return the maximum number of subarrays possible after removing exactly one 
/// conflicting pair.
///
/// Example 1:
/// Input: n = 4, conflictingPairs = [[2,3],[1,4]]
/// Output: 9
/// Explanation:
///
/// Remove [2, 3] from conflictingPairs. Now, conflictingPairs = [[1, 4]].
/// There are 9 subarrays in nums where [1, 4] do not appear together. They 
/// are [1], [2], [3], [4], [1, 2], [2, 3], [3, 4], [1, 2, 3] and [2, 3, 4].
/// The maximum number of subarrays we can achieve after removing one element 
/// from conflictingPairs is 9.
///
/// Example 2:
/// Input: n = 5, conflictingPairs = [[1,2],[2,5],[3,5]]
/// Output: 12
/// Explanation:
/// Remove [1, 2] from conflictingPairs. Now, conflictingPairs = [[2, 5], 
/// [3, 5]].
/// There are 12 subarrays in nums where [2, 5] and [3, 5] do not appear 
/// together.
/// The maximum number of subarrays we can achieve after removing one element 
/// from conflictingPairs is 12.
///  
/// Constraints:
/// 1. 2 <= n <= 10^5
/// 2. 1 <= conflictingPairs.length <= 2 * n
/// 3. conflictingPairs[i].length == 2
/// 4. 1 <= conflictingPairs[i][j] <= n
/// 5. conflictingPairs[i][0] != conflictingPairs[i][1]
/// </summary>
long long LeetCodeArray::maxSubarrays(int n, vector<vector<int>>& conflictingPairs)
{
    long long result = 0;
    vector<vector<pair<int, int>>> pair_list(n + 1);
    for (size_t i = 0; i < conflictingPairs.size(); i++)
    {
        int left = conflictingPairs[i][0];
        int right = conflictingPairs[i][1];
        if (left > right)
        {
            swap(left, right);
        }
        pair_list[right].push_back(make_pair(left, i));
    }

    vector<long long> bonus(n + 1);
    long long extra = 0;
    set<pair<int, int>> pq;
    for (int i = 1; i <= n; i++)
    {
        pq.insert(pair_list[i].begin(), pair_list[i].end());
        while (pq.size() > 2) pq.erase(pq.begin());
        if (pq.empty())
        {
            result += i;
        }
        else if (pq.size() == 1)
        {
            result += i - pq.rbegin()->first;
            bonus[pq.rbegin()->first] += pq.rbegin()->first;
            extra = max(extra, bonus[pq.rbegin()->first]);
        }
        else if (pq.size() == 2)
        {
            result += i - pq.rbegin()->first;
            bonus[pq.rbegin()->first] += pq.rbegin()->first - pq.begin()->first;
            extra = max(extra, bonus[pq.rbegin()->first]);
        }
    }
    return result + extra;
}


/// <summary>
/// Leet Code 3496. Maximize Score After Pair Deletions
///
/// Medium
///
/// You are given an array of integers nums. You must repeatedly perform one 
/// of the following operations while the array has more than two elements:
/// Remove the first two elements.
/// Remove the last two elements.
/// Remove the first and last element.
/// For each operation, add the sum of the removed elements to your total 
/// score.
/// Return the maximum possible score you can achieve.
///
/// Example 1:
/// Input: nums = [2,4,1]
/// Output: 6
/// Explanation:
/// The possible operations are:
/// Remove the first two elements (2 + 4) = 6. The remaining array is [1].
/// Remove the last two elements (4 + 1) = 5. The remaining array is [2].
/// Remove the first and last elements (2 + 1) = 3. The remaining array is [4].
/// The maximum score is obtained by removing the first two elements, 
/// resulting in a final score of 6.
///
/// Example 2:
/// Input: nums = [5,-1,4,2]
/// Output: 7
/// Explanation:
/// The possible operations are:
/// Remove the first and last elements (5 + 2) = 7. The remaining array 
/// is [-1, 4].
/// Remove the first two elements (5 + -1) = 4. The remaining array is [4, 2].
/// Remove the last two elements (4 + 2) = 6. The remaining array is [5, -1].
/// The maximum score is obtained by removing the first and last elements, 
/// resulting in a total score of 7.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 10^5
/// 2. -10^4 <= nums[i] <= 10^4
/// </summary>
int LeetCodeArray::maxScoreII(vector<int>& nums)
{
    int sum = 0;
    for (size_t i = 0; i < nums.size(); i++) sum += nums[i];
    int min_val = INT_MAX;
    if (nums.size() % 2 == 0)
    {
        for (size_t i = 1; i < nums.size(); i++)
        {
            min_val = min(min_val, nums[i - 1] + nums[i]);
        }
    }
    else
    {
        for (size_t i = 0; i < nums.size(); i++)
        {
            min_val = min(min_val, nums[i]);
        }
    }
    return sum - min_val;
}

/// <summary>
/// Leet Code 3500. Minimum Cost to Divide Array Into Subarrays
///
/// Hard
///
/// You are given two integer arrays, nums and cost, of the same size, and 
/// an integer k.
///
/// You can divide nums into subarrays. The cost of the ith subarray 
/// consisting of elements nums[l..r] is:
///
/// (nums[0] + nums[1] + ... + nums[r] + k * i) * (cost[l] + cost[l + 1] 
/// + ... + cost[r]).
/// Note that i represents the order of the subarray: 1 for the first 
/// subarray, 2 for the second, and so on.
///
/// Return the minimum total cost possible from any valid division.
///
/// Example 1:
/// Input: nums = [3,1,4], cost = [4,6,6], k = 1
/// Output: 110
/// Explanation:
/// The minimum total cost possible can be achieved by dividing nums into 
/// subarrays [3, 1] and [4].
/// The cost of the first subarray [3,1] is (3 + 1 + 1 * 1) * (4 + 6) = 50.
/// The cost of the second subarray [4] is (3 + 1 + 4 + 1 * 2) * 6 = 60.
///
/// Example 2:
/// Input: nums = [4,8,5,1,14,2,2,12,1], cost = [7,2,8,4,2,2,1,1,2], k = 7
/// Output: 985
/// Explanation:
///
/// The minimum total cost possible can be achieved by dividing nums into 
/// subarrays [4, 8, 5, 1], [14, 2, 2], and [12, 1].
/// The cost of the first subarray [4, 8, 5, 1] is (4 + 8 + 5 + 1 + 7 * 1) 
/// * (7 + 2 + 8 + 4) = 525.
/// The cost of the second subarray [14, 2, 2] is (4 + 8 + 5 + 1 + 14 + 2 + 
/// 2 + 7 * 2) * (2 + 2 + 1) = 250.
/// The cost of the third subarray [12, 1] is (4 + 8 + 5 + 1 + 14 + 2 + 2 
/// + 12 + 1 + 7 * 3) * (1 + 2) = 210.
/// 
/// Constraints:
/// 1. 1 <= nums.length <= 1000
/// 2. cost.length == nums.length
/// 3. 1 <= nums[i], cost[i] <= 1000
/// 4. 1 <= k <= 1000
/// </summary>
long long LeetCodeArray::minimumCost(vector<int>& nums, vector<int>& cost, int k)
{
    int n = nums.size();
    vector<long long> prefixcost(n + 1, 0), prefixnums(n + 1, 0), prev(n + 1, LLONG_MAX);
    prev[0] = 0;

    for (int i = 0; i < n; i++) 
    {
        prefixnums[i + 1] = prefixnums[i] + nums[i];
        prefixcost[i + 1] = prefixcost[i] + cost[i];
    }

    long long result = LLONG_MAX;

    for (int m = 1; m <= n; m++) 
    {
        vector<long long> curr(n + 1, LLONG_MAX);
        deque<pair<long long, long long>> dq;

        for (int r = m; r <= n; r++) 
        {
            int j = r - 1;
            if (j >= m - 1 && prev[j] != LLONG_MAX) 
            {
                while(
                        dq.size() >= 2 && (prev[j] - dq.back().second) * (dq.back().first - dq[dq.size() - 2].first)
                        <= (dq.back().second - dq[dq.size() - 2].second) * (prefixcost[j] - dq.back().first)
                )
                {
                    dq.pop_back();
                }
                dq.emplace_back(prefixcost[j], prev[j]);
            }

            long long val = prefixnums[r] + k * m;

            while (dq.size() >= 2 && dq[1].second - val * dq[1].first <= dq[0].second - val * dq[0].first)
            {
                dq.pop_front();
            }

            if (!dq.empty())
            {
                curr[r] = dq.front().second - val * dq.front().first + val * prefixcost[r];
            }
        }
        prev = curr;
        result = min(result, prev[n]);
    }
    return result;
}

/// <summary>
/// Leet Code 3499. Maximize Active Section with Trade I
///
/// Medium
///
/// You are given a binary string s of length n, where:
/// '1' represents an active section.
/// '0' represents an inactive section.
/// You can perform at most one trade to maximize the number of active 
/// sections in s. In a trade, you:
///
/// Convert a contiguous block of '1's that is surrounded by '0's to 
/// all '0's.
/// Afterward, convert a contiguous block of '0's that is surrounded 
/// by '1's to all '1's.
/// Return the maximum number of active sections in s after making the 
/// optimal trade.
///
/// Note: Treat s as if it is augmented with a '1' at both ends, forming 
/// t = '1' + s + '1'. The augmented '1's do not contribute to the final 
/// count.
///
/// Example 1:
/// Input: s = "01"
/// Output: 1
/// Explanation:
/// Because there is no block of '1's surrounded by '0's, no valid trade 
/// is possible. The maximum number of active sections is 1.
///
/// Example 2:
/// Input: s = "0100"
/// Output: 4
/// Explanation:
/// String "0100" → Augmented to "101001".
/// Choose "0100", convert "101001" → "100001" → "111111".
/// The final string without augmentation is "1111". The maximum number of active 
/// sections is 4.
///
/// Example 3:
/// Input: s = "1000100"
/// Output: 7
/// Explanation:
/// String "1000100" → Augmented to "110001001".
/// Choose "000100", convert "110001001" → "110000001" → "111111111".
/// The final string without augmentation is "1111111". The maximum number of 
/// active sections is 7.
///
/// Example 4:
/// Input: s = "01010"
/// Output: 4
/// Explanation:
/// String "01010" → Augmented to "1010101".
/// Choose "010", convert "1010101" → "1000101" → "1111101".
/// The final string without augmentation is "11110". The maximum number of 
/// active sections is 4.
/// 
/// Constraints:
/// 1. 1 <= n == s.length <= 105
/// 2. s[i] is either '0' or '1'
/// </summary>
int LeetCodeArray::maxActiveSectionsAfterTradeI(string s)
{
    deque<pair<int, int>> dq;
    pair<int, int> p;
    for (size_t i = 0; i < s.size(); i++)
    {
        if (i == 0)
        {
            p.first = 0;
            p.second = 1;
        }
        else if (s[i] == s[i - 1])
        {
            p.second++;
        }
        else
        {
            dq.push_back(p);
            p.first = i;
            p.second = 1;
        }
    }
    dq.push_back(p);
    int result = 0, zero = 0;
    for (size_t i = 0; i < dq.size(); i++)
    {
        if (s[dq[i].first] == '0')
        {
            if (i + 2 < dq.size())
            {
                zero = max(zero, dq[i].second + dq[i+2].second);
            }
        }
        else if (s[dq[i].first] == '1')
        {
            result += dq[i].second;
        }
    }
    return result + zero;
}

/// <summary>
/// Leet Code 3501. Maximize Active Section with Trade II
///
/// Hard
///
/// You are given a binary string s of length n, where:
///
/// '1' represents an active section.
/// '0' represents an inactive section.
/// You can perform at most one trade to maximize the number of active 
/// sections in s. In a trade, you:
///
/// Convert a contiguous block of '1's that is surrounded by '0's to 
/// all '0's.
/// Afterward, convert a contiguous block of '0's that is surrounded by 
/// '1's to all '1's.
/// Additionally, you are given a 2D array queries, where 
/// queries[i] = [li, ri] represents a substring s[li...ri].
///
/// For each query, determine the maximum possible number of active 
/// sections in s after making the optimal trade on the substring s[li...ri].
///
/// Return an array answer, where answer[i] is the result for queries[i].
///
/// Note
/// For each query, treat s[li...ri] as if it is augmented with a '1' at both 
/// ends, forming t = '1' + s[li...ri] + '1'. The augmented '1's do not 
/// contribute to the final count.
/// The queries are independent of each other.
///
/// Example 1:
/// Input: s = "01", queries = [[0,1]]
/// Output: [1]
/// Explanation:
/// Because there is no block of '1's surrounded by '0's, no valid trade is 
/// possible. The maximum number of active sections is 1.
///
/// Example 2:
/// Input: s = "0100", queries = [[0,3],[0,2],[1,3],[2,3]]
/// Output: [4,3,1,1]
/// Explanation:
/// m0Query [0, 3]bstring "0100" → Augmented to "101001"
/// Choose "0100", convert "0100" → "0000" → "1111".
/// The final string without augmentation is "1111". The maximum number of 
/// active sections is 4.
///
/// Query [0, 2] → Substring "010" → Augmented to "10101"
/// Choose "010", convert "010" → "000" → "111".
/// The final string without augmentation is "1110". The maximum number of 
/// active sections is 3.
///
/// Query [1, 3] → Substring "100" → Augmented to "11001"
/// Because there is no block of '1's surrounded by '0's, no valid trade is 
/// possible. The maximum number of active sections is 1.
///
/// Query [2, 3] → Substring "00" → Augmented to "1001"
/// Because there is no block of '1's surrounded by '0's, no valid trade is 
/// possible. The maximum number of active sections is 1.
///
/// Example 3:
/// Input: s = "1000100", queries = [[1,5],[0,6],[0,4]]
/// Output: [6,7,2]
/// Explanation:
/// Query [1, 5] → Substring "00010" → Augmented to "1000101"
/// Choose "00010", convert "00010" → "00000" → "11111".
/// The final string without augmentation is "1111110". The maximum 
/// number of active sections is 6.
/// 
/// Query [0, 6] → Substring "1000100" → Augmented to "110001001"
/// Choose "000100", convert "000100" → "000000" → "111111".
/// The final string without augmentation is "1111111". The maximum 
/// number of active sections is 7.
/// 
/// Query [0, 4] → Substring "10001" → Augmented to "1100011"
/// Because there is no block of '1's surrounded by '0's, no valid trade 
/// is possible. The maximum number of active sections is 2.
///
/// Example 4:
/// Input: s = "01010", queries = [[0,3],[1,4],[1,3]]
/// Output: [4,4,2]
/// Explanation:
/// Query [0, 3] → Substring "0101" → Augmented to "101011"
/// Choose "010", convert "010" → "000" → "111".
/// The final string without augmentation is "11110". The maximum number of 
/// active sections is 4.
///
/// Query [1, 4] → Substring "1010" → Augmented to "110101"
/// Choose "010", convert "010" → "000" → "111".
/// The final string without augmentation is "01111". The maximum number of 
/// active sections is 4.
///
/// Query [1, 3] → Substring "101" → Augmented to "11011"
/// Because there is no block of '1's surrounded by '0's, no valid trade is 
/// possible. The maximum number of active sections is 2.
///
/// Constraints:
/// 1. 1 <= n == s.length <= 10^5
/// 2. 1 <= queries.length <= 10^5
/// 3. s[i] is either '0' or '1'.
/// 4. queries[i] = [li, ri]
/// 5. 0 <= li <= ri < n
/// </summary>
vector<int> LeetCodeArray::maxActiveSectionsAfterTradeII(string s, vector<vector<int>>& queries)
{
    int n = s.size();
    int activeCount = count(s.begin(), s.end(), '1');

    vector<pair<int, int>> segments;
    for (int i = 0, start = 0; i < n; i++) 
    {
        if (i == n - 1 || s[i] != s[i + 1]) 
        {
            segments.push_back({ start, i - start + 1 });
            start = i + 1;
        }
    }
    int segmentCount = segments.size();

    int maxPower = 20, INF = (int)1e9;
    vector<vector<int>> rmq(maxPower, vector<int>(segmentCount, -INF));

    for (int i = 0; i < segmentCount; i++) 
    {
        if (s[segments[i].first] == '0' && i + 2 < segmentCount) 
        {
            rmq[0][i] = segments[i].second + segments[i + 2].second;
        }
    }

    for (int power = 1, rangeLen = 2; power < maxPower; power++, rangeLen *= 2)
    {
        for (int i = 0, j = rangeLen - 1; j < segmentCount; i++, j++)
        {
            rmq[power][i] = max(rmq[power - 1][i], rmq[power - 1][i + rangeLen / 2]);
        }
    }

    auto getMaxInRange = [&](int left, int right) 
    {
        if (left > right) return -INF;
        int power = 0;
        while ((1LL << power) <= (long long)(right - left + 1))
        {
            power++;
        }
        power--;
        return max(rmq[power][left], rmq[power][right - (1 << power) + 1]);
    };

    vector<int> result;
    for (auto& query : queries) 
    {
        int left = query[0], right = query[1];
        int leftIndex = upper_bound(segments.begin(), segments.end(), pair<int, int>(left, INF)) - segments.begin() - 1;
        int rightIndex = upper_bound(segments.begin(), segments.end(), pair<int, int>(right, INF)) - segments.begin() - 1;

        if (rightIndex - leftIndex + 1 <= 2) 
        {
            result.push_back(activeCount);
            continue;
        }

        auto getSegmentSize = [&](int i) 
        {
            if (i == leftIndex) return segments[leftIndex].second - (left - segments[leftIndex].first);
            if (i == rightIndex) return right - segments[rightIndex].first + 1;
            return segments[i].second;
        };

        auto calculateNewSections = [&](int i) 
        {
            if (s[segments[i].first] == '1') return -INF;
            return getSegmentSize(i) + getSegmentSize(i + 2);
        };

        int bestIncrease = max(getMaxInRange(leftIndex + 1, rightIndex - 3), 0);
        bestIncrease = max(bestIncrease, calculateNewSections(leftIndex));
        bestIncrease = max(bestIncrease, calculateNewSections(rightIndex - 2));

        result.push_back(activeCount + bestIncrease);
    }
    return result;
}
#pragma endregion